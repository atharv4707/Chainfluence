{
  "version": 3,
  "sources": ["../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js", "../../ed2curve/ed2curve.js", "file:///home/runner/work/aptos-wallet-adapter/aptos-wallet-adapter/packages/wallet-adapter-core/dist/index.mjs", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/version.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/WalletCore.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/ga/index.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/error/index.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/constants.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/utils/helpers.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/utils/localStorage.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/utils/walletSelector.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/registry.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/sdkWallets.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/src/index.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/utils/memoize.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/common.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/hex.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/consts.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KDMSOCZY.mjs", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/serializer.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/accountAddress.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/account/utils/address.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/utils/helpers.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/errors/index.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/version.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/client/core.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/client/get.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/utils/utils.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/utils.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/hdKey.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/privateKey.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/publicKey.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/signature.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/secp256k1.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/management/asyncQueue.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/poseidon.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/proof.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/authenticationKey.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/abstraction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/ed25519.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/deserializer.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/ephemeral.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/movePrimitives.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/moveStructs.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/rotationProofChallenge.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/chainId.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/identifier.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/transactionSubmission/helpers.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/types/generated/queries.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/client/post.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/general.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/table.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/utils/const.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/transaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/utils.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/table.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/utils/normalizeBundle.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/utils/apiEndpoints.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/aptos-client/src/index.browser.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/aptosConfig.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/fixedBytes.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/entryFunctionBytes.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/types/types.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/keyless.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/federatedKeyless.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/singleKey.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/multiKey.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/multiEd25519.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/core/crypto/deserializationUtils.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/authenticator/account.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/signingMessage.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/moduleId.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/typeTag/index.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/transactionPayload.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/rawTransaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/authenticator/transaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/signedTransaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/simpleTransaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/multiAgentTransaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/Ed25519Account.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/SingleKeyAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/Account.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/EphemeralKeyPair.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/AbstractKeylessAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/KeylessAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/FederatedKeylessAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/MultiKeyAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/MultiEd25519Account.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/utils.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/AccountUtils.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/AbstractedAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/account/DerivableAbstractedAccount.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/transactionBuilder.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/typeTag/parser.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/helpers.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/remoteAbi.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/transactionSubmission.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/account.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/view.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/abstraction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/account/abstraction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/account.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/coin.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/coin.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/digitalAsset.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/digitalAsset.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/event.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/event.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/faucet.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/faucet.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/fungibleAsset.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/fungibleAsset.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/general.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/ans.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/ans.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/staking.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/staking.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/transactionSubmission/build.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/transactionSubmission/simulate.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/transactionSubmission/submit.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/transactionSubmission/management.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/management/accountSequenceNumber.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/transactions/management/transactionWorker.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/transaction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/keyless.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/keyless.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/internal/object.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/object.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/api/aptos.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/src/types/abstraction.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-standard/src/detect.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-standard/src/errors.ts", "../../@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-standard/src/misc.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosSignAndSubmitTransaction.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosSignIn.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosSignMessage.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosSignTransaction.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosConnect.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosDisconnect.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosGetAccount.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosGetNetwork.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosOnAccountChange.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/features/aptosOnNetworkChange.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/AccountInfo.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/chains.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/errors.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/src/misc.ts", "../../@identity-connect/crypto/src/encrDecr.ts", "../../@identity-connect/crypto/src/errors.ts", "../../@identity-connect/crypto/src/utils.ts", "../../@identity-connect/crypto/src/securedEnvelope.ts", "../../@identity-connect/crypto/src/serialization.ts", "../../@identity-connect/crypto/src/walletAccounts.ts", "../../@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/src/AccountInfo.ts", "../../@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/src/errors.ts", "../../@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/src/misc.ts", "../../@aptos-connect/wallet-api/src/base64.ts", "../../@aptos-connect/wallet-api/src/helpers.ts", "../../@aptos-connect/wallet-api/src/features/connect/request.ts", "../../@aptos-connect/wallet-api/src/WalletRequest.ts", "../../@aptos-connect/wallet-api/src/shared/AccountAuthenticatorInput.ts", "../../@aptos-connect/wallet-api/src/shared/AccountInfo.ts", "../../@aptos-connect/wallet-api/src/shared/PublicKey.ts", "../../@aptos-connect/wallet-api/src/shared/AccountInput.ts", "../../@aptos-connect/wallet-api/src/shared/DappInfo.ts", "../../@aptos-connect/wallet-api/src/shared/EntryFunctionArgument.ts", "../../@aptos-connect/wallet-api/src/shared/Signature.ts", "../../@aptos-connect/wallet-api/src/shared/TransactionPayloadInput.ts", "../../@aptos-connect/wallet-api/src/UserResponse.ts", "../../@aptos-connect/wallet-api/src/WalletResponse.ts", "../../@aptos-connect/wallet-api/src/features/connect/response.ts", "../../@aptos-connect/wallet-api/src/features/disconnect/request.ts", "../../@aptos-connect/wallet-api/src/features/disconnect/response.ts", "../../@aptos-connect/wallet-api/src/shared/AptosSignInInput.ts", "../../@aptos-connect/wallet-api/src/features/signIn/request.ts", "../../@aptos-connect/wallet-api/src/shared/AptosSignInOutput.ts", "../../@aptos-connect/wallet-api/src/features/signIn/response.ts", "../../@aptos-connect/wallet-api/src/features/getConnectedAccounts/request.ts", "../../@aptos-connect/wallet-api/src/features/getConnectedAccounts/response.ts", "../../@aptos-connect/wallet-api/src/features/isConnected/request.ts", "../../@aptos-connect/wallet-api/src/features/isConnected/response.ts", "../../@aptos-connect/wallet-api/src/features/signAndSubmitTransaction/request.ts", "../../@aptos-connect/wallet-api/src/features/signAndSubmitTransaction/response.ts", "../../@aptos-connect/wallet-api/src/features/signMessage/request.ts", "../../@aptos-connect/wallet-api/src/features/signMessage/response.ts", "../../@aptos-connect/wallet-api/src/features/signTransaction/request.ts", "../../@aptos-connect/wallet-api/src/features/signTransaction/response.ts", "../../@aptos-connect/wallet-api/src/messages/common.ts", "../../@aptos-connect/wallet-api/src/messages/prompt.ts", "../../@aptos-connect/wallet-api/src/PopupWalletRequest.ts", "../../@aptos-connect/wallet-api/src/WalletRequestBody.ts", "../../@telegram-apps/transformers/dist/index.js", "../../@telegram-apps/bridge/src/env/hasWebviewProxy.ts", "../../@telegram-apps/bridge/src/env/isIframe.ts", "../../@telegram-apps/toolkit/dist/index.js", "../../@telegram-apps/signals/dist/index.js", "../../@telegram-apps/bridge/src/debug.ts", "../../@telegram-apps/bridge/src/events/transformers.ts", "../../@telegram-apps/bridge/src/events/listening/lastEvent.ts", "../../@telegram-apps/bridge/src/events/listening/signalFor.ts", "../../@telegram-apps/bridge/src/events/listening/on.ts", "../../@telegram-apps/bridge/src/errors.ts", "../../@telegram-apps/bridge/src/methods/$targetOrigin.ts", "../../@telegram-apps/bridge/src/methods/postEvent.ts", "../../@telegram-apps/bridge/src/utils/request.ts", "../../@telegram-apps/bridge/src/launch-params/parseLaunchParams.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveFromUrl.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveFromLocation.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveFromPerformance.ts", "../../@telegram-apps/bridge/src/launch-params/storage.ts", "../../@telegram-apps/bridge/src/launch-params/retrieveLaunchParams.ts", "../../@telegram-apps/bridge/src/env/isTMA.ts", "../../@telegram-apps/bridge/src/events/emitMiniAppsEvent.ts", "../../@telegram-apps/bridge/src/env/mockTelegramEnv.ts", "../../@telegram-apps/bridge/src/events/listening/defineEventHandlers.ts", "../../@telegram-apps/bridge/src/events/listening/removeEventHandlers.ts", "../../@telegram-apps/bridge/src/events/listening/off.ts", "../../@telegram-apps/bridge/src/events/listening/subscribe.ts", "../../@telegram-apps/bridge/src/events/listening/unsubscribe.ts", "../../@telegram-apps/bridge/src/methods/captureSameReq.ts", "../../@telegram-apps/bridge/src/utils/compareVersions.ts", "../../@telegram-apps/bridge/src/methods/supports.ts", "../../@telegram-apps/bridge/src/methods/createPostEvent.ts", "../../@telegram-apps/bridge/src/utils/invokeCustomMethod.ts", "../../@telegram-apps/bridge/src/resetPackageState.ts", "../../uuid/dist/esm-browser/rng.js", "../../uuid/dist/esm-browser/regex.js", "../../uuid/dist/esm-browser/validate.js", "../../uuid/dist/esm-browser/stringify.js", "../../uuid/dist/esm-browser/parse.js", "../../uuid/dist/esm-browser/v35.js", "../../uuid/dist/esm-browser/md5.js", "../../uuid/dist/esm-browser/v3.js", "../../uuid/dist/esm-browser/native.js", "../../uuid/dist/esm-browser/v4.js", "../../uuid/dist/esm-browser/sha1.js", "../../uuid/dist/esm-browser/v5.js", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/index.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/prompt.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/state.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/telegram/openTelegramPrompt.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/telegram/createWalletRequest.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/telegram/getClientIdentityKey.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/telegram/getWalletResponse.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/telegram/smartPolling.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/src/telegram/index.ts", "../../@identity-connect/api/src/constants.ts", "../../@identity-connect/api/src/network.ts", "../../@identity-connect/api/src/types/pairing.ts", "../../@identity-connect/api/src/types/signingRequest.ts", "../../@identity-connect/api/src/types/wallet.ts", "../../@identity-connect/wallet-api/src/serialization/bcsSerialization.ts", "../../@identity-connect/wallet-api/src/serialization/jsonPayload.ts", "../../@identity-connect/wallet-api/src/serialization/error.ts", "../../@identity-connect/wallet-api/src/serialization/rawTxn.ts", "../../@identity-connect/wallet-api/src/serialization/signAndSubmitTransactionRequestArgs.ts", "../../@identity-connect/wallet-api/src/serialization/signTransactionRequestArgs.ts", "../../@identity-connect/wallet-api/src/serialization/signTransactionResponseArgs.ts", "../../@identity-connect/wallet-api/src/utils/makeFullMessage.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/ACDappClient.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/constants.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/conversion.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/PairingClient.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/errors.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/state.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/utils.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/ICDappClient.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/prompt.ts", "../../@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/src/KeylessClient.ts", "../../@aptos-connect/wallet-adapter-plugin/src/index.ts", "../../@aptos-connect/wallet-adapter-plugin/src/AptosConnectGoogleWallet.ts", "../../@aptos-connect/wallet-adapter-plugin/src/AptosConnectWallet.ts", "../../@aptos-connect/wallet-adapter-plugin/src/AptosConnectAccount.ts", "../../@aptos-connect/wallet-adapter-plugin/src/helpers.ts", "../../@aptos-connect/wallet-adapter-plugin/src/config.ts", "../../@aptos-connect/wallet-adapter-plugin/src/AptosConnectAppleWallet.ts", "../../@aptos-labs/wallet-adapter-react/src/index.tsx", "../../@aptos-labs/wallet-adapter-react/src/WalletProvider.tsx", "../../@aptos-labs/wallet-adapter-react/src/useWallet.tsx", "../../@aptos-labs/wallet-adapter-react/src/components/AboutAptosConnect.tsx", "../../@aptos-labs/wallet-adapter-react/src/graphics/LinkGraphic.tsx", "../../@aptos-labs/wallet-adapter-react/src/graphics/WalletGraphic.tsx", "../../@aptos-labs/wallet-adapter-react/src/graphics/Web3Graphic.tsx", "../../@aptos-labs/wallet-adapter-react/src/components/utils.tsx", "../../@aptos-labs/wallet-adapter-react/src/components/AptosPrivacyPolicy.tsx", "../../@aptos-labs/wallet-adapter-react/src/graphics/SmallAptosLogo.tsx", "../../@aptos-labs/wallet-adapter-react/src/components/WalletItem.tsx", "../../@radix-ui/react-slot/src/slot.tsx", "../../@radix-ui/react-compose-refs/src/compose-refs.tsx"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "/*\n * ed2curve: convert Ed25519 signing key pair into Curve25519\n * key pair suitable for Diffie-Hellman key exchange.\n *\n * Written by Dmitry Chestnykh in 2014. Public domain.\n */\n/* jshint newcap: false */\n(function(root, f) {\n  'use strict';\n  if (typeof module !== 'undefined' && module.exports) module.exports = f(require('tweetnacl'));\n  else root.ed2curve = f(root.nacl);\n}(this, function(nacl) {\n  'use strict';\n  if (!nacl) throw new Error('tweetnacl not loaded');\n\n  // -- Operations copied from TweetNaCl.js. --\n\n  var gf = function(init) {\n    var i, r = new Float64Array(16);\n    if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n    return r;\n  };\n\n  var gf0 = gf(),\n      gf1 = gf([1]),\n      D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n      I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\n  function car25519(o) {\n    var c;\n    var i;\n    for (i = 0; i < 16; i++) {\n      o[i] += 65536;\n      c = Math.floor(o[i] / 65536);\n      o[(i+1)*(i<15?1:0)] += c - 1 + 37 * (c-1) * (i===15?1:0);\n      o[i] -= (c * 65536);\n    }\n  }\n\n  function sel25519(p, q, b) {\n    var t, c = ~(b-1);\n    for (var i = 0; i < 16; i++) {\n      t = c & (p[i] ^ q[i]);\n      p[i] ^= t;\n      q[i] ^= t;\n    }\n  }\n\n  function unpack25519(o, n) {\n    var i;\n    for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n    o[15] &= 0x7fff;\n  }\n\n  // addition\n  function A(o, a, b) {\n    var i;\n    for (i = 0; i < 16; i++) o[i] = (a[i] + b[i])|0;\n  }\n\n  // subtraction\n  function Z(o, a, b) {\n    var i;\n    for (i = 0; i < 16; i++) o[i] = (a[i] - b[i])|0;\n  }\n\n  // multiplication\n  function M(o, a, b) {\n    var i, j, t = new Float64Array(31);\n    for (i = 0; i < 31; i++) t[i] = 0;\n    for (i = 0; i < 16; i++) {\n      for (j = 0; j < 16; j++) {\n        t[i+j] += a[i] * b[j];\n      }\n    }\n    for (i = 0; i < 15; i++) {\n      t[i] += 38 * t[i+16];\n    }\n    for (i = 0; i < 16; i++) o[i] = t[i];\n    car25519(o);\n    car25519(o);\n  }\n\n  // squaring\n  function S(o, a) {\n    M(o, a, a);\n  }\n\n  // inversion\n  function inv25519(o, i) {\n    var c = gf();\n    var a;\n    for (a = 0; a < 16; a++) c[a] = i[a];\n    for (a = 253; a >= 0; a--) {\n      S(c, c);\n      if(a !== 2 && a !== 4) M(c, c, i);\n    }\n    for (a = 0; a < 16; a++) o[a] = c[a];\n  }\n\n  function pack25519(o, n) {\n    var i, j, b;\n    var m = gf(), t = gf();\n    for (i = 0; i < 16; i++) t[i] = n[i];\n    car25519(t);\n    car25519(t);\n    car25519(t);\n    for (j = 0; j < 2; j++) {\n      m[0] = t[0] - 0xffed;\n      for (i = 1; i < 15; i++) {\n        m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n        m[i-1] &= 0xffff;\n      }\n      m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n      b = (m[15]>>16) & 1;\n      m[14] &= 0xffff;\n      sel25519(t, m, 1-b);\n    }\n    for (i = 0; i < 16; i++) {\n      o[2*i] = t[i] & 0xff;\n      o[2*i+1] = t[i] >> 8;\n    }\n  }\n\n  function par25519(a) {\n    var d = new Uint8Array(32);\n    pack25519(d, a);\n    return d[0] & 1;\n  }\n\n  function vn(x, xi, y, yi, n) {\n    var i, d = 0;\n    for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];\n    return (1 & ((d - 1) >>> 8)) - 1;\n  }\n\n  function crypto_verify_32(x, xi, y, yi) {\n    return vn(x, xi, y, yi, 32);\n  }\n\n  function neq25519(a, b) {\n    var c = new Uint8Array(32), d = new Uint8Array(32);\n    pack25519(c, a);\n    pack25519(d, b);\n    return crypto_verify_32(c, 0, d, 0);\n  }\n\n  function pow2523(o, i) {\n    var c = gf();\n    var a;\n    for (a = 0; a < 16; a++) c[a] = i[a];\n    for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if (a !== 1) M(c, c, i);\n    }\n    for (a = 0; a < 16; a++) o[a] = c[a];\n  }\n\n  function set25519(r, a) {\n    var i;\n    for (i = 0; i < 16; i++) r[i] = a[i] | 0;\n  }\n\n  function unpackneg(r, p) {\n    var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n    set25519(r[2], gf1);\n    unpack25519(r[1], p);\n    S(num, r[1]);\n    M(den, num, D);\n    Z(num, num, r[2]);\n    A(den, r[2], den);\n\n    S(den2, den);\n    S(den4, den2);\n    M(den6, den4, den2);\n    M(t, den6, num);\n    M(t, t, den);\n\n    pow2523(t, t);\n    M(t, t, num);\n    M(t, t, den);\n    M(t, t, den);\n    M(r[0], t, den);\n\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) M(r[0], r[0], I);\n\n    S(chk, r[0]);\n    M(chk, chk, den);\n    if (neq25519(chk, num)) return -1;\n\n    if (par25519(r[0]) === (p[31] >> 7)) Z(r[0], gf0, r[0]);\n\n    M(r[3], r[0], r[1]);\n    return 0;\n  }\n\n  // ----\n\n  // Converts Ed25519 public key to Curve25519 public key.\n  // montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p\n  function convertPublicKey(pk) {\n    var z = new Uint8Array(32),\n      q = [gf(), gf(), gf(), gf()],\n      a = gf(), b = gf();\n\n    if (unpackneg(q, pk)) return null; // reject invalid key\n\n    var y = q[1];\n\n    A(a, gf1, y);\n    Z(b, gf1, y);\n    inv25519(b, b);\n    M(a, a, b);\n\n    pack25519(z, a);\n    return z;\n  }\n\n  // Converts Ed25519 secret key to Curve25519 secret key.\n  function convertSecretKey(sk) {\n    var d = new Uint8Array(64), o = new Uint8Array(32), i;\n    nacl.lowlevel.crypto_hash(d, sk, 32);\n    d[0] &= 248;\n    d[31] &= 127;\n    d[31] |= 64;\n    for (i = 0; i < 32; i++) o[i] = d[i];\n    for (i = 0; i < 64; i++) d[i] = 0;\n    return o;\n  }\n\n  function convertKeyPair(edKeyPair) {\n    var publicKey = convertPublicKey(edKeyPair.publicKey);\n    if (!publicKey) return null;\n    return {\n      publicKey: publicKey,\n      secretKey: convertSecretKey(edKeyPair.secretKey)\n    };\n  }\n\n  return {\n    convertPublicKey: convertPublicKey,\n    convertSecretKey: convertSecretKey,\n    convertKeyPair: convertKeyPair,\n  };\n\n}));\n", "// src/version.ts\nvar WALLET_ADAPTER_CORE_VERSION = \"7.1.1\";\n\n// src/WalletCore.ts\nimport EventEmitter from \"eventemitter3\";\nimport {\n  AccountAddress,\n  Aptos as Aptos2,\n  Network as Network2,\n  NetworkToChainId\n} from \"@aptos-labs/ts-sdk\";\nimport {\n  getAptosWallets,\n  isWalletWithRequiredFeatureSet,\n  UserResponseStatus\n} from \"@aptos-labs/wallet-standard\";\n\n// src/ga/index.ts\nvar GA4 = class {\n  constructor() {\n    this.aptosGAID = \"G-GNVVWBL3J9\";\n    this.injectGA(this.aptosGAID);\n  }\n  gtag(a, b, c) {\n    let dataLayer = window.dataLayer || [];\n    dataLayer.push(arguments);\n  }\n  injectGA(gaID) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n    const head = document.getElementsByTagName(\"head\")[0];\n    var myScript = document.createElement(\"script\");\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`\n    );\n    const that = this;\n    myScript.onload = function() {\n      that.gtag(\"js\", /* @__PURE__ */ new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false\n      });\n    };\n    head.insertBefore(myScript, head.children[1]);\n  }\n};\n\n// src/error/index.ts\nvar WalletError = class extends Error {\n  constructor(message, error) {\n    super(message);\n    this.error = error;\n  }\n};\nvar WalletNotSelectedError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotSelectedError\";\n  }\n};\nvar WalletNotReadyError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotReadyError\";\n  }\n};\nvar WalletConnectionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletConnectionError\";\n  }\n};\nvar WalletDisconnectionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletDisconnectionError\";\n  }\n};\nvar WalletAccountError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletAccountError\";\n  }\n};\nvar WalletGetNetworkError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletGetNetworkError\";\n  }\n};\nvar WalletAccountChangeError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletAccountChangeError\";\n  }\n};\nvar WalletNetworkChangeError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNetworkChangeError\";\n  }\n};\nvar WalletNotConnectedError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotConnectedError\";\n  }\n};\nvar WalletSignMessageError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignMessageError\";\n  }\n};\nvar WalletSignMessageAndVerifyError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignMessageAndVerifyError\";\n  }\n};\nvar WalletSignAndSubmitMessageError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignAndSubmitMessageError\";\n  }\n};\nvar WalletSignTransactionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignTransactionError\";\n  }\n};\nvar WalletNotSupportedMethod = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotSupportedMethod\";\n  }\n};\nvar WalletChangeNetworkError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletChangeNetworkError\";\n  }\n};\nvar WalletSubmitTransactionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSubmitTransactionError\";\n  }\n};\nvar WalletNotFoundError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotFoundError\";\n  }\n};\n\n// src/constants.ts\nvar WalletReadyState = /* @__PURE__ */ ((WalletReadyState2) => {\n  WalletReadyState2[\"Installed\"] = \"Installed\";\n  WalletReadyState2[\"NotDetected\"] = \"NotDetected\";\n  return WalletReadyState2;\n})(WalletReadyState || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"Mainnet\"] = \"mainnet\";\n  NetworkName2[\"Testnet\"] = \"testnet\";\n  NetworkName2[\"Devnet\"] = \"devnet\";\n  return NetworkName2;\n})(NetworkName || {});\nvar ChainIdToAnsSupportedNetworkMap = {\n  \"1\": \"mainnet\",\n  // mainnet\n  \"2\": \"testnet\"\n  // testnet\n};\nvar APTOS_CONNECT_BASE_URL = \"https://aptosconnect.app\";\nvar APTOS_CONNECT_ACCOUNT_URL = \"https://aptosconnect.app/dashboard/main-account\";\n\n// src/utils/helpers.ts\nimport {\n  Aptos,\n  AptosConfig,\n  Hex,\n  Network,\n  NetworkToNodeAPI\n} from \"@aptos-labs/ts-sdk\";\nfunction isMobile() {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent\n  );\n}\nfunction isInAppBrowser() {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent\n  );\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent\n  );\n  return isIphone || isAndroid;\n}\nfunction isRedirectable() {\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n  return isMobile() && !isInAppBrowser();\n}\nfunction generalizedErrorMessage(error) {\n  return typeof error === \"object\" && \"message\" in error ? error.message : error;\n}\nvar getAptosConfig = (networkInfo, dappConfig) => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  const pluginSettings = {\n    TRANSACTION_SUBMITTER: dappConfig?.transactionSubmitter\n  };\n  if (isAptosNetwork(networkInfo)) {\n    const currentNetwork = convertNetwork(networkInfo);\n    if (isAptosLiveNetwork(currentNetwork)) {\n      const apiKey = dappConfig?.aptosApiKeys;\n      return new AptosConfig({\n        network: currentNetwork,\n        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : void 0 },\n        pluginSettings\n      });\n    }\n    return new AptosConfig({\n      network: currentNetwork,\n      pluginSettings\n    });\n  }\n  const knownNetworks = {\n    okx: \"https://wallet.okx.com/fullnode/aptos/discover/rpc\"\n  };\n  if (networkInfo.url) {\n    const isKnownNetwork = Object.values(knownNetworks).includes(\n      networkInfo.url\n    );\n    if (isKnownNetwork) {\n      return new AptosConfig({\n        network: Network.CUSTOM,\n        fullnode: networkInfo.url,\n        pluginSettings\n      });\n    }\n  }\n  throw new Error(\n    `Invalid network, network ${networkInfo.name} not supported with Aptos wallet adapter to prevent user from using an unexpected network.`\n  );\n};\nvar isAptosNetwork = (networkInfo) => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return NetworkToNodeAPI[networkInfo.name] !== void 0;\n};\nvar isAptosLiveNetwork = (networkInfo) => {\n  return networkInfo === \"devnet\" || networkInfo === \"testnet\" || networkInfo === \"mainnet\";\n};\nvar fetchDevnetChainId = async () => {\n  const aptos = new Aptos();\n  return await aptos.getChainId();\n};\nvar handlePublishPackageTransaction = (transactionInput) => {\n  let metadataBytes = transactionInput.data.functionArguments[0];\n  if (typeof metadataBytes === \"string\") {\n    metadataBytes = Hex.fromHexInput(metadataBytes).toUint8Array();\n  }\n  let byteCode = transactionInput.data.functionArguments[1];\n  if (Array.isArray(byteCode)) {\n    byteCode = byteCode.map((byte) => {\n      if (typeof byte === \"string\") {\n        return Hex.fromHexInput(byte).toUint8Array();\n      }\n      return byte;\n    });\n  } else {\n    throw new WalletSignAndSubmitMessageError(\n      \"The bytecode argument must be an array.\"\n    ).message;\n  }\n  return { metadataBytes, byteCode };\n};\nfunction convertNetwork(networkInfo) {\n  switch (networkInfo?.name) {\n    case \"mainnet\":\n      return Network.MAINNET;\n    case \"testnet\":\n      return Network.TESTNET;\n    case \"devnet\":\n      return Network.DEVNET;\n    case \"local\":\n      return Network.LOCAL;\n    default:\n      throw new Error(\"Invalid Aptos network name\");\n  }\n}\n\n// src/utils/localStorage.ts\nvar LOCAL_STORAGE_ITEM_KEY = \"AptosWalletName\";\nfunction setLocalStorage(walletName) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\nfunction removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\nfunction getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\n// src/utils/walletSelector.ts\nfunction partitionWallets(wallets, partitionFunction = isInstalledOrLoadable) {\n  const defaultWallets = [];\n  const moreWallets = [];\n  for (const wallet of wallets) {\n    if (partitionFunction(wallet)) defaultWallets.push(wallet);\n    else moreWallets.push(wallet);\n  }\n  return { defaultWallets, moreWallets };\n}\nfunction isInstalledOrLoadable(wallet) {\n  return wallet.readyState === \"Installed\" /* Installed */;\n}\nfunction isInstallRequired(wallet) {\n  const isWalletReady = isInstalledOrLoadable(wallet);\n  const isMobile2 = !isWalletReady && isRedirectable();\n  return !isMobile2 && !isWalletReady;\n}\nfunction truncateAddress(address) {\n  if (!address) return;\n  return `${address.slice(0, 6)}...${address.slice(-5)}`;\n}\nfunction isAptosConnectWallet(wallet) {\n  if (!wallet.url) return false;\n  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);\n}\nfunction getAptosConnectWallets(wallets) {\n  const { defaultWallets, moreWallets } = partitionWallets(\n    wallets,\n    isAptosConnectWallet\n  );\n  return { aptosConnectWallets: defaultWallets, otherWallets: moreWallets };\n}\nfunction groupAndSortWallets(wallets, options) {\n  const { aptosConnectWallets, otherWallets } = getAptosConnectWallets(wallets);\n  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);\n  if (options?.sortAptosConnectWallets) {\n    aptosConnectWallets.sort(options.sortAptosConnectWallets);\n  }\n  if (options?.sortAvailableWallets) {\n    defaultWallets.sort(options.sortAvailableWallets);\n  }\n  if (options?.sortInstallableWallets) {\n    moreWallets.sort(options.sortInstallableWallets);\n  }\n  return {\n    /** Wallets that use social login to create an account on the blockchain */\n    aptosConnectWallets,\n    /** Wallets that are currently installed or loadable. */\n    availableWallets: defaultWallets,\n    /** Wallets that are NOT currently installed or loadable. */\n    installableWallets: moreWallets\n  };\n}\n\n// src/registry.ts\nvar aptosStandardSupportedWalletList = [\n  {\n    name: \"OKX Wallet\",\n    url: \"https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge\",\n    icon: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true\n  },\n  {\n    name: \"Petra\",\n    url: \"https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en\",\n    icon: \"data:image/png;base64,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\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"https://petra.app/explore?link=\"\n  },\n  {\n    name: \"Nightly\",\n    url: \"https://nightly.app/\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"nightly://v1?network=aptos&url=\"\n  },\n  {\n    name: \"Pontem Wallet\",\n    url: \"https://pontem.network/pontem-wallet\",\n    icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true\n  }\n];\nvar crossChainStandardSupportedWalletList = [\n  {\n    name: \"Phantom (Solana)\",\n    url: \"https://phantom.com/\",\n    icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: `https://phantom.app/ul/browse/`\n  },\n  {\n    name: \"Phantom (Ethereum)\",\n    url: \"https://phantom.com/\",\n    icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: `https://phantom.app/ul/browse/`\n  },\n  {\n    name: \"Nightly (Solana)\",\n    url: \"https://nightly.app/\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"nightly://v1?network=aptos&url=\"\n  },\n  {\n    name: \"Nightly (Ethereum)\",\n    url: \"https://nightly.app/\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"nightly://v1?network=aptos&url=\"\n  }\n];\n\n// src/sdkWallets.ts\nimport {\n  AptosConnectAppleWallet,\n  AptosConnectGoogleWallet\n} from \"@aptos-connect/wallet-adapter-plugin\";\nfunction getSDKWallets(dappConfig) {\n  const sdkWallets = [];\n  if (typeof window !== \"undefined\") {\n    sdkWallets.push(\n      new AptosConnectGoogleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.aptosConnectDappId,\n        ...dappConfig?.aptosConnect\n      }),\n      new AptosConnectAppleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.aptosConnectDappId,\n        ...dappConfig?.aptosConnect\n      })\n    );\n  }\n  return sdkWallets;\n}\n\n// src/WalletCore.ts\nvar WalletCore = class extends EventEmitter {\n  constructor(optInWallets, dappConfig, disableTelemetry) {\n    super();\n    // Local private variable to hold the wallet that is currently connected\n    this._wallet = null;\n    // Local private variable to hold SDK wallets in the adapter\n    this._sdkWallets = [];\n    // Local array that holds all the wallets that are AIP-62 standard compatible\n    this._standard_wallets = [];\n    // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine\n    this._standard_not_detected_wallets = [];\n    // Local private variable to hold the network that is currently connected\n    this._network = null;\n    // Local private variable to hold the wallet connected state\n    this._connected = false;\n    // Local private variable to hold the connecting state\n    this._connecting = false;\n    // Local private variable to hold the account that is currently connected\n    this._account = null;\n    // Private array that holds all the Wallets a dapp decided to opt-in to\n    this._optInWallets = [];\n    // Local flag to disable the adapter telemetry tool\n    this._disableTelemetry = false;\n    // Google Analytics 4 module\n    this.ga4 = null;\n    this._optInWallets = optInWallets || [];\n    this._dappConfig = dappConfig;\n    this._disableTelemetry = disableTelemetry ?? false;\n    this._sdkWallets = getSDKWallets(this._dappConfig);\n    if (!this._disableTelemetry) {\n      this.ga4 = new GA4();\n    }\n    this.fetchExtensionAIP62AptosWallets();\n    this.fetchSDKAIP62AptosWallets();\n    this.appendNotDetectedStandardSupportedWallets();\n  }\n  fetchExtensionAIP62AptosWallets() {\n    let { aptosWallets, on } = getAptosWallets();\n    this.setExtensionAIP62Wallets(aptosWallets);\n    if (typeof window === \"undefined\") return;\n    const that = this;\n    const removeRegisterListener = on(\"register\", function() {\n      let { aptosWallets: aptosWallets2 } = getAptosWallets();\n      that.setExtensionAIP62Wallets(aptosWallets2);\n    });\n    const removeUnregisterListener = on(\"unregister\", function() {\n      let { aptosWallets: aptosWallets2 } = getAptosWallets();\n      that.setExtensionAIP62Wallets(aptosWallets2);\n    });\n  }\n  /**\n   * Set AIP-62 extension wallets\n   *\n   * @param extensionwWallets\n   */\n  setExtensionAIP62Wallets(extensionwWallets) {\n    extensionwWallets.map((wallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      if (wallet.name === \"Rimosafe\") {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        const index = this._standard_not_detected_wallets.findIndex(\n          (notDetctedWallet) => notDetctedWallet.name == wallet.name\n        );\n        if (index !== -1) {\n          this._standard_not_detected_wallets.splice(index, 1);\n        }\n        const alreadyExists = this._standard_wallets.some(\n          (w) => w.name === wallet.name\n        );\n        if (!alreadyExists) {\n          wallet.readyState = \"Installed\" /* Installed */;\n          wallet.isAptosNativeWallet = this.isAptosNativeWallet(wallet);\n          this._standard_wallets.push(wallet);\n          this.emit(\"standardWalletsAdded\", wallet);\n        }\n      }\n    });\n  }\n  /**\n   * Set AIP-62 SDK wallets\n   */\n  fetchSDKAIP62AptosWallets() {\n    this._sdkWallets.map((wallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        wallet.readyState = \"Installed\" /* Installed */;\n        wallet.isAptosNativeWallet = this.isAptosNativeWallet(wallet);\n        this._standard_wallets.push(wallet);\n      }\n    });\n  }\n  // Aptos native wallets do not have an authenticationFunction property\n  isAptosNativeWallet(wallet) {\n    return !(\"authenticationFunction\" in wallet);\n  }\n  // Since we can't discover AIP-62 wallets that are not installed on the user machine,\n  // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.\n  // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array\n  // when wallet is not installed on the user machine\n  appendNotDetectedStandardSupportedWallets() {\n    const walletRegistry = this._dappConfig?.crossChainWallets ? [\n      ...aptosStandardSupportedWalletList,\n      ...crossChainStandardSupportedWalletList\n    ] : aptosStandardSupportedWalletList;\n    walletRegistry.map((supportedWallet) => {\n      const existingStandardWallet = this._standard_wallets.find(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n      if (existingStandardWallet) {\n        return;\n      }\n      if (this.excludeWallet(supportedWallet)) {\n        return;\n      }\n      if (!existingStandardWallet) {\n        supportedWallet.isAptosNativeWallet = !(\"authenticationFunction\" in supportedWallet);\n        this._standard_not_detected_wallets.push(supportedWallet);\n        this.emit(\"standardNotDetectedWalletAdded\", supportedWallet);\n      }\n    });\n  }\n  /**\n   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include\n   *\n   * @param wallet AdapterWallet | AdapterNotDetectedWallet\n   * @returns boolean\n   */\n  excludeWallet(wallet) {\n    if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {\n      return true;\n    }\n    return false;\n  }\n  recordEvent(eventName, additionalInfo) {\n    this.ga4?.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: \"G-GNVVWBL3J9\",\n      ...additionalInfo\n    });\n  }\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  ensureWalletExists(wallet) {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (!(wallet.readyState === \"Installed\" /* Installed */))\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  ensureAccountExists(account) {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  async setAnsName() {\n    if (this._network?.chainId && this._account) {\n      if (this._account.ansName) return;\n      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isAptosNetwork(this._network)) {\n        this._account.ansName = void 0;\n        return;\n      }\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const aptos = new Aptos2(aptosConfig);\n      try {\n        const name = await aptos.ans.getPrimaryName({\n          address: this._account.address.toString()\n        });\n        this._account.ansName = name;\n      } catch (error) {\n        console.log(`Error setting ANS name ${error}`);\n      }\n    }\n  }\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  clearData() {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet) {\n    this._wallet = wallet;\n  }\n  /**\n   * Sets the connected account\n   *\n   * @param account An account\n   */\n  setAccount(account) {\n    this._account = account;\n  }\n  /**\n   * Sets the connected network\n   *\n   * @param network A network\n   */\n  setNetwork(network) {\n    this._network = network;\n  }\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected() {\n    return this._connected;\n  }\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets() {\n    return this._standard_wallets;\n  }\n  get notDetectedWallets() {\n    return this._standard_not_detected_wallets;\n  }\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet() {\n    try {\n      if (!this._wallet) return null;\n      return this._wallet;\n    } catch (error) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account() {\n    try {\n      return this._account;\n    } catch (error) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network() {\n    try {\n      return this._network;\n    } catch (error) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName) {\n    if (isRedirectable()) {\n      const selectedWallet2 = this._standard_not_detected_wallets.find(\n        (wallet) => wallet.name === walletName\n      );\n      if (selectedWallet2) {\n        const uninstalledWallet = selectedWallet2;\n        if (uninstalledWallet.deeplinkProvider) {\n          let parameter = \"\";\n          if (uninstalledWallet.name.includes(\"Phantom\")) {\n            let url = encodeURIComponent(window.location.href);\n            let ref = encodeURIComponent(window.location.origin);\n            parameter = `${url}?ref=${ref}`;\n          } else {\n            parameter = encodeURIComponent(window.location.href);\n          }\n          const location = uninstalledWallet.deeplinkProvider.concat(parameter);\n          window.location.href = location;\n          return;\n        }\n      }\n    }\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) return;\n    if (this._connected && this._account) {\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n    await this.connectWallet(selectedWallet, async () => {\n      const response = await selectedWallet.features[\"aptos:connect\"].connect();\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return { account: response.args, output: void 0 };\n    });\n  }\n  /**\n   * Signs into the wallet by connecting and signing an authentication messages.\n   *\n   * For more information, visit: https://siwa.aptos.dev\n   *\n   * @param args\n   * @param args.input The AptosSignInInput which defines how the SIWA Message should be constructed\n   * @param args.walletName The name of the wallet to sign into\n   * @returns The AptosSignInOutput which contains the account and signature information\n   */\n  async signIn(args) {\n    const { input, walletName } = args;\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) {\n      throw new WalletNotFoundError(`Wallet ${walletName} not found`).message;\n    }\n    if (!selectedWallet.features[\"aptos:signIn\"]) {\n      throw new WalletNotSupportedMethod(\n        `aptos:signIn is not supported by ${walletName}`\n      ).message;\n    }\n    return await this.connectWallet(selectedWallet, async () => {\n      if (!selectedWallet.features[\"aptos:signIn\"]) {\n        throw new WalletNotSupportedMethod(\n          `aptos:signIn is not supported by ${selectedWallet.name}`\n        ).message;\n      }\n      const response = await selectedWallet.features[\"aptos:signIn\"].signIn(input);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return { account: response.args.account, output: response.args };\n    });\n  }\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  async connectWallet(selectedWallet, onConnect) {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const { account, output } = await onConnect();\n      this.setAccount(account);\n      const network = await selectedWallet.features[\"aptos:network\"].network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n      return output;\n    } catch (error) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"aptos:disconnect\"].disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns AptosSignAndSubmitTransactionOutput\n   */\n  async signAndSubmitTransaction(transactionInput) {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (transactionInput.data.function === \"0x1::account::rotate_authentication_key_call\") {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\").message;\n        }\n        if (transactionInput.data.function === \"0x1::code::publish_package_txn\") {\n          ({\n            metadataBytes: transactionInput.data.functionArguments[0],\n            byteCode: transactionInput.data.functionArguments[1]\n          } = handlePublishPackageTransaction(transactionInput));\n        }\n      }\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n      const shouldUseTxnSubmitter = this._dappConfig?.transactionSubmitter !== void 0 || transactionInput.transactionSubmitter !== void 0;\n      if (this._wallet.features[\"aptos:signAndSubmitTransaction\"] && !shouldUseTxnSubmitter) {\n        if (this._wallet.features[\"aptos:signAndSubmitTransaction\"].version !== \"1.1.0\") {\n          const aptosConfig2 = getAptosConfig(this._network, this._dappConfig);\n          const aptos2 = new Aptos2(aptosConfig2);\n          const transaction2 = await aptos2.transaction.build.simple({\n            sender: this._account.address.toString(),\n            data: transactionInput.data,\n            options: transactionInput.options\n          });\n          const signAndSubmitTransactionMethod = this._wallet.features[\"aptos:signAndSubmitTransaction\"].signAndSubmitTransaction;\n          const response3 = await signAndSubmitTransactionMethod(\n            transaction2\n          );\n          if (response3.status === UserResponseStatus.REJECTED) {\n            throw new WalletConnectionError(\"User has rejected the request\").message;\n          }\n          return response3.args;\n        }\n        const response2 = await this._wallet.features[\"aptos:signAndSubmitTransaction\"].signAndSubmitTransaction({\n          payload: transactionInput.data,\n          gasUnitPrice: transactionInput.options?.gasUnitPrice,\n          maxGasAmount: transactionInput.options?.maxGasAmount\n        });\n        if (response2.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return response2.args;\n      }\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const aptos = new Aptos2(aptosConfig);\n      const transaction = await aptos.transaction.build.simple({\n        sender: this._account.address.toString(),\n        data: transactionInput.data,\n        options: transactionInput.options,\n        withFeePayer: shouldUseTxnSubmitter\n      });\n      const signTransactionResponse = await this.signTransaction({\n        transactionOrPayload: transaction\n      });\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator: signTransactionResponse.authenticator,\n        transactionSubmitter: transactionInput.transactionSubmitter,\n        pluginParams: transactionInput.pluginParams\n      });\n      return { hash: response.hash };\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n  /**\n   * Signs a transaction\n   *\n   * This method supports 2 input types -\n   * 1. A raw transaction that was already built by the dapp,\n   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing\n   *\n   * @param transactionOrPayload AnyRawTransaction | InputTransactionData\n   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer\n   * @param options optional. Transaction options\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(args) {\n    const { transactionOrPayload, asFeePayer } = args;\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_transaction\");\n      if (\"rawTransaction\" in transactionOrPayload) {\n        const response = await this._wallet?.features[\"aptos:signTransaction\"].signTransaction(\n          transactionOrPayload,\n          asFeePayer\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()\n        };\n      } else if (this._wallet.features[\"aptos:signTransaction\"]?.version === \"1.1\") {\n        const signTransactionV1_1StandardInput = {\n          payload: transactionOrPayload.data,\n          expirationTimestamp: transactionOrPayload.options?.expirationTimestamp,\n          expirationSecondsFromNow: transactionOrPayload.options?.expirationSecondsFromNow,\n          gasUnitPrice: transactionOrPayload.options?.gasUnitPrice,\n          maxGasAmount: transactionOrPayload.options?.maxGasAmount,\n          sequenceNumber: transactionOrPayload.options?.accountSequenceNumber,\n          sender: transactionOrPayload.sender ? { address: AccountAddress.from(transactionOrPayload.sender) } : void 0\n        };\n        const walletSignTransactionMethod = this._wallet?.features[\"aptos:signTransaction\"].signTransaction;\n        const response = await walletSignTransactionMethod(\n          signTransactionV1_1StandardInput\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args.authenticator,\n          rawTransaction: response.args.rawTransaction.bcsToBytes()\n        };\n      } else {\n        const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n        const aptos = new Aptos2(aptosConfig);\n        const transaction = await aptos.transaction.build.simple({\n          sender: this._account.address,\n          data: transactionOrPayload.data,\n          options: transactionOrPayload.options,\n          withFeePayer: transactionOrPayload.withFeePayer\n        });\n        const response = await this._wallet?.features[\"aptos:signTransaction\"].signTransaction(\n          transaction,\n          asFeePayer\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transaction.bcsToBytes()\n        };\n      }\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n  /**\n   * Sign a message (doesnt submit to chain).\n   *\n   * @param message - AptosSignMessageInput\n   *\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(message) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n      const response = await this._wallet?.features[\"aptos:signMessage\"]?.signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return response.args;\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction - InputSubmitTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(transaction) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType = additionalSignersAuthenticators !== void 0 ? \"multi-agent\" : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType\n      });\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const aptos = new Aptos2(aptosConfig);\n      if (additionalSignersAuthenticators !== void 0) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators\n        };\n        return aptos.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return aptos.transaction.submit.simple(transaction);\n      }\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSubmitTransactionError(errMsg).message;\n    }\n  }\n  /**\n   Event for when account has changed on the wallet\n   @return the new account info\n   @throws WalletAccountChangeError\n   */\n  async onAccountChange() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"aptos:onAccountChange\"]?.onAccountChange(\n        async (data) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n  /**\n   Event for when network has changed on the wallet\n   @return the new network info\n   @throws WalletNetworkChangeError\n   */\n  async onNetworkChange() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"aptos:onNetworkChange\"]?.onNetworkChange(\n        async (data) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network - Network\n   * @returns AptosChangeNetworkOutput\n   */\n  async changeNetwork(network) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network\n      });\n      const chainId = network === Network2.DEVNET ? await fetchDevnetChainId() : NetworkToChainId[network];\n      const networkInfo = {\n        name: network,\n        chainId\n      };\n      if (this._wallet.features[\"aptos:changeNetwork\"]) {\n        const response = await this._wallet.features[\"aptos:changeNetwork\"].changeNetwork(\n          networkInfo\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return response.args;\n      }\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n  /**\n   * Signs a message and verifies the signer\n   * @param message - AptosSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(message) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n      const response = await this._wallet.features[\"aptos:signMessage\"].signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const signingMessage = new TextEncoder().encode(\n        response.args.fullMessage\n      );\n      if (\"verifySignatureAsync\" in this._account.publicKey) {\n        return await this._account.publicKey.verifySignatureAsync({\n          aptosConfig,\n          message: signingMessage,\n          signature: response.args.signature,\n          options: { throwErrorWithReason: true }\n        });\n      }\n      return this._account.publicKey.verifySignature({\n        message: signingMessage,\n        signature: response.args.signature\n      });\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n};\n\n// src/index.ts\nif (typeof window !== \"undefined\") {\n  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;\n}\nexport {\n  APTOS_CONNECT_ACCOUNT_URL,\n  APTOS_CONNECT_BASE_URL,\n  ChainIdToAnsSupportedNetworkMap,\n  NetworkName,\n  WalletCore,\n  WalletReadyState,\n  aptosStandardSupportedWalletList,\n  convertNetwork,\n  crossChainStandardSupportedWalletList,\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getAptosConfig,\n  getAptosConnectWallets,\n  getLocalStorage,\n  getSDKWallets,\n  groupAndSortWallets,\n  handlePublishPackageTransaction,\n  isAptosConnectWallet,\n  isAptosLiveNetwork,\n  isAptosNetwork,\n  isInAppBrowser,\n  isInstallRequired,\n  isInstalledOrLoadable,\n  isMobile,\n  isRedirectable,\n  partitionWallets,\n  removeLocalStorage,\n  setLocalStorage,\n  truncateAddress\n};\n", "export const WALLET_ADAPTER_CORE_VERSION = \"7.1.1\";\n", "import EventEmitter from \"eventemitter3\";\nimport {\n  AccountAddress,\n  AccountAuthenticator,\n  AnyPublicKey,\n  AnyPublicKeyVariant,\n  AnyRawTransaction,\n  Aptos,\n  Ed25519PublicKey,\n  InputSubmitTransactionData,\n  MultiEd25519PublicKey,\n  MultiEd25519Signature,\n  Network,\n  NetworkToChainId,\n  PendingTransactionResponse,\n  TransactionSubmitter,\n} from \"@aptos-labs/ts-sdk\";\nimport {\n  AptosWallet,\n  getAptosWallets,\n  isWalletWithRequiredFeatureSet,\n  UserResponseStatus,\n  AptosSignAndSubmitTransactionOutput,\n  UserResponse,\n  AptosSignTransactionOutputV1_1,\n  AptosSignTransactionInputV1_1,\n  AptosSignTransactionMethod,\n  AptosSignTransactionMethodV1_1,\n  NetworkInfo,\n  AccountInfo,\n  AptosSignMessageInput,\n  AptosSignMessageOutput,\n  AptosChangeNetworkOutput,\n  AptosSignInInput,\n  AptosSignInOutput,\n} from \"@aptos-labs/wallet-standard\";\nimport { AptosConnectWalletConfig } from \"@aptos-connect/wallet-adapter-plugin\";\n\nexport type {\n  NetworkInfo,\n  AccountInfo,\n  AptosSignAndSubmitTransactionOutput,\n  AptosSignTransactionOutputV1_1,\n  AptosSignMessageInput,\n  AptosSignMessageOutput,\n  AptosChangeNetworkOutput,\n} from \"@aptos-labs/wallet-standard\";\nexport type {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  PendingTransactionResponse,\n  InputSubmitTransactionData,\n  Network,\n  AnyPublicKey,\n  AccountAddress,\n  TransactionSubmitter,\n} from \"@aptos-labs/ts-sdk\";\n\nimport { GA4 } from \"./ga\";\nimport {\n  WalletChangeNetworkError,\n  WalletAccountChangeError,\n  WalletAccountError,\n  WalletConnectionError,\n  WalletGetNetworkError,\n  WalletNetworkChangeError,\n  WalletNotConnectedError,\n  WalletNotReadyError,\n  WalletNotSelectedError,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageError,\n  WalletSignTransactionError,\n  WalletSignMessageAndVerifyError,\n  WalletDisconnectionError,\n  WalletSubmitTransactionError,\n  WalletNotSupportedMethod,\n  WalletNotFoundError,\n} from \"./error\";\nimport { ChainIdToAnsSupportedNetworkMap, WalletReadyState } from \"./constants\";\nimport { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\nimport {\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getAptosConfig,\n  handlePublishPackageTransaction,\n  isAptosNetwork,\n  isRedirectable,\n  removeLocalStorage,\n  setLocalStorage,\n} from \"./utils\";\nimport {\n  aptosStandardSupportedWalletList,\n  crossChainStandardSupportedWalletList,\n} from \"./registry\";\nimport { getSDKWallets } from \"./sdkWallets\";\nimport {\n  AvailableWallets,\n  AptosStandardSupportedWallet,\n  InputTransactionData,\n} from \"./utils/types\";\n\n// An adapter wallet types is a wallet that is compatible with the wallet standard and the wallet adapter properties\nexport type AdapterWallet = AptosWallet & {\n  readyState?: WalletReadyState;\n  isAptosNativeWallet?: boolean;\n};\n\n// An adapter not detected wallet types is a wallet that is compatible with the wallet standard but not detected\nexport type AdapterNotDetectedWallet = Omit<\n  AdapterWallet,\n  \"features\" | \"version\" | \"chains\" | \"accounts\"\n> & {\n  readyState: WalletReadyState.NotDetected;\n};\n\nexport interface DappConfig {\n  network: Network;\n  /**\n   * If provided, the wallet adapter will submit transactions using the provided\n   * transaction submitter rather than via the wallet.\n   */\n  transactionSubmitter?: TransactionSubmitter;\n  aptosApiKeys?: Partial<Record<Network, string>>;\n  aptosConnectDappId?: string;\n  aptosConnect?: Omit<AptosConnectWalletConfig, \"network\">;\n  /**\n   * @deprecated will be removed in a future version\n   */\n  mizuwallet?: {\n    manifestURL: string;\n    appId?: string;\n  };\n  msafeWalletConfig?: {\n    appId?: string;\n    appUrl?: string;\n  };\n  crossChainWallets?: boolean;\n}\n\nexport declare interface WalletCoreEvents {\n  connect(account: AccountInfo | null): void;\n  disconnect(): void;\n  standardWalletsAdded(wallets: AdapterWallet): void;\n  standardNotDetectedWalletAdded(wallets: AdapterNotDetectedWallet): void;\n  networkChange(network: NetworkInfo | null): void;\n  accountChange(account: AccountInfo | null): void;\n}\n\nexport type AdapterAccountInfo = Omit<AccountInfo, \"ansName\"> & {\n  // ansName is a read-only property on the standard AccountInfo type\n  ansName?: string;\n};\n\nexport class WalletCore extends EventEmitter<WalletCoreEvents> {\n  // Local private variable to hold the wallet that is currently connected\n  private _wallet: AdapterWallet | null = null;\n\n  // Local private variable to hold SDK wallets in the adapter\n  private readonly _sdkWallets: AdapterWallet[] = [];\n\n  // Local array that holds all the wallets that are AIP-62 standard compatible\n  private _standard_wallets: AdapterWallet[] = [];\n\n  // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine\n  private _standard_not_detected_wallets: AdapterNotDetectedWallet[] = [];\n\n  // Local private variable to hold the network that is currently connected\n  private _network: NetworkInfo | null = null;\n\n  // Local private variable to hold the wallet connected state\n  private _connected: boolean = false;\n\n  // Local private variable to hold the connecting state\n  private _connecting: boolean = false;\n\n  // Local private variable to hold the account that is currently connected\n  private _account: AdapterAccountInfo | null = null;\n\n  // JSON configuration for AptosConnect\n  private _dappConfig: DappConfig | undefined;\n\n  // Private array that holds all the Wallets a dapp decided to opt-in to\n  private _optInWallets: ReadonlyArray<AvailableWallets> = [];\n\n  // Local flag to disable the adapter telemetry tool\n  private _disableTelemetry: boolean = false;\n\n  // Google Analytics 4 module\n  private readonly ga4: GA4 | null = null;\n\n  constructor(\n    optInWallets?: ReadonlyArray<AvailableWallets>,\n    dappConfig?: DappConfig,\n    disableTelemetry?: boolean\n  ) {\n    super();\n    this._optInWallets = optInWallets || [];\n    this._dappConfig = dappConfig;\n    this._disableTelemetry = disableTelemetry ?? false;\n    this._sdkWallets = getSDKWallets(this._dappConfig);\n\n    // If disableTelemetry set to false (by default), start GA4\n    if (!this._disableTelemetry) {\n      this.ga4 = new GA4();\n    }\n    // Strategy to detect AIP-62 standard compatible extension wallets\n    this.fetchExtensionAIP62AptosWallets();\n    // Strategy to detect AIP-62 standard compatible SDK wallets.\n    // We separate the extension and sdk detection process so we dont refetch sdk wallets everytime a new\n    // extension wallet is detected\n    this.fetchSDKAIP62AptosWallets();\n    // Strategy to append not detected AIP-62 standard compatible extension wallets\n    this.appendNotDetectedStandardSupportedWallets();\n  }\n\n  private fetchExtensionAIP62AptosWallets(): void {\n    let { aptosWallets, on } = getAptosWallets();\n    this.setExtensionAIP62Wallets(aptosWallets);\n\n    if (typeof window === \"undefined\") return;\n    // Adds an event listener for new wallets that get registered after the dapp has been loaded,\n    // receiving an unsubscribe function, which it can later use to remove the listener\n    const that = this;\n    const removeRegisterListener = on(\"register\", function () {\n      let { aptosWallets } = getAptosWallets();\n      that.setExtensionAIP62Wallets(aptosWallets);\n    });\n\n    const removeUnregisterListener = on(\"unregister\", function () {\n      let { aptosWallets } = getAptosWallets();\n      that.setExtensionAIP62Wallets(aptosWallets);\n    });\n  }\n\n  /**\n   * Set AIP-62 extension wallets\n   *\n   * @param extensionwWallets\n   */\n  private setExtensionAIP62Wallets(\n    extensionwWallets: readonly AptosWallet[]\n  ): void {\n    extensionwWallets.map((wallet: AdapterWallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n\n      // Rimosafe is not supported anymore, so hiding it\n      if (wallet.name === \"Rimosafe\") {\n        return;\n      }\n\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n\n      if (isValid) {\n        // check if we already have this wallet as a not detected wallet\n        const index = this._standard_not_detected_wallets.findIndex(\n          (notDetctedWallet) => notDetctedWallet.name == wallet.name\n        );\n        // if we do, remove it from the not detected wallets array as it is now become detected\n        if (index !== -1) {\n          this._standard_not_detected_wallets.splice(index, 1);\n        }\n\n        // ✅ Check if wallet already exists in _standard_wallets\n        const alreadyExists = this._standard_wallets.some(\n          (w) => w.name === wallet.name\n        );\n        if (!alreadyExists) {\n          wallet.readyState = WalletReadyState.Installed;\n          wallet.isAptosNativeWallet = this.isAptosNativeWallet(wallet);\n          this._standard_wallets.push(wallet);\n          this.emit(\"standardWalletsAdded\", wallet);\n        }\n      }\n    });\n  }\n\n  /**\n   * Set AIP-62 SDK wallets\n   */\n  private fetchSDKAIP62AptosWallets(): void {\n    this._sdkWallets.map((wallet: AdapterWallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n\n      if (isValid) {\n        wallet.readyState = WalletReadyState.Installed;\n        wallet.isAptosNativeWallet = this.isAptosNativeWallet(wallet);\n        this._standard_wallets.push(wallet);\n      }\n    });\n  }\n\n  // Aptos native wallets do not have an authenticationFunction property\n  private isAptosNativeWallet(wallet: AptosWallet): boolean {\n    return !(\"authenticationFunction\" in wallet);\n  }\n\n  // Since we can't discover AIP-62 wallets that are not installed on the user machine,\n  // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.\n  // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array\n  // when wallet is not installed on the user machine\n  private appendNotDetectedStandardSupportedWallets(): void {\n    const walletRegistry = this._dappConfig?.crossChainWallets\n      ? [\n          ...aptosStandardSupportedWalletList,\n          ...crossChainStandardSupportedWalletList,\n        ]\n      : aptosStandardSupportedWalletList;\n    // Loop over the registry map\n    walletRegistry.map((supportedWallet: AptosStandardSupportedWallet) => {\n      // Check if we already have this wallet as a detected AIP-62 wallet standard\n      const existingStandardWallet = this._standard_wallets.find(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n      // If it is detected, it means the user has the wallet installed, so dont add it to the wallets array\n      if (existingStandardWallet) {\n        return;\n      }\n      // If AIP-62 wallet detected but it is excluded by the dapp, dont add it to the wallets array\n      if (this.excludeWallet(supportedWallet)) {\n        return;\n      }\n      // If AIP-62 wallet does not exist, append it to the wallet selector modal\n      // as an undetected wallet\n      if (!existingStandardWallet) {\n        // Aptos native wallets do not have an authenticationFunction property\n        supportedWallet.isAptosNativeWallet = !(\n          \"authenticationFunction\" in supportedWallet\n        );\n        this._standard_not_detected_wallets.push(supportedWallet);\n        this.emit(\"standardNotDetectedWalletAdded\", supportedWallet);\n      }\n    });\n  }\n\n  /**\n   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include\n   *\n   * @param wallet AdapterWallet | AdapterNotDetectedWallet\n   * @returns boolean\n   */\n  excludeWallet(wallet: AdapterWallet | AdapterNotDetectedWallet): boolean {\n    // If _optInWallets is not empty, and does not include the provided wallet,\n    // return true to exclude the wallet, otherwise return false\n    if (\n      this._optInWallets.length > 0 &&\n      !this._optInWallets.includes(wallet.name as AvailableWallets)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private recordEvent(eventName: string, additionalInfo?: object): void {\n    this.ga4?.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: process.env.GAID,\n      ...additionalInfo,\n    });\n  }\n\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  private ensureWalletExists(\n    wallet: AdapterWallet | null\n  ): asserts wallet is AdapterWallet {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (!(wallet.readyState === WalletReadyState.Installed))\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  private ensureAccountExists(\n    account: AccountInfo | null\n  ): asserts account is AccountInfo {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  private async setAnsName(): Promise<void> {\n    if (this._network?.chainId && this._account) {\n      if (this._account.ansName) return;\n      // ANS supports only MAINNET or TESTNET\n      if (\n        !ChainIdToAnsSupportedNetworkMap[this._network.chainId] ||\n        !isAptosNetwork(this._network)\n      ) {\n        this._account.ansName = undefined;\n        return;\n      }\n\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const aptos = new Aptos(aptosConfig);\n      try {\n        const name = await aptos.ans.getPrimaryName({\n          address: this._account.address.toString(),\n        });\n        this._account.ansName = name;\n      } catch (error: any) {\n        console.log(`Error setting ANS name ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  private clearData(): void {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet: AptosWallet | null): void {\n    this._wallet = wallet;\n  }\n\n  /**\n   * Sets the connected account\n   *\n   * @param account An account\n   */\n  setAccount(account: AccountInfo | null): void {\n    this._account = account;\n  }\n\n  /**\n   * Sets the connected network\n   *\n   * @param network A network\n   */\n  setNetwork(network: NetworkInfo | null): void {\n    this._network = network;\n  }\n\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected(): boolean {\n    return this._connected;\n  }\n\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets(): ReadonlyArray<AptosWallet> {\n    return this._standard_wallets;\n  }\n\n  get notDetectedWallets(): ReadonlyArray<AdapterNotDetectedWallet> {\n    return this._standard_not_detected_wallets;\n  }\n\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet(): AptosWallet | null {\n    try {\n      if (!this._wallet) return null;\n      return this._wallet;\n    } catch (error: any) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account(): AccountInfo | null {\n    try {\n      return this._account;\n    } catch (error: any) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network(): NetworkInfo | null {\n    try {\n      return this._network;\n    } catch (error: any) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName: string): Promise<void | string> {\n    // First, handle mobile case\n    // Check if we are in a redirectable view (i.e on mobile AND not in an in-app browser)\n    if (isRedirectable()) {\n      const selectedWallet = this._standard_not_detected_wallets.find(\n        (wallet: AdapterNotDetectedWallet) => wallet.name === walletName\n      );\n\n      if (selectedWallet) {\n        // If wallet has a deeplinkProvider property, use it\n        const uninstalledWallet =\n          selectedWallet as unknown as AptosStandardSupportedWallet;\n        if (uninstalledWallet.deeplinkProvider) {\n          let parameter = \"\";\n          if (uninstalledWallet.name.includes(\"Phantom\")) {\n            // Phantom required parameters https://docs.phantom.com/phantom-deeplinks/other-methods/browse#parameters\n            let url = encodeURIComponent(window.location.href);\n            let ref = encodeURIComponent(window.location.origin);\n            parameter = `${url}?ref=${ref}`;\n          } else {\n            parameter = encodeURIComponent(window.location.href);\n          }\n          const location = uninstalledWallet.deeplinkProvider.concat(parameter);\n          window.location.href = location;\n          return;\n        }\n      }\n    }\n\n    // Checks the wallet exists in the detected wallets array\n    const allDetectedWallets = this._standard_wallets;\n\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: AdapterWallet) => wallet.name === walletName\n    );\n\n    if (!selectedWallet) return;\n\n    // Check if wallet is already connected\n    if (this._connected && this._account) {\n      // if the selected wallet is already connected, we don't need to connect again\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n\n    await this.connectWallet(selectedWallet, async () => {\n      const response = await selectedWallet.features[\"aptos:connect\"].connect();\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return { account: response.args, output: undefined };\n    });\n  }\n\n  /**\n   * Signs into the wallet by connecting and signing an authentication messages.\n   *\n   * For more information, visit: https://siwa.aptos.dev\n   *\n   * @param args\n   * @param args.input The AptosSignInInput which defines how the SIWA Message should be constructed\n   * @param args.walletName The name of the wallet to sign into\n   * @returns The AptosSignInOutput which contains the account and signature information\n   */\n  async signIn(args: {\n    input: AptosSignInInput;\n    walletName: string;\n  }): Promise<AptosSignInOutput> {\n    const { input, walletName } = args;\n\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: AdapterWallet) => wallet.name === walletName\n    );\n\n    if (!selectedWallet) {\n      throw new WalletNotFoundError(`Wallet ${walletName} not found`).message;\n    }\n\n    if (!selectedWallet.features[\"aptos:signIn\"]) {\n      throw new WalletNotSupportedMethod(\n        `aptos:signIn is not supported by ${walletName}`\n      ).message;\n    }\n\n    return await this.connectWallet(selectedWallet, async () => {\n      if (!selectedWallet.features[\"aptos:signIn\"]) {\n        throw new WalletNotSupportedMethod(\n          `aptos:signIn is not supported by ${selectedWallet.name}`\n        ).message;\n      }\n\n      const response =\n        await selectedWallet.features[\"aptos:signIn\"].signIn(input);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return { account: response.args.account, output: response.args };\n    });\n  }\n\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  private async connectWallet<T>(\n    selectedWallet: AdapterWallet,\n    onConnect: () => Promise<{ account: AccountInfo; output: T }>\n  ): Promise<T> {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const { account, output } = await onConnect();\n      this.setAccount(account);\n      const network = await selectedWallet.features[\"aptos:network\"].network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n      return output;\n    } catch (error: any) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"aptos:disconnect\"].disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns AptosSignAndSubmitTransactionOutput\n   */\n  async signAndSubmitTransaction(\n    transactionInput: InputTransactionData\n  ): Promise<AptosSignAndSubmitTransactionOutput> {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (\n          transactionInput.data.function ===\n          \"0x1::account::rotate_authentication_key_call\"\n        ) {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\")\n            .message;\n        }\n\n        if (\n          transactionInput.data.function === \"0x1::code::publish_package_txn\"\n        ) {\n          ({\n            metadataBytes: transactionInput.data.functionArguments[0],\n            byteCode: transactionInput.data.functionArguments[1],\n          } = handlePublishPackageTransaction(transactionInput));\n        }\n      }\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n\n      // We'll submit ourselves if a custom transaction submitter has been provided.\n      const shouldUseTxnSubmitter =\n        this._dappConfig?.transactionSubmitter !== undefined ||\n        transactionInput.transactionSubmitter !== undefined;\n\n      if (\n        this._wallet.features[\"aptos:signAndSubmitTransaction\"] &&\n        !shouldUseTxnSubmitter\n      ) {\n        // check for backward compatibility. before version 1.1.0 the standard expected\n        // AnyRawTransaction input so the adapter built the transaction before sending it to the wallet\n        if (\n          this._wallet.features[\"aptos:signAndSubmitTransaction\"].version !==\n          \"1.1.0\"\n        ) {\n          const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n\n          const aptos = new Aptos(aptosConfig);\n          const transaction = await aptos.transaction.build.simple({\n            sender: this._account.address.toString(),\n            data: transactionInput.data,\n            options: transactionInput.options,\n          });\n\n          type AptosSignAndSubmitTransactionV1Method = (\n            transaction: AnyRawTransaction\n          ) => Promise<UserResponse<AptosSignAndSubmitTransactionOutput>>;\n\n          const signAndSubmitTransactionMethod = this._wallet.features[\n            \"aptos:signAndSubmitTransaction\"\n          ]\n            .signAndSubmitTransaction as unknown as AptosSignAndSubmitTransactionV1Method;\n\n          const response = (await signAndSubmitTransactionMethod(\n            transaction\n          )) as UserResponse<AptosSignAndSubmitTransactionOutput>;\n\n          if (response.status === UserResponseStatus.REJECTED) {\n            throw new WalletConnectionError(\"User has rejected the request\")\n              .message;\n          }\n\n          return response.args;\n        }\n\n        const response = await this._wallet.features[\n          \"aptos:signAndSubmitTransaction\"\n        ].signAndSubmitTransaction({\n          payload: transactionInput.data,\n          gasUnitPrice: transactionInput.options?.gasUnitPrice,\n          maxGasAmount: transactionInput.options?.maxGasAmount,\n        });\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n\n      // If wallet does not support signAndSubmitTransaction or a transaction submitter\n      // is provided, the adapter will sign and submit it for the dapp.\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const aptos = new Aptos(aptosConfig);\n      const transaction = await aptos.transaction.build.simple({\n        sender: this._account.address.toString(),\n        data: transactionInput.data,\n        options: transactionInput.options,\n        withFeePayer: shouldUseTxnSubmitter,\n      });\n\n      const signTransactionResponse = await this.signTransaction({\n        transactionOrPayload: transaction,\n      });\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator: signTransactionResponse.authenticator,\n        transactionSubmitter: transactionInput.transactionSubmitter,\n        pluginParams: transactionInput.pluginParams,\n      });\n      return { hash: response.hash };\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a transaction\n   *\n   * This method supports 2 input types -\n   * 1. A raw transaction that was already built by the dapp,\n   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing\n   *\n   * @param transactionOrPayload AnyRawTransaction | InputTransactionData\n   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer\n   * @param options optional. Transaction options\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(args: {\n    transactionOrPayload: AnyRawTransaction | InputTransactionData;\n    asFeePayer?: boolean;\n  }): Promise<{\n    authenticator: AccountAuthenticator;\n    rawTransaction: Uint8Array;\n  }> {\n    const { transactionOrPayload, asFeePayer } = args;\n    /**\n     * All standard compatible wallets should support AnyRawTransaction for signTransaction version 1.0.0\n     * For standard signTransaction version 1.1.0, the standard expects a transaction input\n     *\n     * So, if the input is AnyRawTransaction, we can directly call the wallet's signTransaction method\n     *\n     *\n     * If the input is InputTransactionData, we need to\n     * 1. check if the wallet supports signTransaction version 1.1.0 - if so, we convert the input to the standard expected input\n     * 2. if it does not support signTransaction version 1.1.0, we convert it to a rawTransaction input and call the wallet's signTransaction method\n     */\n\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_transaction\");\n\n      // dapp sends a generated transaction (i.e AnyRawTransaction), which is supported by the wallet standard at signTransaction version 1.0.0\n      if (\"rawTransaction\" in transactionOrPayload) {\n        const response = (await this._wallet?.features[\n          \"aptos:signTransaction\"\n        ].signTransaction(\n          transactionOrPayload,\n          asFeePayer\n        )) as UserResponse<AccountAuthenticator>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes(),\n        };\n      } // dapp sends a transaction data input (i.e InputTransactionData), which is supported by the wallet standard at signTransaction version 1.1.0\n      else if (\n        this._wallet.features[\"aptos:signTransaction\"]?.version === \"1.1\"\n      ) {\n        // convert input to standard expected input\n        const signTransactionV1_1StandardInput: AptosSignTransactionInputV1_1 =\n          {\n            payload: transactionOrPayload.data,\n            expirationTimestamp:\n              transactionOrPayload.options?.expirationTimestamp,\n            expirationSecondsFromNow:\n              transactionOrPayload.options?.expirationSecondsFromNow,\n            gasUnitPrice: transactionOrPayload.options?.gasUnitPrice,\n            maxGasAmount: transactionOrPayload.options?.maxGasAmount,\n            sequenceNumber: transactionOrPayload.options?.accountSequenceNumber,\n            sender: transactionOrPayload.sender\n              ? { address: AccountAddress.from(transactionOrPayload.sender) }\n              : undefined,\n          };\n\n        const walletSignTransactionMethod = this._wallet?.features[\n          \"aptos:signTransaction\"\n        ].signTransaction as AptosSignTransactionMethod &\n          AptosSignTransactionMethodV1_1;\n\n        const response = (await walletSignTransactionMethod(\n          signTransactionV1_1StandardInput\n        )) as UserResponse<AptosSignTransactionOutputV1_1>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return {\n          authenticator: response.args.authenticator,\n          rawTransaction: response.args.rawTransaction.bcsToBytes(),\n        };\n      } else {\n        // dapp input is InputTransactionData but the wallet does not support it, so we convert it to a rawTransaction\n        const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n        const aptos = new Aptos(aptosConfig);\n\n        const transaction = await aptos.transaction.build.simple({\n          sender: this._account.address,\n          data: transactionOrPayload.data,\n          options: transactionOrPayload.options,\n          withFeePayer: transactionOrPayload.withFeePayer,\n        });\n\n        const response = (await this._wallet?.features[\n          \"aptos:signTransaction\"\n        ].signTransaction(\n          transaction,\n          asFeePayer\n        )) as UserResponse<AccountAuthenticator>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n\n        return {\n          authenticator: response.args,\n          rawTransaction: transaction.bcsToBytes(),\n        };\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sign a message (doesnt submit to chain).\n   *\n   * @param message - AptosSignMessageInput\n   *\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(\n    message: AptosSignMessageInput\n  ): Promise<AptosSignMessageOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n\n      const response =\n        await this._wallet?.features[\"aptos:signMessage\"]?.signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n      return response.args;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction - InputSubmitTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse> {\n    // The standard does not support submitTransaction, so we use the adapter to submit the transaction\n    try {\n      this.ensureWalletExists(this._wallet);\n\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType =\n        additionalSignersAuthenticators !== undefined\n          ? \"multi-agent\"\n          : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType,\n      });\n\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const aptos = new Aptos(aptosConfig);\n      if (additionalSignersAuthenticators !== undefined) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators,\n        };\n        return aptos.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return aptos.transaction.submit.simple(transaction);\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSubmitTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   Event for when account has changed on the wallet\n   @return the new account info\n   @throws WalletAccountChangeError\n   */\n  async onAccountChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"aptos:onAccountChange\"]?.onAccountChange(\n        async (data: AccountInfo) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   Event for when network has changed on the wallet\n   @return the new network info\n   @throws WalletNetworkChangeError\n   */\n  async onNetworkChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"aptos:onNetworkChange\"]?.onNetworkChange(\n        async (data: NetworkInfo) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network - Network\n   * @returns AptosChangeNetworkOutput\n   */\n  async changeNetwork(network: Network): Promise<AptosChangeNetworkOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network,\n      });\n      const chainId =\n        network === Network.DEVNET\n          ? await fetchDevnetChainId()\n          : NetworkToChainId[network];\n\n      const networkInfo: NetworkInfo = {\n        name: network,\n        chainId,\n      };\n\n      if (this._wallet.features[\"aptos:changeNetwork\"]) {\n        const response =\n          await this._wallet.features[\"aptos:changeNetwork\"].changeNetwork(\n            networkInfo\n          );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a message and verifies the signer\n   * @param message - AptosSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(message: AptosSignMessageInput): Promise<boolean> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n\n      // sign the message\n      const response = (await this._wallet.features[\n        \"aptos:signMessage\"\n      ].signMessage(message)) as UserResponse<AptosSignMessageOutput>;\n\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n\n      const aptosConfig = getAptosConfig(this._network, this._dappConfig);\n      const signingMessage = new TextEncoder().encode(\n        response.args.fullMessage\n      );\n      if (\"verifySignatureAsync\" in (this._account.publicKey as Object)) {\n        return await this._account.publicKey.verifySignatureAsync({\n          aptosConfig,\n          message: signingMessage,\n          signature: response.args.signature,\n          options: { throwErrorWithReason: true },\n        });\n      }\n      return this._account.publicKey.verifySignature({\n        message: signingMessage,\n        signature: response.args.signature,\n      });\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n", "export class GA4 {\n  readonly aptosGAID: string | undefined = process.env.GAID;\n\n  constructor() {\n    // Inject Aptos Google Analytics 4 script\n    this.injectGA(this.aptosGAID);\n  }\n\n  gtag(a: string, b: string | object, c?: object) {\n    let dataLayer = (window as any).dataLayer || [];\n    dataLayer.push(arguments);\n  }\n\n  private injectGA(gaID?: string) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n\n    const head = document.getElementsByTagName(\"head\")[0];\n\n    var myScript = document.createElement(\"script\");\n\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`,\n    );\n\n    const that = this;\n    myScript.onload = function () {\n      that.gtag(\"js\", new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false,\n      });\n    };\n\n    head.insertBefore(myScript, head.children[1]);\n  }\n}\n", "export class WalletError extends Error {\n  public error: any;\n\n  constructor(message?: string, error?: any) {\n    super(message);\n    this.error = error;\n  }\n}\n\nexport class WalletNotSelectedError extends WalletError {\n  name = \"WalletNotSelectedError\";\n}\n\nexport class WalletNotReadyError extends WalletError {\n  name = \"WalletNotReadyError\";\n}\n\nexport class WalletLoadError extends WalletError {\n  name = \"WalletLoadError\";\n}\n\nexport class WalletConfigError extends WalletError {\n  name = \"WalletConfigError\";\n}\n\nexport class WalletConnectionError extends WalletError {\n  name = \"WalletConnectionError\";\n}\n\nexport class WalletDisconnectedError extends WalletError {\n  name = \"WalletDisconnectedError\";\n}\n\nexport class WalletDisconnectionError extends WalletError {\n  name = \"WalletDisconnectionError\";\n}\n\nexport class WalletAccountError extends WalletError {\n  name = \"WalletAccountError\";\n}\nexport class WalletGetNetworkError extends WalletError {\n  name = \"WalletGetNetworkError\";\n}\n\nexport class WalletAccountChangeError extends WalletError {\n  name = \"WalletAccountChangeError\";\n}\n\nexport class WalletNetworkChangeError extends WalletError {\n  name = \"WalletNetworkChangeError\";\n}\n\nexport class WalletPublicKeyError extends WalletError {\n  name = \"WalletPublicKeyError\";\n}\n\nexport class WalletKeypairError extends WalletError {\n  name = \"WalletKeypairError\";\n}\n\nexport class WalletNotConnectedError extends WalletError {\n  name = \"WalletNotConnectedError\";\n}\n\nexport class WalletSendTransactionError extends WalletError {\n  name = \"WalletSendTransactionError\";\n}\n\nexport class WalletSignMessageError extends WalletError {\n  name = \"WalletSignMessageError\";\n}\n\nexport class WalletSignMessageAndVerifyError extends WalletError {\n  name = \"WalletSignMessageAndVerifyError\";\n}\n\nexport class WalletSignAndSubmitMessageError extends WalletError {\n  name = \"WalletSignAndSubmitMessageError\";\n}\n\nexport class WalletSignTransactionError extends WalletError {\n  name = \"WalletSignTransactionError\";\n}\n\nexport class WalletTimeoutError extends WalletError {\n  name = \"WalletTimeoutError\";\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n  name = \"WalletWindowBlockedError\";\n}\n\nexport class WalletWindowClosedError extends WalletError {\n  name = \"WalletWindowClosedError\";\n}\n\nexport class WalletResponseError extends WalletError {\n  name = \"WalletResponseError\";\n}\n\nexport class WalletNotSupportedMethod extends WalletError {\n  name = \"WalletNotSupportedMethod\";\n}\n\nexport class WalletChangeNetworkError extends WalletError {\n  name = \"WalletChangeNetworkError\";\n}\n\nexport class WalletSubmitTransactionError extends WalletError {\n  name = \"WalletSubmitTransactionError\";\n}\n\nexport class WalletNotFoundError extends WalletError {\n  name = \"WalletNotFoundError\";\n}\n", "export enum WalletReadyState {\n  /**\n   * Wallet can only be in one of two states - installed or not installed\n   * Installed: wallets are detected by the browser event listeners and means they are installed on the user's browser.\n   * NotDetected: wallets are not detected by the browser event listeners and means they are not installed on the user's browser.\n   */\n  Installed = \"Installed\",\n  NotDetected = \"NotDetected\",\n}\n\nexport enum NetworkName {\n  Mainnet = \"mainnet\",\n  Testnet = \"testnet\",\n  Devnet = \"devnet\",\n}\n\nexport const ChainIdToAnsSupportedNetworkMap: Record<string, string> = {\n  \"1\": \"mainnet\", // mainnet\n  \"2\": \"testnet\", // testnet\n};\n\n/** The base URL for all Aptos Connect wallets. */\nexport const APTOS_CONNECT_BASE_URL = \"https://aptosconnect.app\";\n\n/** The URL to the Aptos Connect account page if the user is signed in to Aptos Connect. */\nexport const APTOS_CONNECT_ACCOUNT_URL =\n  \"https://aptosconnect.app/dashboard/main-account\";\n", "import {\n  Aptos,\n  AptosConfig,\n  Hex,\n  Network,\n  NetworkToNodeAPI,\n  PluginSettings,\n} from \"@aptos-labs/ts-sdk\";\nimport {\n  NetworkInfo,\n  NetworkInfo as StandardNetworkInfo,\n} from \"@aptos-labs/wallet-standard\";\n\nimport { DappConfig } from \"../WalletCore\";\nimport { WalletSignAndSubmitMessageError } from \"../error\";\nimport { InputTransactionData } from \"./types\";\n\nexport function isMobile(): boolean {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent,\n  );\n}\n\nexport function isInAppBrowser(): boolean {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent,\n  );\n\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent,\n  );\n\n  return isIphone || isAndroid;\n}\n\nexport function isRedirectable(): boolean {\n  // SSR: return false\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n\n  // if we are on mobile and NOT in a in-app browser we will redirect to a wallet app\n\n  return isMobile() && !isInAppBrowser();\n}\n\nexport function generalizedErrorMessage(error: any): string {\n  return typeof error === \"object\" && \"message\" in error\n    ? error.message\n    : error;\n}\n\n/**\n * Helper function to get AptosConfig that supports Aptos and Custom networks\n *\n * @param networkInfo\n * @param dappConfig\n * @returns AptosConfig\n */\nexport const getAptosConfig = (\n  networkInfo: NetworkInfo | null,\n  dappConfig: DappConfig | undefined,\n): AptosConfig => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n\n  const pluginSettings: PluginSettings = {\n    TRANSACTION_SUBMITTER: dappConfig?.transactionSubmitter,\n  };\n\n  if (isAptosNetwork(networkInfo)) {\n    const currentNetwork = convertNetwork(networkInfo);\n\n    if (isAptosLiveNetwork(currentNetwork)) {\n      const apiKey = dappConfig?.aptosApiKeys;\n      return new AptosConfig({\n        network: currentNetwork,\n        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : undefined },\n        pluginSettings,\n      });\n    }\n\n    return new AptosConfig({\n      network: currentNetwork,\n      pluginSettings,\n    });\n  }\n\n  const knownNetworks = {\n    okx: \"https://wallet.okx.com/fullnode/aptos/discover/rpc\",\n  };\n\n  if (networkInfo.url) {\n    const isKnownNetwork = Object.values(knownNetworks).includes(\n      networkInfo.url,\n    );\n\n    if (isKnownNetwork) {\n      return new AptosConfig({\n        network: Network.CUSTOM,\n        fullnode: networkInfo.url,\n        pluginSettings,\n      });\n    }\n  }\n\n  // Custom networks are not supported, please ensure that the wallet is returning the appropriate network Mainnet, Testnet, Devnet, Local\n  throw new Error(\n    `Invalid network, network ${networkInfo.name} not supported with Aptos wallet adapter to prevent user from using an unexpected network.`,\n  );\n};\n\n/**\n * Helper function to resolve if the current connected network is an Aptos network\n *\n * @param networkInfo\n * @returns boolean\n */\nexport const isAptosNetwork = (\n  networkInfo: NetworkInfo | StandardNetworkInfo | null,\n): boolean => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return NetworkToNodeAPI[networkInfo.name] !== undefined;\n};\n\nexport const isAptosLiveNetwork = (networkInfo: Network): boolean => {\n  return (\n    networkInfo === \"devnet\" ||\n    networkInfo === \"testnet\" ||\n    networkInfo === \"mainnet\"\n  );\n};\n\n/**\n * Helper function to fetch Devnet chain id\n */\nexport const fetchDevnetChainId = async (): Promise<number> => {\n  const aptos = new Aptos(); // default to devnet\n  return await aptos.getChainId();\n};\n\n/**\n * A helper function to handle the publish package transaction.\n * The Aptos SDK expects the metadataBytes and byteCode to be Uint8Array, but in case the arguments are passed in\n * as a string, this function converts the string to Uint8Array.\n */\nexport const handlePublishPackageTransaction = (\n  transactionInput: InputTransactionData,\n) => {\n  // convert the first argument, metadataBytes, to uint8array if is a string\n  let metadataBytes = transactionInput.data.functionArguments[0];\n  if (typeof metadataBytes === \"string\") {\n    metadataBytes = Hex.fromHexInput(metadataBytes).toUint8Array();\n  }\n\n  // convert the second argument, byteCode, to uint8array if is a string\n  let byteCode = transactionInput.data.functionArguments[1];\n  if (Array.isArray(byteCode)) {\n    byteCode = byteCode.map((byte) => {\n      if (typeof byte === \"string\") {\n        return Hex.fromHexInput(byte).toUint8Array();\n      }\n      return byte;\n    });\n  } else {\n    throw new WalletSignAndSubmitMessageError(\n      \"The bytecode argument must be an array.\",\n    ).message;\n  }\n\n  return { metadataBytes, byteCode };\n};\n\n// old => new\nexport function convertNetwork(networkInfo: NetworkInfo | null): Network {\n  switch (networkInfo?.name) {\n    case \"mainnet\" as Network:\n      return Network.MAINNET;\n    case \"testnet\" as Network:\n      return Network.TESTNET;\n    case \"devnet\" as Network:\n      return Network.DEVNET;\n    case \"local\" as Network:\n      return Network.LOCAL;\n    default:\n      throw new Error(\"Invalid Aptos network name\");\n  }\n}\n", "const LOCAL_STORAGE_ITEM_KEY = \"AptosWalletName\";\n\nexport function setLocalStorage(walletName: string) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\n\nexport function removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\nexport function getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n", "import { WalletInfo } from \"./types\";\nimport { AdapterNotDetectedWallet, AdapterWallet } from \"../WalletCore\";\nimport { APTOS_CONNECT_BASE_URL, WalletReadyState } from \"../constants\";\nimport { isRedirectable } from \"./helpers\";\n\n/**\n * A function that will partition the provided wallets into two list — `defaultWallets` and `moreWallets`.\n * By default, the wallets will be partitioned by whether or not they are installed or loadable.\n * You can pass your own partition function if you wish to customize this behavior.\n */\nexport function partitionWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n  partitionFunction: (\n    wallet: AdapterWallet | AdapterNotDetectedWallet,\n  ) => boolean = isInstalledOrLoadable,\n) {\n  const defaultWallets: Array<AdapterWallet> = [];\n  const moreWallets: Array<AdapterNotDetectedWallet> = [];\n\n  for (const wallet of wallets) {\n    if (partitionFunction(wallet)) defaultWallets.push(wallet as AdapterWallet);\n    else moreWallets.push(wallet as AdapterNotDetectedWallet);\n  }\n\n  return { defaultWallets, moreWallets };\n}\n\n/** Returns true if the wallet is installed or loadable. */\nexport function isInstalledOrLoadable(\n  wallet: AdapterWallet | AdapterNotDetectedWallet,\n) {\n  return wallet.readyState === WalletReadyState.Installed;\n}\n\n/**\n * Returns true if the user is on desktop and the provided wallet requires installation of a browser extension.\n * This can be used to decide whether to show a \"Connect\" button or \"Install\" link in the UI.\n */\nexport function isInstallRequired(\n  wallet: AdapterWallet | AdapterNotDetectedWallet,\n) {\n  const isWalletReady = isInstalledOrLoadable(wallet);\n  const isMobile = !isWalletReady && isRedirectable();\n\n  return !isMobile && !isWalletReady;\n}\n\n/** Truncates the provided wallet address at the middle with an ellipsis. */\nexport function truncateAddress(address: string | undefined) {\n  if (!address) return;\n  return `${address.slice(0, 6)}...${address.slice(-5)}`;\n}\n\n/** Returns `true` if the provided wallet is an Aptos Connect wallet. */\nexport function isAptosConnectWallet(wallet: WalletInfo | AdapterWallet) {\n  if (!wallet.url) return false;\n  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);\n}\n\n/**\n * Partitions the `wallets` array so that Aptos Connect wallets are grouped separately from the rest.\n * Aptos Connect is a web wallet that uses social login to create accounts on the blockchain.\n */\nexport function getAptosConnectWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n) {\n  const { defaultWallets, moreWallets } = partitionWallets(\n    wallets,\n    isAptosConnectWallet,\n  );\n  return { aptosConnectWallets: defaultWallets, otherWallets: moreWallets };\n}\n\nexport interface WalletSortingOptions {\n  /** An optional function for sorting Aptos Connect wallets. */\n  sortAptosConnectWallets?: (a: AdapterWallet, b: AdapterWallet) => number;\n  /** An optional function for sorting wallets that are currently installed or loadable. */\n  sortAvailableWallets?: (\n    a: AdapterWallet | AdapterNotDetectedWallet,\n    b: AdapterWallet | AdapterNotDetectedWallet,\n  ) => number;\n  /** An optional function for sorting wallets that are NOT currently installed or loadable. */\n  sortInstallableWallets?: (\n    a: AdapterWallet | AdapterNotDetectedWallet,\n    b: AdapterWallet | AdapterNotDetectedWallet,\n  ) => number;\n}\n\n/**\n * Partitions the `wallets` array into three distinct groups:\n *\n * `aptosConnectWallets` - Wallets that use social login to create accounts on\n * the blockchain via Aptos Connect.\n *\n * `availableWallets` - Wallets that are currently installed or loadable by the client.\n *\n * `installableWallets` - Wallets that are NOT current installed or loadable and\n * require the client to install a browser extension first.\n *\n * Additionally, these wallet groups can be sorted by passing sort functions via the `options` argument.\n */\nexport function groupAndSortWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n  options?: WalletSortingOptions,\n) {\n  const { aptosConnectWallets, otherWallets } = getAptosConnectWallets(wallets);\n  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);\n\n  if (options?.sortAptosConnectWallets) {\n    aptosConnectWallets.sort(options.sortAptosConnectWallets);\n  }\n  if (options?.sortAvailableWallets) {\n    defaultWallets.sort(options.sortAvailableWallets);\n  }\n  if (options?.sortInstallableWallets) {\n    moreWallets.sort(options.sortInstallableWallets);\n  }\n\n  return {\n    /** Wallets that use social login to create an account on the blockchain */\n    aptosConnectWallets,\n    /** Wallets that are currently installed or loadable. */\n    availableWallets: defaultWallets,\n    /** Wallets that are NOT currently installed or loadable. */\n    installableWallets: moreWallets,\n  };\n}\n", "import { WalletReadyState } from \"./constants\";\nimport { AptosStandardSupportedWallet } from \"./utils/types\";\n\n/**\n * Registry of AIP-62 wallet standard supported wallets.\n * This list is used to show supported wallets even if they are not installed on the user machine.\n *\n * AIP-62 compatible wallets are required to add their wallet info here if they want to be detected by the adapter\n *\n * @param name - The name of your wallet cast to WalletName (Ex. \"Petra\" as WalletName<\"Petra\">)\n * @param url - The link to your chrome extension or main website where new users can create an account with your wallet.\n * @param icon - An icon for your wallet. Can be one of 4 data types. Be sure to follow the below format exactly (including the literal \",\" after base64).\n *        Format: `data:image/${\"svg+xml\" | \"webp\" | \"png\" | \"gif\"};base64,${string}`\n *        Note: ${...} data in the above format should be replaced. Other characters are literals (ex. \";\")\n * @param deeplinkProvider optional - An optional deeplink provider for the wallet. If the wallet is not installed, we can redirect the user to the wallet's deeplink provider\n * @example \"https://myWallet.app/explore?link=\"\n */\nexport const aptosStandardSupportedWalletList: Array<AptosStandardSupportedWallet> =\n  [\n    {\n      name: \"OKX Wallet\",\n      url: \"https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge\",\n      icon: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n    },\n    {\n      name: \"Petra\",\n      url: \"https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en\",\n      icon: \"data:image/png;base64,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\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"https://petra.app/explore?link=\",\n    },\n    {\n      name: \"Nightly\",\n      url: \"https://nightly.app/\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"nightly://v1?network=aptos&url=\",\n    },\n    {\n      name: \"Pontem Wallet\",\n      url: \"https://pontem.network/pontem-wallet\",\n      icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n    },\n  ];\n\nexport const crossChainStandardSupportedWalletList: Array<AptosStandardSupportedWallet> =\n  [\n    {\n      name: \"Phantom (Solana)\",\n      url: \"https://phantom.com/\",\n      icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: `https://phantom.app/ul/browse/`,\n    },\n    {\n      name: \"Phantom (Ethereum)\",\n      url: \"https://phantom.com/\",\n      icon: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: `https://phantom.app/ul/browse/`,\n    },\n    {\n      name: \"Nightly (Solana)\",\n      url: \"https://nightly.app/\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"nightly://v1?network=aptos&url=\",\n    },\n    {\n      name: \"Nightly (Ethereum)\",\n      url: \"https://nightly.app/\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"nightly://v1?network=aptos&url=\",\n    },\n  ];\n", "import {\n  AptosConnectAppleWallet,\n  AptosConnectGoogleWallet,\n} from \"@aptos-connect/wallet-adapter-plugin\";\nimport { DappConfig, AdapterWallet } from \"./WalletCore\";\n\nexport function getSDKWallets(dappConfig?: DappConfig) {\n  const sdkWallets: AdapterWallet[] = [];\n\n  // Need to check window is defined for AptosConnect\n  if (typeof window !== \"undefined\") {\n    sdkWallets.push(\n      new AptosConnectGoogleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.aptosConnectDappId,\n        ...dappConfig?.aptosConnect,\n      }),\n      new AptosConnectAppleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.aptosConnectDappId,\n        ...dappConfig?.aptosConnect,\n      })\n    );\n  }\n\n  // Add new SDK wallet plugins (ones that should be installed as packages) here:\n  // Ex. sdkWallets.push(new YourSDKWallet(dappConfig))\n\n  return sdkWallets;\n}\n", "import { AptosSignInBoundFields } from \"@aptos-labs/wallet-standard\";\nimport { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\n\nexport type {\n  AptosSignInOutput,\n  AptosSignInInput,\n  AptosSignInBoundFields,\n} from \"@aptos-labs/wallet-standard\";\n/**\n * @deprecated Use `AptosSignInBoundFields` instead. This will be removed in future versions.\n */\nexport type AptosSignInRequiredFields = AptosSignInBoundFields;\n\nexport * from \"./WalletCore\";\nexport * from \"./constants\";\nexport * from \"./utils\";\nexport * from \"./sdkWallets\";\nexport * from \"./registry\";\n\n// inject adapter core version to the window\nif (typeof window !== \"undefined\") {\n  (window as any).WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * The global cache Map shared across all functions.  Must keep care to ensure that the\n * cache keys are unique across all functions.\n * @group Implementation\n * @category Utils\n */\nconst cache = new Map<string, { value: any; timestamp: number }>();\n\n/**\n * A memoize higher-order function to cache the response of an async function.\n * This function helps to improve performance by avoiding repeated calls to the same async function with the same arguments\n * within a specified time-to-live (TTL).\n *\n * @param func The async function to cache the result of.\n * @param key The cache key used to store the result.\n * @param ttlMs The time-to-live in milliseconds for cached data.\n * @returns The cached or latest result.\n * @group Implementation\n * @category Utils\n */\nexport function memoizeAsync<T>(\n  func: (...args: any[]) => Promise<T>,\n  key: string,\n  ttlMs?: number,\n): (...args: any[]) => Promise<T> {\n  return async (...args: any[]) => {\n    // Check if the cached result exists and is within TTL\n    if (cache.has(key)) {\n      const { value, timestamp } = cache.get(key)!;\n      if (ttlMs === undefined || Date.now() - timestamp <= ttlMs) {\n        return value;\n      }\n    }\n\n    // If not cached or TTL expired, compute the result\n    const result = await func(...args);\n\n    // Cache the result with a timestamp\n    cache.set(key, { value: result, timestamp: Date.now() });\n\n    return result;\n  };\n}\n\n/**\n * Caches the result of a function call to improve performance on subsequent calls with the same arguments.\n *\n * @param key - The key to cache on, all accesses by this key will return the cached value.\n * @param func - The function whose result will be cached.\n * @param ttlMs - The time-to-live in milliseconds for cached data.\n * @returns A memoized version of the provided function that returns the cached result if available and within TTL.\n * @group Implementation\n * @category Utils\n */\nexport function memoize<T>(func: (...args: any[]) => T, key: string, ttlMs?: number): (...args: any[]) => T {\n  return (...args: any[]) => {\n    // Check if the cached result exists and is within TTL\n    if (cache.has(key)) {\n      const { value, timestamp } = cache.get(key)!;\n      if (ttlMs === undefined || Date.now() - timestamp <= ttlMs) {\n        return value;\n      }\n    }\n\n    // If not cached or TTL expired, compute the result\n    const result = func(...args);\n\n    // Cache the result with a timestamp\n    cache.set(key, { value: result, timestamp: Date.now() });\n\n    return result;\n  };\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This error is used to explain why parsing failed.\n * @group Implementation\n * @category Serialization\n */\nexport class ParsingError<T> extends Error {\n  /**\n   * This provides a programmatic way to access why parsing failed. Downstream devs\n   * might want to use this to build their own error messages if the default error\n   * messages are not suitable for their use case. This should be an enum.\n   * @group Implementation\n   * @category Serialization\n   */\n  public invalidReason: T;\n\n  /**\n   * Creates an instance of the error with a specified message and invalid reason.\n   *\n   * @param message The error message that describes the issue.\n   * @param invalidReason The reason why the input is considered invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(message: string, invalidReason: T) {\n    super(message);\n    this.invalidReason = invalidReason;\n  }\n}\n\n/**\n * Whereas ParsingError is thrown when parsing fails, e.g. in a fromString function,\n * this type is returned from \"defensive\" functions like isValid.\n * @group Implementation\n * @category Serialization\n */\nexport type ParsingResult<T> = {\n  /**\n   * True if valid, false otherwise.\n   * @group Implementation\n   * @category Serialization\n   */\n  valid: boolean;\n\n  /**\n   * If valid is false, this will be a code explaining why parsing failed.\n   * @group Implementation\n   * @category Serialization\n   */\n  invalidReason?: T;\n\n  /**\n   * If valid is false, this will be a string explaining why parsing failed.\n   * @group Implementation\n   * @category Serialization\n   */\n  invalidReasonMessage?: string;\n};\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { HexInput } from \"../types\";\n\n/**\n * Provides reasons for parsing failures related to hexadecimal values.\n * @group Implementation\n * @category Serialization\n */\nexport enum HexInvalidReason {\n  TOO_SHORT = \"too_short\",\n  INVALID_LENGTH = \"invalid_length\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n}\n\n/**\n * NOTE: Do not use this class when working with account addresses; use AccountAddress instead.\n * When accepting hex data as input to a function, prefer to accept HexInput and\n *\n * A helper class for working with hex data. Hex data, when represented as a string,\n * generally looks like this, for example: 0xaabbcc, 45cd32, etc.\n *\n * then use the static helper methods of this class to convert it into the desired\n * format. This enables the greatest flexibility for the developer.\n *\n * Example usage:\n * ```typescript\n * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {\n *   const txnHashString = Hex.fromHexInput(txnHash).toString();\n *   return await getTransactionByHashInner(txnHashString);\n * }\n * ```\n * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string\n * with a leading 0x prefix, regardless of what the input format was.\n *\n * Other ways to chain the functions together:\n * - `Hex.fromHexString({ hexInput: \"0x1f\" }).toUint8Array()`\n * - `new Hex([1, 3]).toStringWithoutPrefix()`\n * @group Implementation\n * @category Serialization\n */\nexport class Hex {\n  private readonly data: Uint8Array;\n\n  /**\n   * Create a new Hex instance from a Uint8Array.\n   *\n   * @param data - The Uint8Array containing the data to initialize the Hex instance.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(data: Uint8Array) {\n    this.data = data;\n  }\n\n  // ===\n  // Methods for representing an instance of Hex as other types.\n  // ===\n\n  /**\n   * Get the inner hex data as a Uint8Array. The inner data is already a Uint8Array, so no conversion takes place.\n   *\n   * @returns Hex data as Uint8Array\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Get the hex data as a string without the 0x prefix.\n   *\n   * @returns Hex string without 0x prefix\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the hex data as a string with the 0x prefix.\n   *\n   * @returns Hex string with 0x prefix\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  // ===\n  // Methods for creating an instance of Hex from other types.\n  // ===\n\n  /**\n   * Converts a hex string into a Hex instance, allowing for both prefixed and non-prefixed formats.\n   *\n   * @param str - A hex string, with or without the 0x prefix.\n   *\n   * @throws ParsingError - If the hex string is too short, has an odd number of characters, or contains invalid hex characters.\n   *\n   * @returns Hex - The resulting Hex instance created from the provided string.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromHexString(str: string): Hex {\n    let input = str;\n\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n\n    if (input.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\",\n        HexInvalidReason.TOO_SHORT,\n      );\n    }\n\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", HexInvalidReason.INVALID_LENGTH);\n    }\n\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (error: any) {\n      throw new ParsingError(\n        `Hex string contains invalid hex characters: ${error?.message}`,\n        HexInvalidReason.INVALID_HEX_CHARS,\n      );\n    }\n  }\n\n  /**\n   * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Hex instance.\n   * This function is useful for transforming hexadecimal representations into a structured Hex object for further manipulation.\n   *\n   * @param hexInput - A HexInput which can be a string or Uint8Array.\n   * @returns A Hex instance created from the provided hexInput.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromHexInput(hexInput: HexInput): Hex {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromHexString(hexInput);\n  }\n\n  /**\n   * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Uint8Array.\n   *\n   * @param hexInput - A HexInput which can be a string or Uint8Array.\n   * @returns A Uint8Array created from the provided hexInput.\n   */\n  static hexInputToUint8Array(hexInput: HexInput): Uint8Array {\n    if (hexInput instanceof Uint8Array) return hexInput;\n    return Hex.fromHexString(hexInput).toUint8Array();\n  }\n\n  /**\n   * Converts a HexInput (string or Uint8Array) to a hex string with '0x' prefix.\n   *\n   * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array\n   * @returns A hex string with '0x' prefix (e.g., \"0x1234\")\n   *\n   * @example\n   * ```typescript\n   * Hex.hexInputToString(\"1234\")        // returns \"0x1234\"\n   * Hex.hexInputToString(\"0x1234\")      // returns \"0x1234\"\n   * Hex.hexInputToString(new Uint8Array([0x12, 0x34])) // returns \"0x1234\"\n   * ```\n   */\n  static hexInputToString(hexInput: HexInput): string {\n    return Hex.fromHexInput(hexInput).toString();\n  }\n\n  /**\n   * Converts a HexInput (string or Uint8Array) to a hex string without '0x' prefix.\n   *\n   * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array\n   * @returns A hex string without '0x' prefix (e.g., \"1234\")\n   *\n   * @example\n   * ```typescript\n   * Hex.hexInputToStringWithoutPrefix(\"1234\")        // returns \"1234\"\n   * Hex.hexInputToStringWithoutPrefix(\"0x1234\")      // returns \"1234\"\n   * Hex.hexInputToStringWithoutPrefix(new Uint8Array([0x12, 0x34])) // returns \"1234\"\n   * ```\n   */\n  static hexInputToStringWithoutPrefix(hexInput: HexInput): string {\n    return Hex.fromHexInput(hexInput).toStringWithoutPrefix();\n  }\n\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the provided string is a valid hexadecimal representation.\n   *\n   * @param str - A hex string representing byte data.\n   *\n   * @returns An object containing:\n   *  - valid: A boolean indicating whether the string is valid.\n   *  - invalidReason: The reason for invalidity if the string is not valid.\n   *  - invalidReasonMessage: A message explaining why the string is invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isValid(str: string): ParsingResult<HexInvalidReason> {\n    try {\n      Hex.fromHexString(str);\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Determine if two Hex instances are equal by comparing their underlying byte data.\n   *\n   * @param other The Hex instance to compare to.\n   * @returns true if the Hex instances are equal, false if not.\n   * @group Implementation\n   * @category Serialization\n   */\n  equals(other: Hex): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n\nexport const hexToAsciiString = (hex: string) => new TextDecoder().decode(Hex.fromHexInput(hex).toUint8Array());\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Uint8, Uint16, Uint32, Uint64, Uint128, Uint256 } from \"../types\";\n\n// Upper bound values for uint8, uint16, uint64 etc.  These are all derived as\n// 2^N - 1, where N is the number of bits in the type.\nexport const MAX_U8_NUMBER: Uint8 = 255;\nexport const MAX_U16_NUMBER: Uint16 = 65535;\nexport const MAX_U32_NUMBER: Uint32 = 4294967295;\nexport const MAX_U64_BIG_INT: Uint64 = 18446744073709551615n;\nexport const MAX_U128_BIG_INT: Uint128 = 340282366920938463463374607431768211455n;\nexport const MAX_U256_BIG_INT: Uint256 =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n", "var h=Object.defineProperty;var i=Object.getOwnPropertyDescriptor;var j=(g,b,d,c)=>{for(var a=c>1?void 0:c?i(b,d):b,e=g.length-1,f;e>=0;e--)(f=g[e])&&(a=(c?f(b,d,a):f(a))||a);return c&&a&&h(b,d,a),a};export{j as a};\n//# sourceMappingURL=chunk-KDMSOCZY.mjs.map", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-bitwise */\nimport {\n  MAX_U128_BIG_INT,\n  MAX_U16_NUMBER,\n  MAX_U32_NUMBER,\n  MAX_U64_BIG_INT,\n  MAX_U8_NUMBER,\n  MAX_U256_BIG_INT,\n} from \"./consts\";\nimport { Hex } from \"../core/hex\";\nimport { AnyNumber, Uint16, Uint32, Uint8 } from \"../types\";\n\n/**\n * This class serves as a base class for all serializable types. It facilitates\n * composable serialization of complex types and enables the serialization of\n * instances to their BCS (Binary Canonical Serialization) representation.\n * @group Implementation\n * @category BCS\n */\nexport abstract class Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Serializes a `Serializable` value to its BCS representation.\n   * This function is the TypeScript SDK equivalent of `bcs::to_bytes` in Move.\n   * @returns the BCS representation of the Serializable instance as a byte buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  bcsToBytes(): Uint8Array {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n\n  /**\n   * Converts the BCS-serialized bytes of a value into a Hex instance.\n   * This function provides a Hex representation of the BCS-serialized data for easier handling and manipulation.\n   * @returns A Hex instance with the BCS-serialized bytes loaded into its underlying Uint8Array.\n   * @group Implementation\n   * @category BCS\n   */\n  bcsToHex(): Hex {\n    const bcsBytes = this.bcsToBytes();\n    return Hex.fromHexInput(bcsBytes);\n  }\n\n  /**\n   * Returns the hex string representation of the `Serializable` value without the 0x prefix.\n   * @returns the hex format as a string without `0x` prefix.\n   */\n  toStringWithoutPrefix(): string {\n    return this.bcsToHex().toStringWithoutPrefix();\n  }\n\n  /**\n   * Returns the hex string representation of the `Serializable` value with the 0x prefix.\n   * @returns the hex formatas a string prefixed by `0x`.\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n}\n\n/**\n * A class for serializing various data types into a binary format.\n * It provides methods to serialize strings, bytes, numbers, and other serializable objects\n * using the Binary Coded Serialization (BCS) layout. The serialized data can be retrieved as a\n * Uint8Array.\n * @group Implementation\n * @category BCS\n */\nexport class Serializer {\n  private buffer: ArrayBuffer;\n\n  private offset: number;\n\n  /**\n   * Constructs a serializer with a buffer of size `length` bytes, 64 bytes by default.\n   * The `length` must be greater than 0.\n   *\n   * @param length - The size of the buffer in bytes.\n   * @group Implementation\n   * @category BCS\n   */\n  constructor(length: number = 64) {\n    if (length <= 0) {\n      throw new Error(\"Length needs to be greater than 0\");\n    }\n    this.buffer = new ArrayBuffer(length);\n    this.offset = 0;\n  }\n\n  /**\n   * Ensures that the internal buffer can accommodate the specified number of bytes.\n   * This function dynamically resizes the buffer if the current size is insufficient.\n   *\n   * @param bytes - The number of bytes to ensure the buffer can handle.\n   * @group Implementation\n   * @category BCS\n   */\n  private ensureBufferWillHandleSize(bytes: number) {\n    while (this.buffer.byteLength < this.offset + bytes) {\n      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));\n      this.buffer = newBuffer;\n    }\n  }\n\n  /**\n   * Appends the specified values to the buffer, ensuring that the buffer can accommodate the new data.\n   *\n   * @param {Uint8Array} values - The values to be appended to the buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  protected appendToBuffer(values: Uint8Array) {\n    this.ensureBufferWillHandleSize(values.length);\n    new Uint8Array(this.buffer, this.offset).set(values);\n    this.offset += values.length;\n  }\n\n  /**\n   * Serializes a value into the buffer using the provided function, ensuring the buffer can accommodate the size.\n   *\n   * @param fn - The function to serialize the value, which takes a byte offset, the value to serialize, and an optional little-endian flag.\n   * @param fn.byteOffset - The byte offset at which to write the value.\n   * @param fn.value - The numeric value to serialize into the buffer.\n   * @param fn.littleEndian - Optional flag indicating whether to use little-endian byte order (defaults to true).\n   * @group Implementation\n   * @category BCS\n   */\n  // TODO: JSDoc bytesLength and value\n  private serializeWithFunction(\n    fn: (byteOffset: number, value: number, littleEndian?: boolean) => void,\n    bytesLength: number,\n    value: number,\n  ) {\n    this.ensureBufferWillHandleSize(bytesLength);\n    const dv = new DataView(this.buffer, this.offset);\n    fn.apply(dv, [0, value, true]);\n    this.offset += bytesLength;\n  }\n\n  /**\n   * Serializes a string. UTF8 string is supported.\n   * The number of bytes in the string content is serialized first, as a uleb128-encoded u32 integer.\n   * Then the string content is serialized as UTF8 encoded bytes.\n   *\n   * BCS layout for \"string\": string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   *\n   * @param value - The string to serialize.\n   *\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeStr(\"1234abcd\");\n   * assert(serializer.toUint8Array() === new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  serializeStr(value: string) {\n    const textEncoder = new TextEncoder();\n    this.serializeBytes(textEncoder.encode(value));\n  }\n\n  /**\n   * Serializes an array of bytes.\n   *\n   * This function encodes the length of the byte array as a u32 integer in uleb128 format, followed by the byte array itself.\n   * BCS layout for \"bytes\": bytes_length | bytes\n   * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.\n   * @param value - The byte array to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeBytes(value: Uint8Array) {\n    this.serializeU32AsUleb128(value.length);\n    this.appendToBuffer(value);\n  }\n\n  /**\n   * Serializes an array of bytes with a known length, allowing for efficient deserialization without needing to serialize the\n   * length itself.\n   * When deserializing, the number of bytes to deserialize needs to be passed in.\n\n   * @param value - The Uint8Array to be serialized.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeFixedBytes(value: Uint8Array) {\n    this.appendToBuffer(value);\n  }\n\n  /**\n   * Serializes a boolean value into a byte representation.\n   *\n   * The BCS layout for a boolean uses one byte, where \"0x01\" represents true and \"0x00\" represents false.\n   *\n   * @param value - The boolean value to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeBool(value: boolean) {\n    /**\n     * Ensures that the provided value is a boolean.\n     * This function throws an error if the value is not a boolean, helping to enforce type safety in your code.\n     *\n     * @param value - The value to be checked for boolean type.\n     * @throws {Error} Throws an error if the value is not a boolean.\n     * @group Implementation\n     * @category BCS\n     */\n    ensureBoolean(value);\n    const byteValue = value ? 1 : 0;\n    this.appendToBuffer(new Uint8Array([byteValue]));\n  }\n\n  /**\n   * Serializes a Uint8 value and appends it to the buffer.\n   * BCS layout for \"uint8\": One byte. Binary format in little-endian representation.\n   *\n   * @param value - The Uint8 value to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U8_NUMBER)\n  serializeU8(value: Uint8) {\n    this.appendToBuffer(new Uint8Array([value]));\n  }\n\n  /**\n   * Serializes a uint16 number.\n   *\n   * @group Implementation\n   * @category BCS\n\n   */\n\n  /**\n   * Serializes a 16-bit unsigned integer value into a binary format.\n   * BCS layout for \"uint16\": Two bytes. Binary format in little-endian representation.\n   *\n   * @param value - The 16-bit unsigned integer value to serialize.\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeU16(4660);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x34, 0x12]));\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U16_NUMBER)\n  serializeU16(value: Uint16) {\n    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);\n  }\n\n  /**\n   * Serializes a 32-bit unsigned integer value into a binary format.\n   * This function is useful for encoding data that needs to be stored or transmitted in a compact form.\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeU32(305419896);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x78, 0x56, 0x34, 0x12]));\n   * ```\n   * @param value - The 32-bit unsigned integer value to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U32_NUMBER)\n  serializeU32(value: Uint32) {\n    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);\n  }\n\n  /**\n   * Serializes a 64-bit unsigned integer into a format suitable for storage or transmission.\n   * This function breaks down the value into two 32-bit components and writes them in little-endian order.\n   *\n   * @param value - The 64-bit unsigned integer to serialize, represented as a number.\n   * @example\n   * ```ts\n   * const serializer = new Serializer();\n   * serializer.serializeU64(1311768467750121216);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(BigInt(0), MAX_U64_BIG_INT)\n  serializeU64(value: AnyNumber) {\n    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);\n    const high = BigInt(value) >> BigInt(32);\n\n    // write little endian number\n    this.serializeU32(Number(low));\n    this.serializeU32(Number(high));\n  }\n\n  /**\n   * Serializes a U128 value into a format suitable for storage or transmission.\n   *\n   * @param value - The U128 value to serialize, represented as a number.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(BigInt(0), MAX_U128_BIG_INT)\n  serializeU128(value: AnyNumber) {\n    const low = BigInt(value) & MAX_U64_BIG_INT;\n    const high = BigInt(value) >> BigInt(64);\n\n    // write little endian number\n    this.serializeU64(low);\n    this.serializeU64(high);\n  }\n\n  /**\n   * Serializes a U256 value into a byte representation.\n   * This function is essential for encoding large numbers in a compact format suitable for transmission or storage.\n   *\n   * @param value - The U256 value to serialize, represented as an AnyNumber.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(BigInt(0), MAX_U256_BIG_INT)\n  serializeU256(value: AnyNumber) {\n    const low = BigInt(value) & MAX_U128_BIG_INT;\n    const high = BigInt(value) >> BigInt(128);\n\n    // write little endian number\n    this.serializeU128(low);\n    this.serializeU128(high);\n  }\n\n  /**\n   * Serializes a 32-bit unsigned integer as a variable-length ULEB128 encoded byte array.\n   * BCS uses uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values\n   *\n   * @param val - The 32-bit unsigned integer value to be serialized.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U32_NUMBER)\n  serializeU32AsUleb128(val: Uint32) {\n    let value = val;\n    const valueArray = [];\n    while (value >>> 7 !== 0) {\n      valueArray.push((value & 0x7f) | 0x80);\n      value >>>= 7;\n    }\n    valueArray.push(value);\n    this.appendToBuffer(new Uint8Array(valueArray));\n  }\n\n  /**\n   * Returns the buffered bytes as a Uint8Array.\n   *\n   * This function allows you to retrieve the byte representation of the buffer up to the current offset.\n   *\n   * @returns Uint8Array - The byte array representation of the buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  toUint8Array(): Uint8Array {\n    return new Uint8Array(this.buffer).slice(0, this.offset);\n  }\n\n  /**\n   * Serializes a `Serializable` value, facilitating composable serialization.\n   *\n   * @param value The Serializable value to serialize.\n   *\n   * @returns the serializer instance\n   * @group Implementation\n   * @category BCS\n   */\n  serialize<T extends Serializable>(value: T): void {\n    // NOTE: The `serialize` method called by `value` is defined in `value`'s\n    // Serializable interface, not the one defined in this class.\n    value.serialize(this);\n  }\n\n  /**\n   * Serializes an array of BCS Serializable values to a serializer instance.\n   * The bytes are added to the serializer instance's byte buffer.\n   *\n   * @param values The array of BCS Serializable values\n   * @example\n   * const addresses = new Array<AccountAddress>(\n   *   AccountAddress.from(\"0x1\"),\n   *   AccountAddress.from(\"0x2\"),\n   *   AccountAddress.from(\"0xa\"),\n   *   AccountAddress.from(\"0xb\"),\n   * );\n   * const serializer = new Serializer();\n   * serializer.serializeVector(addresses);\n   * const serializedBytes = serializer.toUint8Array();\n   * // serializedBytes is now the BCS-serialized bytes\n   * // The equivalent value in Move would be:\n   * // `bcs::to_bytes(&vector<address> [@0x1, @0x2, @0xa, @0xb])`;\n   * @group Implementation\n   * @category BCS\n   */\n  serializeVector<T extends Serializable>(values: Array<T>): void {\n    this.serializeU32AsUleb128(values.length);\n    values.forEach((item) => {\n      item.serialize(this);\n    });\n  }\n\n  /**\n   * Serializes an optional value which can be a Serializable, string, or Uint8Array.\n   * For strings and Uint8Arrays, it uses the appropriate serialization method.\n   *\n   * @param value The value to serialize (Serializable, string, Uint8Array, or undefined)\n   * @param len Optional fixed length for Uint8Array serialization. If provided, uses serializeFixedBytes instead of serializeBytes\n   *\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeOption(\"hello\");  // Serializes optional string\n   * serializer.serializeOption(new Uint8Array([1, 2, 3]));  // Serializes optional bytes\n   * serializer.serializeOption(new Uint8Array([1, 2, 3]), 3);  // Serializes optional fixed-length bytes\n   * serializer.serializeOption(new AccountAddress(...));  // Serializes optional Serializable\n   * serializer.serializeOption(undefined);  // Serializes none case\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  serializeOption<T extends Serializable | string | Uint8Array>(value?: T, len?: number): void {\n    const hasValue = value !== undefined;\n    this.serializeBool(hasValue);\n    if (hasValue) {\n      if (typeof value === \"string\") {\n        this.serializeStr(value);\n      } else if (value instanceof Uint8Array) {\n        if (len !== undefined) {\n          this.serializeFixedBytes(value);\n        } else {\n          this.serializeBytes(value);\n        }\n      } else {\n        value.serialize(this);\n      }\n    }\n  }\n\n  /**\n   * @deprecated use `serializeOption` instead.\n   * Serializes an optional string, supporting UTF8 encoding.\n   * The function encodes the existence of the string first, followed by the length and content if it exists.\n   *\n   * BCS layout for optional \"string\": 1 | string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   * BCS layout for undefined: 0\n   *\n   * @param value - The optional string to serialize. If undefined, it will serialize as 0.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeOptionStr(value?: string): void {\n    if (value === undefined) {\n      this.serializeU32AsUleb128(0);\n    } else {\n      this.serializeU32AsUleb128(1);\n      this.serializeStr(value);\n    }\n  }\n}\n\n/**\n * @group Implementation\n * @category BCS\n */\nexport function ensureBoolean(value: unknown): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    throw new Error(`${value} is not a boolean value`);\n  }\n}\n/**\n * @group Implementation\n * @category BCS\n */\nexport const outOfRangeErrorMessage = (value: AnyNumber, min: AnyNumber, max: AnyNumber) =>\n  `${value} is out of range: [${min}, ${max}]`;\n\n/**\n * Validates that a given number is within a specified range.\n * This function throws an error if the value is outside the defined minimum and maximum bounds.\n *\n * @param value - The number to validate.\n * @param minValue - The minimum allowable value (inclusive).\n * @param maxValue - The maximum allowable value (inclusive).\n * @group Implementation\n * @category BCS\n */\nexport function validateNumberInRange<T extends AnyNumber>(value: T, minValue: T, maxValue: T) {\n  const valueBigInt = BigInt(value);\n  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {\n    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));\n  }\n}\n\n/**\n * A decorator that validates that the input argument for a function is within a specified range.\n * This ensures that the function is only called with valid input values, preventing potential errors.\n *\n * @param minValue - The input argument must be greater than or equal to this value.\n * @param maxValue - The input argument must be less than or equal to this value.\n * @group Implementation\n * @category BCS\n */\nfunction checkNumberRange<T extends AnyNumber>(minValue: T, maxValue: T) {\n  return (target: unknown, propertyKey: string, descriptor: PropertyDescriptor) => {\n    const childFunction = descriptor.value;\n    // eslint-disable-next-line no-param-reassign\n    descriptor.value = function deco(value: AnyNumber) {\n      validateNumberInRange(value, minValue, maxValue);\n      return childFunction.apply(this, [value]);\n    };\n\n    return descriptor;\n  };\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { TransactionArgument } from \"../transactions/instances/transactionArgument\";\nimport { HexInput, ScriptTransactionArgumentVariants } from \"../types\";\n\n/**\n * Provides reasons for an address was invalid.\n * @group Implementation\n * @category Serialization\n */\nexport enum AddressInvalidReason {\n  INCORRECT_NUMBER_OF_BYTES = \"incorrect_number_of_bytes\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n  TOO_SHORT = \"too_short\",\n  TOO_LONG = \"too_long\",\n  LEADING_ZERO_X_REQUIRED = \"leading_zero_x_required\",\n  LONG_FORM_REQUIRED_UNLESS_SPECIAL = \"long_form_required_unless_special\",\n  INVALID_PADDING_ZEROES = \"INVALID_PADDING_ZEROES\",\n  INVALID_PADDING_STRICTNESS = \"INVALID_PADDING_STRICTNESS\",\n}\n\n/**\n * The input for an account address, which can be either a hexadecimal string or a standard account address.\n * @group Implementation\n * @category Serialization\n */\nexport type AccountAddressInput = HexInput | AccountAddress;\n\n/**\n * NOTE: Only use this class for account addresses. For other hex data, e.g. transaction\n * hashes, use the Hex class.\n *\n * AccountAddress is used for working with account addresses. Account addresses, when\n * represented as a string, generally look like these examples:\n * - 0x1\n * - 0xaa86fe99004361f747f91342ca13c426ca0cccb0c1217677180c9493bad6ef0c\n *\n * Proper formatting and parsing of account addresses is defined by AIP-40.\n * To learn more about the standard, read the AIP here:\n * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n *\n * The comments in this class make frequent reference to the LONG and SHORT formats,\n * as well as \"special\" addresses. To learn what these refer to see AIP-40.\n * @group Implementation\n * @category Serialization\n */\nexport class AccountAddress extends Serializable implements TransactionArgument {\n  /**\n   * This is the internal representation of an account address.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly data: Uint8Array;\n\n  /**\n   * The number of bytes that make up an account address.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The length of an address string in LONG form without a leading 0x.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LONG_STRING_LENGTH: number = 64;\n\n  static ZERO: AccountAddress = AccountAddress.from(\"0x0\");\n\n  static ONE: AccountAddress = AccountAddress.from(\"0x1\");\n\n  static TWO: AccountAddress = AccountAddress.from(\"0x2\");\n\n  static THREE: AccountAddress = AccountAddress.from(\"0x3\");\n\n  static FOUR: AccountAddress = AccountAddress.from(\"0x4\");\n\n  static A: AccountAddress = AccountAddress.from(\"0xA\");\n\n  /**\n   * Creates an instance of AccountAddress from a Uint8Array.\n   *\n   * This function ensures that the input data is exactly 32 bytes long, which is required for a valid account address.\n   *\n   * @param input A Uint8Array representing an account address.\n   * @throws ParsingError if the input length is not equal to 32 bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(input: Uint8Array) {\n    super();\n    if (input.length !== AccountAddress.LENGTH) {\n      throw new ParsingError(\n        \"AccountAddress data should be exactly 32 bytes long\",\n        AddressInvalidReason.INCORRECT_NUMBER_OF_BYTES,\n      );\n    }\n    this.data = input;\n  }\n\n  /**\n   * Determines if the address is classified as special, which is defined as 0x0 to 0xf inclusive.\n   * In other words, the last byte of the address must be < 0b10000 (16)\n   * and every other byte must be zero.\n   *\n   * For more information on how special addresses are defined, see AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns true if the address is special, false otherwise.\n   * @group Implementation\n   * @category Serialization\n   */\n  isSpecial(): boolean {\n    return (\n      this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 0b10000\n    );\n  }\n  // ===\n  // Methods for representing an instance of AccountAddress as other types.\n  // ===\n\n  /**\n   * Return the AccountAddress as a string as per AIP-40.\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   * This representation returns special addresses in SHORT form (0xf)\n   * and other addresses in LONG form (0x + 64 characters).\n   *\n   * @returns AccountAddress as a string conforming to AIP-40.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): `0x${string}` {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  /**\n   * Return the AccountAddress as a string conforming to AIP-40 but without the leading 0x.\n   *\n   * NOTE: Prefer to use `toString` where possible.\n   *\n   * @returns AccountAddress as a string without the leading 0x.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringWithoutPrefix(): string {\n    let hex = bytesToHex(this.data);\n    if (this.isSpecial()) {\n      hex = hex[hex.length - 1];\n    }\n    return hex;\n  }\n\n  /**\n   * Convert the account address to a string in LONG format, which is always 0x followed by 64 hex characters.\n   *\n   * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).\n   *\n   * @returns AccountAddress as a string in LONG form.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringLong(): `0x${string}` {\n    return `0x${this.toStringLongWithoutPrefix()}`;\n  }\n\n  /**\n   * Returns the account address as a string in LONG form without a leading 0x.\n   * This function will include leading zeroes and will produce a string of 64 hex characters.\n   *\n   * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).\n   *\n   * @returns {string} The account address in LONG form.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringLongWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Convert the account address to a string in SHORT format, which is 0x followed by the shortest\n   * possible representation (no leading zeros).\n   *\n   * @returns AccountAddress as a string in SHORT form.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringShort(): `0x${string}` {\n    return `0x${this.toStringShortWithoutPrefix()}`;\n  }\n\n  /**\n   * Returns a lossless short string representation of the address by trimming leading zeros.\n   * If the address consists of all zeros, returns \"0\".\n   *\n   * @returns A string representation of the address without leading zeros\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringShortWithoutPrefix(): string {\n    const hex = bytesToHex(this.data).replace(/^0+/, \"\");\n    return hex === \"\" ? \"0\" : hex;\n  }\n\n  /**\n   * Get the inner data as a Uint8Array.\n   * The inner data is already a Uint8Array, so no conversion takes place.\n   *\n   * @returns Hex data as Uint8Array\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Serialize the AccountAddress to a Serializer instance's data buffer.\n   * @param serializer The serializer to serialize the AccountAddress to.\n   * @returns void\n   * @example\n   * const serializer = new Serializer();\n   * const address = AccountAddress.fromString(\"0x1\");\n   * address.serialize(serializer);\n   * const bytes = serializer.toUint8Array();\n   * // `bytes` is now the BCS-serialized address.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  /**\n   * Serializes the current instance into a byte sequence suitable for entry functions.\n   * This allows for the proper encoding of data when interacting with entry functions in the blockchain.\n   *\n   * @param serializer - The serializer instance used to convert the data into bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * Serializes the current instance for use in a script function by encoding it into a byte sequence.\n   * This process involves serializing the variant index and the instance data, making it suitable for transmission.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Address);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Deserialize an AccountAddress from the byte buffer in a Deserializer instance.\n   * This function allows you to convert a byte representation of an AccountAddress into an instance of AccountAddress.\n   * @param deserializer The deserializer to deserialize the AccountAddress from.\n   * @returns An instance of AccountAddress.\n   * @example\n   * const bytes = hexToBytes(\"0x0102030405060708091011121314151617181920212223242526272829303132\");\n   * const deserializer = new Deserializer(bytes);\n   * const address = AccountAddress.deserialize(deserializer);\n   * // `address` is now an instance of AccountAddress.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): AccountAddress {\n    const bytes = deserializer.deserializeFixedBytes(AccountAddress.LENGTH);\n    return new AccountAddress(bytes);\n  }\n\n  // ===\n  // Methods for creating an instance of AccountAddress from other types.\n  // ===\n\n  /**\n   * NOTE: This function has strict parsing behavior. For relaxed behavior, please use\n   * the `fromString` function.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows only the strictest formats defined by AIP-40. In short this\n   * means only the following formats are accepted:\n   *\n   * - LONG\n   * - SHORT for special addresses\n   *\n   * Where:\n   * - LONG is defined as 0x + 64 hex characters.\n   * - SHORT for special addresses is 0x0 to 0xf inclusive without padding zeroes.\n   *\n   * This means the following are not accepted:\n   * - SHORT for non-special addresses.\n   * - Any address without a leading 0x.\n   *\n   * @param input - A hex string representing an account address.\n   *\n   * @throws {ParsingError} If the hex string does not start with 0x or is not in a valid format.\n   *\n   * @remarks\n   *\n   * This function has strict parsing behavior. For relaxed behavior, please use the `fromString` function.\n   *\n   * @see AIP-40 documentation for more details on address formats:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns An instance of AccountAddress.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromStringStrict(input: string): AccountAddress {\n    // Assert the string starts with 0x.\n    if (!input.startsWith(\"0x\")) {\n      throw new ParsingError(\"Hex string must start with a leading 0x.\", AddressInvalidReason.LEADING_ZERO_X_REQUIRED);\n    }\n\n    const address = AccountAddress.fromString(input);\n\n    // Check if the address is in LONG form. If it is not, this is only allowed for\n    // special addresses, in which case we check it is in proper SHORT form.\n    if (input.length !== AccountAddress.LONG_STRING_LENGTH + 2) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `The given hex string ${input} is not a special address, it must be represented as 0x + 64 chars.`,\n          AddressInvalidReason.LONG_FORM_REQUIRED_UNLESS_SPECIAL,\n        );\n      } else if (input.length !== 3) {\n        // 0x + one hex char is the only valid SHORT form for special addresses.\n        throw new ParsingError(\n          // eslint-disable-next-line max-len\n          `The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,\n          AddressInvalidReason.INVALID_PADDING_ZEROES,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * NOTE: This function has relaxed parsing behavior. For strict behavior, please use\n   * the `fromStringStrict` function. Where possible use `fromStringStrict` rather than this\n   * function, `fromString`.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows all formats defined by AIP-40. In short this means the\n   * following formats are accepted:\n   *\n   * - LONG, with or without leading 0x\n   * - SHORT*, with or without leading 0x\n   *\n   * Where:\n   * - LONG is 64 hex characters.\n   * - SHORT* is 1 to 63 hex characters inclusive. The address can have missing values up to `maxMissingChars` before it is padded.\n   * - Padding zeroes are allowed, e.g. 0x0123 is valid.\n   *\n   * Learn more about the different address formats by reading AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @param input A hex string representing an account address.\n   * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.\n   *\n   * @returns An instance of AccountAddress.\n   *\n   * @throws ParsingError if the hex string is too short, too long, or contains invalid characters.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromString(input: string, { maxMissingChars = 4 }: { maxMissingChars?: number } = {}): AccountAddress {\n    let parsedInput = input;\n    // Remove leading 0x for parsing.\n    if (input.startsWith(\"0x\")) {\n      parsedInput = input.slice(2);\n    }\n\n    // Ensure the address string is at least 1 character long.\n    if (parsedInput.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_SHORT,\n      );\n    }\n\n    // Ensure the address string is not longer than 64 characters.\n    if (parsedInput.length > 64) {\n      throw new ParsingError(\n        \"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_LONG,\n      );\n    }\n\n    // Ensure that the maxMissingChars is between or equal to 0 and 63.\n    if (maxMissingChars > 63 || maxMissingChars < 0) {\n      throw new ParsingError(\n        `maxMissingChars must be between or equal to 0 and 63. Received ${maxMissingChars}`,\n        AddressInvalidReason.INVALID_PADDING_STRICTNESS,\n      );\n    }\n\n    let addressBytes: Uint8Array;\n    try {\n      // Pad the address with leading zeroes, so it is 64 chars long and then convert\n      // the hex string to bytes. Every two characters in a hex string constitutes a\n      // single byte. So a 64 length hex string becomes a 32 byte array.\n      addressBytes = hexToBytes(parsedInput.padStart(64, \"0\"));\n    } catch (error: any) {\n      // At this point the only way this can fail is if the hex string contains\n      // invalid characters.\n      throw new ParsingError(`Hex characters are invalid: ${error?.message}`, AddressInvalidReason.INVALID_HEX_CHARS);\n    }\n\n    const address = new AccountAddress(addressBytes);\n\n    // Cannot pad the address if it has more than maxMissingChars missing.\n    if (parsedInput.length < 64 - maxMissingChars) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `Hex string is too short, must be ${64 - maxMissingChars} to 64 chars long, excluding the leading 0x. You may need to fix \nthe addresss by padding it with 0s before passing it to \\`fromString\\` (e.g. <addressString>.padStart(64, '0')). \nReceived ${input}`,\n          AddressInvalidReason.TOO_SHORT,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * Convenience method for creating an AccountAddress from various input types.\n   * This function accepts a string, Uint8Array, or an existing AccountAddress instance and returns the corresponding\n   * AccountAddress.\n   *\n   * @param input - The input to convert into an AccountAddress. This can be a string representation of an address, a Uint8Array,\n   * or an existing AccountAddress.\n   * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  static from(input: AccountAddressInput, { maxMissingChars = 4 }: { maxMissingChars?: number } = {}): AccountAddress {\n    if (typeof input === \"string\") {\n      return AccountAddress.fromString(input, { maxMissingChars });\n    }\n    if (input instanceof Uint8Array) {\n      return new AccountAddress(input);\n    }\n    return input;\n  }\n\n  /**\n   * Create an AccountAddress from various input types, including strings, Uint8Array, and AccountAddress instances.\n   *\n   * @param input - The input to convert into an AccountAddress, which can be a string, a Uint8Array, or an AccountAddress.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromStrict(input: AccountAddressInput): AccountAddress {\n    if (typeof input === \"string\") {\n      return AccountAddress.fromStringStrict(input);\n    }\n    if (input instanceof Uint8Array) {\n      return new AccountAddress(input);\n    }\n    return input;\n  }\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the provided input is a valid AccountAddress.\n   *\n   * @param args - The arguments for validation.\n   * @param args.input - A hex string representing an account address.\n   * @param args.strict - If true, use strict parsing behavior; if false, use relaxed parsing behavior.\n   *\n   * @returns An object indicating whether the address is valid. If valid, valid = true; if not, valid = false with additional details.\n   * If the address is invalid, invalidReason will explain why it is invalid, and invalidReasonMessage will provide the error message.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isValid(args: { input: AccountAddressInput; strict?: boolean }): ParsingResult<AddressInvalidReason> {\n    try {\n      if (args.strict) {\n        AccountAddress.fromStrict(args.input);\n      } else {\n        AccountAddress.from(args.input);\n      }\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Determine if two AccountAddresses are equal based on their underlying byte data.\n   *\n   * @param other - The AccountAddress to compare to.\n   * @returns true if the AccountAddresses are equal, false if not.\n   * @group Implementation\n   * @category Serialization\n   */\n  equals(other: AccountAddress): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n", "import { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"../../accountAddress\";\nimport { DeriveScheme } from \"../../../types\";\n\n/**\n * Creates an object address from creator address and seed\n *\n * @param creatorAddress The object creator account address\n * @param seed The seed in either Uint8Array | string type\n *\n * @returns The object account address\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport const createObjectAddress = (creatorAddress: AccountAddress, seed: Uint8Array | string): AccountAddress => {\n  const creatorBytes = creatorAddress.bcsToBytes();\n\n  const seedBytes = typeof seed === \"string\" ? Buffer.from(seed, \"utf8\") : seed;\n\n  const bytes = new Uint8Array([...creatorBytes, ...seedBytes, DeriveScheme.DeriveObjectAddressFromSeed]);\n\n  return new AccountAddress(sha3_256(bytes));\n};\n\n/**\n * Creates a resource address from creator address and seed\n *\n * @param creatorAddress The creator account address\n * @param seed The seed in either Uint8Array | string type\n *\n * @returns The resource account address\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport const createResourceAddress = (creatorAddress: AccountAddress, seed: Uint8Array | string): AccountAddress => {\n  const creatorBytes = creatorAddress.bcsToBytes();\n\n  const seedBytes = typeof seed === \"string\" ? Buffer.from(seed, \"utf8\") : seed;\n\n  const bytes = new Uint8Array([...creatorBytes, ...seedBytes, DeriveScheme.DeriveResourceAccountAddress]);\n\n  return new AccountAddress(sha3_256(bytes));\n};\n\n/**\n * Creates a token object address from creator address, collection name and token name\n *\n * @param creatorAddress The token creator account address\n * @param collectionName The collection name\n * @param tokenName The token name\n *\n * @returns The token account address\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport const createTokenAddress = (\n  creatorAddress: AccountAddress,\n  collectionName: string,\n  tokenName: string,\n): AccountAddress => {\n  const seed = `${collectionName}::${tokenName}`;\n  return createObjectAddress(creatorAddress, seed);\n};\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { decode } from \"js-base64\";\nimport { MoveFunctionId, MoveStructId } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { createObjectAddress } from \"../core/account/utils/address\";\n\n/**\n * Sleep for the specified amount of time in milliseconds.\n * This function can be used to introduce delays in asynchronous operations.\n *\n * @param timeMs - The time in milliseconds to sleep.\n * @group Implementation\n * @category Utils\n */\nexport async function sleep(timeMs: number): Promise<null> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeMs);\n  });\n}\n\n/**\n * Get the error message from an unknown error.\n *\n * @param error The error to get the message from\n * @returns The error message\n * @group Implementation\n * @category Utils\n */\nexport function getErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : String(error);\n}\n\n/**\n * @group Implementation\n * @category Utils\n */\nexport const nowInSeconds = () => Math.floor(Date.now() / 1000);\n\n/**\n * Floors the given timestamp to the nearest whole hour.\n * This function is useful for normalizing timestamps to hourly intervals.\n *\n * @param timestampInSeconds - The timestamp in seconds to be floored.\n * @group Implementation\n * @category Utils\n */\nexport function floorToWholeHour(timestampInSeconds: number): number {\n  const date = new Date(timestampInSeconds * 1000);\n  // Reset minutes and seconds to zero\n  date.setMinutes(0);\n  date.setSeconds(0);\n  date.setMilliseconds(0);\n  return Math.floor(date.getTime() / 1000);\n}\n\n/**\n * Decodes a base64 URL-encoded string into its original form.\n * This function is useful for converting base64 URL-encoded data back to a readable format.\n *\n * @param base64Url - The base64 URL-encoded string to decode.\n * @returns The decoded string.\n * @group Implementation\n * @category Utils\n */\nexport function base64UrlDecode(base64Url: string): string {\n  // Replace base64url-specific characters\n  const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Pad the string with '=' characters if needed\n  const paddedBase64 = base64 + \"==\".substring(0, (3 - (base64.length % 3)) % 3);\n  const decodedString = decode(paddedBase64);\n  return decodedString;\n}\n\nexport function base64UrlToBytes(base64Url: string): Uint8Array {\n  // Convert Base64Url to Base64\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Add padding if needed\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  // Use Buffer to convert base64 to Uint8Array\n  return new Uint8Array(Buffer.from(base64, \"base64\"));\n}\n\n/**\n * Amount is represented in the smallest unit format on chain, this function converts\n * a human-readable amount format to the smallest unit format\n * @example\n * human-readable amount format: 500\n * on chain amount format when decimal is 8: 50000000000\n *\n * @param value The value in human-readable format\n * @param decimal The token decimal\n * @returns The value in the smallest units\n * @group Implementation\n * @category Utils\n */\nexport const convertAmountFromHumanReadableToOnChain = (value: number, decimal: number) => value * 10 ** decimal;\n\n/**\n * Amount is represented in the smallest unit format on chain, this function converts\n * the smallest unit format to a human-readable amount format\n * @example\n * human-readable amount format: 500\n * on chain amount format when decimal is 8: 50000000000\n *\n * @param value The value in human-readable format\n * @param decimal The token decimal\n * @returns The value in the smallest units\n * @group Implementation\n * @category Utils\n */\nexport const convertAmountFromOnChainToHumanReadable = (value: number, decimal: number) => value / 10 ** decimal;\n\n/**\n * Convert a hex string to an ascii string with the `0x` prefix.\n *\n * `0x6170746f735f636f696e` --> `aptos_coin`\n *\n * @param hex The hex string to convert (e.g. `0x6170746f735f636f696e`)\n * @returns The ascii string\n * @group Implementation\n * @category Utils\n */\nconst hexToAscii = (hex: string) => {\n  let str = \"\";\n  for (let n = 2; n < hex.length; n += 2) {\n    str += String.fromCharCode(parseInt(hex.substring(n, n + 2), 16));\n  }\n  return str;\n};\n\n/**\n * Convert an encoded struct to a MoveStructId.\n *\n * @example\n * const structObj = {\n *   account_address: \"0x1\",\n *   module_name: \"0x6170746f735f636f696e\",\n *   struct_name: \"0x4170746f73436f696e\",\n * };\n * // structId is \"0x1::aptos_coin::AptosCoin\"\n * const structId = parseEncodedStruct(structObj);\n *\n * @param structObj The struct with account_address, module_name, and struct_name properties\n * @returns The MoveStructId\n * @group Implementation\n * @category Utils\n */\nexport const parseEncodedStruct = (structObj: {\n  account_address: string;\n  module_name: string;\n  struct_name: string;\n}): MoveStructId => {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const { account_address, module_name, struct_name } = structObj;\n  const moduleName = hexToAscii(module_name);\n  const structName = hexToAscii(struct_name);\n  return `${account_address}::${moduleName}::${structName}`;\n};\n\n/**\n * Determines whether the given object is an encoded struct type with the following properties:\n * - account_address: string\n * - module_name: string\n * - struct_name: string\n *\n * @param structObj The object to check\n * @returns Whether the object is an encoded struct type\n * @group Implementation\n * @category Utils\n */\nexport const isEncodedStruct = (\n  structObj: any,\n): structObj is {\n  account_address: string;\n  module_name: string;\n  struct_name: string;\n} =>\n  typeof structObj === \"object\" &&\n  !Array.isArray(structObj) &&\n  structObj !== null &&\n  \"account_address\" in structObj &&\n  \"module_name\" in structObj &&\n  \"struct_name\" in structObj &&\n  typeof structObj.account_address === \"string\" &&\n  typeof structObj.module_name === \"string\" &&\n  typeof structObj.struct_name === \"string\";\n\n/**\n * Splits a function identifier into its constituent parts: module address, module name, and function name.\n * This function helps in validating and extracting details from a function identifier string.\n *\n * @param functionArg - The function identifier string in the format \"moduleAddress::moduleName::functionName\".\n * @returns An object containing the module address, module name, and function name.\n * @throws Error if the function identifier does not contain exactly three parts.\n * @group Implementation\n * @category Transactions\n */\nexport function getFunctionParts(functionArg: MoveFunctionId) {\n  const funcNameParts = functionArg.split(\"::\");\n  if (funcNameParts.length !== 3) {\n    throw new Error(`Invalid function ${functionArg}`);\n  }\n  const moduleAddress = funcNameParts[0];\n  const moduleName = funcNameParts[1];\n  const functionName = funcNameParts[2];\n  return { moduleAddress, moduleName, functionName };\n}\n\n/**\n * Validates the provided function information.\n *\n * @param functionInfo - The function information to validate.\n * @returns Whether the function information is valid.\n * @group Implementation\n * @category Utils\n */\nexport function isValidFunctionInfo(functionInfo: string): boolean {\n  const parts = functionInfo.split(\"::\");\n  return parts.length === 3 && AccountAddress.isValid({ input: parts[0] }).valid;\n}\n\n/**\n * Truncates the provided wallet address at the middle with an ellipsis.\n *\n * @param address - The wallet address to truncate.\n * @param start - The number of characters to show at the beginning of the address.\n * @param end - The number of characters to show at the end of the address.\n * @returns The truncated address.\n * @group Implementation\n * @category Utils\n */\nexport function truncateAddress(address: string, start: number = 6, end: number = 5) {\n  return `${address.slice(0, start)}...${address.slice(-end)}`;\n}\n\n/**\n * Constants for metadata address calculation\n */\nconst APTOS_COIN_TYPE_STR = \"0x1::aptos_coin::AptosCoin\";\nconst APT_METADATA_ADDRESS_HEX = AccountAddress.A.toStringLong();\n\n/**\n * Helper function to standardize Move type string by converting all addresses to short form,\n * including addresses within nested type parameters\n */\nfunction standardizeMoveTypeString(input: string): string {\n  // Regular expression to match addresses in the type string, including those within type parameters\n  // This regex matches \"0x\" followed by hex digits, handling both standalone addresses and those within <>\n  const addressRegex = /0x[0-9a-fA-F]+/g;\n\n  return input.replace(addressRegex, (match) => {\n    // Use AccountAddress to handle the address\n    return AccountAddress.from(match, { maxMissingChars: 63 }).toStringShort();\n  });\n}\n\n/**\n * Calculates the paired FA metadata address for a given coin type.\n * This function is tolerant of various address formats in the coin type string,\n * including complex nested types.\n *\n * @example\n * // All these formats are valid and will produce the same result:\n * pairedFaMetadataAddress(\"0x1::aptos_coin::AptosCoin\")  // simple form\n * pairedFaMetadataAddress(\"0x0000000000000000000000000000000000000000000000000000000000000001::aptos_coin::AptosCoin\")  // long form\n * pairedFaMetadataAddress(\"0x00001::aptos_coin::AptosCoin\")  // with leading zeros\n * pairedFaMetadataAddress(\"0x1::coin::Coin<0x1412::a::struct<0x0001::aptos_coin::AptosCoin>>\")  // nested type parameters\n *\n * @param coinType - The coin type string in any of these formats:\n *   - Short form address: \"0x1::aptos_coin::AptosCoin\"\n *   - Long form address: \"0x0000000000000000000000000000000000000000000000000000000000000001::aptos_coin::AptosCoin\"\n *   - With leading zeros: \"0x00001::aptos_coin::AptosCoin\"\n *   - With nested types: \"0x1::coin::Coin<0x1412::a::struct<0x0001::aptos_coin::AptosCoin>>\"\n * @returns The calculated metadata address as an AccountAddress instance\n */\nexport function pairedFaMetadataAddress(coinType: `0x${string}::${string}::${string}`): AccountAddress {\n  // Standardize the coin type string to handle any address format\n  const standardizedMoveTypeName = standardizeMoveTypeString(coinType);\n\n  return standardizedMoveTypeName === APTOS_COIN_TYPE_STR\n    ? AccountAddress.A\n    : createObjectAddress(AccountAddress.A, standardizedMoveTypeName);\n}\n", "import { AptosApiType } from \"../utils/const\";\nimport { getErrorMessage } from \"../utils/helpers\";\nimport { AptosRequest, AptosResponse } from \"../types\";\n\nexport enum KeylessErrorCategory {\n  API_ERROR,\n  EXTERNAL_API_ERROR,\n  SESSION_EXPIRED,\n  INVALID_STATE,\n  INVALID_SIGNATURE,\n  UNKNOWN,\n}\n\nexport enum KeylessErrorResolutionTip {\n  REAUTHENTICATE = \"Re-authentiate to continue using your keyless account\",\n  // eslint-disable-next-line max-len\n  REAUTHENTICATE_UNSURE = \"Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support\",\n  UPDATE_REQUEST_PARAMS = \"Update the invalid request parameters and reauthenticate.\",\n  // eslint-disable-next-line max-len\n  RATE_LIMIT_EXCEEDED = \"Cache the keyless account and reuse it to avoid making too many requests.  Keyless accounts are valid until either the EphemeralKeyPair expires, when the JWK is rotated, or when the proof verifying key is changed, whichever comes soonest.\",\n  // eslint-disable-next-line max-len\n  SERVER_ERROR = \"Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx\",\n  // eslint-disable-next-line max-len\n  CALL_PRECHECK = \"Call `await account.checkKeylessAccountValidity()` to wait for asyncronous changes and check for account validity before signing or serializing.\",\n  REINSTANTIATE = \"Try instantiating the account again.  Avoid manipulating the account object directly\",\n  JOIN_SUPPORT_GROUP = \"For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx\",\n  UNKNOWN = \"Error unknown. For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx\",\n}\n\nexport enum KeylessErrorType {\n  EPHEMERAL_KEY_PAIR_EXPIRED,\n\n  PROOF_NOT_FOUND,\n\n  ASYNC_PROOF_FETCH_FAILED,\n\n  INVALID_PROOF_VERIFICATION_FAILED,\n\n  INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND,\n\n  INVALID_JWT_SIG,\n\n  INVALID_JWT_JWK_NOT_FOUND,\n\n  INVALID_JWT_ISS_NOT_RECOGNIZED,\n\n  INVALID_JWT_FEDERATED_ISS_NOT_SUPPORTED,\n\n  INVALID_TW_SIG_VERIFICATION_FAILED,\n\n  INVALID_TW_SIG_PUBLIC_KEY_NOT_FOUND,\n\n  INVALID_EXPIRY_HORIZON,\n\n  JWT_PARSING_ERROR,\n\n  JWK_FETCH_FAILED,\n\n  JWK_FETCH_FAILED_FEDERATED,\n\n  RATE_LIMIT_EXCEEDED,\n\n  PEPPER_SERVICE_INTERNAL_ERROR,\n\n  PEPPER_SERVICE_BAD_REQUEST,\n\n  PEPPER_SERVICE_OTHER,\n\n  PROVER_SERVICE_INTERNAL_ERROR,\n\n  PROVER_SERVICE_BAD_REQUEST,\n\n  PROVER_SERVICE_OTHER,\n\n  FULL_NODE_CONFIG_LOOKUP_ERROR,\n\n  FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR,\n\n  FULL_NODE_JWKS_LOOKUP_ERROR,\n\n  FULL_NODE_OTHER,\n\n  SIGNATURE_TYPE_INVALID,\n\n  SIGNATURE_EXPIRED,\n\n  MAX_EXPIRY_HORIZON_EXCEEDED,\n\n  EPHEMERAL_SIGNATURE_VERIFICATION_FAILED,\n\n  TRAINING_WHEELS_SIGNATURE_MISSING,\n\n  TRAINING_WHEELS_SIGNATURE_VERIFICATION_FAILED,\n\n  PROOF_VERIFICATION_FAILED,\n\n  UNKNOWN,\n}\n\nconst KeylessErrors: { [key in KeylessErrorType]: [string, KeylessErrorCategory, KeylessErrorResolutionTip] } = {\n  [KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED]: [\n    \"The ephemeral keypair has expired.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.PROOF_NOT_FOUND]: [\n    \"The required proof could not be found.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.CALL_PRECHECK,\n  ],\n  [KeylessErrorType.ASYNC_PROOF_FETCH_FAILED]: [\n    \"The required proof failed to fetch.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_PROOF_VERIFICATION_FAILED]: [\n    \"The provided proof is invalid.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND]: [\n    \"The verification key used to authenticate was updated.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.INVALID_JWT_SIG]: [\n    \"The JWK was found, but JWT failed verification\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_JWT_JWK_NOT_FOUND]: [\n    \"The JWK required to verify the JWT could not be found. The JWK may have been rotated out.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.INVALID_JWT_ISS_NOT_RECOGNIZED]: [\n    \"The JWT issuer is not recognized.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.UPDATE_REQUEST_PARAMS,\n  ],\n  [KeylessErrorType.INVALID_JWT_FEDERATED_ISS_NOT_SUPPORTED]: [\n    \"The JWT issuer is not supported by the Federated Keyless \",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_TW_SIG_VERIFICATION_FAILED]: [\n    \"The training wheels signature is invalid.\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REAUTHENTICATE_UNSURE,\n  ],\n  [KeylessErrorType.INVALID_TW_SIG_PUBLIC_KEY_NOT_FOUND]: [\n    \"The public key used to verify the training wheels signature was not found.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.INVALID_EXPIRY_HORIZON]: [\n    \"The expiry horizon is invalid.\",\n    KeylessErrorCategory.SESSION_EXPIRED,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.JWK_FETCH_FAILED]: [\n    \"Failed to fetch JWKS.\",\n    KeylessErrorCategory.EXTERNAL_API_ERROR,\n    KeylessErrorResolutionTip.JOIN_SUPPORT_GROUP,\n  ],\n  [KeylessErrorType.JWK_FETCH_FAILED_FEDERATED]: [\n    \"Failed to fetch JWKS for Federated Keyless provider.\",\n    KeylessErrorCategory.EXTERNAL_API_ERROR,\n    KeylessErrorResolutionTip.JOIN_SUPPORT_GROUP,\n  ],\n  [KeylessErrorType.RATE_LIMIT_EXCEEDED]: [\n    \"Rate limit exceeded. Too many requests in a short period.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.RATE_LIMIT_EXCEEDED,\n  ],\n  [KeylessErrorType.PEPPER_SERVICE_INTERNAL_ERROR]: [\n    \"Internal error from Pepper service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.PEPPER_SERVICE_BAD_REQUEST]: [\n    \"Bad request sent to Pepper service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.UPDATE_REQUEST_PARAMS,\n  ],\n  [KeylessErrorType.PEPPER_SERVICE_OTHER]: [\n    \"Unknown error from Pepper service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.PROVER_SERVICE_INTERNAL_ERROR]: [\n    \"Internal error from Prover service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.PROVER_SERVICE_BAD_REQUEST]: [\n    \"Bad request sent to Prover service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.UPDATE_REQUEST_PARAMS,\n  ],\n  [KeylessErrorType.PROVER_SERVICE_OTHER]: [\n    \"Unknown error from Prover service.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.JWT_PARSING_ERROR]: [\n    \"Error when parsing JWT. This should never happen. Join https://t.me/+h5CN-W35yUFiYzkx for support\",\n    KeylessErrorCategory.INVALID_STATE,\n    KeylessErrorResolutionTip.REINSTANTIATE,\n  ],\n  [KeylessErrorType.FULL_NODE_CONFIG_LOOKUP_ERROR]: [\n    \"Error when looking up on-chain keyless configuration.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR]: [\n    \"Error when looking up on-chain verification key.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.FULL_NODE_JWKS_LOOKUP_ERROR]: [\n    \"Error when looking up on-chain JWKS.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.FULL_NODE_OTHER]: [\n    \"Unknown error from full node.\",\n    KeylessErrorCategory.API_ERROR,\n    KeylessErrorResolutionTip.SERVER_ERROR,\n  ],\n  [KeylessErrorType.SIGNATURE_TYPE_INVALID]: [\n    \"The signature is not a valid Keyless signature.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.JOIN_SUPPORT_GROUP,\n  ],\n  [KeylessErrorType.SIGNATURE_EXPIRED]: [\n    \"The ephemeral key pair used to sign the message has expired.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.MAX_EXPIRY_HORIZON_EXCEEDED]: [\n    \"The expiry horizon on the signature exceeds the maximum allowed value.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.EPHEMERAL_SIGNATURE_VERIFICATION_FAILED]: [\n    \"Failed to verify the ephemeral signature with the ephemeral public key.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.TRAINING_WHEELS_SIGNATURE_MISSING]: [\n    \"The training wheels signature is missing but is required by the Keyless configuration.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.TRAINING_WHEELS_SIGNATURE_VERIFICATION_FAILED]: [\n    \"Failed to verify the training wheels signature with the training wheels public key.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.PROOF_VERIFICATION_FAILED]: [\n    \"The proof verification failed.\",\n    KeylessErrorCategory.INVALID_SIGNATURE,\n    KeylessErrorResolutionTip.REAUTHENTICATE,\n  ],\n  [KeylessErrorType.UNKNOWN]: [\n    \"An unknown error has occurred.\",\n    KeylessErrorCategory.UNKNOWN,\n    KeylessErrorResolutionTip.UNKNOWN,\n  ],\n};\n\nexport class KeylessError extends Error {\n  readonly innerError?: unknown;\n\n  readonly category: KeylessErrorCategory;\n\n  readonly resolutionTip: KeylessErrorResolutionTip;\n\n  readonly type: KeylessErrorType;\n\n  readonly details?: string;\n\n  /** @internal this constructor is for sdk internal use - do not instantiate outside of the SDK codebase */\n  constructor(args: {\n    innerError?: unknown;\n    category: KeylessErrorCategory;\n    resolutionTip: KeylessErrorResolutionTip;\n    type: KeylessErrorType;\n    message?: string;\n    details?: string;\n  }) {\n    const { innerError, category, resolutionTip, type, message = KeylessErrors[type][0], details } = args;\n    super(message);\n    this.name = \"KeylessError\";\n    this.innerError = innerError;\n    this.category = category;\n    this.resolutionTip = resolutionTip;\n    this.type = type;\n    this.details = details;\n    this.message = KeylessError.constructMessage(message, resolutionTip, innerError, details);\n  }\n\n  static constructMessage(\n    message: string,\n    tip: KeylessErrorResolutionTip,\n    innerError?: unknown,\n    details?: string,\n  ): string {\n    let result = `\\nMessage: ${message}`;\n    if (details) {\n      result += `\\nDetails: ${details}`;\n    }\n    if (innerError instanceof AptosApiError) {\n      result += `\\nAptosApiError: ${innerError.message}`;\n    } else if (innerError !== undefined) {\n      result += `\\nError: ${getErrorMessage(innerError)}`;\n    }\n    result += `\\nKeylessErrorResolutionTip: ${tip}`;\n    return result;\n  }\n\n  /**\n   * Static constructor that creates a KeylessError instance using the KeylessErrors constant\n   * @param args.type The type of KeylessError\n   * @param args.aptosApiError optional AptosApiError supplied for api errors\n   * @param args.details optional details to include in the error message\n   * @returns A new KeylessError instance\n   */\n  static fromErrorType(args: { type: KeylessErrorType; error?: unknown; details?: string }): KeylessError {\n    const { error, type, details } = args;\n\n    const [message, category, resolutionTip] = KeylessErrors[type];\n    return new KeylessError({\n      message,\n      details,\n      innerError: error,\n      category,\n      resolutionTip,\n      type,\n    });\n  }\n}\n\n/**\n * Options for handling errors in the Aptos API.\n */\ntype AptosApiErrorOpts = {\n  apiType: AptosApiType;\n  aptosRequest: AptosRequest;\n  aptosResponse: AptosResponse<any, any>;\n};\n\n/**\n * Represents an error returned from the Aptos API.\n * This class encapsulates the details of the error, including the request URL, response status, and additional data.\n *\n * @param name - The name of the error, which is always \"AptosApiError\".\n * @param url - The URL to which the request was made.\n * @param status - The HTTP response status code (e.g., 400).\n * @param statusText - The message associated with the response status.\n * @param data - The response data returned from the API.\n * @param request - The original AptosRequest that triggered the error.\n */\nexport class AptosApiError extends Error {\n  readonly url: string;\n\n  readonly status: number;\n\n  readonly statusText: string;\n\n  readonly data: any;\n\n  readonly request: AptosRequest;\n\n  /**\n   * Constructs an instance of AptosApiError with relevant error details.\n   *\n   * @param opts - The options for creating the AptosApiError.\n   * @param opts.apiType - The type of API that generated the error.\n   * @param opts.aptosRequest - The request object that caused the error.\n   * @param opts.aptosResponse - The response object containing error details.\n   *\n   * @internal This constructor is for SDK internal use - do not instantiate outside the SDK codebase.\n   */\n  constructor({ apiType, aptosRequest, aptosResponse }: AptosApiErrorOpts) {\n    super(deriveErrorMessage({ apiType, aptosRequest, aptosResponse }));\n\n    this.name = \"AptosApiError\";\n    this.url = aptosResponse.url;\n    this.status = aptosResponse.status;\n    this.statusText = aptosResponse.statusText;\n    this.data = aptosResponse.data;\n    this.request = aptosRequest;\n  }\n}\n\n/**\n * Derives an error message from the Aptos API response, providing context for debugging.\n * This function helps in understanding the nature of the error encountered during an API request.\n *\n * @param {AptosApiErrorOpts} opts - The options for deriving the error message.\n * @param {AptosApiType} opts.apiType - The type of API being called.\n * @param {AptosRequest} opts.aptosRequest - The original request made to the Aptos API.\n * @param {AptosResponse} opts.aptosResponse - The response received from the Aptos API.\n */\nfunction deriveErrorMessage({ apiType, aptosRequest, aptosResponse }: AptosApiErrorOpts): string {\n  // eslint-disable-next-line max-len\n  // extract the W3C trace_id from the response headers if it exists. Some services set this in the response, and it's useful for debugging.\n  // See https://www.w3.org/TR/trace-context/#relationship-between-the-headers .\n  const traceId = aptosResponse.headers?.traceparent?.split(\"-\")[1];\n  const traceIdString = traceId ? `(trace_id:${traceId}) ` : \"\";\n\n  const errorPrelude: string = `Request to [${apiType}]: ${aptosRequest.method} ${\n    aptosResponse.url ?? aptosRequest.url\n  } ${traceIdString}failed with`;\n\n  // handle graphql responses from indexer api and extract the error message of the first error\n  if (apiType === AptosApiType.INDEXER && aptosResponse.data?.errors?.[0]?.message != null) {\n    return `${errorPrelude}: ${aptosResponse.data.errors[0].message}`;\n  }\n\n  // Received well-known structured error response body - simply serialize and return it.\n  // We don't need http status codes etc. in this case.\n  if (aptosResponse.data?.message != null && aptosResponse.data?.error_code != null) {\n    return `${errorPrelude}: ${JSON.stringify(aptosResponse.data)}`;\n  }\n\n  // This is the generic/catch-all case. We received some response from the API, but it doesn't appear to be a well-known structure.\n  // We print http status codes and the response body (after some trimming),\n  // in the hope that this gives enough context what went wrong without printing overly huge messages.\n  return `${errorPrelude} status: ${aptosResponse.statusText}(code:${\n    aptosResponse.status\n  }) and response body: ${serializeAnyPayloadForErrorMessage(aptosResponse.data)}`;\n}\n\nconst SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH = 400;\n\n/**\n * This function accepts a payload of any type (probably an object) and serializes it to a string\n * Since we don't know the type or size of the payload, and we don't want to add a huge object in full to the error message\n * we limit the to the first 200 and last 200 characters of the serialized payload and put a \"...\" in the middle.\n * @param payload - The payload to serialize, which can be of any type.\n *\n * @returns A string representation of the serialized payload, potentially truncated.\n */\nfunction serializeAnyPayloadForErrorMessage(payload: any): string {\n  const serializedPayload = JSON.stringify(payload);\n  if (serializedPayload.length <= SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH) {\n    return serializedPayload;\n  }\n  return `truncated(original_size:${serializedPayload.length}): ${serializedPayload.slice(\n    0,\n    SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH / 2,\n  )}...${serializedPayload.slice(-SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH / 2)}`;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * The current version of the SDK\n *\n * hardcoded for now, we would want to have it injected dynamically\n */\nexport const VERSION = \"3.1.3\";\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { VERSION } from \"../version\";\nimport { AnyNumber, AptosRequest, AptosResponse, Client, ClientRequest, ClientResponse, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\n\n/**\n * Sends a request using the specified options and returns the response.\n *\n * @param options - The options for the request.\n * @param options.url - The URL to send the request to.\n * @param options.method - The HTTP method to use for the request.\n * @param options.body - The body of the request.\n * @param options.contentType - The content type of the request.\n * @param options.params - The query parameters to include in the request.\n * @param options.overrides - Additional overrides for the request.\n * @param options.overrides.HEADERS - Custom headers to include in the request.\n * @param options.overrides.AUTH_TOKEN - The authorization token for the request.\n * @param options.overrides.API_KEY - The API key for the request.\n * @param options.originMethod - The origin method for the request.\n * @param client - The client used to make the request.\n *\n * @returns The response from the request.\n * @group Implementation\n * @category Client\n */\nexport async function request<Req, Res>(options: ClientRequest<Req>, client: Client): Promise<ClientResponse<Res>> {\n  const { url, method, body, contentType, params, overrides, originMethod } = options;\n  const headers: Record<string, string | AnyNumber | boolean | undefined> = {\n    ...overrides?.HEADERS,\n    \"x-aptos-client\": `aptos-typescript-sdk/${VERSION}`,\n    \"content-type\": contentType ?? MimeType.JSON,\n    \"x-aptos-typescript-sdk-origin-method\": originMethod,\n  };\n\n  if (overrides?.AUTH_TOKEN) {\n    headers.Authorization = `Bearer ${overrides?.AUTH_TOKEN}`;\n  }\n  if (overrides?.API_KEY) {\n    headers.Authorization = `Bearer ${overrides?.API_KEY}`;\n  }\n\n  /*\n   * make a call using the @aptos-labs/aptos-client package\n   * {@link https://www.npmjs.com/package/@aptos-labs/aptos-client}\n   */\n  return client.provider<Req, Res>({\n    url,\n    method,\n    body,\n    params,\n    headers,\n    overrides,\n  });\n}\n\n/**\n * The main function to use when making an API request, returning the response or throwing an AptosApiError on failure.\n *\n * @param aptosRequestOpts - Options for the Aptos request, including the URL and path.\n * @param aptosConfig - The configuration information for the SDK client instance.\n * @param apiType - The type of API being accessed, which determines how the response is handled.\n * @returns The response from the API request or throws an AptosApiError if the request fails.\n * @group Implementation\n * @category Client\n */\nexport async function aptosRequest<Req extends {}, Res extends {}>(\n  aptosRequestOpts: AptosRequest,\n  aptosConfig: AptosConfig,\n  apiType: AptosApiType,\n): Promise<AptosResponse<Req, Res>> {\n  const { url, path } = aptosRequestOpts;\n  const fullUrl = path ? `${url}/${path}` : url;\n  const clientResponse = await request<Req, Res>({ ...aptosRequestOpts, url: fullUrl }, aptosConfig.client);\n\n  const aptosResponse: AptosResponse<Req, Res> = {\n    status: clientResponse.status,\n    statusText: clientResponse.statusText ?? \"No status text provided\",\n    data: clientResponse.data,\n    headers: clientResponse.headers,\n    config: clientResponse.config,\n    request: clientResponse.request,\n    url: fullUrl,\n  };\n\n  // Handle case for `Unauthorized` error (i.e. API_KEY error)\n  if (aptosResponse.status === 401) {\n    throw new AptosApiError({ apiType, aptosRequest: aptosRequestOpts, aptosResponse });\n  }\n\n  // to support both fullnode and indexer responses,\n  // check if it is an indexer query, and adjust response.data\n  if (apiType === AptosApiType.INDEXER) {\n    const indexerResponse = aptosResponse.data as any;\n    // Handle Indexer general errors\n    if (indexerResponse.errors) {\n      throw new AptosApiError({\n        apiType,\n        aptosRequest: aptosRequestOpts,\n        aptosResponse,\n      });\n    }\n    aptosResponse.data = indexerResponse.data as Res;\n  } else if (apiType === AptosApiType.PEPPER || apiType === AptosApiType.PROVER) {\n    if (aptosResponse.status >= 400) {\n      throw new AptosApiError({ apiType, aptosRequest: aptosRequestOpts, aptosResponse });\n    }\n  }\n\n  if (aptosResponse.status >= 200 && aptosResponse.status < 300) {\n    return aptosResponse;\n  }\n\n  // We have to explicitly check for all request types, because if the error is a non-indexer error, but\n  // comes from an indexer request (e.g. 404), we'll need to mention it appropriately\n  throw new AptosApiError({ apiType, aptosRequest: aptosRequestOpts, aptosResponse });\n}\n", "import { AptosConfig } from \"../api/aptosConfig\";\nimport { aptosRequest } from \"./core\";\nimport { AptosResponse, AnyNumber, ClientConfig, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils/const\";\n\n/**\n * Options for making a GET request, including configuration for the API client.\n * @group Implementation\n * @category Client\n */\nexport type GetRequestOptions = {\n  /**\n   * The config for the API client\n   * @group Implementation\n   * @category Client\n   */\n  aptosConfig: AptosConfig;\n  /**\n   * The type of API endpoint to call e.g. fullnode, indexer, etc\n   * @group Implementation\n   * @category Client\n   */\n  type: AptosApiType;\n  /**\n   * The name of the API method\n   * @group Implementation\n   * @category Client\n   */\n  originMethod: string;\n  /**\n   * The URL path to the API method\n   * @group Implementation\n   * @category Client\n   */\n  path: string;\n  /**\n   * The content type of the request body\n   * @group Implementation\n   * @category Client\n   */\n  contentType?: MimeType;\n  /**\n   * The accepted content type of the response of the API\n   * @group Implementation\n   * @category Client\n   */\n  acceptType?: MimeType;\n  /**\n   * The query parameters for the request\n   * @group Implementation\n   * @category Client\n   */\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  /**\n   * Specific client overrides for this request to override aptosConfig\n   * @group Implementation\n   * @category Client\n   */\n  overrides?: ClientConfig;\n};\n\n/**\n * Options for making a request to the Aptos API, excluding the \"type\" field.\n * @group Implementation\n * @category Client\n */\nexport type GetAptosRequestOptions = Omit<GetRequestOptions, \"type\">;\n\n/**\n * Executes a GET request to retrieve data based on the provided options.\n *\n * @param options - The options for the GET request.\n * @param options.aptosConfig - The configuration object for Aptos requests.\n * @param options.overrides - Optional overrides for the request configuration.\n * @param options.params - Query parameters to include in the request.\n * @param options.contentType - The content type of the request.\n * @param options.acceptType - The accepted response type.\n * @param options.path - The specific path for the request.\n * @param options.originMethod - The original method of the request.\n * @param options.type - The type of request being made.\n * @returns The response from the GET request.\n * @group Implementation\n * @category Client\n */\nexport async function get<Req extends {}, Res extends {}>(\n  options: GetRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig, overrides, params, contentType, acceptType, path, originMethod, type } = options;\n  const url = aptosConfig.getRequestUrl(type);\n\n  return aptosRequest<Req, Res>(\n    {\n      url,\n      method: \"GET\",\n      originMethod,\n      path,\n      contentType,\n      acceptType,\n      params,\n      overrides: {\n        ...aptosConfig.clientConfig,\n        ...overrides,\n      },\n    },\n    aptosConfig,\n    options.type,\n  );\n}\n\n/**\n * Retrieves data from the Aptos full node using the provided options.\n *\n * @param options - The options for the request to the Aptos full node.\n * @param options.aptosConfig - Configuration settings specific to the Aptos client and full node.\n * @param options.aptosConfig.clientConfig - The client configuration settings.\n * @param options.aptosConfig.fullnodeConfig - The full node configuration settings.\n * @param options.overrides - Additional overrides for the request.\n * @param options.type - The type of API request being made.\n *\n * @returns A promise that resolves with the response from the Aptos full node.\n * @group Implementation\n * @category Client\n */\nexport async function getAptosFullNode<Req extends {}, Res extends {}>(\n  options: GetAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig } = options;\n\n  return get<Req, Res>({\n    ...options,\n    type: AptosApiType.FULLNODE,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...aptosConfig.fullnodeConfig,\n      ...options.overrides,\n      HEADERS: { ...aptosConfig.clientConfig?.HEADERS, ...aptosConfig.fullnodeConfig?.HEADERS },\n    },\n  });\n}\n\n/**\n * Makes a GET request to the Aptos Pepper service to retrieve data.\n *\n * @param options - The options for the request.\n * @param options.param1 - Description of param1.\n * @param options.param2 - Description of param2.\n * @returns AptosResponse - The response from the Aptos Pepper service.\n * @group Implementation\n * @category Client\n */\nexport async function getAptosPepperService<Req extends {}, Res extends {}>(\n  options: GetAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  return get<Req, Res>({ ...options, type: AptosApiType.PEPPER });\n}\n\n/**\n * This function is a helper for paginating using a function wrapping an API\n * @group Implementation\n * @category Client\n */\nexport async function paginateWithCursor<Req extends Record<string, any>, Res extends Array<{}>>(\n  options: GetAptosRequestOptions,\n): Promise<Res> {\n  const out: Res = new Array(0) as Res;\n  let cursor: string | undefined;\n  const requestParams = options.params as { start?: string; limit?: number };\n  do {\n    // eslint-disable-next-line no-await-in-loop\n    const response = await get<Req, Res>({\n      type: AptosApiType.FULLNODE,\n      aptosConfig: options.aptosConfig,\n      originMethod: options.originMethod,\n      path: options.path,\n      params: requestParams,\n      overrides: options.overrides,\n    });\n    /**\n     * the cursor is a \"state key\" from the API perspective. Client\n     * should not need to \"care\" what it represents but just use it\n     * to query the next chunk of data.\n     * @group Implementation\n     * @category Client\n     */\n    cursor = response.headers[\"x-aptos-cursor\"];\n    // Now that we have the cursor (if any), we remove the headers before\n    // adding these to the output of this function.\n    delete response.headers;\n    out.push(...response.data);\n    requestParams.start = cursor;\n  } while (cursor !== null && cursor !== undefined);\n  return out;\n}\n\n/// This function is a helper for paginating using a function wrapping an API using offset instead of start\nexport async function paginateWithObfuscatedCursor<Req extends Record<string, any>, Res extends Array<{}>>(\n  options: GetAptosRequestOptions,\n): Promise<Res> {\n  const out: Res = new Array(0) as Res;\n  let cursor: string | undefined;\n  const requestParams = options.params as { start?: string; limit?: number };\n  const totalLimit = requestParams.limit;\n  do {\n    // eslint-disable-next-line no-await-in-loop\n    const { response, cursor: newCursor } = await getPageWithObfuscatedCursor<Req, Res>({ ...options });\n\n    /**\n     * the cursor is a \"state key\" from the API perspective. Client\n     * should not need to \"care\" what it represents but just use it\n     * to query the next chunk of data.\n     */\n    cursor = newCursor;\n    out.push(...response.data);\n    if (options?.params) {\n      options.params.start = cursor;\n    }\n\n    // Re-evaluate length\n    if (totalLimit !== undefined) {\n      const newLimit = totalLimit - out.length;\n      if (newLimit <= 0) {\n        break;\n      }\n      requestParams.limit = newLimit;\n    }\n  } while (cursor !== null && cursor !== undefined);\n  return out;\n}\n\nexport async function getPageWithObfuscatedCursor<Req extends Record<string, any>, Res extends Array<{}>>(\n  options: GetAptosRequestOptions,\n): Promise<{ response: AptosResponse<Req, Res>; cursor: string | undefined }> {\n  let cursor: string | undefined;\n  let requestParams: { start?: string; limit?: number } = {};\n\n  // Drop any other values\n  // TODO: Throw error if cursor is not a string\n  if (typeof options.params?.cursor === \"string\") {\n    requestParams.start = options.params.cursor;\n  }\n  if (typeof options.params?.limit === \"number\") {\n    requestParams.limit = options.params.limit;\n  }\n\n  // eslint-disable-next-line no-await-in-loop\n  const response = await get<Req, Res>({\n    type: AptosApiType.FULLNODE,\n    aptosConfig: options.aptosConfig,\n    originMethod: options.originMethod,\n    path: options.path,\n    params: requestParams,\n    overrides: options.overrides,\n  });\n\n  /**\n   * the cursor is a \"state key\" from the API perspective. Client\n   * should not need to \"care\" what it represents but just use it\n   * to query the next chunk of data.\n   */\n  cursor = response.headers[\"x-aptos-cursor\"];\n  return { response, cursor };\n}\n", "import { AccountAddress, AccountAddressInput } from \"../../core/accountAddress\";\nimport { MoveModuleBytecode, LedgerVersionArg, AccountData } from \"../../types/types\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { getAptosFullNode } from \"../../client\";\nimport { memoizeAsync } from \"../../utils/memoize\";\n\n/**\n * Retrieves account information for a specified account address.\n *\n * @param args - The arguments for retrieving account information.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.accountAddress - The address of the account to retrieve information for.\n * @group Implementation\n */\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  const { aptosConfig, accountAddress } = args;\n  const { data } = await getAptosFullNode<{}, AccountData>({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}`,\n  });\n  return data;\n}\n\n/**\n * Queries for a move module given an account address and module name.\n * This function can help you retrieve the module's ABI and other relevant information.\n *\n * @param args - The arguments for retrieving the module.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The account address in hex-encoded 32 byte format.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - Specifies the ledger version of transactions. By default, the latest version will be used.\n * @returns The move module.\n * @group Implementation\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  // We don't memoize the account module by ledger version, as it's not a common use case, this would be handled\n  // by the developer directly\n  if (args.options?.ledgerVersion !== undefined) {\n    return getModuleInner(args);\n  }\n\n  return memoizeAsync(\n    async () => getModuleInner(args),\n    `module-${args.accountAddress}-${args.moduleName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\n/**\n * Retrieves the bytecode of a specified module from a given account address.\n *\n * @param args - The parameters for retrieving the module bytecode.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account from which to retrieve the module.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nasync function getModuleInner(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  const { aptosConfig, accountAddress, moduleName, options } = args;\n\n  const { data } = await getAptosFullNode<{}, MoveModuleBytecode>({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/module/${moduleName}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data;\n}\n", "import { HexInput } from \"../../types\";\nimport { Hex } from \"../hex\";\n\n/**\n * Helper function to convert a message to sign or to verify to a valid message input\n *\n * @param message a message as a string or Uint8Array\n *\n * @returns a valid HexInput - string or Uint8Array\n * @group Implementation\n * @category Serialization\n */\nexport const convertSigningMessage = (message: HexInput): HexInput => {\n  // if message is of type string, verify it is a valid Hex string\n  if (typeof message === \"string\") {\n    const isValid = Hex.isValid(message);\n    // If message is not a valid Hex string, convert it\n    if (!isValid.valid) {\n      return new TextEncoder().encode(message);\n    }\n    // If message is a valid Hex string, return it\n    return message;\n  }\n  // message is a Uint8Array\n  return message;\n};\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport * as bip39 from \"@scure/bip39\";\n\n/**\n * Contains the derived cryptographic key as a Uint8Array.\n * @group Implementation\n * @category Serialization\n */\nexport type DerivedKeys = {\n  key: Uint8Array;\n  chainCode: Uint8Array;\n};\n\n/**\n * Aptos derive path is 637\n * @group Implementation\n * @category Serialization\n */\nexport const APTOS_HARDENED_REGEX = /^m\\/44'\\/637'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'?$/;\n\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const APTOS_BIP44_REGEX = /^m\\/44'\\/637'\\/[0-9]+'\\/[0-9]+\\/[0-9]+$/;\n\n/**\n * Supported key types and their associated seeds.\n * @group Implementation\n * @category Serialization\n */\nexport enum KeyType {\n  ED25519 = \"ed25519 seed\",\n}\n\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const HARDENED_OFFSET = 0x80000000;\n\n/**\n * Validate a BIP-44 derivation path string to ensure it meets the required format.\n * This function checks if the provided path adheres to the BIP-44 standard for Secp256k1.\n * Parse and validate a path that is compliant to BIP-44 in form m/44'/637'/{account_index}'/{change_index}/{address_index}\n * for Secp256k1\n *\n * Note that for Secp256k1, the last two components must be non-hardened.\n *\n * @param path - The path string to validate (e.g. `m/44'/637'/0'/0/0`).\n * @group Implementation\n * @category Serialization\n */\nexport function isValidBIP44Path(path: string): boolean {\n  return APTOS_BIP44_REGEX.test(path);\n}\n\n/**\n * Aptos derive path is 637\n *\n * Parse and validate a path that is compliant to SLIP-0010 and BIP-44\n * in form m/44'/637'/{account_index}'/{change_index}'/{address_index}'.\n * See SLIP-0010 {@link https://github.com/satoshilabs/slips/blob/master/slip-0044.md}\n * See BIP-44 {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n *\n * Note that for Ed25519, all components must be hardened.\n * This is because non-hardened [PK] derivation would not work due to Ed25519's lack of a key homomorphism.\n * Specifically, you cannot derive the PK associated with derivation path a/b/c given the PK of a/b.\n * This is because the PK in Ed25519 is, more or less, computed as 𝑔𝐻(𝑠𝑘),\n * with the hash function breaking the homomorphism.\n *\n * @param path - The derivation path string to validate (e.g. `m/44'/637'/0'/0'/0'`).\n * @group Implementation\n * @category Serialization\n */\nexport function isValidHardenedPath(path: string): boolean {\n  return APTOS_HARDENED_REGEX.test(path);\n}\n\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const deriveKey = (hashSeed: Uint8Array | string, data: Uint8Array | string): DerivedKeys => {\n  const digest = hmac.create(sha512, hashSeed).update(data).digest();\n  return {\n    key: digest.slice(0, 32),\n    chainCode: digest.slice(32),\n  };\n};\n\n/**\n * Derive a child key from the private key\n * @param key\n * @param chainCode\n * @param index\n * @group Implementation\n * @category Serialization\n */\nexport const CKDPriv = ({ key, chainCode }: DerivedKeys, index: number): DerivedKeys => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, index);\n  const indexBytes = new Uint8Array(buffer);\n  const zero = new Uint8Array([0]);\n  const data = new Uint8Array([...zero, ...key, ...indexBytes]);\n  return deriveKey(chainCode, data);\n};\n\nconst removeApostrophes = (val: string): string => val.replace(/'/g, \"\");\n\n/**\n * Splits derive path into segments\n * @param path\n * @group Implementation\n * @category Serialization\n */\nexport const splitPath = (path: string): Array<string> => path.split(\"/\").slice(1).map(removeApostrophes);\n\n/**\n * Normalizes the mnemonic by removing extra whitespace and making it lowercase\n * @param mnemonic the mnemonic seed phrase\n * @group Implementation\n * @category Serialization\n */\nexport const mnemonicToSeed = (mnemonic: string): Uint8Array => {\n  const normalizedMnemonic = mnemonic\n    .trim()\n    .split(/\\s+/)\n    .map((part) => part.toLowerCase())\n    .join(\" \");\n  return bip39.mnemonicToSeedSync(normalizedMnemonic);\n};\n", "/* eslint-disable max-len */\n\nimport { HexInput, PrivateKeyVariants } from \"../../types\";\nimport { Hex } from \"../hex\";\nimport { PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents a private key used for signing messages and deriving the associated public key.\n * @group Implementation\n * @category Serialization\n */\nexport interface PrivateKey {\n  /**\n   * Sign the given message with the private key to create a signature.\n   * @param message - The message to be signed, provided in HexInput format.\n   * @returns A Signature object representing the signed message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Signature;\n\n  /**\n   * Derive the public key associated with the private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): PublicKey;\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array;\n}\n\nexport class PrivateKey {\n  /**\n   * The AIP-80 compliant prefixes for each private key type. Append this to a private key's hex representation\n   * to get an AIP-80 compliant string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   */\n  public static readonly AIP80_PREFIXES = {\n    [PrivateKeyVariants.Ed25519]: \"ed25519-priv-\",\n    [PrivateKeyVariants.Secp256k1]: \"secp256k1-priv-\",\n  };\n\n  /**\n   * Format a HexInput to an AIP-80 compliant string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param privateKey - The HexString or Uint8Array format of the private key.\n   * @param privateKeyType - The private key type\n   */\n  public static formatPrivateKey(privateKey: HexInput, type: PrivateKeyVariants): string {\n    const aip80Prefix = PrivateKey.AIP80_PREFIXES[type];\n\n    // Remove the prefix if it exists\n    let formattedPrivateKey = privateKey;\n    if (typeof formattedPrivateKey === \"string\" && formattedPrivateKey.startsWith(aip80Prefix)) {\n      // eslint-disable-next-line prefer-destructuring\n      formattedPrivateKey = formattedPrivateKey.split(\"-\")[2];\n    }\n\n    return `${aip80Prefix}${Hex.fromHexInput(formattedPrivateKey).toString()}`;\n  }\n\n  /**\n   * Parse a HexInput that may be a HexString, Uint8Array, or a AIP-80 compliant string to a Hex instance.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param value - A HexString, Uint8Array, or a AIP-80 compliant string.\n   * @param privateKeyType - The private key type\n   * @param strict - If true, the value MUST be compliant with AIP-80.\n   */\n  public static parseHexInput(value: HexInput, type: PrivateKeyVariants, strict?: boolean): Hex {\n    let data: Hex;\n\n    const aip80Prefix = PrivateKey.AIP80_PREFIXES[type];\n    if (typeof value === \"string\") {\n      if (!strict && !value.startsWith(aip80Prefix)) {\n        // HexString input\n        data = Hex.fromHexInput(value);\n        // If the strictness is false, the user has opted into non-AIP-80 compliant private keys.\n        if (strict !== false) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"[Aptos SDK] It is recommended that private keys are AIP-80 compliant (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md). You can fix the private key by formatting it with `PrivateKey.formatPrivateKey(privateKey: string, type: 'ed25519' | 'secp256k1'): string`.\",\n          );\n        }\n      } else if (value.startsWith(aip80Prefix)) {\n        // AIP-80 Compliant String input\n        data = Hex.fromHexString(value.split(\"-\")[2]);\n      } else {\n        if (strict) {\n          // The value does not start with the AIP-80 prefix, and strict is true.\n          throw new Error(\"Invalid HexString input while parsing private key. Must AIP-80 compliant string.\");\n        }\n\n        // This condition should never be reached.\n        throw new Error(\"Invalid HexString input while parsing private key.\");\n      }\n    } else {\n      // The value is an Uint8Array\n      data = Hex.fromHexInput(value);\n    }\n\n    return data;\n  }\n}\n", "import { AptosConfig } from \"../../api\";\nimport { Serializable } from \"../../bcs\";\nimport { HexInput } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Hex } from \"../hex\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents the arguments required to verify a digital signature.\n *\n * @param message - The original message that was signed.\n * @param signature - The signature to be verified against the message.\n * @group Implementation\n * @category Serialization\n */\nexport interface VerifySignatureArgs {\n  message: HexInput;\n  signature: Signature;\n}\n\n/**\n * Represents the arguments required to verify a digital signature asynchronously.\n *\n * The validity of certain types of signatures are dependent on network state.  This is the case for\n * Keyless signatures which need to lookup the verification key and keyless configuration.\n *\n * @param aptosConfig - The Aptos configuration to use\n * @param message - The original message that was signed.\n * @param signature - The signature to be verified against the message.\n * @group Implementation\n * @category Serialization\n */\nexport type VerifySignatureAsyncArgs = VerifySignatureArgs & {\n  aptosConfig: AptosConfig;\n  options?: any;\n};\n\n/**\n * Represents an abstract public key.\n *\n * This class provides a common interface for verifying signatures associated with the public key.\n * It allows for the retrieval of the raw public key bytes and the public key in a hexadecimal string format.\n * @group Implementation\n * @category Serialization\n */\nexport abstract class PublicKey extends Serializable {\n  /**\n   * Verifies that the private key associated with this public key signed the message with the given signature.\n   * @param args.message The message that was signed\n   * @param args.signature The signature to verify\n   * @group Implementation\n   * @category Serialization\n   */\n  abstract verifySignature(args: VerifySignatureArgs): boolean;\n\n  /**\n   * Verifies signature with the public key and makes any network calls required to get state required to verify the signature.\n   * @param args.aptosConfig The Aptos configuration\n   * @param args.message The message that was signed\n   * @param args.signature The signature to verify\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Get the raw public key bytes\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  /**\n   * Get the public key as a hex string with a 0x prefix.\n   *\n   * @returns The public key in hex format.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    const bytes = this.toUint8Array();\n    return Hex.fromHexInput(bytes).toString();\n  }\n}\n\n/**\n * An abstract representation of an account public key.\n *\n * Provides a common interface for deriving an authentication key.\n *\n * @abstract\n * @group Implementation\n * @category Serialization\n */\nexport abstract class AccountPublicKey extends PublicKey {\n  /**\n   * Get the authentication key associated with this public key\n   * @group Implementation\n   * @category Serialization\n   */\n  abstract authKey(): AuthenticationKey;\n}\n", "import { Serializable } from \"../../bcs\";\nimport { Hex } from \"../hex\";\n\n/**\n * An abstract representation of a crypto signature,\n * associated with a specific signature scheme, e.g., Ed25519 or Secp256k1.\n *\n * This class represents the product of signing a message directly from a\n * PrivateKey and can be verified against a CryptoPublicKey.\n * @group Implementation\n * @category Serialization\n */\nexport abstract class Signature extends Serializable {\n  /**\n   * Get the raw signature bytes\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  /**\n   * Get the signature as a hex string with a 0x prefix e.g. 0x123456...\n   * @returns The hex string representation of the signature.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    const bytes = this.toUint8Array();\n    return Hex.fromHexInput(bytes).toString();\n  }\n}\n\n/**\n * An abstract representation of an account signature,\n * associated to a specific authentication scheme e.g. Ed25519 or SingleKey\n *\n * This is the product of signing a message through an account,\n * and can be verified against an AccountPublicKey.\n * @group Implementation\n * @category Serialization\n */\n// export abstract class AccountSignature extends Serializable {\n//   /**\n//    * Get the raw signature bytes\n//    */\n//   abstract toUint8Array(): Uint8Array;\n//\n//   /**\n//    * Get the signature as a hex string with a 0x prefix e.g. 0x123456...\n//    */\n//   toString(): string {\n//     const bytes = this.toUint8Array();\n//     return Hex.fromHexInput(bytes).toString();\n//   }\n// }\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { HDKey } from \"@scure/bip32\";\nimport { Serializable, Deserializer, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport { HexInput, PrivateKeyVariants } from \"../../types\";\nimport { isValidBIP44Path, mnemonicToSeed } from \"./hdKey\";\nimport { PrivateKey } from \"./privateKey\";\nimport { PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { convertSigningMessage } from \"./utils\";\nimport { AptosConfig } from \"../../api\";\n\n/**\n * Represents a Secp256k1 ECDSA public key.\n *\n * @extends PublicKey\n * @property LENGTH - The length of the Secp256k1 public key in bytes.\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256k1PublicKey extends PublicKey {\n  // Secp256k1 ecdsa public keys contain a prefix indicating compression and two 32-byte coordinates.\n  static readonly LENGTH: number = 65;\n\n  // If it's compressed, it is only 33 bytes\n  static readonly COMPRESSED_LENGTH: number = 33;\n\n  // Hex value of the public key\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a HexInput, which can be a string or Uint8Array.\n   * This constructor validates the length of the provided signature data.\n   *\n   * @param hexInput - A HexInput (string or Uint8Array) representing the signature data.\n   * @throws Error if the length of the signature data is not equal to Secp256k1Signature.LENGTH.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    const { length } = hex.toUint8Array();\n    if (length === Secp256k1PublicKey.LENGTH) {\n      this.key = hex;\n    } else if (length === Secp256k1PublicKey.COMPRESSED_LENGTH) {\n      const point = secp256k1.ProjectivePoint.fromHex(hex.toUint8Array());\n      this.key = Hex.fromHexInput(point.toRawBytes(false));\n    } else {\n      throw new Error(\n        `PublicKey length should be ${Secp256k1PublicKey.LENGTH} or ${Secp256k1PublicKey.COMPRESSED_LENGTH}, received ${length}`,\n      );\n    }\n  }\n\n  // region PublicKey\n  /**\n   * Verifies a Secp256k1 signature against the public key.\n   *\n   * This function checks the validity of a signature for a given message, ensuring that the signature is canonical as a malleability check.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: Secp256k1Signature }): boolean {\n    const { message, signature } = args;\n    const messageToVerify = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToVerify).toUint8Array();\n    const messageSha3Bytes = sha3_256(messageBytes);\n    const signatureBytes = signature.toUint8Array();\n    return secp256k1.verify(signatureBytes, messageSha3Bytes, this.key.toUint8Array(), { lowS: true });\n  }\n\n  /**\n   * Note: Secp256k1Signatures can be verified syncronously.\n   *\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of Secp256k1Signature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Secp256k1Signature;\n  }): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Get the data as a Uint8Array representation.\n   *\n   * @returns Uint8Array representation of the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This function is essential for converting data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to convert the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  /**\n   * Deserializes a Secp256k1Signature from the provided deserializer.\n   * This function allows you to reconstruct a Secp256k1Signature object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  // eslint-disable-next-line class-methods-use-this\n  deserialize(deserializer: Deserializer) {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256k1Signature(hex);\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  // endregion\n\n  /**\n   * Determine if the provided public key is an instance of Secp256k1PublicKey.\n   *\n   * @deprecated use `instanceof Secp256k1PublicKey` instead\n   * @param publicKey - The public key to check.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is Secp256k1PublicKey {\n    return publicKey instanceof Secp256k1PublicKey;\n  }\n\n  /**\n   * Determines if the provided public key is a valid instance of a Secp256k1 public key.\n   * This function checks for the presence of a \"key\" property and validates the length of the key data.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid Secp256k1 public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is Secp256k1PublicKey {\n    return \"key\" in publicKey && (publicKey.key as any)?.data?.length === Secp256k1PublicKey.LENGTH;\n  }\n}\n\n/**\n * Represents a Secp256k1 ECDSA private key, providing functionality to create, sign messages,\n * derive public keys, and serialize/deserialize the key.\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256k1PrivateKey extends Serializable implements PrivateKey {\n  /**\n   * Length of Secp256k1 ecdsa private key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The private key bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly key: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   * @param strict If true, private key must AIP-80 compliant.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput, strict?: boolean) {\n    super();\n\n    const privateKeyHex = PrivateKey.parseHexInput(hexInput, PrivateKeyVariants.Secp256k1, strict);\n    if (privateKeyHex.toUint8Array().length !== Secp256k1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Secp256k1PrivateKey.LENGTH}`);\n    }\n\n    this.key = privateKeyHex;\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Secp256k1PrivateKey - A newly generated Secp256k1 private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static generate(): Secp256k1PrivateKey {\n    const hexInput = secp256k1.utils.randomPrivateKey();\n    return new Secp256k1PrivateKey(hexInput, false);\n  }\n\n  /**\n   * Derives a private key from a mnemonic seed phrase using a specified BIP44 path.\n   *\n   * @param path - The BIP44 path to derive the key from.\n   * @param mnemonics - The mnemonic seed phrase used for key generation.\n   *\n   * @returns The generated private key.\n   *\n   * @throws Error if the provided path is not a valid BIP44 path.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromDerivationPath(path: string, mnemonics: string): Secp256k1PrivateKey {\n    if (!isValidBIP44Path(path)) {\n      throw new Error(`Invalid derivation path ${path}`);\n    }\n    return Secp256k1PrivateKey.fromDerivationPathInner(path, mnemonicToSeed(mnemonics));\n  }\n\n  /**\n   * Derives a private key from a specified BIP44 path using a given seed.\n   * This function is essential for generating keys that follow the hierarchical deterministic (HD) wallet structure.\n   *\n   * @param path - The BIP44 path used for key derivation.\n   * @param seed - The seed phrase created by the mnemonics, represented as a Uint8Array.\n   * @returns The generated private key as an instance of Secp256k1PrivateKey.\n   * @throws Error if the derived private key is invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  private static fromDerivationPathInner(path: string, seed: Uint8Array): Secp256k1PrivateKey {\n    const { privateKey } = HDKey.fromMasterSeed(seed).derive(path);\n    // library returns privateKey as Uint8Array | null\n    if (privateKey === null) {\n      throw new Error(\"Invalid key\");\n    }\n\n    return new Secp256k1PrivateKey(privateKey, false);\n  }\n\n  // endregion\n\n  // region PrivateKey\n\n  /**\n   * Sign the given message with the private key.\n   * This function generates a cryptographic signature for the provided message, ensuring the signature is canonical and non-malleable.\n   *\n   * @param message - A message in HexInput format to be signed.\n   * @returns Signature - The generated signature for the provided message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Secp256k1Signature {\n    const messageToSign = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToSign);\n    const messageHashBytes = sha3_256(messageBytes.toUint8Array());\n    const signature = secp256k1.sign(messageHashBytes, this.key.toUint8Array(), { lowS: true });\n    return new Secp256k1Signature(signature.toCompactRawBytes());\n  }\n\n  /**\n   * Derive the Secp256k1PublicKey from this private key.\n   *\n   * @returns Secp256k1PublicKey The derived public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): Secp256k1PublicKey {\n    const bytes = secp256k1.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a string representation.\n   *\n   * @returns string representation of the private key\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return this.toAIP80String();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   */\n  toHexString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Get the private key as a AIP-80 compliant hex string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @returns AIP-80 compliant string representation of the private key.\n   */\n  toAIP80String(): string {\n    return PrivateKey.formatPrivateKey(this.key.toString(), PrivateKeyVariants.Secp256k1);\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PrivateKey(bytes, false);\n  }\n\n  // endregion\n\n  /**\n   * Determines if the provided private key is an instance of Secp256k1PrivateKey.\n   *\n   * @param privateKey - The private key to be checked.\n   *\n   * @deprecated use `instanceof Secp256k1PrivateKey` instead\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPrivateKey(privateKey: PrivateKey): privateKey is Secp256k1PrivateKey {\n    return privateKey instanceof Secp256k1PrivateKey;\n  }\n}\n\n/**\n * Represents a signature of a message signed using a Secp256k1 ECDSA private key.\n *\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256k1Signature extends Signature {\n  /**\n   * Secp256k1 ecdsa signatures are 256-bit.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly data: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new Signature instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n    const data = Hex.fromHexInput(hexInput);\n    if (data.toUint8Array().length !== Secp256k1Signature.LENGTH) {\n      throw new Error(\n        `Signature length should be ${Secp256k1Signature.LENGTH}, received ${data.toUint8Array().length}`,\n      );\n    }\n    this.data = data;\n  }\n\n  // endregion\n\n  // region Signature\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1Signature {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256k1Signature(hex);\n  }\n\n  // endregion\n}\n", "/**\n * The AsyncQueue class is an async-aware data structure that provides a queue-like\n * behavior for managing asynchronous tasks or operations.\n * It allows to enqueue items and dequeue them asynchronously.\n * This is not thread-safe, but it is async concurrency safe, and\n * it does not guarantee ordering for those that call into and await on enqueue.\n * @group Implementation\n * @category Transactions\n */\n\ninterface PendingDequeue<T> {\n  resolve: (value: T) => void;\n  reject: (reason?: AsyncQueueCancelledError) => void;\n}\n\nexport class AsyncQueue<T> {\n  readonly queue: T[] = [];\n\n  // The pendingDequeue is used to handle the resolution of promises when items are enqueued and dequeued.\n  private pendingDequeue: PendingDequeue<T>[] = [];\n\n  private cancelled: boolean = false;\n\n  /**\n   * Adds an item to the queue. If there are pending dequeued promises, it resolves the oldest promise with the enqueued item\n   * immediately; otherwise, it adds the item to the queue.\n   *\n   * @param item - The item to be added to the queue.\n   * @group Implementation\n   * @category Transactions\n   */\n  enqueue(item: T): void {\n    this.cancelled = false;\n\n    if (this.pendingDequeue.length > 0) {\n      const promise = this.pendingDequeue.shift();\n\n      promise?.resolve(item);\n\n      return;\n    }\n\n    this.queue.push(item);\n  }\n\n  /**\n   * Dequeues the next item from the queue and returns a promise that resolves to it.\n   * If the queue is empty, it creates a new promise that will be resolved when an item is enqueued.\n   *\n   * @returns Promise<T>\n   * @group Implementation\n   * @category Transactions\n   */\n  async dequeue(): Promise<T> {\n    if (this.queue.length > 0) {\n      return Promise.resolve(this.queue.shift()!);\n    }\n\n    return new Promise<T>((resolve, reject) => {\n      this.pendingDequeue.push({ resolve, reject });\n    });\n  }\n\n  /**\n   * Determine whether the queue is empty.\n   *\n   * @returns boolean - Returns true if the queue has no elements, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isEmpty(): boolean {\n    return this.queue.length === 0;\n  }\n\n  /**\n   * Cancels all pending promises in the queue and rejects them with an AsyncQueueCancelledError.\n   * This ensures that any awaiting code can handle the cancellation appropriately.\n   *\n   * @returns {void}\n   * @group Implementation\n   * @category Transactions\n   */\n  cancel(): void {\n    this.cancelled = true;\n\n    this.pendingDequeue.forEach(async ({ reject }) => {\n      reject(new AsyncQueueCancelledError(\"Task cancelled\"));\n    });\n\n    this.pendingDequeue = [];\n\n    this.queue.length = 0;\n  }\n\n  /**\n   * Determine whether the queue has been cancelled.\n   *\n   * @returns boolean - Returns true if the queue is cancelled, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isCancelled(): boolean {\n    return this.cancelled;\n  }\n\n  /**\n   * Retrieve the length of the pending dequeue.\n   *\n   * @returns number - The number of items currently in the pending dequeue.\n   * @group Implementation\n   * @category Transactions\n   */\n  pendingDequeueLength(): number {\n    return this.pendingDequeue.length;\n  }\n}\n\n/**\n * Represents an error that occurs when an asynchronous queue operation is cancelled.\n * This error extends the built-in Error class to provide additional context for cancellation events.\n *\n * @extends Error\n * @group Implementation\n * @category Transactions\n */\nexport class AsyncQueueCancelledError extends Error {}\n", "/* eslint-disable no-bitwise */\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from \"poseidon-lite\";\n\nconst numInputsToPoseidonFunc = [\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n];\n\nconst BYTES_PACKED_PER_SCALAR = 31;\nconst MAX_NUM_INPUT_SCALARS = 16;\nconst MAX_NUM_INPUT_BYTES = (MAX_NUM_INPUT_SCALARS - 1) * BYTES_PACKED_PER_SCALAR;\n\n/**\n * Hashes a string to a field element via Poseidon hashing.\n * This function is useful for converting a string into a fixed-size hash that can be used in cryptographic applications.\n *\n * @param str - The string to be hashed.\n * @param maxSizeBytes - The maximum size in bytes for the resulting hash.\n * @returns bigint - The result of the hash.\n * @group Implementation\n * @category Serialization\n */\nexport function hashStrToField(str: string, maxSizeBytes: number): bigint {\n  const textEncoder = new TextEncoder();\n  const strBytes = textEncoder.encode(str);\n  return hashBytesWithLen(strBytes, maxSizeBytes);\n}\n\n/**\n * Computes a Poseidon hash of the provided byte array, ensuring that the byte array does not exceed the specified maximum size.\n * This function is useful for generating a hash from a byte array while enforcing size constraints.\n *\n * @param bytes - The byte array to be hashed.\n * @param maxSizeBytes - The maximum allowed size for the byte array.\n * @throws Error if the length of the inputted bytes exceeds the specified maximum size.\n * @group Implementation\n * @category Serialization\n */\nfunction hashBytesWithLen(bytes: Uint8Array, maxSizeBytes: number): bigint {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Inputted bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  const packed = padAndPackBytesWithLen(bytes, maxSizeBytes);\n  return poseidonHash(packed);\n}\n\n/**\n * Pads the input byte array with zeros to a specified maximum size and then packs the bytes.\n * This function ensures that the byte array does not exceed the specified maximum size, throwing an error if it does.\n *\n * @param bytes - The byte array to be padded and packed.\n * @param maxSizeBytes - The maximum size in bytes that the input array can have.\n * @throws Error if the input byte array exceeds the specified maximum size.\n * @group Implementation\n * @category Serialization\n */\nfunction padAndPackBytesNoLen(bytes: Uint8Array, maxSizeBytes: number): bigint[] {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Input bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  const paddedStrBytes = padUint8ArrayWithZeros(bytes, maxSizeBytes);\n  return packBytes(paddedStrBytes);\n}\n\n/**\n * Pads and packs the given byte array to a specified maximum size and appends its length.\n * This function ensures that the byte array does not exceed the maximum size, throwing an error if it does.\n * It is useful for preparing byte data for further processing or transmission by ensuring a consistent format.\n *\n * @param bytes - The byte array to be padded and packed.\n * @param maxSizeBytes - The maximum allowed size for the byte array.\n * @throws Error if the length of the input bytes exceeds the maximum size.\n * @returns A new Uint8Array that contains the padded and packed bytes along with the length of the original byte array.\n * @group Implementation\n * @category Serialization\n */\nexport function padAndPackBytesWithLen(bytes: Uint8Array, maxSizeBytes: number): bigint[] {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Input bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  return padAndPackBytesNoLen(bytes, maxSizeBytes).concat([BigInt(bytes.length)]);\n}\n\n/**\n * Packs a Uint8Array into an array of BigInts, ensuring the input does not exceed the maximum allowed bytes.\n * @param bytes - The Uint8Array to be packed.\n * @throws {Error} Throws an error if the input exceeds the maximum number of bytes allowed.\n * @group Implementation\n * @category Serialization\n */\nfunction packBytes(bytes: Uint8Array): bigint[] {\n  if (bytes.length > MAX_NUM_INPUT_BYTES) {\n    throw new Error(`Can't pack more than ${MAX_NUM_INPUT_BYTES}.  Was given ${bytes.length} bytes`);\n  }\n  return chunkUint8Array(bytes, BYTES_PACKED_PER_SCALAR).map((chunk) => bytesToBigIntLE(chunk));\n}\n\n/**\n * Splits a Uint8Array into smaller chunks of the specified size.\n * This function is useful for processing large arrays in manageable segments.\n *\n * @param array - The Uint8Array to be split into chunks.\n * @param chunkSize - The size of each chunk.\n * @returns An array of Uint8Array chunks.\n * @group Implementation\n * @category Serialization\n */\nfunction chunkUint8Array(array: Uint8Array, chunkSize: number): Uint8Array[] {\n  const result: Uint8Array[] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.subarray(i, i + chunkSize));\n  }\n  return result;\n}\n\n/**\n * Converts a little-endian byte array into a BigInt.\n * This function is useful for interpreting byte data as a numerical value in a way that respects the little-endian format.\n *\n * @param bytes - The byte array to convert.\n * @returns The resulting BigInt representation of the byte array.\n * @group Implementation\n * @category Serialization\n */\nexport function bytesToBigIntLE(bytes: Uint8Array): bigint {\n  let result = BigInt(0);\n  for (let i = bytes.length - 1; i >= 0; i -= 1) {\n    result = (result << BigInt(8)) | BigInt(bytes[i]);\n  }\n  return result;\n}\n\n/**\n * Converts a bigint value into a little-endian byte array of a specified length.\n * This function is useful for representing large integers in a byte format, which is often required for cryptographic operations\n * or binary data manipulation.\n *\n * @param value - The number to convert into bytes.\n * @param length - The desired length of the resulting byte array.\n * @returns A Uint8Array containing the little-endian representation of the bigint value.\n * @group Implementation\n * @category Serialization\n */\nexport function bigIntToBytesLE(value: bigint | number, length: number): Uint8Array {\n  let val = BigInt(value);\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; i += 1) {\n    bytes[i] = Number(val & BigInt(0xff));\n    val >>= BigInt(8);\n  }\n  return bytes;\n}\n\n/**\n * Pads the input Uint8Array with zeros to achieve the specified size.\n * This function is useful for ensuring that a byte array meets a required length for further processing.\n *\n * @param inputArray - The Uint8Array to be padded.\n * @param paddedSize - The desired size of the padded array, which must be greater than or equal to the input array size.\n * @throws Error if paddedSize is less than the length of inputArray.\n * @group Implementation\n * @category Serialization\n */\nfunction padUint8ArrayWithZeros(inputArray: Uint8Array, paddedSize: number): Uint8Array {\n  if (paddedSize < inputArray.length) {\n    throw new Error(\"Padded size must be greater than or equal to the input array size.\");\n  }\n\n  // Create a new Uint8Array with the padded size\n  const paddedArray = new Uint8Array(paddedSize);\n\n  // Copy the content of the input array to the new array\n  paddedArray.set(inputArray);\n\n  // Fill the remaining space with zeros\n  for (let i = inputArray.length; i < paddedSize; i += 1) {\n    paddedArray[i] = 0;\n  }\n\n  return paddedArray;\n}\n\n/**\n * Hashes up to 16 scalar elements via the Poseidon hashing algorithm.\n * Each element must be scalar fields of the BN254 elliptic curve group.\n *\n * @param inputs - An array of elements to be hashed, which can be of type number, bigint, or string.\n * @returns bigint - The result of the hash.\n * @throws Error - Throws an error if the input length exceeds the maximum allowed.\n * @group Implementation\n * @category Serialization\n */\nexport function poseidonHash(inputs: (number | bigint | string)[]): bigint {\n  if (inputs.length > numInputsToPoseidonFunc.length) {\n    throw new Error(\n      `Unable to hash input of length ${inputs.length}.  Max input length is ${numInputsToPoseidonFunc.length}`,\n    );\n  }\n  return numInputsToPoseidonFunc[inputs.length - 1](inputs);\n}\n", "import { Serializable } from \"../../bcs\";\n\n/**\n * An abstract representation of a cryptographic proof associated with specific\n * zero-knowledge proof schemes, such as Groth16 and PLONK.\n * @group Implementation\n * @category Serialization\n */\nexport abstract class Proof extends Serializable {}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"./accountAddress\";\nimport type { AccountPublicKey } from \"./crypto\";\nimport { Hex } from \"./hex\";\nimport { AuthenticationKeyScheme, HexInput } from \"../types\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\n\n/**\n * Represents an authentication key used for account management. Each account stores an authentication key that enables account\n * owners to rotate their private key(s) without changing the address that hosts their account. The authentication key is a\n * SHA3-256 hash of data and is always 32 bytes in length.\n *\n * @see {@link https://aptos.dev/concepts/accounts | Account Basics}\n *\n * Account addresses can be derived from the AuthenticationKey.\n * @group Implementation\n * @category Serialization\n */\nexport class AuthenticationKey extends Serializable {\n  /**\n   * An authentication key is always a SHA3-256 hash of data, and is always 32 bytes.\n   *\n   * The data to hash depends on the underlying public key type and the derivation scheme.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The raw bytes of the authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly data: Hex;\n\n  /**\n   * Creates an instance of the AuthenticationKey using the provided hex input.\n   * This ensures that the hex input is valid and conforms to the required length for an Authentication Key.\n   *\n   * @param args - The arguments for constructing the AuthenticationKey.\n   * @param args.data - The hex input data to be used for the Authentication Key.\n   * @throws {Error} Throws an error if the length of the provided hex input is not equal to the required Authentication Key\n   * length.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { data: HexInput }) {\n    super();\n    const { data } = args;\n    const hex = Hex.fromHexInput(data);\n    if (hex.toUint8Array().length !== AuthenticationKey.LENGTH) {\n      throw new Error(`Authentication Key length should be ${AuthenticationKey.LENGTH}`);\n    }\n    this.data = hex;\n  }\n\n  /**\n   * Serializes the fixed bytes data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data.toUint8Array());\n  }\n\n  /**\n   * Deserialize an AuthenticationKey from the byte buffer in a Deserializer instance.\n   * @param deserializer - The deserializer to deserialize the AuthenticationKey from.\n   * @returns An instance of AuthenticationKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): AuthenticationKey {\n    const bytes = deserializer.deserializeFixedBytes(AuthenticationKey.LENGTH);\n    return new AuthenticationKey({ data: bytes });\n  }\n\n  /**\n   * Convert the internal data representation to a Uint8Array.\n   *\n   * This function is useful for obtaining a byte representation of the data, which can be utilized for serialization or transmission.\n   *\n   * @returns Uint8Array representation of the internal data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Generates an AuthenticationKey from the specified scheme and input bytes.\n   * This function is essential for creating a valid authentication key based on a given scheme.\n   *\n   * @param args - The arguments for generating the AuthenticationKey.\n   * @param args.scheme - The authentication key scheme to use.\n   * @param args.input - The input data in hexadecimal format to derive the key.\n   * @returns An instance of AuthenticationKey containing the generated key data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromSchemeAndBytes(args: { scheme: AuthenticationKeyScheme; input: HexInput }): AuthenticationKey {\n    const { scheme, input } = args;\n    const inputBytes = Hex.fromHexInput(input).toUint8Array();\n    const hashInput = new Uint8Array([...inputBytes, scheme]);\n    const hash = sha3Hash.create();\n    hash.update(hashInput);\n    const hashDigest = hash.digest();\n    return new AuthenticationKey({ data: hashDigest });\n  }\n\n  /**\n   * Derives an AuthenticationKey from the provided public key using a specified derivation scheme.\n   *\n   * @deprecated Use `fromPublicKey` instead.\n   * @param args - The arguments for deriving the authentication key.\n   * @param args.publicKey - The public key used for the derivation.\n   * @param args.scheme - The scheme to use for deriving the authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public static fromPublicKeyAndScheme(args: { publicKey: AccountPublicKey; scheme: AuthenticationKeyScheme }) {\n    const { publicKey } = args;\n    return publicKey.authKey();\n  }\n\n  /**\n   * Converts a PublicKey to an AuthenticationKey using the derivation scheme inferred from the provided PublicKey instance.\n   *\n   * @param args - The arguments for the function.\n   * @param args.publicKey - The PublicKey to be converted.\n   * @returns AuthenticationKey - The derived AuthenticationKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromPublicKey(args: { publicKey: AccountPublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n    return publicKey.authKey();\n  }\n\n  /**\n   * Derives an account address from an AuthenticationKey by translating the AuthenticationKey bytes directly to an AccountAddress.\n   *\n   * @returns AccountAddress - The derived account address.\n   * @group Implementation\n   * @category Serialization\n   */\n  derivedAddress(): AccountAddress {\n    return new AccountAddress(this.data.toUint8Array());\n  }\n}\n", "import { Deserializer, Serializer } from \"../../bcs\";\nimport { HexInput } from \"../../types\";\nimport { AccountAddress } from \"../accountAddress\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Hex } from \"../hex\";\nimport { AccountPublicKey, VerifySignatureArgs, VerifySignatureAsyncArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\n\nexport class AbstractSignature extends Signature {\n  readonly value: Uint8Array;\n\n  constructor(value: HexInput) {\n    super();\n    this.value = Hex.fromHexInput(value).toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  static deserialize(deserializer: Deserializer): AbstractSignature {\n    return new AbstractSignature(deserializer.deserializeBytes());\n  }\n}\n\nexport class AbstractPublicKey extends AccountPublicKey {\n  readonly accountAddress: AccountAddress;\n\n  constructor(accountAddress: AccountAddress) {\n    super();\n    this.accountAddress = accountAddress;\n  }\n\n  authKey(): AuthenticationKey {\n    return new AuthenticationKey({ data: this.accountAddress.toUint8Array() });\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  verifySignature(args: VerifySignatureArgs): boolean {\n    throw new Error(\"This function is not implemented for AbstractPublicKey.\");\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  async verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean> {\n    throw new Error(\"This function is not implemented for AbstractPublicKey.\");\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  serialize(serializer: Serializer): void {\n    throw new Error(\"This function is not implemented for AbstractPublicKey.\");\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ed25519 } from \"@noble/curves/ed25519\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Hex } from \"../hex\";\nimport { HexInput, SigningScheme as AuthenticationKeyScheme, PrivateKeyVariants } from \"../../types\";\nimport { CKDPriv, deriveKey, HARDENED_OFFSET, isValidHardenedPath, mnemonicToSeed, splitPath } from \"./hdKey\";\nimport { PrivateKey } from \"./privateKey\";\nimport { AccountPublicKey, PublicKey, VerifySignatureArgs, VerifySignatureAsyncArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { convertSigningMessage } from \"./utils\";\n\n/**\n * L is the value that greater than or equal to will produce a non-canonical signature, and must be rejected\n * @group Implementation\n * @category Serialization\n */\nconst L: number[] = [\n  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n];\n\n/**\n * Checks if an ED25519 signature is non-canonical.\n * This function helps determine the validity of a signature by verifying its canonical form.\n *\n * @param signature - The signature to be checked for canonicality.\n * @returns A boolean indicating whether the signature is non-canonical.\n *\n * Comes from Aptos Core\n * https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-crypto/src/ed25519/ed25519_sigs.rs#L47-L85\n * @group Implementation\n * @category Serialization\n */\nexport function isCanonicalEd25519Signature(signature: Signature): boolean {\n  const s = signature.toUint8Array().slice(32);\n  for (let i = L.length - 1; i >= 0; i -= 1) {\n    if (s[i] < L[i]) {\n      return true;\n    }\n    if (s[i] > L[i]) {\n      return false;\n    }\n  }\n  // As this stage S == L which implies a non-canonical S.\n  return false;\n}\n\n/**\n * Represents the public key of an Ed25519 key pair.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Ed25519 scheme is represented in the SDK as `Legacy authentication key` and also\n * as `AnyPublicKey` that represents any `Unified authentication key`.\n * @group Implementation\n * @category Serialization\n */\nexport class Ed25519PublicKey extends AccountPublicKey {\n  /**\n   * Length of an Ed25519 public key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * Bytes of the public key\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly key: Hex;\n\n  /**\n   * Creates an instance of the Ed25519Signature class from a hex input.\n   * This constructor validates the length of the signature to ensure it meets the required specifications.\n   *\n   * @param hexInput - The hex input representing the Ed25519 signature.\n   * @throws Error if the signature length is not equal to Ed25519Signature.LENGTH.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Ed25519PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Ed25519PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies a signed message using a public key.\n   *\n   * @param args - The arguments for verification.\n   * @param args.message - A signed message as a Hex string or Uint8Array.\n   * @param args.signature - The signature of the message.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: VerifySignatureArgs): boolean {\n    const { message, signature } = args;\n    // Verify malleability\n    if (!isCanonicalEd25519Signature(signature)) {\n      return false;\n    }\n\n    const messageToVerify = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToVerify).toUint8Array();\n    const signatureBytes = signature.toUint8Array();\n    const publicKeyBytes = this.key.toUint8Array();\n    return ed25519.verify(signatureBytes, messageBytes, publicKeyBytes);\n  }\n\n  /**\n   * Note: Ed25519Signatures can be verified syncronously.\n   *\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of Secp256k1Signature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Generates an authentication key from the public key using the Ed25519 scheme.\n   * This function is essential for creating a secure authentication key that can be used for further cryptographic operations.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.Ed25519,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Convert the internal data representation to a Uint8Array.\n   *\n   * @returns Uint8Array representation of the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This allows for the conversion of data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  /**\n   * Deserialize bytes into an Ed25519Signature object.\n   * This function is used to convert serialized byte data into a usable Ed25519Signature instance.\n   *\n   * @param deserializer - The deserializer instance used to read the byte data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): Ed25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(bytes);\n  }\n\n  // endregion\n\n  /**\n   * Determine if the provided public key is an instance of Ed25519PublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @returns True if the public key is an instance of Ed25519PublicKey, otherwise false.\n   * @deprecated use `instanceof Ed25519PublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is Ed25519PublicKey {\n    return publicKey instanceof Ed25519PublicKey;\n  }\n\n  /**\n   * Determines if the provided public key is a valid Ed25519 public key.\n   * This function checks for the presence of the \"key\" property and verifies that its data length matches the expected length\n   * for Ed25519 public keys.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid Ed25519 public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is Ed25519PublicKey {\n    return \"key\" in publicKey && (publicKey.key as any)?.data?.length === Ed25519PublicKey.LENGTH;\n  }\n}\n\n/**\n * Represents the private key of an Ed25519 key pair.\n * @group Implementation\n * @category Serialization\n */\nexport class Ed25519PrivateKey extends Serializable implements PrivateKey {\n  /**\n   * Length of an Ed25519 private key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The Ed25519 key seed to use for BIP-32 compatibility\n   * See more {@link https://github.com/satoshilabs/slips/blob/master/slip-0010.md}\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly SLIP_0010_SEED = \"ed25519 seed\";\n\n  /**\n   * The Ed25519 signing key\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly signingKey: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param hexInput HexInput (string or Uint8Array)\n   * @param strict If true, private key must AIP-80 compliant.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput, strict?: boolean) {\n    super();\n\n    const privateKeyHex = PrivateKey.parseHexInput(hexInput, PrivateKeyVariants.Ed25519, strict);\n    if (privateKeyHex.toUint8Array().length !== Ed25519PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Ed25519PrivateKey.LENGTH}`);\n    }\n\n    // Create keyPair from Private key in Uint8Array format\n    this.signingKey = privateKeyHex;\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Ed25519PrivateKey A newly generated Ed25519 private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static generate(): Ed25519PrivateKey {\n    const keyPair = ed25519.utils.randomPrivateKey();\n    return new Ed25519PrivateKey(keyPair, false);\n  }\n\n  /**\n   * Derives a private key from a mnemonic seed phrase using a specified BIP44 path.\n   * To derive multiple keys from the same phrase, change the path\n   *\n   * IMPORTANT: Ed25519 supports hardened derivation only, as it lacks a key homomorphism, making non-hardened derivation impossible.\n   *\n   * @param path - The BIP44 path used for key derivation.\n   * @param mnemonics - The mnemonic seed phrase from which the key will be derived.\n   * @throws Error if the provided path is not a valid hardened path.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromDerivationPath(path: string, mnemonics: string): Ed25519PrivateKey {\n    if (!isValidHardenedPath(path)) {\n      throw new Error(`Invalid derivation path ${path}`);\n    }\n    return Ed25519PrivateKey.fromDerivationPathInner(path, mnemonicToSeed(mnemonics));\n  }\n\n  /**\n   * Derives a child private key from a given BIP44 path and seed.\n   * A private inner function so we can separate from the main fromDerivationPath() method\n   * to add tests to verify we create the keys correctly.\n   *\n   * @param path - The BIP44 path used for key derivation.\n   * @param seed - The seed phrase created by the mnemonics, represented as a Uint8Array.\n   * @param offset - The offset used for key derivation, defaults to HARDENED_OFFSET.\n   * @returns An instance of Ed25519PrivateKey derived from the specified path and seed.\n   * @group Implementation\n   * @category Serialization\n   */\n  private static fromDerivationPathInner(path: string, seed: Uint8Array, offset = HARDENED_OFFSET): Ed25519PrivateKey {\n    const { key, chainCode } = deriveKey(Ed25519PrivateKey.SLIP_0010_SEED, seed);\n\n    const segments = splitPath(path).map((el) => parseInt(el, 10));\n\n    // Derive the child key based on the path\n    const { key: privateKey } = segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n      key,\n      chainCode,\n    });\n    return new Ed25519PrivateKey(privateKey, false);\n  }\n\n  // endregion\n\n  // region PrivateKey\n\n  /**\n   * Derive the Ed25519PublicKey for this private key.\n   *\n   * @returns Ed25519PublicKey - The derived public key corresponding to the private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): Ed25519PublicKey {\n    const bytes = ed25519.getPublicKey(this.signingKey.toUint8Array());\n    return new Ed25519PublicKey(bytes);\n  }\n\n  /**\n   * Sign the given message with the private key.\n   * This function generates a digital signature for the specified message, ensuring its authenticity and integrity.\n   *\n   * @param message - A message as a string or Uint8Array in HexInput format.\n   * @returns A digital signature for the provided message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Ed25519Signature {\n    const messageToSign = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToSign).toUint8Array();\n    const signatureBytes = ed25519.sign(messageBytes, this.signingKey.toUint8Array());\n    return new Ed25519Signature(signatureBytes);\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the private key\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.signingKey.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return this.toAIP80String();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   */\n  toHexString(): string {\n    return this.signingKey.toString();\n  }\n\n  /**\n   * Get the private key as a AIP-80 compliant hex string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @returns AIP-80 compliant string representation of the private key.\n   */\n  toAIP80String(): string {\n    return PrivateKey.formatPrivateKey(this.signingKey.toString(), PrivateKeyVariants.Ed25519);\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PrivateKey(bytes, false);\n  }\n\n  // endregion\n\n  /**\n   * Determines if the provided private key is an instance of Ed25519PrivateKey.\n   *\n   * @param privateKey - The private key to check.\n   * @returns A boolean indicating whether the private key is an Ed25519PrivateKey.\n   *\n   * @deprecated Use `instanceof Ed25519PrivateKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPrivateKey(privateKey: PrivateKey): privateKey is Ed25519PrivateKey {\n    return privateKey instanceof Ed25519PrivateKey;\n  }\n}\n\n/**\n * Represents a signature of a message signed using an Ed25519 private key.\n * @group Implementation\n * @category Serialization\n */\nexport class Ed25519Signature extends Signature {\n  /**\n   * Length of an Ed25519 signature, which is 64 bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly data: Hex;\n\n  // region Constructors\n\n  constructor(hexInput: HexInput) {\n    super();\n    const data = Hex.fromHexInput(hexInput);\n    if (data.toUint8Array().length !== Ed25519Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Ed25519Signature.LENGTH}`);\n    }\n    this.data = data;\n  }\n\n  // endregion\n\n  // region Signature\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519Signature(bytes);\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-bitwise */\nimport { MAX_U32_NUMBER } from \"./consts\";\nimport { Uint8, Uint16, Uint32, Uint64, Uint128, Uint256, HexInput } from \"../types\";\nimport { Hex } from \"../core/hex\";\n\n/**\n * This interface exists to define Deserializable<T> inputs for functions that\n * deserialize a byte buffer into a type T.\n * It is not intended to be implemented or extended, because Typescript has no support\n * for static methods in interfaces.\n *\n * @template T - The type that this will deserialize into.\n * @group Implementation\n * @category BCS\n */\nexport interface Deserializable<T> {\n  /**\n   * Deserializes the buffered bytes into an instance of the specified class type.\n   * This function provides an alternative syntax for deserialization, allowing users to call\n   * `deserializer.deserialize(MyClass)` instead of `MyClass.deserialize(deserializer)`.\n   *\n   * @param deserializer - The deserializer instance with the buffered bytes.\n   * @returns The deserialized value of class type T.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));\n   * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function\n   * // value is now an instance of MyClass\n   * // equivalent to `const value = MyClass.deserialize(deserializer)`\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  deserialize(deserializer: Deserializer): T;\n}\n\n/**\n * A class that provides methods for deserializing various data types from a byte buffer.\n * It supports deserialization of primitive types, strings, and complex objects using a BCS (Binary Common Serialization) layout.\n * @group Implementation\n * @category BCS\n */\nexport class Deserializer {\n  private buffer: ArrayBuffer;\n\n  private offset: number;\n\n  /**\n   * Creates a new instance of the class with a copy of the provided data buffer.\n   * This prevents outside mutation of the buffer.\n   *\n   * @param data - The data to be copied into the internal buffer as a Uint8Array.\n   * @group Implementation\n   * @category BCS\n   */\n  constructor(data: Uint8Array) {\n    // copies data to prevent outside mutation of buffer.\n    this.buffer = new ArrayBuffer(data.length);\n    new Uint8Array(this.buffer).set(data, 0);\n    this.offset = 0;\n  }\n\n  static fromHex(hex: HexInput): Deserializer {\n    const data = Hex.hexInputToUint8Array(hex);\n    return new Deserializer(data);\n  }\n\n  /**\n   * Reads a specified number of bytes from the buffer and advances the offset.\n   *\n   * @param length - The number of bytes to read from the buffer.\n   * @throws Throws an error if the read operation exceeds the buffer's length.\n   * @group Implementation\n   * @category BCS\n   */\n  private read(length: number): ArrayBuffer {\n    if (this.offset + length > this.buffer.byteLength) {\n      throw new Error(\"Reached to the end of buffer\");\n    }\n\n    const bytes = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n\n  /**\n   * Returns the number of bytes remaining in the buffer.\n   *\n   * This information is useful to determine if there's more data to be read.\n   *\n   * @returns The number of bytes remaining in the buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  remaining(): number {\n    return this.buffer.byteLength - this.offset;\n  }\n\n  /**\n   * Asserts that the buffer has no remaining bytes.\n   *\n   * @throws {Error} Throws an error if there are remaining bytes in the buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  assertFinished(): void {\n    if (this.remaining() !== 0) {\n      throw new Error(\"Buffer has remaining bytes\");\n    }\n  }\n\n  /**\n   * Deserializes a UTF-8 encoded string from a byte array. It first reads the length of the string in bytes,\n   * followed by the actual byte content, and decodes it into a string.\n   *\n   * BCS layout for \"string\": string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   *\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * assert(deserializer.deserializeStr() === \"1234abcd\");\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeStr(): string {\n    const value = this.deserializeBytes();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(value);\n  }\n\n  /**\n   * @deprecated use `deserializeOption(\"string\")` instead.\n   *\n   * The BCS layout for Optional<String> is 0 if none, else 1 followed by the string length and string content.\n   * @returns The deserialized string if it exists, otherwise undefined.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x00]));\n   * assert(deserializer.deserializeOptionStr() === undefined);\n   * const deserializer = new Deserializer(new Uint8Array([1, 8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * assert(deserializer.deserializeOptionStr() === \"1234abcd\");\n   * ```\n   */\n  deserializeOptionStr(): string | undefined {\n    return this.deserializeOption(\"string\");\n  }\n\n  /**\n   * Deserializes an optional value from the buffer.\n   *\n   * The BCS layout for Optional<T> starts with a boolean byte (0 if none, 1 if some),\n   * followed by the value if present.\n   *\n   * @template T - The type of the value to deserialize\n   * @param type - Either a Deserializable class or one of the string literals: \"string\", \"bytes\", or \"fixedBytes\"\n   * @param len - Required length when type is \"fixedBytes\", ignored otherwise\n   * @returns The deserialized value if present, undefined otherwise\n   *\n   * @throws {Error} When \"fixedBytes\" is specified without a length\n   *\n   * @example\n   * ```typescript\n   * // Deserialize an optional string\n   * const deserializer = new Deserializer(new Uint8Array([1, 3, 97, 98, 99]));\n   * const optStr = deserializer.deserializeOption(\"string\");\n   * // optStr === \"abc\"\n   *\n   * // Deserialize an optional custom type\n   * const deserializer = new Deserializer(new Uint8Array([0]));\n   * const optValue = deserializer.deserializeOption(MyClass);\n   * // optValue === undefined\n   *\n   * // Deserialize optional bytes\n   * const deserializer = new Deserializer(new Uint8Array([1, 3, 1, 2, 3]));\n   * const optBytes = deserializer.deserializeOption(\"bytes\");\n   * // optBytes === Uint8Array[1, 2, 3]\n   *\n   * // Deserialize optional fixed bytes\n   * const deserializer = new Deserializer(new Uint8Array([1, 1, 2, 3, 4]));\n   * const optBytes = deserializer.deserializeOption(\"fixedBytes\", 4);\n   * // optBytes === Uint8Array[1, 2, 3, 4]\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeOption(type: \"string\"): string | undefined;\n  deserializeOption(type: \"bytes\"): Uint8Array | undefined;\n  deserializeOption(type: \"fixedBytes\", len: number): Uint8Array | undefined;\n  deserializeOption<T>(type: Deserializable<T>): T | undefined;\n  deserializeOption<T>(\n    type: Deserializable<T> | \"string\" | \"bytes\" | \"fixedBytes\",\n    len?: number,\n  ): T | string | Uint8Array | undefined {\n    const exists = this.deserializeBool();\n    if (!exists) return undefined;\n\n    if (type === \"string\") {\n      return this.deserializeStr();\n    }\n    if (type === \"bytes\") {\n      return this.deserializeBytes();\n    }\n    if (type === \"fixedBytes\") {\n      if (len === undefined) {\n        throw new Error(\"Fixed bytes length not provided\");\n      }\n      return this.deserializeFixedBytes(len);\n    }\n\n    return this.deserialize(type);\n  }\n\n  /**\n   * Deserializes an array of bytes.\n   *\n   * The BCS layout for \"bytes\" consists of a bytes_length followed by the bytes themselves, where bytes_length is a u32 integer\n   * encoded as a uleb128 integer, indicating the length of the bytes array.\n   *\n   * @returns {Uint8Array} The deserialized array of bytes.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeBytes(): Uint8Array {\n    const len = this.deserializeUleb128AsU32();\n    return new Uint8Array(this.read(len));\n  }\n\n  /**\n   * Deserializes an array of bytes of a specified length.\n   *\n   * @param len - The number of bytes to read from the source.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeFixedBytes(len: number): Uint8Array {\n    return new Uint8Array(this.read(len));\n  }\n\n  /**\n   * Deserializes a boolean value from a byte stream.\n   *\n   * The BCS layout for a boolean uses one byte, where \"0x01\" represents true and \"0x00\" represents false.\n   * An error is thrown if the byte value is not valid.\n   *\n   * @returns The deserialized boolean value.\n   * @throws Throws an error if the boolean value is invalid.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeBool(): boolean {\n    const bool = new Uint8Array(this.read(1))[0];\n    if (bool !== 1 && bool !== 0) {\n      throw new Error(\"Invalid boolean value\");\n    }\n    return bool === 1;\n  }\n\n  /**\n   * Deserializes a uint8 number from the binary data.\n   *\n   * BCS layout for \"uint8\": One byte. Binary format in little-endian representation.\n   *\n   * @returns {number} The deserialized uint8 number.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeU8(): Uint8 {\n    return new DataView(this.read(1)).getUint8(0);\n  }\n\n  /**\n   * Deserializes a uint16 number from a binary format in little-endian representation.\n   *\n   * BCS layout for \"uint16\": Two bytes.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));\n   * assert(deserializer.deserializeU16() === 4660);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeU16(): Uint16 {\n    return new DataView(this.read(2)).getUint16(0, true);\n  }\n\n  /**\n   * Deserializes a uint32 number from a binary format in little-endian representation.\n   *\n   * BCS layout for \"uint32\": Four bytes.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));\n   * assert(deserializer.deserializeU32() === 305419896);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeU32(): Uint32 {\n    return new DataView(this.read(4)).getUint32(0, true);\n  }\n\n  /**\n   * Deserializes a uint64 number.\n   *\n   * This function combines two 32-bit values to return a 64-bit unsigned integer in little-endian representation.\n   * @example\n   * ```typescript\n   * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));\n   * assert(deserializer.deserializeU64() === 1311768467750121216);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeU64(): Uint64 {\n    const low = this.deserializeU32();\n    const high = this.deserializeU32();\n\n    // combine the two 32-bit values and return (little endian)\n    return BigInt((BigInt(high) << BigInt(32)) | BigInt(low));\n  }\n\n  /**\n   * Deserializes a uint128 number from its binary representation.\n   * This function combines two 64-bit values to return a single uint128 value in little-endian format.\n   *\n   * @returns {BigInt} The deserialized uint128 number.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeU128(): Uint128 {\n    const low = this.deserializeU64();\n    const high = this.deserializeU64();\n\n    // combine the two 64-bit values and return (little endian)\n    return BigInt((high << BigInt(64)) | low);\n  }\n\n  /**\n   * Deserializes a uint256 number from its binary representation.\n   *\n   * The BCS layout for \"uint256\" consists of thirty-two bytes in little-endian format.\n   *\n   * @returns {BigInt} The deserialized uint256 number.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeU256(): Uint256 {\n    const low = this.deserializeU128();\n    const high = this.deserializeU128();\n\n    // combine the two 128-bit values and return (little endian)\n    return BigInt((high << BigInt(128)) | low);\n  }\n\n  /**\n   * Deserializes a uleb128 encoded uint32 number.\n   *\n   * This function is used for interpreting lengths of variable-length sequences and tags of enum values in BCS encoding.\n   *\n   * @throws {Error} Throws an error if the parsed value exceeds the maximum uint32 number.\n   * @returns {number} The deserialized uint32 value.\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeUleb128AsU32(): Uint32 {\n    let value: bigint = BigInt(0);\n    let shift = 0;\n\n    while (value < MAX_U32_NUMBER) {\n      const byte = this.deserializeU8();\n      value |= BigInt(byte & 0x7f) << BigInt(shift);\n\n      if ((byte & 0x80) === 0) {\n        break;\n      }\n      shift += 7;\n    }\n\n    if (value > MAX_U32_NUMBER) {\n      throw new Error(\"Overflow while parsing uleb128-encoded uint32 value\");\n    }\n\n    return Number(value);\n  }\n\n  /**\n   * Helper function that primarily exists to support alternative syntax for deserialization.\n   * That is, if we have a `const deserializer: new Deserializer(...)`, instead of having to use\n   * `MyClass.deserialize(deserializer)`, we can call `deserializer.deserialize(MyClass)`.\n   *\n   * @example const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));\n   * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function\n   * // value is now an instance of MyClass\n   * // equivalent to `const value = MyClass.deserialize(deserializer)`\n   * @param cls The BCS-deserializable class to deserialize the buffered bytes into.\n   *\n   * @returns the deserialized value of class type T\n   * @group Implementation\n   * @category BCS\n   */\n  deserialize<T>(cls: Deserializable<T>): T {\n    // NOTE: `deserialize` in `cls.deserialize(this)` here is a static method defined in `cls`,\n    // It is separate from the `deserialize` instance method defined here in Deserializer.\n    return cls.deserialize(this);\n  }\n\n  /**\n   * Deserializes an array of BCS Deserializable values given an existing Deserializer instance with a loaded byte buffer.\n   *\n   * @param cls The BCS-deserializable class to deserialize the buffered bytes into.\n   * @returns An array of deserialized values of type T.\n   * @example\n   * // serialize a vector of addresses\n   * const addresses = new Array<AccountAddress>(\n   *   AccountAddress.from(\"0x1\"),\n   *   AccountAddress.from(\"0x2\"),\n   *   AccountAddress.from(\"0xa\"),\n   *   AccountAddress.from(\"0xb\"),\n   * );\n   * const serializer = new Serializer();\n   * serializer.serializeVector(addresses);\n   * const serializedBytes = serializer.toUint8Array();\n   *\n   * // deserialize the bytes into an array of addresses\n   * const deserializer = new Deserializer(serializedBytes);\n   * const deserializedAddresses = deserializer.deserializeVector(AccountAddress);\n   * // deserializedAddresses is now an array of AccountAddress instances\n   * @group Implementation\n   * @category BCS\n   */\n  deserializeVector<T>(cls: Deserializable<T>): Array<T> {\n    const length = this.deserializeUleb128AsU32();\n    const vector = new Array<T>();\n    for (let i = 0; i < length; i += 1) {\n      vector.push(this.deserialize(cls));\n    }\n    return vector;\n  }\n}\n", "import { Serializer, Deserializer } from \"../../bcs\";\nimport { EphemeralPublicKeyVariant, EphemeralSignatureVariant, HexInput } from \"../../types\";\nimport { PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { Hex } from \"../hex\";\nimport { AptosConfig } from \"../../api\";\n\n/**\n * Represents ephemeral public keys for Aptos Keyless accounts.\n *\n * These keys are used only temporarily within Keyless accounts and are not utilized as public keys for account identification.\n * @group Implementation\n * @category Serialization\n */\nexport class EphemeralPublicKey extends PublicKey {\n  /**\n   * The public key itself\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKey: PublicKey;\n\n  /**\n   * An enum indicating the scheme of the ephemeral public key\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly variant: EphemeralPublicKeyVariant;\n\n  /**\n   * Creates an instance of EphemeralPublicKey using the provided public key.\n   * This constructor ensures that only supported signature types are accepted.\n   *\n   * @param publicKey - The public key to be used for the ephemeral public key.\n   * @throws Error if the signature type is unsupported.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(publicKey: PublicKey) {\n    super();\n    const publicKeyType = publicKey.constructor.name;\n    switch (publicKeyType) {\n      case Ed25519PublicKey.name:\n        this.publicKey = publicKey;\n        this.variant = EphemeralPublicKeyVariant.Ed25519;\n        break;\n      default:\n        throw new Error(`Unsupported key for EphemeralPublicKey - ${publicKeyType}`);\n    }\n  }\n\n  /**\n   * Verifies a signed message using the ephemeral public key.\n   *\n   * @param args - The arguments for the verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature that was signed by the private key of the ephemeral public key.\n   * @returns true if the signature is valid, otherwise false.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: EphemeralSignature }): boolean {\n    const { message, signature } = args;\n    return this.publicKey.verifySignature({ message, signature: signature.signature });\n  }\n\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: EphemeralSignature;\n  }): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Serializes the current instance, specifically handling the Ed25519 signature type.\n   * This function ensures that the signature is properly serialized using the provided serializer.\n   *\n   * @param serializer - The serializer instance used to serialize the signature.\n   * @throws Error if the signature type is unknown.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(EphemeralPublicKeyVariant.Ed25519);\n      this.publicKey.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown public key type\");\n    }\n  }\n\n  /**\n   * Deserializes an EphemeralSignature from the provided deserializer.\n   * This function allows you to retrieve an EphemeralSignature based on the deserialized data.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): EphemeralPublicKey {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case EphemeralPublicKeyVariant.Ed25519:\n        return new EphemeralPublicKey(Ed25519PublicKey.deserialize(deserializer));\n      default:\n        throw new Error(`Unknown variant index for EphemeralPublicKey: ${index}`);\n    }\n  }\n\n  /**\n   * Determines if the provided public key is an instance of `EphemeralPublicKey`.\n   *\n   * @param publicKey - The public key to check.\n   * @returns A boolean indicating whether the public key is an ephemeral type.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is EphemeralPublicKey {\n    return publicKey instanceof EphemeralPublicKey;\n  }\n}\n\n/**\n * Represents ephemeral signatures used in Aptos Keyless accounts.\n *\n * These signatures are utilized within the KeylessSignature framework.\n * @group Implementation\n * @category Serialization\n */\nexport class EphemeralSignature extends Signature {\n  /**\n   * The signature signed by the private key of an EphemeralKeyPair\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signature: Signature;\n\n  constructor(signature: Signature) {\n    super();\n    const signatureType = signature.constructor.name;\n    switch (signatureType) {\n      case Ed25519Signature.name:\n        this.signature = signature;\n        break;\n      default:\n        throw new Error(`Unsupported signature for EphemeralSignature - ${signatureType}`);\n    }\n  }\n\n  /**\n   * Deserializes an ephemeral signature from a hexadecimal input.\n   * This function allows you to convert a hexadecimal representation of an ephemeral signature into its deserialized form for\n   * further processing.\n   *\n   * @param hexInput - The hexadecimal input representing the ephemeral signature.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromHex(hexInput: HexInput): EphemeralSignature {\n    const data = Hex.fromHexInput(hexInput);\n    const deserializer = new Deserializer(data.toUint8Array());\n    return EphemeralSignature.deserialize(deserializer);\n  }\n\n  serialize(serializer: Serializer): void {\n    if (this.signature instanceof Ed25519Signature) {\n      serializer.serializeU32AsUleb128(EphemeralSignatureVariant.Ed25519);\n      this.signature.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown signature type\");\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): EphemeralSignature {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case EphemeralSignatureVariant.Ed25519:\n        return new EphemeralSignature(Ed25519Signature.deserialize(deserializer));\n      default:\n        throw new Error(`Unknown variant index for EphemeralSignature: ${index}`);\n    }\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  MAX_U128_BIG_INT,\n  MAX_U16_NUMBER,\n  MAX_U32_NUMBER,\n  MAX_U64_BIG_INT,\n  MAX_U8_NUMBER,\n  MAX_U256_BIG_INT,\n} from \"../consts\";\nimport { Deserializer } from \"../deserializer\";\nimport { Serializable, Serializer, ensureBoolean, validateNumberInRange } from \"../serializer\";\nimport { TransactionArgument } from \"../../transactions/instances/transactionArgument\";\nimport { AnyNumber, Uint16, Uint32, Uint8, ScriptTransactionArgumentVariants } from \"../../types\";\n\n/**\n * Represents a boolean value that can be serialized and deserialized.\n * This class extends the Serializable class and provides methods to serialize\n * the boolean value for different contexts, such as entry functions and script functions.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class Bool extends Serializable implements TransactionArgument {\n  public readonly value: boolean;\n\n  /**\n   * Constructs a new instance with a specified value.\n   * This ensures that the value is validated to be within the acceptable range.\n   *\n   * @param value - The number to be validated and assigned, which must be between 0 and MAX_U256_BIG_INT.\n   * @group Implementation\n   * @category BCS\n   */\n  constructor(value: boolean) {\n    super();\n\n    /**\n     * Ensures that the provided value is of type boolean.\n     * This function throws an error if the value is not a boolean, helping to enforce type safety in your code.\n     *\n     * @param value - The value to be checked for boolean type.\n     * @throws {Error} Throws an error if the value is not a boolean.\n     * @group Implementation\n     * @category BCS\n     */\n    ensureBoolean(value);\n    this.value = value;\n  }\n\n  /**\n   * Serializes the value using the provided serializer.\n   * This function is essential for converting the value into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBool(this.value);\n  }\n\n  /**\n   * Serializes the current instance for use in an entry function by converting it to a byte sequence.\n   * This allows the instance to be properly formatted for serialization in transactions.\n   *\n   * @param serializer - The serializer instance used to serialize the byte sequence.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * Serializes the current instance for use in a script function.\n   * This allows for the conversion of the instance into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Bool);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Deserializes a U256 value from the provided deserializer.\n   *\n   * @param deserializer - The deserializer instance used to read the U256 data.\n   * @group Implementation\n   * @category BCS\n   */\n  // eslint-disable-next-line class-methods-use-this\n  deserialize(deserializer: Deserializer) {\n    return new U256(deserializer.deserializeU256());\n  }\n\n  static deserialize(deserializer: Deserializer): Bool {\n    return new Bool(deserializer.deserializeBool());\n  }\n}\n\n/**\n * Represents an unsigned 8-bit integer (U8) value.\n * This class extends the Serializable class and provides methods for serialization and deserialization of U8 values.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class U8 extends Serializable implements TransactionArgument {\n  public readonly value: Uint8;\n\n  constructor(value: Uint8) {\n    super();\n    validateNumberInRange(value, 0, MAX_U8_NUMBER);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU8(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U8);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U8 {\n    return new U8(deserializer.deserializeU8());\n  }\n}\n\n/**\n * Represents a 16-bit unsigned integer (U16) value.\n * This class extends the Serializable class and provides methods for serialization\n * and deserialization of the U16 value.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class U16 extends Serializable implements TransactionArgument {\n  public readonly value: Uint16;\n\n  constructor(value: Uint16) {\n    super();\n    validateNumberInRange(value, 0, MAX_U16_NUMBER);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU16(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U16);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U16 {\n    return new U16(deserializer.deserializeU16());\n  }\n}\n\n/**\n * Represents a 32-bit unsigned integer (U32) that can be serialized and deserialized.\n * This class ensures that the value is within the valid range for a U32.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class U32 extends Serializable implements TransactionArgument {\n  public readonly value: Uint32;\n\n  constructor(value: Uint32) {\n    super();\n    validateNumberInRange(value, 0, MAX_U32_NUMBER);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U32);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U32 {\n    return new U32(deserializer.deserializeU32());\n  }\n}\n\n/**\n * Represents a 64-bit unsigned integer (U64) and provides methods for serialization.\n *\n * This class ensures that the value is within the valid range for a U64 and provides\n * functionality to serialize the value for various use cases, including entry functions\n * and script functions.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class U64 extends Serializable implements TransactionArgument {\n  public readonly value: bigint;\n\n  constructor(value: AnyNumber) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U64_BIG_INT);\n    this.value = BigInt(value);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU64(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U64);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U64 {\n    return new U64(deserializer.deserializeU64());\n  }\n}\n\n/**\n * Represents a 128-bit unsigned integer value.\n * This class provides methods for serialization and deserialization\n * of U128 values, ensuring that the values are within the valid range.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class U128 extends Serializable implements TransactionArgument {\n  public readonly value: bigint;\n\n  constructor(value: AnyNumber) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U128_BIG_INT);\n    this.value = BigInt(value);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU128(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U128);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U128 {\n    return new U128(deserializer.deserializeU128());\n  }\n}\n\n/**\n * Represents a 256-bit unsigned integer (U256) that extends the Serializable class.\n * This class provides methods for serialization and deserialization of U256 values,\n * ensuring that the values are within the valid range.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class U256 extends Serializable implements TransactionArgument {\n  public readonly value: bigint;\n\n  constructor(value: AnyNumber) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U256_BIG_INT);\n    this.value = BigInt(value);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU256(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U256);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U256 {\n    return new U256(deserializer.deserializeU256());\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Bool, U128, U16, U256, U32, U64, U8 } from \"./movePrimitives\";\nimport { Serializable, Serializer } from \"../serializer\";\nimport { Deserializable, Deserializer } from \"../deserializer\";\nimport { AnyNumber, HexInput, ScriptTransactionArgumentVariants } from \"../../types\";\nimport { Hex } from \"../../core/hex\";\nimport { EntryFunctionArgument, TransactionArgument } from \"../../transactions/instances/transactionArgument\";\n\n/**\n * This class is the Aptos Typescript SDK representation of a Move `vector<T>`,\n * where `T` represents either a primitive type (`bool`, `u8`, `u64`, ...)\n * or a BCS-serializable struct itself.\n *\n * It is a BCS-serializable, array-like type that contains an array of values of type `T`,\n * where `T` is a class that implements `Serializable`.\n *\n * The purpose of this class is to facilitate easy construction of BCS-serializable\n * Move `vector<T>` types.\n *\n * @example\n * // in Move: `vector<u8> [1, 2, 3, 4];`\n * const vecOfU8s = new MoveVector<U8>([new U8(1), new U8(2), new U8(3), new U8(4)]);\n * // in Move: `std::bcs::to_bytes(vector<u8> [1, 2, 3, 4]);`\n * const bcsBytes = vecOfU8s.toUint8Array();\n *\n * // vector<vector<u8>> [ vector<u8> [1], vector<u8> [1, 2, 3, 4], vector<u8> [5, 6, 7, 8] ];\n * const vecOfVecs = new MoveVector<MoveVector<U8>>([\n *   new MoveVector<U8>([new U8(1)]),\n *   MoveVector.U8([1, 2, 3, 4]),\n *   MoveVector.U8([5, 6, 7, 8]),\n * ]);\n *\n * // vector<Option<u8>> [ std::option::some<u8>(1), std::option::some<u8>(2) ];\n * const vecOfOptionU8s = new MoveVector<MoveOption<U8>>([\n *    MoveOption.U8(1),\n *    MoveOption.U8(2),\n * ]);\n *\n * // vector<MoveString> [ std::string::utf8(b\"hello\"), std::string::utf8(b\"world\") ];\n * const vecOfStrings = new MoveVector([new MoveString(\"hello\"), new MoveString(\"world\")]);\n * const vecOfStrings2 = MoveVector.MoveString([\"hello\", \"world\"]);\n *\n * @param values an Array<T> of values where T is a class that implements Serializable\n * @returns a `MoveVector<T>` with the values `values`\n * @group Implementation\n * @category BCS\n */\nexport class MoveVector<T extends Serializable & EntryFunctionArgument>\n  extends Serializable\n  implements TransactionArgument\n{\n  public values: Array<T>;\n\n  /**\n   * Initializes a new instance of the class with an optional value.\n   * This constructor sets up the internal vector based on the provided value.\n   *\n   * @param values - The initial value to be stored in the vector, or null to initialize an empty vector.\n   * @group Implementation\n   * @category BCS\n   */\n  constructor(values: Array<T>) {\n    super();\n    this.values = values;\n  }\n\n  /**\n   * Serializes the current instance into a byte sequence suitable for entry functions.\n   * This allows the data to be properly formatted for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to serialize the byte sequence.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * NOTE: This function will only work when the inner values in the `MoveVector` are `U8`s.\n   * @param serializer\n   * @group Implementation\n   * @category BCS\n   */\n\n  /**\n   * Serialize the string as a fixed byte string without the length prefix for use in a script function.\n   * @param serializer - The serializer used to convert the byte vector into a format suitable for a script function.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    // This checks if the type of a non-empty vector is of type other than U8.  If so, we use the Serialized\n    // transaction argument type to serialize the argument.\n    if (this.values[0] !== undefined && !(this.values[0] instanceof U8)) {\n      const serialized = new Serialized(this.bcsToBytes());\n      serialized.serializeForScriptFunction(serializer);\n      return;\n    }\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U8Vector);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Factory method to generate a MoveVector<U8> from a `number` or `undefined`.\n   *\n   * This method allows you to create a MoveVector that encapsulates a U8 value, enabling you to handle optional U8 values\n   * effectively.\n   *\n   * @param values - The values used to fill the MoveVector. If `values` is undefined or null, the resulting MoveVector's\n   * `.isSome()` method will return false.\n   * @returns A MoveVector<U8> with an inner value `value`.\n   *\n   * @example\n   * ```typescript\n   * const v = MoveVector.U8([1, 2, 3, 4]);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  static U8(values: Array<number> | HexInput): MoveVector<U8> {\n    let numbers: Array<number>;\n\n    if (Array.isArray(values) && values.length === 0) {\n      // Handle empty array, since it won't have a \"first value\"\n      numbers = [];\n    } else if (Array.isArray(values) && typeof values[0] === \"number\") {\n      numbers = values;\n    } else if (typeof values === \"string\") {\n      const hex = Hex.fromHexInput(values);\n      numbers = Array.from(hex.toUint8Array());\n    } else if (values instanceof Uint8Array) {\n      numbers = Array.from(values);\n    } else {\n      throw new Error(\"Invalid input type, must be an number[], Uint8Array, or hex string\");\n    }\n\n    return new MoveVector<U8>(numbers.map((v) => new U8(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U16> from a `number` or `null`.\n   *\n   * This method allows you to create a MoveVector that can either hold a U16 value or be empty.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is null or undefined, the resulting MoveVector's\n   * `.isSome()` method will return false.\n   * @returns A MoveVector<U16> with an inner value `value`.\n   * @example\n   * ```typescript\n   * const v = MoveVector.U16([1, 2, 3, 4]);\n   * ```\n   * @group Implementation\n   * @category BCS\n\n   */\n  static U16(values: Array<number>): MoveVector<U16> {\n    return new MoveVector<U16>(values.map((v) => new U16(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector<U32> from a `number` or `null`.\n   *\n   * This method allows you to create a MoveVector that can either hold a U32 value or be empty.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is null or undefined,\n   * the resulting MoveVector's .isSome() method will return false.\n   * @returns A MoveVector<U32> with an inner value `value`.\n   *\n   * @example\n   * ```\n   * const v = MoveVector.U32([1, 2, 3, 4]);\n   * ```\n   * @group Implementation\n   * @category BCS\n\n   */\n  static U32(values: Array<number>): MoveVector<U32> {\n    return new MoveVector<U32>(values.map((v) => new U32(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector<U64> from a number, bigint, or null/undefined.\n   * This allows for the creation of an optional U64 value that can be checked for presence.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is undefined or null, the resulting MoveVector's\n   * `.isSome()` method will return false.\n   * @returns A MoveVector<U64> with an inner value `value`.\n   *\n   * @example\n   * ```typescript\n   * const v = MoveVector.U64([1, 2, 3, 4]);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  static U64(values: Array<AnyNumber>): MoveVector<U64> {\n    return new MoveVector<U64>(values.map((v) => new U64(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector<U128> from a number, bigint, or undefined.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is undefined, the resulting MoveVector's `.isSome()`\n   * method will return false.\n   * @returns A MoveVector<U128> with an inner value `value`.\n   *\n   * @example\n   * ```typescript\n   * const v = MoveVector.U128([1, 2, 3, 4]);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  static U128(values: Array<AnyNumber>): MoveVector<U128> {\n    return new MoveVector<U128>(values.map((v) => new U128(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector<U256> from a number, bigint, or null/undefined.\n   * This allows for the creation of an optional U256 value, enabling checks for presence or absence of a value.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is undefined or null,\n   *                the resulting MoveVector's .isSome() method will return false.\n   * @returns A MoveVector<U256> with an inner value `value`.\n   *\n   * @example\n   * ```typescript\n   * const v = MoveVector.U256([1, 2, 3, 4]);\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  static U256(values: Array<AnyNumber>): MoveVector<U256> {\n    return new MoveVector<U256>(values.map((v) => new U256(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector<Bool> from a `boolean` or `undefined`.\n   * This method allows you to create an optional boolean value that can be used in various contexts where a boolean may or may\n   * not be present.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is undefined, the resulting MoveVector's .isSome() method\n   * will return false.\n   * @returns A MoveVector<Bool> with an inner value `value`.\n   *\n   * @example\n   *    * const v = MoveVector.Bool([true, false, true, false]);\n   * @group Implementation\n   * @category BCS\n   */\n  static Bool(values: Array<boolean>): MoveVector<Bool> {\n    return new MoveVector<Bool>(values.map((v) => new Bool(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector<MoveString> from a `string` or `undefined`.\n   * This function creates a MoveVector that encapsulates a MoveString if the provided value is not null or undefined.\n   *\n   * @param values - The value used to fill the MoveVector. If `value` is undefined, the resulting MoveVector's .isSome() method\n   * will return false.\n   * @returns A MoveVector<MoveString> with an inner value `value`.\n   *\n   * @example\n   * const v = MoveVector.MoveString([\"hello\", \"world\"]);\n   * @group Implementation\n   * @category BCS\n   */\n  static MoveString(values: Array<string>): MoveVector<MoveString> {\n    return new MoveVector<MoveString>(values.map((v) => new MoveString(v)));\n  }\n\n  /**\n   * Serializes the current object using the provided serializer.\n   * This function will serialize the value if it is present.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serialize(serializer: Serializer): void;\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.values);\n  }\n\n  /**\n   * Deserialize a MoveVector of type T, specifically where T is a Serializable and Deserializable type.\n   *\n   * NOTE: This only works with a depth of one. Generics will not work.\n   *\n   * NOTE: This will not work with types that aren't of the Serializable class.\n   *\n   * If you're looking for a more flexible deserialization function, you can use the deserializeVector function\n   * in the Deserializer class.\n   *\n   * @example\n   * const vec = MoveVector.deserialize(deserializer, U64);\n   * @param deserializer the Deserializer instance to use, with bytes loaded into it already.\n   * @param cls the class to typecast the input values to, must be a Serializable and Deserializable type.\n   * @returns a MoveVector of the corresponding class T\n   *\n   * @group Implementation\n   * @category BCS\n   */\n  static deserialize<T extends Serializable & EntryFunctionArgument>(\n    deserializer: Deserializer,\n    cls: Deserializable<T>,\n  ): MoveVector<T> {\n    const length = deserializer.deserializeUleb128AsU32();\n    const values = new Array<T>();\n    for (let i = 0; i < length; i += 1) {\n      values.push(cls.deserialize(deserializer));\n    }\n    return new MoveVector(values);\n  }\n}\n\n/**\n * Represents a serialized data structure that encapsulates a byte array.\n * This class extends the Serializable class and provides methods for serialization\n * and deserialization of byte data, as well as converting to a MoveVector.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class Serialized extends Serializable implements TransactionArgument {\n  public readonly value: Uint8Array;\n\n  constructor(value: HexInput) {\n    super();\n    this.value = Hex.fromHexInput(value).toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    this.serialize(serializer);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Serialized);\n    this.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Serialized {\n    return new Serialized(deserializer.deserializeBytes());\n  }\n\n  /**\n   * Deserialize the bytecode into a MoveVector of the specified type.\n   * This function allows you to convert serialized data into a usable MoveVector format.\n   *\n   * @param cls - The class type of the elements in the MoveVector.\n   * @group Implementation\n   * @category BCS\n   */\n  toMoveVector<T extends Serializable & EntryFunctionArgument>(cls: Deserializable<T>): MoveVector<T> {\n    const deserializer = new Deserializer(this.bcsToBytes());\n    deserializer.deserializeUleb128AsU32();\n    const vec = deserializer.deserializeVector(cls);\n    return new MoveVector(vec);\n  }\n}\n\n/**\n * Represents a string value that can be serialized and deserialized.\n * This class extends the Serializable base class and provides methods\n * for serializing the string in different contexts, such as for entry\n * functions and script functions.\n *\n * @extends Serializable\n * @group Implementation\n * @category BCS\n */\nexport class MoveString extends Serializable implements TransactionArgument {\n  public value: string;\n\n  constructor(value: string) {\n    super();\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    // Serialize the string as a fixed byte string, i.e., without the length prefix\n    const textEncoder = new TextEncoder();\n    const fixedStringBytes = textEncoder.encode(this.value);\n    // Put those bytes into a vector<u8> and serialize it as a script function argument\n    const vectorU8 = MoveVector.U8(fixedStringBytes);\n    vectorU8.serializeForScriptFunction(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MoveString {\n    return new MoveString(deserializer.deserializeStr());\n  }\n}\n\nexport class MoveOption<T extends Serializable & EntryFunctionArgument>\n  extends Serializable\n  implements EntryFunctionArgument\n{\n  private vec: MoveVector<T>;\n\n  public readonly value?: T;\n\n  constructor(value?: T | null) {\n    super();\n    if (typeof value !== \"undefined\" && value !== null) {\n      this.vec = new MoveVector([value]);\n    } else {\n      this.vec = new MoveVector([]);\n    }\n\n    [this.value] = this.vec.values;\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * Retrieves the inner value of the MoveOption.\n   *\n   * This method is inspired by Rust's `Option<T>.unwrap()`, where attempting to unwrap a `None` value results in a panic.\n   * This method will throw an error if the value is not present.\n   *\n   * @example\n   * const option = new MoveOption<Bool>(new Bool(true));\n   * const value = option.unwrap();  // Returns the Bool instance\n   *\n   * @throws {Error} Throws an error if the MoveOption does not contain a value.\n   *\n   * @returns {T} The contained value if present.\n   * @group Implementation\n   * @category BCS\n   */\n  unwrap(): T {\n    if (!this.isSome()) {\n      throw new Error(\"Called unwrap on a MoveOption with no value\");\n    } else {\n      return this.vec.values[0];\n    }\n  }\n\n  /**\n   * Check if the MoveOption has a value.\n   *\n   * @returns {boolean} Returns true if there is exactly one value in the MoveOption.\n   * @group Implementation\n   * @category BCS\n   */\n  isSome(): boolean {\n    return this.vec.values.length === 1;\n  }\n\n  serialize(serializer: Serializer): void {\n    // serialize 0 or 1\n    // if 1, serialize the value\n    this.vec.serialize(serializer);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U8> from a `number` or `undefined`.\n   *\n   * @example\n   * MoveOption.U8(1).isSome() === true;\n   * MoveOption.U8().isSome() === false;\n   * MoveOption.U8(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U8> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static U8(value?: number | null): MoveOption<U8> {\n    return new MoveOption<U8>(value !== null && value !== undefined ? new U8(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U16> from a `number` or `undefined`.\n   *\n   * @example\n   * MoveOption.U16(1).isSome() === true;\n   * MoveOption.U16().isSome() === false;\n   * MoveOption.U16(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U16> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static U16(value?: number | null): MoveOption<U16> {\n    return new MoveOption<U16>(value !== null && value !== undefined ? new U16(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U32> from a `number` or `undefined`.\n   *\n   * @example\n   * MoveOption.U32(1).isSome() === true;\n   * MoveOption.U32().isSome() === false;\n   * MoveOption.U32(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U32> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static U32(value?: number | null): MoveOption<U32> {\n    return new MoveOption<U32>(value !== null && value !== undefined ? new U32(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U64> from a `number` or a `bigint` or `undefined`.\n   *\n   * @example\n   * MoveOption.U64(1).isSome() === true;\n   * MoveOption.U64().isSome() === false;\n   * MoveOption.U64(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U64> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static U64(value?: AnyNumber | null): MoveOption<U64> {\n    return new MoveOption<U64>(value !== null && value !== undefined ? new U64(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U128> from a `number` or a `bigint` or `undefined`.\n   *\n   * @example\n   * MoveOption.U128(1).isSome() === true;\n   * MoveOption.U128().isSome() === false;\n   * MoveOption.U128(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U128> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static U128(value?: AnyNumber | null): MoveOption<U128> {\n    return new MoveOption<U128>(value !== null && value !== undefined ? new U128(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U256> from a `number` or a `bigint` or `undefined`.\n   *\n   * @example\n   * MoveOption.U256(1).isSome() === true;\n   * MoveOption.U256().isSome() === false;\n   * MoveOption.U256(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U256> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static U256(value?: AnyNumber | null): MoveOption<U256> {\n    return new MoveOption<U256>(value !== null && value !== undefined ? new U256(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<Bool> from a `boolean` or `undefined`.\n   *\n   * @example\n   * MoveOption.Bool(true).isSome() === true;\n   * MoveOption.Bool().isSome() === false;\n   * MoveOption.Bool(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<Bool> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static Bool(value?: boolean | null): MoveOption<Bool> {\n    return new MoveOption<Bool>(value !== null && value !== undefined ? new Bool(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<MoveString> from a `string` or `undefined`.\n   *\n   * @example\n   * MoveOption.MoveString(\"hello\").isSome() === true;\n   * MoveOption.MoveString(\"\").isSome() === true;\n   * MoveOption.MoveString().isSome() === false;\n   * MoveOption.MoveString(undefined).isSome() === false;\n   * @param value the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<MoveString> with an inner value `value`\n   * @group Implementation\n   * @category BCS\n   */\n  static MoveString(value?: string | null): MoveOption<MoveString> {\n    return new MoveOption<MoveString>(value !== null && value !== undefined ? new MoveString(value) : undefined);\n  }\n\n  static deserialize<U extends Serializable & EntryFunctionArgument>(\n    deserializer: Deserializer,\n    cls: Deserializable<U>,\n  ): MoveOption<U> {\n    const vector = MoveVector.deserialize(deserializer, cls);\n    return new MoveOption(vector.values[0]);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core/accountAddress\";\nimport { AnyNumber } from \"../../types\";\nimport { PublicKey } from \"../../core/crypto\";\nimport { MoveString, MoveVector, U64, U8 } from \"../../bcs\";\n\n/**\n * Represents a challenge required for the account owner to sign in order to rotate the authentication key.\n * @group Implementation\n * @category Transactions\n */\nexport class RotationProofChallenge extends Serializable {\n  // Resource account address\n  public readonly accountAddress: AccountAddress = AccountAddress.ONE;\n\n  // Module name, i.e: 0x1::account\n  public readonly moduleName: MoveString = new MoveString(\"account\");\n\n  // The rotation proof challenge struct name that live under the module\n  public readonly structName: MoveString = new MoveString(\"RotationProofChallenge\");\n\n  // Signer's address\n  public readonly originator: AccountAddress;\n\n  // Signer's current authentication key\n  public readonly currentAuthKey: AccountAddress;\n\n  // New public key to rotate to\n  public readonly newPublicKey: MoveVector<U8>;\n\n  // Sequence number of the account\n  public readonly sequenceNumber: U64;\n\n  /**\n   * Initializes a new instance of the class with the specified parameters.\n   * This constructor sets up the necessary attributes for managing account keys.\n   *\n   * @param args - The parameters required to create the instance.\n   * @param args.sequenceNumber - The sequence number associated with the transaction.\n   * @param args.originator - The account address of the originator.\n   * @param args.currentAuthKey - The current authentication key of the account.\n   * @param args.newPublicKey - The new public key to be set for the account.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(args: {\n    sequenceNumber: AnyNumber;\n    originator: AccountAddress;\n    currentAuthKey: AccountAddress;\n    newPublicKey: PublicKey;\n  }) {\n    super();\n    this.sequenceNumber = new U64(args.sequenceNumber);\n    this.originator = args.originator;\n    this.currentAuthKey = args.currentAuthKey;\n    this.newPublicKey = MoveVector.U8(args.newPublicKey.toUint8Array());\n  }\n\n  /**\n   * Serializes the properties of the current instance for transmission or storage.\n   * This function helps in converting the instance data into a format suitable for serialization.\n   *\n   * @param serializer - The serializer used to serialize the instance properties.\n   * @param serializer.accountAddress - The account address to serialize.\n   * @param serializer.moduleName - The module name to serialize.\n   * @param serializer.structName - The struct name to serialize.\n   * @param serializer.sequenceNumber - The sequence number to serialize.\n   * @param serializer.originator - The originator to serialize.\n   * @param serializer.currentAuthKey - The current authentication key to serialize.\n   * @param serializer.newPublicKey - The new public key to serialize.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.accountAddress);\n    serializer.serialize(this.moduleName);\n    serializer.serialize(this.structName);\n    serializer.serialize(this.sequenceNumber);\n    serializer.serialize(this.originator);\n    serializer.serialize(this.currentAuthKey);\n    serializer.serialize(this.newPublicKey);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../../bcs/serializer\";\nimport { Deserializer } from \"../../bcs/deserializer\";\n\n/**\n * Represents a ChainId that can be serialized and deserialized.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport class ChainId extends Serializable {\n  public readonly chainId: number;\n\n  /**\n   * Initializes a new instance of the class with the specified chain ID.\n   *\n   * @param chainId - The ID of the blockchain network to be used.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(chainId: number) {\n    super();\n    this.chainId = chainId;\n  }\n\n  /**\n   * Serializes the current object using the provided serializer.\n   * This function helps in converting the object into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU8(this.chainId);\n  }\n\n  /**\n   * Deserializes a ChainId from the provided deserializer.\n   * This function allows you to reconstruct a ChainId object from serialized data.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): ChainId {\n    const chainId = deserializer.deserializeU8();\n    return new ChainId(chainId);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\n\n/**\n * Represents an Identifier that can be serialized and deserialized.\n * This class is used to denote the module \"name\" in \"ModuleId\" and\n * the \"function name\" in \"EntryFunction\".\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport class Identifier extends Serializable {\n  public identifier: string;\n\n  /**\n   * Creates an instance of the class with a specified identifier.\n   *\n   * @param identifier - The unique identifier for the instance.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(identifier: string) {\n    super();\n    this.identifier = identifier;\n  }\n\n  /**\n   * Serializes the identifier of the current instance using the provided serializer.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.identifier);\n  }\n\n  /**\n   * Deserializes an identifier from the provided deserializer.\n   * This function is useful for reconstructing an Identifier object from a serialized format.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): Identifier {\n    const identifier = deserializer.deserializeStr();\n    return new Identifier(identifier);\n  }\n}\n", "import { AccountAuthenticator, AnyRawTransaction, InputTransactionPluginData } from \"../../transactions\";\nimport { AptosConfig } from \"../aptosConfig\";\n\n/**\n * Validates the fee payer data when submitting a transaction to ensure that the fee\n * payer authenticator is provided if a fee payer address is specified. This helps\n * prevent errors in transaction submission related to fee payer authentication.\n *\n * The validation is skipped if a custom transaction submitter is defined.\n *\n * @param config - The Aptos configuration that may contain a transaction submitter.\n * @param args - The method arguments containing transaction data and optional transaction submitter.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * const config = new AptosConfig({ network: Network.TESTNET });\n * const aptos = new Aptos(config);\n *\n * class TransactionHandler {\n *   async submitTransaction(methodArgs: { transaction: { feePayerAddress: string }, feePayerAuthenticator?: string }) {\n *     validateFeePayerDataOnSubmission(this.config, methodArgs);\n *     // Logic to submit the transaction\n *   }\n * }\n *\n * async function runExample() {\n *   const handler = new TransactionHandler();\n *\n *   // Attempt to submit a transaction without a fee payer authenticator\n *   try {\n *     await handler.submitTransaction({\n *       transaction: { feePayerAddress: \"0x1\" }, // replace with a real fee payer address\n *     });\n *   } catch (error) {\n *     console.error(error.message); // Should log the error message\n *   }\n *\n *   // Submit a transaction with a fee payer authenticator\n *   await handler.submitTransaction({\n *     transaction: { feePayerAddress: \"0x1\" }, // replace with a real fee payer address\n *     feePayerAuthenticator: \"authenticatorValue\", // replace with a real authenticator\n *   });\n *\n *   console.log(\"Transaction submitted successfully.\");\n * }\n * runExample().catch(console.error);\n * ```\n * @group Implementation\n */\nexport function validateFeePayerDataOnSubmission(\n  config: AptosConfig,\n  args: {\n    transaction: AnyRawTransaction;\n    senderAuthenticator: AccountAuthenticator;\n    feePayerAuthenticator?: AccountAuthenticator;\n  } & InputTransactionPluginData,\n): void {\n  // Skip validation if a transaction submitter is defined.\n  if (config.getTransactionSubmitter() !== undefined || args.transactionSubmitter !== undefined) {\n    return;\n  }\n\n  if (args.transaction.feePayerAddress && !args.feePayerAuthenticator) {\n    throw new Error(\"You are submitting a Fee Payer transaction but missing the feePayerAuthenticator\");\n  }\n}\n\n/**\n * Validates that the fee payer public key is provided when simulating a Fee Payer transaction.\n * This ensures that all necessary data is present for the simulation to proceed correctly.\n *\n * @param target - The target object where the method is defined.\n * @param propertyKey - The name of the method being decorated.\n * @param descriptor - The property descriptor for the method.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * const config = new AptosConfig({ network: Network.TESTNET });\n * const aptos = new Aptos(config);\n *\n * async function runExample() {\n *   const methodArgs = {\n *     transaction: {\n *       feePayerAddress: \"0x1\", // replace with a real fee payer address\n *     },\n *     feePayerPublicKey: undefined, // missing fee payer public key\n *   };\n *\n *   try {\n *     // This will throw an error due to missing feePayerPublicKey\n *     await aptos.someMethod(methodArgs);\n *   } catch (error) {\n *     console.error(error.message); // Output the error message\n *   }\n * }\n * runExample().catch(console.error);\n * ```\n * @group Implementation\n */\nexport function ValidateFeePayerDataOnSimulation(target: unknown, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  /* eslint-disable-next-line func-names, no-param-reassign */\n  descriptor.value = async function (...args: any[]) {\n    return originalMethod.apply(this, args);\n  };\n\n  return descriptor;\n}\n", "import * as Types from \"./operations\";\n\nimport { GraphQLClient, RequestOptions } from \"graphql-request\";\ntype GraphQLClientRequestHeaders = RequestOptions[\"requestHeaders\"];\nexport const TokenActivitiesFieldsFragmentDoc = `\n    fragment TokenActivitiesFields on token_activities_v2 {\n  after_value\n  before_value\n  entry_function_id_str\n  event_account_address\n  event_index\n  from_address\n  is_fungible_v2\n  property_version_v1\n  to_address\n  token_amount\n  token_data_id\n  token_standard\n  transaction_timestamp\n  transaction_version\n  type\n}\n    `;\nexport const AnsTokenFragmentFragmentDoc = `\n    fragment AnsTokenFragment on current_aptos_names {\n  domain\n  expiration_timestamp\n  registered_address\n  subdomain\n  token_standard\n  is_primary\n  owner_address\n  subdomain_expiration_policy\n  domain_expiration_timestamp\n}\n    `;\nexport const CurrentTokenOwnershipFieldsFragmentDoc = `\n    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {\n  token_standard\n  token_properties_mutated_v1\n  token_data_id\n  table_type_v1\n  storage_id\n  property_version_v1\n  owner_address\n  last_transaction_version\n  last_transaction_timestamp\n  is_soulbound_v2\n  is_fungible_v2\n  amount\n  current_token_data {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    decimals\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\nexport const GetAccountAddressesForAuthKey = `\n    query getAccountAddressesForAuthKey($where_condition: auth_key_account_addresses_bool_exp, $order_by: [auth_key_account_addresses_order_by!]) {\n  auth_key_account_addresses(where: $where_condition, order_by: $order_by) {\n    auth_key\n    account_address\n    last_transaction_version\n    is_auth_key_used\n  }\n}\n    `;\nexport const GetAccountCoinsCount = `\n    query getAccountCoinsCount($address: String) {\n  current_fungible_asset_balances_aggregate(\n    where: {owner_address: {_eq: $address}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAccountCoinsData = `\n    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n    metadata {\n      token_standard\n      symbol\n      supply_aggregator_table_key_v1\n      supply_aggregator_table_handle_v1\n      project_uri\n      name\n      last_transaction_version\n      last_transaction_timestamp\n      icon_uri\n      decimals\n      creator_address\n      asset_type\n    }\n  }\n}\n    `;\nexport const GetAccountCollectionsWithOwnedTokens = `\n    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {\n  current_collection_ownership_v2_view(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      mutable_description\n      max_supply\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n    collection_id\n    collection_name\n    collection_uri\n    creator_address\n    distinct_tokens\n    last_transaction_version\n    owner_address\n    single_token_uri\n  }\n}\n    `;\nexport const GetAccountOwnedTokens = `\n    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountOwnedTokensByTokenData = `\n    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountOwnedTokensFromCollection = `\n    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountTokensCount = `\n    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {\n  current_token_ownerships_v2_aggregate(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAccountTransactionsCount = `\n    query getAccountTransactionsCount($address: String) {\n  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAuthKeysForPublicKey = `\n    query getAuthKeysForPublicKey($where_condition: public_key_auth_keys_bool_exp, $order_by: [public_key_auth_keys_order_by!]) {\n  public_key_auth_keys(where: $where_condition, order_by: $order_by) {\n    public_key\n    public_key_type\n    auth_key\n    account_public_key\n    last_transaction_version\n    is_public_key_used\n    signature_type\n  }\n}\n    `;\nexport const GetChainTopUserTransactions = `\n    query getChainTopUserTransactions($limit: Int) {\n  user_transactions(limit: $limit, order_by: {version: desc}) {\n    version\n  }\n}\n    `;\nexport const GetCollectionData = `\n    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {\n  current_collections_v2(where: $where_condition) {\n    uri\n    total_minted_v2\n    token_standard\n    table_handle_v1\n    mutable_uri\n    mutable_description\n    max_supply\n    collection_id\n    collection_name\n    creator_address\n    current_supply\n    description\n    last_transaction_timestamp\n    last_transaction_version\n    cdn_asset_uris {\n      cdn_image_uri\n      asset_uri\n      animation_optimizer_retry_count\n      cdn_animation_uri\n      cdn_json_uri\n      image_optimizer_retry_count\n      json_parser_retry_count\n      raw_animation_uri\n      raw_image_uri\n    }\n  }\n}\n    `;\nexport const GetCurrentFungibleAssetBalances = `\n    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n  }\n}\n    `;\nexport const GetDelegatedStakingActivities = `\n    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {\n  delegated_staking_activities(\n    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}\n  ) {\n    amount\n    delegator_address\n    event_index\n    event_type\n    pool_address\n    transaction_version\n  }\n}\n    `;\nexport const GetEvents = `\n    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {\n  events(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    account_address\n    creation_number\n    data\n    event_index\n    sequence_number\n    transaction_block_height\n    transaction_version\n    type\n    indexed_type\n  }\n}\n    `;\nexport const GetFungibleAssetActivities = `\n    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_activities(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    block_height\n    entry_function_id_str\n    event_index\n    gas_fee_payer_address\n    is_frozen\n    is_gas_fee\n    is_transaction_success\n    owner_address\n    storage_id\n    storage_refund_amount\n    token_standard\n    transaction_timestamp\n    transaction_version\n    type\n  }\n}\n    `;\nexport const GetFungibleAssetMetadata = `\n    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {\n    icon_uri\n    project_uri\n    supply_aggregator_table_handle_v1\n    supply_aggregator_table_key_v1\n    creator_address\n    asset_type\n    decimals\n    last_transaction_timestamp\n    last_transaction_version\n    name\n    symbol\n    token_standard\n    supply_v2\n    maximum_v2\n  }\n}\n    `;\nexport const GetNames = `\n    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {\n  current_aptos_names(\n    limit: $limit\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n  ) {\n    ...AnsTokenFragment\n  }\n}\n    ${AnsTokenFragmentFragmentDoc}`;\nexport const GetNumberOfDelegators = `\n    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {\n  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {\n    num_active_delegator\n    pool_address\n  }\n}\n    `;\nexport const GetObjectData = `\n    query getObjectData($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {\n  current_objects(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    allow_ungated_transfer\n    state_key_hash\n    owner_address\n    object_address\n    last_transaction_version\n    last_guid_creation_num\n    is_deleted\n  }\n}\n    `;\nexport const GetProcessorStatus = `\n    query getProcessorStatus($where_condition: processor_status_bool_exp) {\n  processor_status(where: $where_condition) {\n    last_success_version\n    processor\n    last_updated\n  }\n}\n    `;\nexport const GetTableItemsData = `\n    query getTableItemsData($where_condition: table_items_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_items_order_by!]) {\n  table_items(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    decoded_key\n    decoded_value\n    key\n    table_handle\n    transaction_version\n    write_set_change_index\n  }\n}\n    `;\nexport const GetTableItemsMetadata = `\n    query getTableItemsMetadata($where_condition: table_metadatas_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_metadatas_order_by!]) {\n  table_metadatas(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    handle\n    key_type\n    value_type\n  }\n}\n    `;\nexport const GetTokenActivity = `\n    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {\n  token_activities_v2(\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n    limit: $limit\n  ) {\n    ...TokenActivitiesFields\n  }\n}\n    ${TokenActivitiesFieldsFragmentDoc}`;\nexport const GetCurrentTokenOwnership = `\n    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetTokenData = `\n    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {\n  current_token_datas_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    decimals\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string,\n  variables?: any,\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getAccountAddressesForAuthKey(\n      variables?: Types.GetAccountAddressesForAuthKeyQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountAddressesForAuthKeyQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountAddressesForAuthKeyQuery>(GetAccountAddressesForAuthKey, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountAddressesForAuthKey\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountCoinsCount(\n      variables?: Types.GetAccountCoinsCountQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountCoinsCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCoinsCountQuery>(GetAccountCoinsCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountCoinsCount\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountCoinsData(\n      variables: Types.GetAccountCoinsDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountCoinsDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCoinsDataQuery>(GetAccountCoinsData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountCoinsData\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountCollectionsWithOwnedTokens(\n      variables: Types.GetAccountCollectionsWithOwnedTokensQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountCollectionsWithOwnedTokensQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCollectionsWithOwnedTokensQuery>(\n            GetAccountCollectionsWithOwnedTokens,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders },\n          ),\n        \"getAccountCollectionsWithOwnedTokens\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountOwnedTokens(\n      variables: Types.GetAccountOwnedTokensQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountOwnedTokensQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensQuery>(GetAccountOwnedTokens, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedTokens\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountOwnedTokensByTokenData(\n      variables: Types.GetAccountOwnedTokensByTokenDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountOwnedTokensByTokenDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensByTokenDataQuery>(GetAccountOwnedTokensByTokenData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedTokensByTokenData\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountOwnedTokensFromCollection(\n      variables: Types.GetAccountOwnedTokensFromCollectionQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountOwnedTokensFromCollectionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensFromCollectionQuery>(\n            GetAccountOwnedTokensFromCollection,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders },\n          ),\n        \"getAccountOwnedTokensFromCollection\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountTokensCount(\n      variables?: Types.GetAccountTokensCountQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountTokensCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountTokensCountQuery>(GetAccountTokensCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountTokensCount\",\n        \"query\",\n        variables,\n      );\n    },\n    getAccountTransactionsCount(\n      variables?: Types.GetAccountTransactionsCountQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAccountTransactionsCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountTransactionsCountQuery>(GetAccountTransactionsCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountTransactionsCount\",\n        \"query\",\n        variables,\n      );\n    },\n    getAuthKeysForPublicKey(\n      variables?: Types.GetAuthKeysForPublicKeyQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetAuthKeysForPublicKeyQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAuthKeysForPublicKeyQuery>(GetAuthKeysForPublicKey, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAuthKeysForPublicKey\",\n        \"query\",\n        variables,\n      );\n    },\n    getChainTopUserTransactions(\n      variables?: Types.GetChainTopUserTransactionsQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetChainTopUserTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetChainTopUserTransactionsQuery>(GetChainTopUserTransactions, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getChainTopUserTransactions\",\n        \"query\",\n        variables,\n      );\n    },\n    getCollectionData(\n      variables: Types.GetCollectionDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetCollectionDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCollectionDataQuery>(GetCollectionData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCollectionData\",\n        \"query\",\n        variables,\n      );\n    },\n    getCurrentFungibleAssetBalances(\n      variables?: Types.GetCurrentFungibleAssetBalancesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetCurrentFungibleAssetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCurrentFungibleAssetBalancesQuery>(GetCurrentFungibleAssetBalances, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCurrentFungibleAssetBalances\",\n        \"query\",\n        variables,\n      );\n    },\n    getDelegatedStakingActivities(\n      variables?: Types.GetDelegatedStakingActivitiesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetDelegatedStakingActivitiesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetDelegatedStakingActivitiesQuery>(GetDelegatedStakingActivities, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getDelegatedStakingActivities\",\n        \"query\",\n        variables,\n      );\n    },\n    getEvents(\n      variables?: Types.GetEventsQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetEventsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetEventsQuery>(GetEvents, variables, { ...requestHeaders, ...wrappedRequestHeaders }),\n        \"getEvents\",\n        \"query\",\n        variables,\n      );\n    },\n    getFungibleAssetActivities(\n      variables?: Types.GetFungibleAssetActivitiesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetFungibleAssetActivitiesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetFungibleAssetActivitiesQuery>(GetFungibleAssetActivities, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getFungibleAssetActivities\",\n        \"query\",\n        variables,\n      );\n    },\n    getFungibleAssetMetadata(\n      variables?: Types.GetFungibleAssetMetadataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetFungibleAssetMetadataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetFungibleAssetMetadataQuery>(GetFungibleAssetMetadata, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getFungibleAssetMetadata\",\n        \"query\",\n        variables,\n      );\n    },\n    getNames(\n      variables?: Types.GetNamesQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetNamesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetNamesQuery>(GetNames, variables, { ...requestHeaders, ...wrappedRequestHeaders }),\n        \"getNames\",\n        \"query\",\n        variables,\n      );\n    },\n    getNumberOfDelegators(\n      variables?: Types.GetNumberOfDelegatorsQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetNumberOfDelegatorsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetNumberOfDelegatorsQuery>(GetNumberOfDelegators, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getNumberOfDelegators\",\n        \"query\",\n        variables,\n      );\n    },\n    getObjectData(\n      variables?: Types.GetObjectDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetObjectDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetObjectDataQuery>(GetObjectData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getObjectData\",\n        \"query\",\n        variables,\n      );\n    },\n    getProcessorStatus(\n      variables?: Types.GetProcessorStatusQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetProcessorStatusQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetProcessorStatusQuery>(GetProcessorStatus, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getProcessorStatus\",\n        \"query\",\n        variables,\n      );\n    },\n    getTableItemsData(\n      variables: Types.GetTableItemsDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTableItemsDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTableItemsDataQuery>(GetTableItemsData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTableItemsData\",\n        \"query\",\n        variables,\n      );\n    },\n    getTableItemsMetadata(\n      variables: Types.GetTableItemsMetadataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTableItemsMetadataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTableItemsMetadataQuery>(GetTableItemsMetadata, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTableItemsMetadata\",\n        \"query\",\n        variables,\n      );\n    },\n    getTokenActivity(\n      variables: Types.GetTokenActivityQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTokenActivityQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTokenActivityQuery>(GetTokenActivity, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTokenActivity\",\n        \"query\",\n        variables,\n      );\n    },\n    getCurrentTokenOwnership(\n      variables: Types.GetCurrentTokenOwnershipQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetCurrentTokenOwnershipQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCurrentTokenOwnershipQuery>(GetCurrentTokenOwnership, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCurrentTokenOwnership\",\n        \"query\",\n        variables,\n      );\n    },\n    getTokenData(\n      variables?: Types.GetTokenDataQueryVariables,\n      requestHeaders?: GraphQLClientRequestHeaders,\n    ): Promise<Types.GetTokenDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTokenDataQuery>(GetTokenData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTokenData\",\n        \"query\",\n        variables,\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { aptosRequest } from \"./core\";\nimport { AptosResponse, AnyNumber, ClientConfig, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils/const\";\n\n/**\n * Options for making a POST request, including the API client configuration.\n * @group Implementation\n * @category Client\n */\nexport type PostRequestOptions = {\n  /**\n   * The config for the API client\n   * @group Implementation\n   * @category Client\n   */\n  aptosConfig: AptosConfig;\n  /**\n   * The type of API endpoint to call e.g. fullnode, indexer, etc\n   * @group Implementation\n   * @category Client\n   */\n  type: AptosApiType;\n  /**\n   * The name of the API method\n   * @group Implementation\n   * @category Client\n   */\n  originMethod: string;\n  /**\n   * The URL path to the API method\n   * @group Implementation\n   * @category Client\n   */\n  path: string;\n  /**\n   * The content type of the request body\n   * @group Implementation\n   * @category Client\n   */\n  contentType?: MimeType;\n  /**\n   * The accepted content type of the response of the API\n   * @group Implementation\n   * @category Client\n   */\n  acceptType?: MimeType;\n  /**\n   * The query parameters for the request\n   * @group Implementation\n   * @category Client\n   */\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  /**\n   * The body of the request, should match the content type of the request\n   * @group Implementation\n   * @category Client\n   */\n  body?: any;\n  /**\n   * Specific client overrides for this request to override aptosConfig\n   * @group Implementation\n   * @category Client\n   */\n  overrides?: ClientConfig;\n};\n\n/**\n * Options for posting a request to Aptos, excluding the type field.\n * @group Implementation\n * @category Client\n */\nexport type PostAptosRequestOptions = Omit<PostRequestOptions, \"type\">;\n\n/**\n * Executes a POST request to the specified URL with the provided options.\n *\n * @param options - The options for the POST request.\n * @param options.type - The type of the request.\n * @param options.originMethod - The original method that initiated the request.\n * @param options.path - The path for the request.\n * @param options.body - The body content to be sent with the request.\n * @param options.acceptType - The type of response expected from the server.\n * @param options.contentType - The content type of the request body.\n * @param options.params - Additional parameters to include in the request.\n * @param options.aptosConfig - Configuration settings for the Aptos request.\n * @param options.overrides - Any overrides for the default request behavior.\n * @returns The response from the POST request.\n * @group Implementation\n * @category Client\n */\nexport async function post<Req extends {}, Res extends {}>(\n  options: PostRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { type, originMethod, path, body, acceptType, contentType, params, aptosConfig, overrides } = options;\n  const url = aptosConfig.getRequestUrl(type);\n\n  return aptosRequest<Req, Res>(\n    {\n      url,\n      method: \"POST\",\n      originMethod,\n      path,\n      body,\n      contentType,\n      acceptType,\n      params,\n      overrides,\n    },\n    aptosConfig,\n    options.type,\n  );\n}\n\n/**\n * Sends a request to the Aptos full node using the specified options.\n * This function allows you to interact with the Aptos blockchain by sending requests to the full node.\n *\n * @param options - The options for the request.\n * @param options.aptosConfig - Configuration settings for the Aptos client.\n * @param options.aptosConfig.clientConfig - Client-specific configuration settings.\n * @param options.aptosConfig.fullnodeConfig - Full node-specific configuration settings.\n * @param options.overrides - Additional overrides for the request.\n * @group Implementation\n * @category Client\n */\nexport async function postAptosFullNode<Req extends {}, Res extends {}>(\n  options: PostAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig } = options;\n\n  return post<Req, Res>({\n    ...options,\n    type: AptosApiType.FULLNODE,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...aptosConfig.fullnodeConfig,\n      ...options.overrides,\n      HEADERS: { ...aptosConfig.clientConfig?.HEADERS, ...aptosConfig.fullnodeConfig?.HEADERS },\n    },\n  });\n}\n\n/**\n * Sends a request to the Aptos indexer with the specified options.\n * This function allows you to interact with the Aptos indexer and customize the request using various configurations.\n *\n * @param options - The options for the request to the Aptos indexer.\n * @param options.aptosConfig - Configuration settings specific to the Aptos client and indexer.\n * @param options.aptosConfig.clientConfig - The client configuration settings.\n * @param options.aptosConfig.indexerConfig - The indexer configuration settings.\n * @param options.overrides - Additional overrides for the request.\n * @param options.overrides.HEADERS - Custom headers to include in the request.\n * @group Implementation\n * @category Client\n */\nexport async function postAptosIndexer<Req extends {}, Res extends {}>(\n  options: PostAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig } = options;\n\n  return post<Req, Res>({\n    ...options,\n    type: AptosApiType.INDEXER,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...aptosConfig.indexerConfig,\n      ...options.overrides,\n      HEADERS: { ...aptosConfig.clientConfig?.HEADERS, ...aptosConfig.indexerConfig?.HEADERS },\n    },\n  });\n}\n\n/**\n * Sends a request to the Aptos faucet to obtain test tokens.\n * This function modifies the provided configuration to ensure that the API_KEY is not included in the request.\n *\n * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n * the minting page at https://aptos.dev/network/faucet.\n *\n * @param options - The options for the request.\n * @param options.aptosConfig - The configuration settings for the Aptos client.\n * @param options.aptosConfig.clientConfig - The client-specific configuration settings.\n * @param options.aptosConfig.clientConfig.HEADERS - Optional headers to include in the request.\n * @param options.aptosConfig.faucetConfig - The configuration settings specific to the faucet.\n * @param options.overrides - Additional overrides for the request configuration.\n * @group Implementation\n * @category Client\n */\nexport async function postAptosFaucet<Req extends {}, Res extends {}>(\n  options: PostAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig } = options;\n  // Faucet does not support API_KEY\n  // Create a new object with the desired modification\n  const modifiedAptosConfig = {\n    ...aptosConfig,\n    clientConfig: { ...aptosConfig.clientConfig },\n  };\n  // Delete API_KEY config\n  delete modifiedAptosConfig?.clientConfig?.API_KEY;\n\n  return post<Req, Res>({\n    ...options,\n    type: AptosApiType.FAUCET,\n    overrides: {\n      ...modifiedAptosConfig.clientConfig,\n      ...modifiedAptosConfig.faucetConfig,\n      ...options.overrides,\n      HEADERS: { ...modifiedAptosConfig.clientConfig?.HEADERS, ...modifiedAptosConfig.faucetConfig?.HEADERS },\n    },\n  });\n}\n\n/**\n * Makes a post request to the pepper service.\n *\n * @param options - The options for the request.\n * @param options.url - The URL to which the request is sent.\n * @param options.headers - The headers to include in the request.\n * @param options.body - The body of the request.\n * @returns A promise that resolves to the response from the pepper service.\n * @group Implementation\n * @category Client\n */\nexport async function postAptosPepperService<Req extends {}, Res extends {}>(\n  options: PostAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  return post<Req, Res>({ ...options, type: AptosApiType.PEPPER });\n}\n\n/**\n * Sends a request to the Aptos proving service with the specified options.\n *\n * @param options - The options for the request to the Aptos proving service.\n * @param options.type - The type of the request, which should be set to AptosApiType.PROVER.\n * @param options.data - The data to be included in the request.\n * @group Implementation\n * @category Client\n */\nexport async function postAptosProvingService<Req extends {}, Res extends {}>(\n  options: PostAptosRequestOptions,\n): Promise<AptosResponse<Req, Res>> {\n  return post<Req, Res>({ ...options, type: AptosApiType.PROVER });\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/general}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * general namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, postAptosIndexer } from \"../client\";\nimport { GetChainTopUserTransactionsResponse, GetProcessorStatusResponse, GraphqlQuery, LedgerInfo } from \"../types\";\nimport { GetChainTopUserTransactionsQuery, GetProcessorStatusQuery } from \"../types/generated/operations\";\nimport { GetChainTopUserTransactions, GetProcessorStatus } from \"../types/generated/queries\";\nimport { ProcessorType } from \"../utils/const\";\n\n/**\n * Retrieves information about the current ledger.\n *\n * @param args - The arguments for retrieving ledger information.\n * @param args.aptosConfig - The configuration object for connecting to the Aptos network.\n * @group Implementation\n */\nexport async function getLedgerInfo(args: { aptosConfig: AptosConfig }): Promise<LedgerInfo> {\n  const { aptosConfig } = args;\n  const { data } = await getAptosFullNode<{}, LedgerInfo>({\n    aptosConfig,\n    originMethod: \"getLedgerInfo\",\n    path: \"\",\n  });\n  return data;\n}\n\n/**\n * Retrieves the top user transactions for a specific blockchain chain.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.limit - The maximum number of transactions to retrieve.\n * @returns An array of user transactions.\n * @group Implementation\n */\nexport async function getChainTopUserTransactions(args: {\n  aptosConfig: AptosConfig;\n  limit: number;\n}): Promise<GetChainTopUserTransactionsResponse> {\n  const { aptosConfig, limit } = args;\n  const graphqlQuery = {\n    query: GetChainTopUserTransactions,\n    variables: { limit },\n  };\n\n  const data = await queryIndexer<GetChainTopUserTransactionsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getChainTopUserTransactions\",\n  });\n\n  return data.user_transactions;\n}\n\n/**\n * Executes a GraphQL query against the Aptos indexer and retrieves the resulting data.\n *\n * @param args - The arguments for the query.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.query - The GraphQL query to be executed.\n * @param args.originMethod - An optional string to specify the origin method for tracking purposes.\n * @returns The data returned from the query execution.\n * @group Implementation\n */\nexport async function queryIndexer<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  query: GraphqlQuery;\n  originMethod?: string;\n}): Promise<T> {\n  const { aptosConfig, query, originMethod } = args;\n  const { data } = await postAptosIndexer<GraphqlQuery, T>({\n    aptosConfig,\n    originMethod: originMethod ?? \"queryIndexer\",\n    path: \"\",\n    body: query,\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return data;\n}\n\n/**\n * Retrieves the current statuses of processors.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @returns The statuses of the processors.\n * @group Implementation\n */\nexport async function getProcessorStatuses(args: { aptosConfig: AptosConfig }): Promise<GetProcessorStatusResponse> {\n  const { aptosConfig } = args;\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatuses\",\n  });\n\n  return data.processor_status;\n}\n\n/**\n * Retrieves the last success version from the indexer.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @returns The last success version as a BigInt.\n * @group Implementation\n */\nexport async function getIndexerLastSuccessVersion(args: { aptosConfig: AptosConfig }): Promise<bigint> {\n  const response = await getProcessorStatuses({ aptosConfig: args.aptosConfig });\n  return BigInt(response[0].last_success_version);\n}\n\n/**\n * Retrieves the status of a specified processor in the Aptos network.\n * This function allows you to check the current operational status of a processor, which can be useful for monitoring and troubleshooting.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for connecting to the Aptos network.\n * @param args.processorType - The type of processor whose status you want to retrieve.\n * @returns The status of the specified processor.\n * @group Implementation\n */\nexport async function getProcessorStatus(args: {\n  aptosConfig: AptosConfig;\n  processorType: ProcessorType;\n}): Promise<GetProcessorStatusResponse[0]> {\n  const { aptosConfig, processorType } = args;\n\n  const whereCondition: { processor: { _eq: string } } = {\n    processor: { _eq: processorType },\n  };\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatus\",\n  });\n\n  return data.processor_status[0];\n}\n", "import { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosFullNode } from \"../client\";\nimport {\n  TableItemRequest,\n  LedgerVersionArg,\n  PaginationArgs,\n  WhereArg,\n  OrderByArg,\n  GetTableItemsDataResponse,\n  GetTableItemsMetadataResponse,\n} from \"../types\";\nimport { GetTableItemsDataQuery, GetTableItemsMetadataQuery } from \"../types/generated/operations\";\nimport { GetTableItemsData, GetTableItemsMetadata } from \"../types/generated/queries\";\nimport { TableItemsBoolExp, TableMetadatasBoolExp } from \"../types/generated/types\";\nimport { queryIndexer } from \"./general\";\n\n/**\n * Retrieves a specific item from a table in the Aptos blockchain.\n *\n * @param args - The arguments for retrieving the table item.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.handle - The identifier for the table from which to retrieve the item.\n * @param args.data - The request data for the table item.\n * @param args.options - Optional parameters for the request, including ledger version.\n * @group Implementation\n */\nexport async function getTableItem<T>(args: {\n  aptosConfig: AptosConfig;\n  handle: string;\n  data: TableItemRequest;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, handle, data, options } = args;\n  const response = await postAptosFullNode<TableItemRequest, any>({\n    aptosConfig,\n    originMethod: \"getTableItem\",\n    path: `tables/${handle}/item`,\n    params: { ledger_version: options?.ledgerVersion },\n    body: data,\n  });\n  return response.data as T;\n}\n\n/**\n * Retrieves table items data based on specified conditions and pagination options.\n *\n * @param args - The arguments for retrieving table items data.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for pagination and filtering.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.where - Conditions to filter the table items.\n * @param args.options.orderBy - The criteria to sort the results.\n * @group Implementation\n */\nexport async function getTableItemsData(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<TableItemsBoolExp> & OrderByArg<GetTableItemsDataResponse[0]>;\n}) {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetTableItemsData,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetTableItemsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTableItemsData\",\n  });\n\n  return data.table_items;\n}\n\n/**\n * Retrieves metadata for table items based on specified options.\n *\n * @param args - The arguments for retrieving table items metadata.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for pagination and filtering.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.where - Conditions to filter the results.\n * @param args.options.orderBy - The order in which to return the results.\n * @returns A promise that resolves to an array of table metadata.\n * @group Implementation\n */\nexport async function getTableItemsMetadata(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<TableMetadatasBoolExp> & OrderByArg<GetTableItemsMetadataResponse[0]>;\n}): Promise<GetTableItemsMetadataResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetTableItemsMetadata,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetTableItemsMetadataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTableItemsMetadata\",\n  });\n\n  return data.table_metadatas;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Types of API endpoints used for routing requests in the Aptos network.\n * @group Implementation\n * @category Utils\n */\nexport enum AptosApiType {\n  FULLNODE = \"Fullnode\",\n  INDEXER = \"Indexer\",\n  FAUCET = \"Faucet\",\n  PEPPER = \"Pepper\",\n  PROVER = \"Prover\",\n}\n\n/**\n * The default max gas amount when none is given.\n *\n * This is the maximum number of gas units that will be used by a transaction before being rejected.\n *\n * Note that max gas amount varies based on the transaction.  A larger transaction will go over this\n * default gas amount, and the value will need to be changed for the specific transaction.\n * @group Implementation\n * @category Utils\n */\nexport const DEFAULT_MAX_GAS_AMOUNT = 200000;\n\n/**\n * The default transaction expiration seconds from now.\n *\n * This time is how long until the blockchain nodes will reject the transaction.\n *\n * Note that the transaction expiration time varies based on network connection and network load.  It may need to be\n * increased for the transaction to be processed.\n * @group Implementation\n * @category Utils\n */\nexport const DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;\n\n/**\n * The default number of seconds to wait for a transaction to be processed.\n *\n * This time is the amount of time that the SDK will wait for a transaction to be processed when waiting for\n * the results of the transaction.  It may take longer based on network connection and network load.\n * @group Implementation\n * @category Utils\n */\nexport const DEFAULT_TXN_TIMEOUT_SEC = 20;\n\n/**\n * The default gas currency for the network.\n * @group Implementation\n * @category Utils\n */\nexport const APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\n/**\n * @group Implementation\n * @category Utils\n */\nexport const APTOS_FA = \"0x000000000000000000000000000000000000000000000000000000000000000a\";\n/**\n * @group Implementation\n * @category Utils\n */\nexport const RAW_TRANSACTION_SALT = \"APTOS::RawTransaction\";\n/**\n * @group Implementation\n * @category Utils\n */\nexport const RAW_TRANSACTION_WITH_DATA_SALT = \"APTOS::RawTransactionWithData\";\n\n/**\n * Supported processor types for the indexer API, sourced from the processor_status table in the indexer database.\n * {@link https://cloud.hasura.io/public/graphiql?endpoint=https://api.mainnet.aptoslabs.com/v1/graphql}\n * @group Implementation\n * @category Utils\n */\nexport enum ProcessorType {\n  ACCOUNT_RESTORATION_PROCESSOR = \"account_restoration_processor\",\n  ACCOUNT_TRANSACTION_PROCESSOR = \"account_transactions_processor\",\n  DEFAULT = \"default_processor\",\n  EVENTS_PROCESSOR = \"events_processor\",\n  // Fungible asset processor also handles coins\n  FUNGIBLE_ASSET_PROCESSOR = \"fungible_asset_processor\",\n  STAKE_PROCESSOR = \"stake_processor\",\n  // Token V2 processor replaces Token processor (not only for digital assets)\n  TOKEN_V2_PROCESSOR = \"token_v2_processor\",\n  USER_TRANSACTION_PROCESSOR = \"user_transaction_processor\",\n  OBJECT_PROCESSOR = \"objects_processor\",\n}\n\n/**\n * Regular expression pattern for Firebase Auth issuer URLs\n * Matches URLs in the format: https://securetoken.google.com/[project-id]\n * where project-id can contain letters, numbers, hyphens, and underscores\n */\nexport const FIREBASE_AUTH_ISS_PATTERN = /^https:\\/\\/securetoken\\.google\\.com\\/[a-zA-Z0-9-_]+$/;\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, paginateWithCursor } from \"../client\";\nimport { AptosApiError } from \"../errors\";\nimport {\n  TransactionResponseType,\n  type AnyNumber,\n  type GasEstimation,\n  type HexInput,\n  type PaginationArgs,\n  type TransactionResponse,\n  WaitForTransactionOptions,\n  CommittedTransactionResponse,\n  Block,\n} from \"../types\";\nimport { DEFAULT_TXN_TIMEOUT_SEC, ProcessorType } from \"../utils/const\";\nimport { sleep } from \"../utils/helpers\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { getIndexerLastSuccessVersion, getProcessorStatus } from \"./general\";\n\n/**\n * Retrieve a list of transactions based on the specified options.\n *\n * @param {Object} args - The parameters for retrieving transactions.\n * @param {Object} args.aptosConfig - The configuration object for Aptos.\n * @param {Object} args.options - The options for pagination.\n * @param {number} args.options.offset - The number of transactions to skip before starting to collect the result set.\n * @param {number} args.options.limit - The maximum number of transactions to return.\n * @group Implementation\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves the estimated gas price for transactions on the Aptos network.\n * This function helps users understand the current gas price, which is essential for transaction planning and cost estimation.\n *\n * @param args - The configuration parameters for the Aptos network.\n * @param args.aptosConfig - The configuration object containing network details.\n * @group Implementation\n */\nexport async function getGasPriceEstimation(args: { aptosConfig: AptosConfig }) {\n  const { aptosConfig } = args;\n\n  return memoizeAsync(\n    async () => {\n      const { data } = await getAptosFullNode<{}, GasEstimation>({\n        aptosConfig,\n        originMethod: \"getGasPriceEstimation\",\n        path: \"estimate_gas_price\",\n      });\n      return data;\n    },\n    `gas-price-${aptosConfig.network}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\n/**\n * Retrieves the transaction details associated with a specific ledger version.\n *\n * @param args - The arguments for the transaction retrieval.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.ledgerVersion - The ledger version for which to retrieve the transaction.\n * @returns The transaction details for the specified ledger version.\n * @group Implementation\n */\nexport async function getTransactionByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, ledgerVersion } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    originMethod: \"getTransactionByVersion\",\n    path: `transactions/by_version/${ledgerVersion}`,\n  });\n  return data;\n}\n\n/**\n * Retrieves transaction details using the specified transaction hash.\n *\n * @param args - The arguments for retrieving the transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.transactionHash - The hash of the transaction to retrieve.\n * @returns A promise that resolves to the transaction details.\n * @group Implementation\n */\nexport async function getTransactionByHash(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, transactionHash } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    path: `transactions/by_hash/${transactionHash}`,\n    originMethod: \"getTransactionByHash\",\n  });\n  return data;\n}\n\n/**\n * Checks if a transaction is currently pending based on its hash.\n * This function helps determine the status of a transaction in the Aptos network.\n *\n * @param args - The arguments for checking the transaction status.\n * @param args.aptosConfig - The configuration settings for connecting to the Aptos network.\n * @param args.transactionHash - The hash of the transaction to check.\n * @returns A boolean indicating whether the transaction is pending.\n * @throws An error if the transaction cannot be retrieved due to reasons other than a 404 status.\n * @group Implementation\n */\nexport async function isTransactionPending(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<boolean> {\n  const { aptosConfig, transactionHash } = args;\n  try {\n    const transaction = await getTransactionByHash({ aptosConfig, transactionHash });\n    return transaction.type === TransactionResponseType.Pending;\n  } catch (e: any) {\n    if (e?.status === 404) {\n      return true;\n    }\n    throw e;\n  }\n}\n\n/**\n * Waits for a transaction to be confirmed by its hash.\n * This function allows you to monitor the status of a transaction until it is finalized.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.transactionHash - The hash of the transaction to wait for.\n * @group Implementation\n */\nexport async function longWaitForTransaction(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, transactionHash } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    path: `transactions/wait_by_hash/${transactionHash}`,\n    originMethod: \"longWaitForTransaction\",\n  });\n  return data;\n}\n\n/**\n * Waits for a transaction to be confirmed on the blockchain and handles potential errors during the process.\n * This function allows you to monitor the status of a transaction until it is either confirmed or fails.\n *\n * @param args - The arguments for waiting for a transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.transactionHash - The hash of the transaction to wait for.\n * @param args.options - Optional settings for waiting, including timeout and success check.\n * @param args.options.timeoutSecs - The maximum time to wait for the transaction in seconds. Defaults to a predefined value.\n * @param args.options.checkSuccess - A flag indicating whether to check the success status of the transaction. Defaults to true.\n * @returns A promise that resolves to the transaction response once the transaction is confirmed.\n * @throws WaitForTransactionError if the transaction times out or remains pending.\n * @throws FailedTransactionError if the transaction fails.\n * @group Implementation\n */\nexport async function waitForTransaction(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n  options?: WaitForTransactionOptions;\n}): Promise<CommittedTransactionResponse> {\n  const { aptosConfig, transactionHash, options } = args;\n  const timeoutSecs = options?.timeoutSecs ?? DEFAULT_TXN_TIMEOUT_SEC;\n  const checkSuccess = options?.checkSuccess ?? true;\n\n  let isPending = true;\n  let timeElapsed = 0;\n  let lastTxn: TransactionResponse | undefined;\n  let lastError: AptosApiError | undefined;\n  let backoffIntervalMs = 200;\n  const backoffMultiplier = 1.5;\n\n  /**\n   * Handles API errors by throwing the last error or a timeout error for a failed transaction.\n   *\n   * @param e - The error object that occurred during the API call.\n   * @throws {Error} Throws the last error if it exists; otherwise, throws a WaitForTransactionError indicating a timeout.\n   * @group Implementation\n   */\n  function handleAPIError(e: any) {\n    // In short, this means we will retry if it was an AptosApiError and the code was 404 or 5xx.\n    const isAptosApiError = e instanceof AptosApiError;\n    if (!isAptosApiError) {\n      throw e; // This would be unexpected\n    }\n    lastError = e;\n    const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;\n    if (isRequestError) {\n      throw e;\n    }\n  }\n\n  // check to see if the txn is already on the blockchain\n  try {\n    lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });\n    isPending = lastTxn.type === TransactionResponseType.Pending;\n  } catch (e) {\n    handleAPIError(e);\n  }\n\n  // If the transaction is pending, we do a long wait once to avoid polling\n  if (isPending) {\n    const startTime = Date.now();\n    try {\n      lastTxn = await longWaitForTransaction({ aptosConfig, transactionHash });\n      isPending = lastTxn.type === TransactionResponseType.Pending;\n    } catch (e) {\n      handleAPIError(e);\n    }\n    timeElapsed = (Date.now() - startTime) / 1000;\n  }\n\n  // Now we do polling to see if the transaction is still pending\n  while (isPending) {\n    if (timeElapsed >= timeoutSecs) {\n      break;\n    }\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });\n\n      isPending = lastTxn.type === TransactionResponseType.Pending;\n\n      if (!isPending) {\n        break;\n      }\n    } catch (e) {\n      handleAPIError(e);\n    }\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(backoffIntervalMs);\n    timeElapsed += backoffIntervalMs / 1000; // Convert to seconds\n    backoffIntervalMs *= backoffMultiplier;\n  }\n\n  // There is a chance that lastTxn is still undefined. Let's throw the last error otherwise a WaitForTransactionError\n  if (lastTxn === undefined) {\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new WaitForTransactionError(\n        `Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`,\n        lastTxn,\n      );\n    }\n  }\n\n  if (lastTxn.type === TransactionResponseType.Pending) {\n    throw new WaitForTransactionError(\n      `Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`,\n      lastTxn,\n    );\n  }\n  if (!checkSuccess) {\n    return lastTxn;\n  }\n  if (!lastTxn.success) {\n    throw new FailedTransactionError(\n      `Transaction ${transactionHash} failed with an error: ${lastTxn.vm_status}`,\n      lastTxn,\n    );\n  }\n\n  return lastTxn;\n}\n\n/**\n * Waits for the indexer to sync up to the specified ledger version. The timeout is 3 seconds.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.minimumLedgerVersion - The minimum ledger version that the indexer should sync to.\n * @param args.processorType - (Optional) The type of processor to check the last success version from.\n * @group Implementation\n */\nexport async function waitForIndexer(args: {\n  aptosConfig: AptosConfig;\n  minimumLedgerVersion: AnyNumber;\n  processorType?: ProcessorType;\n}): Promise<void> {\n  const { aptosConfig, processorType } = args;\n  const minimumLedgerVersion = BigInt(args.minimumLedgerVersion);\n  const timeoutMilliseconds = 3000; // 3 seconds\n  const startTime = new Date().getTime();\n  let indexerVersion = BigInt(-1);\n\n  while (indexerVersion < minimumLedgerVersion) {\n    // check for timeout\n    if (new Date().getTime() - startTime > timeoutMilliseconds) {\n      throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    }\n\n    if (processorType === undefined) {\n      // Get the last success version from all processor\n      // eslint-disable-next-line no-await-in-loop\n      indexerVersion = await getIndexerLastSuccessVersion({ aptosConfig });\n    } else {\n      // Get the last success version from the specific processor\n      // eslint-disable-next-line no-await-in-loop\n      const processor = await getProcessorStatus({ aptosConfig, processorType });\n      indexerVersion = processor.last_success_version;\n    }\n\n    if (indexerVersion >= minimumLedgerVersion) {\n      // break out immediately if we are synced\n      break;\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(200);\n  }\n}\n\n/**\n * Represents an error that occurs when waiting for a transaction to complete.\n * This error is thrown by the `waitForTransaction` function when a transaction\n * times out or when the transaction response is undefined.\n *\n * @param message - A descriptive message for the error.\n * @param lastSubmittedTransaction - The last submitted transaction response, if available.\n * @group Implementation\n */\nexport class WaitForTransactionError extends Error {\n  public readonly lastSubmittedTransaction: TransactionResponse | undefined;\n\n  /**\n   * Constructs an instance of the class with a specified message and transaction response.\n   *\n   * @param message - The message associated with the transaction.\n   * @param lastSubmittedTransaction - The transaction response object containing details about the transaction.\n   * @group Implementation\n   */\n  constructor(message: string, lastSubmittedTransaction: TransactionResponse | undefined) {\n    super(message);\n    this.lastSubmittedTransaction = lastSubmittedTransaction;\n  }\n}\n\n/**\n * Represents an error that occurs when a transaction fails.\n * This error is thrown by the `waitForTransaction` function when the `checkSuccess` parameter is set to true.\n *\n * @param message - A description of the error.\n * @param transaction - The transaction response associated with the failure.\n * @group Implementation\n */\nexport class FailedTransactionError extends Error {\n  public readonly transaction: TransactionResponse;\n\n  constructor(message: string, transaction: TransactionResponse) {\n    super(message);\n    this.transaction = transaction;\n  }\n}\n\n/**\n * Retrieves a block from the Aptos blockchain by its ledger version.\n * This function allows you to obtain detailed information about a specific block, including its transactions if requested.\n *\n * @param args - The arguments for retrieving the block.\n * @param args.aptosConfig - The configuration object for connecting to the Aptos node.\n * @param args.ledgerVersion - The ledger version of the block to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.withTransactions - Indicates whether to include transactions in the block data.\n * @group Implementation\n */\nexport async function getBlockByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, ledgerVersion, options } = args;\n  const { data: block } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByVersion\",\n    path: `blocks/by_version/${ledgerVersion}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n\n  return fillBlockTransactions({ block, ...args });\n}\n\n/**\n * Retrieves a block from the Aptos blockchain by its height.\n *\n * @param args - The parameters for retrieving the block.\n * @param args.aptosConfig - The configuration object for connecting to the Aptos network.\n * @param args.blockHeight - The height of the block to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.withTransactions - Indicates whether to include transactions in the block data.\n * @returns A promise that resolves to the block data, potentially including its transactions.\n * @group Implementation\n */\nexport async function getBlockByHeight(args: {\n  aptosConfig: AptosConfig;\n  blockHeight: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, blockHeight, options } = args;\n  const { data: block } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByHeight\",\n    path: `blocks/by_height/${blockHeight}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n  return fillBlockTransactions({ block, ...args });\n}\n\n/**\n * Fills in the block with transactions if not enough were returned. This function ensures that the block contains all relevant\n * transactions by fetching any missing ones based on the specified options.\n * @param args - The arguments for filling the block transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.block - The block object that will be filled with transactions.\n * @param args.options - Optional settings for fetching transactions.\n * @param args.options.withTransactions - Indicates whether to include transactions in the block.\n * @group Implementation\n */\nasync function fillBlockTransactions(args: {\n  aptosConfig: AptosConfig;\n  block: Block;\n  options?: { withTransactions?: boolean };\n}) {\n  const { aptosConfig, block, options } = args;\n  if (options?.withTransactions) {\n    // Transactions should be filled, but this ensures it\n    block.transactions = block.transactions ?? [];\n\n    const lastTxn = block.transactions[block.transactions.length - 1];\n    const firstVersion = BigInt(block.first_version);\n    const lastVersion = BigInt(block.last_version);\n\n    // Convert the transaction to the type\n    const curVersion: string | undefined = (lastTxn as any)?.version;\n    let latestVersion;\n\n    // This time, if we don't have any transactions, we will try once with the start of the block\n    if (curVersion === undefined) {\n      latestVersion = firstVersion - 1n;\n    } else {\n      latestVersion = BigInt(curVersion);\n    }\n\n    // If we have all the transactions in the block, we can skip out, otherwise we need to fill the transactions\n    if (latestVersion === lastVersion) {\n      return block;\n    }\n\n    // For now, we will grab all the transactions in groups of 100, but we can make this more efficient by trying larger\n    // amounts\n    const fetchFutures = [];\n    const pageSize = 100n;\n    for (let i = latestVersion + 1n; i < lastVersion; i += BigInt(100)) {\n      fetchFutures.push(\n        getTransactions({\n          aptosConfig,\n          options: {\n            offset: i,\n            limit: Math.min(Number(pageSize), Number(lastVersion - i + 1n)),\n          },\n        }),\n      );\n    }\n\n    // Combine all the futures\n    const responses = await Promise.all(fetchFutures);\n    for (const txns of responses) {\n      block.transactions.push(...txns);\n    }\n  }\n\n  return block;\n}\n", "import { waitForIndexer } from \"../internal/transaction\";\nimport { ProcessorType } from \"../utils\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { AnyNumber } from \"../types\";\n\n/**\n * Waits for the indexer to reach a specified ledger version, allowing for synchronization with the blockchain.\n * This function is useful for ensuring that your application is working with the most up-to-date data before proceeding.\n *\n * @param args - The parameters for waiting on the indexer.\n * @param args.config - The configuration object for Aptos.\n * @param [args.minimumLedgerVersion] - The minimum ledger version to wait for. If not specified, the function will not wait.\n * @param args.processorType - The type of processor to wait for.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network, ProcessorType } from \"@aptos-labs/ts-sdk\";\n *\n * const config = new AptosConfig({ network: Network.TESTNET });\n * const aptos = new Aptos(config);\n *\n * async function runExample() {\n *   // Wait for the indexer to reach a specific ledger version\n *   await aptos.waitForIndexerOnVersion({\n *     config: config,\n *     minimumLedgerVersion: 1000n, // replace with a real ledger version\n *     processorType: ProcessorType.DEFAULT,\n *   });\n *\n *   console.log(\"Indexer is synced to the specified ledger version.\");\n * }\n * runExample().catch(console.error);\n * ```\n * @group Implementation\n */\nexport async function waitForIndexerOnVersion(args: {\n  config: AptosConfig;\n  minimumLedgerVersion?: AnyNumber;\n  processorType: ProcessorType;\n}) {\n  if (args.minimumLedgerVersion !== undefined) {\n    await waitForIndexer({\n      aptosConfig: args.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: args.processorType,\n    });\n  }\n}\n", "import { getTableItem, getTableItemsData, getTableItemsMetadata } from \"../internal/table\";\nimport {\n  TableItemRequest,\n  LedgerVersionArg,\n  AnyNumber,\n  PaginationArgs,\n  WhereArg,\n  OrderByArg,\n  GetTableItemsDataResponse,\n  GetTableItemsMetadataResponse,\n} from \"../types\";\nimport { TableItemsBoolExp, TableMetadatasBoolExp } from \"../types/generated/types\";\nimport { ProcessorType } from \"../utils\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\n\n/**\n * A class to query all `Table` Aptos related queries.\n * @group Table\n */\nexport class Table {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Table\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries for a specific item in a table identified by the handle and the key for the item.\n   * This function allows you to retrieve structured data from a table in the Aptos blockchain.\n   *\n   * @param args.handle A pointer to where that table is stored.\n   * @param args.data Object that describes the table item, including key and value types.\n   * @param args.data.key_type The Move type of the table key.\n   * @param args.data.value_type The Move type of the table value.\n   * @param args.data.key The value of the table key.\n   * @param args.options.ledgerVersion The ledger version to query; if not provided, it will get the latest version.\n   *\n   * @returns Table item value rendered in JSON.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve a table item from the Aptos blockchain\n   *   const tableItem = await aptos.getTableItem({\n   *     handle: \"0x1b854694ae746cdbd8d44186ca4929b2b337df21d1c74633be19b2710552fdca\",\n   *     data: {\n   *       key_type: \"address\", // Move type of table key\n   *       value_type: \"u128\", // Move type of table value\n   *       key: \"0x619dc29a0aac8fa146714058e8dd6d2d0f3bdf5f6331907bf91f3acd81e6935\" // Value of table key\n   *     },\n   *   });\n   *\n   *   console.log(tableItem);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Table\n   */\n  async getTableItem<T>(args: { handle: string; data: TableItemRequest; options?: LedgerVersionArg }): Promise<T> {\n    return getTableItem<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for table items data with optional filtering and pagination.\n   * This function allows you to retrieve specific data from a table based on provided criteria.\n   *\n   * @param args - The arguments for querying table items data.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to wait for before querying.\n   * @param args.options - Optional parameters for pagination and filtering.\n   * @param args.options.where - Conditions to filter the response.\n   * @param args.options.offset - The number of items to skip before starting to collect the result set.\n   * @param args.options.limit - The maximum number of items to return.\n   * @param args.options.orderBy - The criteria to order the results.\n   *\n   * Note: This query calls the indexer server.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve table items data with specific filtering options\n   *   const data = await aptos.getTableItemsData({\n   *     minimumLedgerVersion: 1, // specify your own minimum ledger version if needed\n   *     options: {\n   *       where: {\n   *         table_handle: { _eq: \"0x1b854694ae746cdbd8d44186ca4929b2b337df21d1c74633be19b2710552fdca\" },\n   *         transaction_version: { _eq: \"0\" }\n   *       },\n   *       limit: 10, // specify your own limit if needed\n   *     },\n   *   });\n   *\n   *   console.log(data);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   *\n   * @returns GetTableItemsDataResponse\n   * @group Table\n   */\n  async getTableItemsData(args: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<TableItemsBoolExp> & OrderByArg<GetTableItemsDataResponse[0]>;\n  }): Promise<GetTableItemsDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.DEFAULT,\n    });\n    return getTableItemsData({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for the metadata of table items, allowing for filtering and pagination.\n   *\n   * @param args - The parameters for the query.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to wait for before querying.\n   * @param args.options - Optional parameters for pagination and filtering.\n   * @param args.options.where - Conditions to filter the response.\n   * @param args.options.offset - The offset for pagination.\n   * @param args.options.limit - The maximum number of items to return.\n   * @param args.options.orderBy - The order in which to return the items.\n   *\n   * Note that this query calls the indexer server.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching table items metadata with a filter condition\n   *   const data = await aptos.getTableItemsMetadata({\n   *     minimumLedgerVersion: 1, // specify your own minimum ledger version if needed\n   *     options: {\n   *       where: { handle: { _eq: \"0x1b854694ae746cdbd8d44186ca4929b2b337df21d1c74633be19b2710552fdca\" } },\n   *       limit: 10, // specify your own limit if needed\n   *     },\n   *   });\n   *\n   *   console.log(data);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   *\n   * @returns GetTableItemsMetadataResponse\n   * @group Table\n   */\n  async getTableItemsMetadata(args: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<TableMetadatasBoolExp> & OrderByArg<GetTableItemsMetadataResponse[0]>;\n  }): Promise<GetTableItemsMetadataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.DEFAULT,\n    });\n    return getTableItemsMetadata({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializable } from \"../bcs\";\n/**\n * @group Implementation\n * @category Utils\n */\nexport type DeserializableClass<T extends Serializable> = {\n  /**\n   * Deserializes a serialized object using the provided deserializer.\n   * This function allows you to reconstruct an object from its serialized form.\n   *\n   * @param deserializer - An instance of the Deserializer used to read the serialized data.\n   * @group Implementation\n   * @category Utils\n   */\n  deserialize(deserializer: Deserializer): T;\n};\n\n/**\n * Normalizes an instance of a class by deserializing it from its byte representation.\n * This function allows the `instanceof` operator to work correctly when the input objects originate from a different bundle.\n *\n * @param cls - The class of the object to normalize.\n * @param value - The instance to normalize.\n * @group Implementation\n * @category Utils\n */\nexport function normalizeBundle<T extends Serializable>(cls: DeserializableClass<T>, value: T) {\n  const serializedBytes = value.bcsToBytes();\n  const deserializer = new Deserializer(serializedBytes);\n  return cls.deserialize(deserializer);\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToIndexerAPI: Record<string, string> = {\n  mainnet: \"https://api.mainnet.aptoslabs.com/v1/graphql\",\n  testnet: \"https://api.testnet.aptoslabs.com/v1/graphql\",\n  devnet: \"https://api.devnet.aptoslabs.com/v1/graphql\",\n  local: \"http://127.0.0.1:8090/v1/graphql\",\n};\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToNodeAPI: Record<string, string> = {\n  mainnet: \"https://api.mainnet.aptoslabs.com/v1\",\n  testnet: \"https://api.testnet.aptoslabs.com/v1\",\n  devnet: \"https://api.devnet.aptoslabs.com/v1\",\n  local: \"http://127.0.0.1:8080/v1\",\n};\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToFaucetAPI: Record<string, string> = {\n  devnet: \"https://faucet.devnet.aptoslabs.com\",\n  local: \"http://127.0.0.1:8081\",\n};\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToPepperAPI: Record<string, string> = {\n  mainnet: \"https://api.mainnet.aptoslabs.com/keyless/pepper/v0\",\n  testnet: \"https://api.testnet.aptoslabs.com/keyless/pepper/v0\",\n  devnet: \"https://api.devnet.aptoslabs.com/keyless/pepper/v0\",\n  // Use the devnet service for local environment\n  local: \"https://api.devnet.aptoslabs.com/keyless/pepper/v0\",\n};\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToProverAPI: Record<string, string> = {\n  mainnet: \"https://api.mainnet.aptoslabs.com/keyless/prover/v0\",\n  testnet: \"https://api.testnet.aptoslabs.com/keyless/prover/v0\",\n  devnet: \"https://api.devnet.aptoslabs.com/keyless/prover/v0\",\n  // Use the devnet service for local environment\n  local: \"https://api.devnet.aptoslabs.com/keyless/prover/v0\",\n};\n\n/**\n * Different network environments for connecting to services, ranging from production to development setups.\n * @group Implementation\n * @category Network\n */\nexport enum Network {\n  MAINNET = \"mainnet\",\n  TESTNET = \"testnet\",\n  DEVNET = \"devnet\",\n  LOCAL = \"local\",\n  CUSTOM = \"custom\",\n}\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToChainId: Record<string, number> = {\n  mainnet: 1,\n  testnet: 2,\n  local: 4,\n};\n\n/**\n * @group Implementation\n * @category Network\n */\nexport const NetworkToNetworkName: Record<string, Network> = {\n  mainnet: Network.MAINNET,\n  testnet: Network.TESTNET,\n  devnet: Network.DEVNET,\n  local: Network.LOCAL,\n  custom: Network.CUSTOM,\n};\n", "import { AptosClientRequest, AptosClientResponse } from \"./types\";\n\n/**\n * Used for JSON responses\n *\n * @param options\n */\nexport default async function aptosClient<Res>(\n  options: AptosClientRequest,\n): Promise<AptosClientResponse<Res>> {\n  return jsonRequest<Res>(options);\n}\n\nexport async function jsonRequest<Res>(\n  options: AptosClientRequest,\n): Promise<AptosClientResponse<Res>> {\n  const { requestUrl, requestConfig } = buildRequest(options);\n\n  const res = await fetch(requestUrl, requestConfig);\n  const data = await res.json();\n\n  return {\n    status: res.status,\n    statusText: res.statusText,\n    data,\n    headers: res.headers,\n    config: requestConfig,\n  };\n}\n\n/**\n * Used for binary responses, such as BCS outputs\n *\n * @experimental\n * @param options\n */\nexport async function bcsRequest(\n  options: AptosClientRequest,\n): Promise<AptosClientResponse<ArrayBuffer>> {\n  const { requestUrl, requestConfig } = buildRequest(options);\n\n  const res = await fetch(requestUrl, requestConfig);\n  const data = await res.arrayBuffer();\n\n  return {\n    status: res.status,\n    statusText: res.statusText,\n    data,\n    headers: res.headers,\n    config: requestConfig,\n  };\n}\n\nfunction buildRequest(options: AptosClientRequest) {\n  const headers = new Headers();\n  Object.entries(options?.headers ?? {}).forEach(([key, value]) => {\n    headers.append(key, String(value));\n  });\n\n  const body =\n    options.body instanceof Uint8Array\n      ? options.body\n      : JSON.stringify(options.body);\n\n  const withCredentialsOption = options.overrides?.WITH_CREDENTIALS;\n  let credentials: RequestCredentials;\n  if (withCredentialsOption === false) {\n    credentials = \"omit\";\n  } else if (withCredentialsOption === true) {\n    credentials = \"include\";\n  } else {\n    credentials = withCredentialsOption ?? \"include\";\n  }\n\n  const requestConfig: RequestInit = {\n    method: options.method,\n    headers,\n    body,\n    credentials,\n  };\n\n  const params = new URLSearchParams();\n  Object.entries(options.params ?? {}).forEach(([key, value]) => {\n    if (value !== undefined) {\n      params.append(key, String(value));\n    }\n  });\n\n  const requestUrl =\n    options.url + (params.size > 0 ? `?${params.toString()}` : \"\");\n\n  return { requestUrl, requestConfig };\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport aptosClient from \"@aptos-labs/aptos-client\";\nimport {\n  AptosSettings,\n  ClientConfig,\n  Client,\n  FullNodeConfig,\n  IndexerConfig,\n  FaucetConfig,\n  TransactionGenerationConfig,\n  PluginConfig,\n  TransactionSubmitter,\n} from \"../types\";\nimport {\n  NetworkToNodeAPI,\n  NetworkToFaucetAPI,\n  NetworkToIndexerAPI,\n  Network,\n  NetworkToPepperAPI,\n  NetworkToProverAPI,\n} from \"../utils/apiEndpoints\";\nimport { AptosApiType, DEFAULT_MAX_GAS_AMOUNT, DEFAULT_TXN_EXP_SEC_FROM_NOW } from \"../utils/const\";\n\n/**\n * Represents the configuration settings for an Aptos SDK client instance.\n * This class allows customization of various endpoints and client settings.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * async function runExample() {\n *     // Create a configuration for connecting to the Aptos testnet\n *     const config = new AptosConfig({ network: Network.TESTNET });\n *\n *     // Initialize the Aptos client with the configuration\n *     const aptos = new Aptos(config);\n *\n *     console.log(\"Aptos client initialized:\", aptos);\n * }\n * runExample().catch(console.error);\n * ```\n * @group Client\n */\nexport class AptosConfig {\n  /**\n   * The Network that this SDK is associated with. Defaults to DEVNET\n   * @group Client\n   */\n  readonly network: Network;\n\n  /**\n   * The client instance the SDK uses. Defaults to `@aptos-labs/aptos-client\n   * @group Client\n   */\n  readonly client: Client;\n\n  /**\n   * The optional hardcoded fullnode URL to send requests to instead of using the network\n   * @group Client\n   */\n  readonly fullnode?: string;\n\n  /**\n   * The optional hardcoded faucet URL to send requests to instead of using the network\n   * @group Client\n   */\n  readonly faucet?: string;\n\n  /**\n   * The optional hardcoded pepper service URL to send requests to instead of using the network\n   * @group Client\n   */\n  readonly pepper?: string;\n\n  /**\n   * The optional hardcoded prover service URL to send requests to instead of using the network\n   * @group Client\n   */\n  readonly prover?: string;\n\n  /**\n   * The optional hardcoded indexer URL to send requests to instead of using the network\n   * @group Client\n   */\n  readonly indexer?: string;\n\n  /**\n   * Optional client configurations\n   * @group Client\n   */\n  readonly clientConfig?: ClientConfig;\n\n  /**\n   * Optional specific Fullnode configurations\n   * @group Client\n   */\n  readonly fullnodeConfig?: FullNodeConfig;\n\n  /**\n   * Optional specific Indexer configurations\n   * @group Client\n   */\n  readonly indexerConfig?: IndexerConfig;\n\n  /**\n   * Optional specific Faucet configurations\n   * @group Client\n   */\n  readonly faucetConfig?: FaucetConfig;\n\n  /**\n   * Optional specific Transaction Generation configurations\n   * @group Client\n   */\n  readonly transactionGenerationConfig?: TransactionGenerationConfig;\n\n  /**\n   * Optional plugin config to override client behavior.\n   * @group Client\n   */\n  private pluginConfig?: PluginConfig;\n\n  /**\n   * Initializes an instance of the Aptos client with the specified settings.\n   * This allows users to configure various aspects of the client, such as network and endpoints.\n   *\n   * @param settings - Optional configuration settings for the Aptos client.\n   * @param settings.network - The network to connect to, defaults to `Network.DEVNET`.\n   * @param settings.fullnode - The fullnode endpoint to use for requests.\n   * @param settings.faucet - The faucet endpoint for obtaining test tokens.\n   * @param settings.pepper - The pepper used for transaction signing.\n   * @param settings.prover - The prover endpoint for transaction verification.\n   * @param settings.indexer - The indexer endpoint for querying blockchain data.\n   * @param settings.client - Custom client settings, defaults to a standard Aptos client.\n   * @param settings.clientConfig - Additional configuration for the client.\n   * @param settings.fullnodeConfig - Additional configuration for the fullnode.\n   * @param settings.indexerConfig - Additional configuration for the indexer.\n   * @param settings.faucetConfig - Additional configuration for the faucet.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with default settings\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify the network\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Client\n   */\n  constructor(settings?: AptosSettings) {\n    // If there are any endpoint overrides, they are custom networks, keep that in mind\n    if (settings?.fullnode || settings?.indexer || settings?.faucet || settings?.pepper || settings?.prover) {\n      if (settings?.network === Network.CUSTOM) {\n        console.info(\"Note: using CUSTOM network will require queries to lookup ChainId\");\n      } else if (!settings?.network) {\n        throw new Error(\"Custom endpoints require a network to be specified\");\n      }\n    }\n\n    this.network = settings?.network ?? Network.DEVNET;\n    this.fullnode = settings?.fullnode;\n    this.faucet = settings?.faucet;\n    this.pepper = settings?.pepper;\n    this.prover = settings?.prover;\n    this.indexer = settings?.indexer;\n    this.client = settings?.client ?? { provider: aptosClient };\n    this.clientConfig = settings?.clientConfig ?? {};\n    this.fullnodeConfig = settings?.fullnodeConfig ?? {};\n    this.indexerConfig = settings?.indexerConfig ?? {};\n    this.faucetConfig = settings?.faucetConfig ?? {};\n    this.transactionGenerationConfig = settings?.transactionGenerationConfig ?? {};\n    this.pluginConfig = settings?.pluginSettings\n      ? {\n          ...settings.pluginSettings,\n          IGNORE_TRANSACTION_SUBMITTER: false,\n        }\n      : undefined;\n  }\n\n  /**\n   * Returns the URL endpoint to send the request to based on the specified API type.\n   * If a custom URL was provided in the configuration, that URL is returned. Otherwise, the URL endpoint is derived from the network.\n   *\n   * @param apiType - The type of Aptos API to get the URL for. This can be one of the following: FULLNODE, FAUCET, INDEXER, PEPPER, PROVER.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, AptosApiType } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the request URL for the FULLNODE API\n   *   const url = config.getRequestUrl(AptosApiType.FULLNODE);\n   *   console.log(\"Request URL for FULLNODE:\", url);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Client\n   */\n  getRequestUrl(apiType: AptosApiType): string {\n    switch (apiType) {\n      case AptosApiType.FULLNODE:\n        if (this.fullnode !== undefined) return this.fullnode;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom full node url\");\n        return NetworkToNodeAPI[this.network];\n      case AptosApiType.FAUCET:\n        if (this.faucet !== undefined) return this.faucet;\n        if (this.network === Network.TESTNET) {\n          throw new Error(\n            \"There is no way to programmatically mint testnet APT, you must use the minting site at https://aptos.dev/network/faucet\",\n          );\n        }\n        if (this.network === Network.MAINNET) {\n          throw new Error(\"There is no mainnet faucet\");\n        }\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom faucet url\");\n        return NetworkToFaucetAPI[this.network];\n      case AptosApiType.INDEXER:\n        if (this.indexer !== undefined) return this.indexer;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom indexer url\");\n        return NetworkToIndexerAPI[this.network];\n      case AptosApiType.PEPPER:\n        if (this.pepper !== undefined) return this.pepper;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom pepper service url\");\n        return NetworkToPepperAPI[this.network];\n      case AptosApiType.PROVER:\n        if (this.prover !== undefined) return this.prover;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom prover service url\");\n        return NetworkToProverAPI[this.network];\n      default:\n        throw Error(`apiType ${apiType} is not supported`);\n    }\n  }\n\n  /**\n   * Checks if the provided URL is a known pepper service endpoint.\n   *\n   * @param url - The URL to check against the known pepper service endpoints.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const url = \"https://example.pepper.service\"; // replace with a real pepper service URL\n   *\n   *     // Check if the URL is a known pepper service endpoint\n   *     const isPepperService = config.isPepperServiceRequest(url);\n   *\n   *     console.log(`Is the URL a known pepper service? ${isPepperService}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Client\n   */\n  isPepperServiceRequest(url: string): boolean {\n    return NetworkToPepperAPI[this.network] === url;\n  }\n\n  /**\n   * Checks if the provided URL is a known prover service endpoint.\n   *\n   * @param url - The URL to check against known prover service endpoints.\n   * @returns A boolean indicating whether the URL is a known prover service endpoint.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * // Check if the URL is a known prover service endpoint\n   * const url = \"https://prover.testnet.aptos.dev\"; // replace with a real URL if needed\n   * const isProver = config.isProverServiceRequest(url);\n   *\n   * console.log(`Is the URL a known prover service? ${isProver}`);\n   * ```\n   * @group Client\n   */\n  isProverServiceRequest(url: string): boolean {\n    return NetworkToProverAPI[this.network] === url;\n  }\n\n  getDefaultMaxGasAmount(): number {\n    return this.transactionGenerationConfig?.defaultMaxGasAmount ?? DEFAULT_MAX_GAS_AMOUNT;\n  }\n\n  getDefaultTxnExpirySecFromNow(): number {\n    return this.transactionGenerationConfig?.defaultTxnExpirySecFromNow ?? DEFAULT_TXN_EXP_SEC_FROM_NOW;\n  }\n\n  /**\n   * If you have set a custom transaction submitter, you can use this to determine\n   * whether to use it or not. For example, to stop using the transaction submitter:\n   *\n   * @example\n   * ```\n   * aptos.config.setIgnoreTransactionSubmitter(true);\n   * ```\n   *\n   * @group Client\n   */\n  setIgnoreTransactionSubmitter(ignore: boolean) {\n    if (this.pluginConfig) {\n      this.pluginConfig.IGNORE_TRANSACTION_SUBMITTER = ignore;\n    }\n  }\n\n  /**\n   * If a custom transaction submitter has been specified in the PluginConfig and\n   * IGNORE_TRANSACTION_SUBMITTER is false, this will return a transaction submitter\n   * that should be used instead of the default transaction submission behavior.\n   */\n  getTransactionSubmitter(): TransactionSubmitter | undefined {\n    if (this.pluginConfig === undefined) {\n      return undefined;\n    }\n\n    if (this.pluginConfig.IGNORE_TRANSACTION_SUBMITTER === true) {\n      return undefined;\n    }\n\n    return this.pluginConfig.TRANSACTION_SUBMITTER;\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../serializer\";\nimport { Deserializer } from \"../deserializer\";\nimport { HexInput } from \"../../types\";\nimport { Hex } from \"../../core/hex\";\nimport { TransactionArgument } from \"../../transactions/instances/transactionArgument\";\n\n/**\n * Represents a contiguous sequence of already serialized BCS bytes.\n * \n * This class differs from most other Serializable classes in that its internal byte buffer is serialized to BCS\n * bytes exactly as-is, without prepending the length of the bytes. It is ideal for scenarios where custom serialization\n * is required, such as passing serialized bytes as transaction arguments. Additionally, it serves as a representation \n * of type-agnostic BCS bytes, akin to a vector<u8>.\n * \n * An example use case includes handling bytes resulting from entry function arguments that have been serialized \n * for an entry function.\n * \n * @example\n * const yourCustomSerializedBytes = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\n * const fixedBytes = new FixedBytes(yourCustomSerializedBytes);\n * const payload = await generateTransactionPayload({\n *   function: \"0xbeefcafe::your_module::your_function_that_requires_custom_serialization\",\n *   functionArguments: [yourCustomBytes],\n * });\n * \n * This class is particularly useful when you want to handle a fixed-size byte array without the overhead of \n * length prepending, such as when dealing with 32-byte addresses stored as U8 in a MoveVector<U8>.\n\n *  For example, if you store each of the 32 bytes for an address as a U8 in a MoveVector<U8>, when you\n *  serialize that MoveVector<U8>, it will be serialized to 33 bytes. If you solely want to pass around\n *  the 32 bytes as a Serializable class that *does not* prepend the length to the BCS-serialized representation,\n *  use this class.* \n * @param value - HexInput representing a sequence of Uint8 bytes.\n * @returns A Serializable FixedBytes instance, which when serialized, does not prepend the length of the bytes.\n * @see EntryFunctionBytes\n * @group Implementation\n * @category BCS\n */\nexport class FixedBytes extends Serializable implements TransactionArgument {\n  public value: Uint8Array;\n\n  /**\n   * Creates an instance of the class with a specified hexadecimal input.\n   * The value is converted from hexadecimal format to a Uint8Array.\n   *\n   * @param value - The hexadecimal input to be converted.\n   * @group Implementation\n   * @category BCS\n   */\n  constructor(value: HexInput) {\n    super();\n    this.value = Hex.fromHexInput(value).toUint8Array();\n  }\n\n  /**\n   * Serializes the fixed bytes value using the provided serializer.\n   * This function is essential for converting the fixed bytes into a format suitable for storage or transmission.\n   *\n   * @param serializer - The serializer instance used for serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.value);\n  }\n\n  /**\n   * Serializes the current instance for an entry function using the provided serializer.\n   * This allows the instance to be converted into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    serializer.serialize(this);\n  }\n\n  /**\n   * Serializes the current instance using the provided serializer.\n   * This function is essential for preparing data to be passed as arguments in script functions.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serialize(this);\n  }\n\n  /**\n   * Deserializes a fixed-length byte array from the provided deserializer.\n   * This function helps in reconstructing a FixedBytes object from the serialized data.\n   *\n   * @param deserializer - The deserializer instance used to read the byte data.\n   * @param length - The length of the byte array to be deserialized.\n   * @group Implementation\n   * @category BCS\n   */\n  static deserialize(deserializer: Deserializer, length: number): FixedBytes {\n    const bytes = deserializer.deserializeFixedBytes(length);\n    return new FixedBytes(bytes);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../serializer\";\nimport { Deserializer } from \"../deserializer\";\nimport { FixedBytes } from \"./fixedBytes\";\nimport { EntryFunctionArgument } from \"../../transactions/instances/transactionArgument\";\nimport { HexInput } from \"../../types\";\n\n/**\n * This class exists solely to represent a sequence of fixed bytes as a serialized entry function, because\n * serializing an entry function appends a prefix that's *only* used for entry function arguments.\n *\n * NOTE: Using this class for serialized script functions will lead to erroneous and unexpected behavior.\n *\n * If you wish to convert this class back to a TransactionArgument, you must know the type\n * of the argument beforehand, and use the appropriate class to deserialize the bytes within\n * an instance of this class.\n * @group Implementation\n * @category BCS\n */\nexport class EntryFunctionBytes extends Serializable implements EntryFunctionArgument {\n  public readonly value: FixedBytes;\n\n  /**\n   * Creates an instance of the class with a specified hexadecimal input value.\n   *\n   * @param value - The hexadecimal input to be converted into FixedBytes.\n   * @group Implementation\n   * @category BCS\n   */\n  private constructor(value: HexInput) {\n    super();\n    this.value = new FixedBytes(value);\n  }\n\n  // Note that to see the Move, BCS-serialized representation of the underlying fixed byte vector,\n  // we must not serialize the length prefix.\n  //\n  // In other words, this class is only used to represent a sequence of bytes that are already\n  // BCS-serialized as a type. To represent those bytes accurately, the BCS-serialized form is the same exact\n  // representation.\n\n  /**\n   * Serializes the value using the provided serializer.\n   * This function is essential for accurately representing a sequence of bytes that are already BCS-serialized as a type.\n   *\n   * Note that to see the Move, BCS-serialized representation of the underlying fixed byte vector,\n   * we must not serialize the length prefix.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.value);\n  }\n\n  // When we serialize these bytes as an entry function argument, we need to\n  // serialize the length prefix. This essentially converts the underlying fixed byte vector to a type-agnostic\n  // byte vector to an `any` type.\n  // NOTE: This, and the lack of a `serializeForScriptFunction`, is the only meaningful difference between this\n  // class and FixedBytes.\n\n  /**\n   * Serializes the current instance for use as an entry function argument by converting the underlying fixed byte vector to a\n   * type-agnostic byte vector.\n   * This process includes serializing the length prefix of the byte vector.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.value.value.length);\n    serializer.serialize(this);\n  }\n\n  /**\n   * The only way to create an instance of this class is to use this static method.\n   * This function should only be used when deserializing a sequence of EntryFunctionPayload arguments.\n   * @param deserializer - The deserializer instance with the buffered bytes.\n   * @param length - The length of the bytes to deserialize.\n   * @returns An instance of this class, which will now only be usable as an EntryFunctionArgument.\n   * @group Implementation\n   * @category BCS\n   */\n  static deserialize(deserializer: Deserializer, length: number): EntryFunctionBytes {\n    const fixedBytes = FixedBytes.deserialize(deserializer, length);\n    return new EntryFunctionBytes(fixedBytes.value);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { AptosConfig } from \"../api\";\nimport { InputSubmitTransactionData } from \"../transactions\";\nimport { Network } from \"../utils/apiEndpoints\";\nimport { OrderBy, TokenStandard } from \"./indexer\";\n\n/**\n * Different MIME types used for data interchange in transactions and responses.\n */\nexport enum MimeType {\n  /**\n   * JSON representation, used for transaction submission and accept type JSON output\n   */\n  JSON = \"application/json\",\n  /**\n   * BCS representation, used for accept type BCS output\n   */\n  BCS = \"application/x-bcs\",\n  /**\n   * BCS representation, used for transaction submission in BCS input\n   */\n  BCS_SIGNED_TRANSACTION = \"application/x.aptos.signed_transaction+bcs\",\n  BCS_VIEW_FUNCTION = \"application/x.aptos.view_function+bcs\",\n}\n\n/**\n * Hexadecimal data input for functions, supporting both string and Uint8Array formats.\n */\nexport type HexInput = string | Uint8Array;\n\n/**\n * Variants of type tags used in the system, encompassing various data types and structures.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/language_storage.rs#L27}\n */\nexport enum TypeTagVariants {\n  Bool = 0,\n  U8 = 1,\n  U64 = 2,\n  U128 = 3,\n  Address = 4,\n  Signer = 5,\n  Vector = 6,\n  Struct = 7,\n  U16 = 8,\n  U32 = 9,\n  U256 = 10,\n  Reference = 254, // This is specifically a placeholder and does not represent a real type\n  Generic = 255, // This is specifically a placeholder and does not represent a real type\n}\n\n/**\n * Variants of script transaction arguments used in Rust, encompassing various data types for transaction processing.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/transaction_argument.rs#L11}\n */\nexport enum ScriptTransactionArgumentVariants {\n  U8 = 0,\n  U64 = 1,\n  U128 = 2,\n  Address = 3,\n  U8Vector = 4,\n  Bool = 5,\n  U16 = 6,\n  U32 = 7,\n  U256 = 8,\n  Serialized = 9,\n}\n\n/**\n * The payload for various transaction types in the system.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L478}\n */\nexport enum TransactionPayloadVariants {\n  Script = 0,\n  EntryFunction = 2,\n  Multisig = 3,\n  Payload = 4,\n}\n\n/**\n * The inner payload type to support orderless transactions and all future transaction types.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L478}\n */\nexport enum TransactionInnerPayloadVariants {\n  V1 = 0,\n}\n\n/**\n * Executable types for transactions, which can be either a script or an entry function.\n *\n * Empty is reserved for Multisig voting transactions, which do not have an executable payload.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L685}\n */\nexport enum TransactionExecutableVariants {\n  Script = 0,\n  EntryFunction = 1,\n  Empty = 2,\n}\n\n/**\n * Variants of transaction extra configurations, which can include additional settings or parameters.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L737}\n */\nexport enum TransactionExtraConfigVariants {\n  V1 = 0,\n}\n\n/**\n * Variants of transactions used in the system.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L440}\n */\nexport enum TransactionVariants {\n  MultiAgentTransaction = 0,\n  FeePayerTransaction = 1,\n}\n\n/**\n * Variants of transaction authenticators used in the system.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L44}\n */\nexport enum TransactionAuthenticatorVariant {\n  Ed25519 = 0,\n  MultiEd25519 = 1,\n  MultiAgent = 2,\n  FeePayer = 3,\n  SingleSender = 4,\n}\n\n/**\n * Variants of account authenticators used in transactions.\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L414}\n */\nexport enum AccountAuthenticatorVariant {\n  Ed25519 = 0,\n  MultiEd25519 = 1,\n  SingleKey = 2,\n  MultiKey = 3,\n  NoAccountAuthenticator = 4,\n  Abstraction = 5,\n}\n\n/**\n * Variants of private keys that can comply with the AIP-80 standard.\n * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md}\n */\nexport enum PrivateKeyVariants {\n  Ed25519 = \"ed25519\",\n  Secp256k1 = \"secp256k1\",\n}\n\n/**\n * Variants of public keys used in cryptographic operations.\n */\nexport enum AnyPublicKeyVariant {\n  Ed25519 = 0,\n  Secp256k1 = 1,\n  Keyless = 3,\n  FederatedKeyless = 4,\n}\n\nexport function anyPublicKeyVariantToString(variant: AnyPublicKeyVariant): string {\n  switch (variant) {\n    case AnyPublicKeyVariant.Ed25519:\n      return \"ed25519\";\n    case AnyPublicKeyVariant.Secp256k1:\n      return \"secp256k1\";\n    case AnyPublicKeyVariant.Keyless:\n      return \"keyless\";\n    case AnyPublicKeyVariant.FederatedKeyless:\n      return \"federated_keyless\";\n    default:\n      throw new Error(\"Unknown public key variant\");\n  }\n}\n\n/**\n * Variants of signature types used for cryptographic operations.\n */\nexport enum AnySignatureVariant {\n  Ed25519 = 0,\n  Secp256k1 = 1,\n  Keyless = 3,\n}\n\n/**\n * Variants of ephemeral public keys used in cryptographic operations.\n */\nexport enum EphemeralPublicKeyVariant {\n  Ed25519 = 0,\n}\n\n/**\n * Variants of ephemeral signatures used for secure communication.\n */\nexport enum EphemeralSignatureVariant {\n  Ed25519 = 0,\n}\n\n/**\n * Variants of ephemeral certificates used in secure transactions.\n */\nexport enum EphemeralCertificateVariant {\n  ZkProof = 0,\n}\n\n/**\n * Variants of zero-knowledge proofs used in cryptographic operations.\n */\nexport enum ZkpVariant {\n  Groth16 = 0,\n}\n\n/**\n * BCS types\n */\nexport type Uint8 = number;\n\n/**\n * A 16-bit unsigned integer.\n */\nexport type Uint16 = number;\n\n/**\n * A 32-bit unsigned integer.\n */\nexport type Uint32 = number;\n\n/**\n * A 64-bit unsigned integer value.\n */\nexport type Uint64 = bigint;\n\n/**\n * A 128-bit unsigned integer used for precise arithmetic operations.\n */\nexport type Uint128 = bigint;\n\n/**\n * A 256-bit unsigned integer used for precise numerical calculations.\n */\nexport type Uint256 = bigint;\n\n/**\n * A number or a bigint value.\n */\nexport type AnyNumber = number | bigint;\n\n/**\n * Configuration options for initializing the SDK, allowing customization of its behavior and interaction with the Aptos network.\n */\nexport type AptosSettings = {\n  readonly network?: Network;\n\n  readonly fullnode?: string;\n\n  readonly faucet?: string;\n\n  readonly indexer?: string;\n\n  readonly pepper?: string;\n\n  readonly prover?: string;\n\n  readonly clientConfig?: ClientConfig;\n\n  readonly client?: Client;\n\n  readonly fullnodeConfig?: FullNodeConfig;\n\n  readonly indexerConfig?: IndexerConfig;\n\n  readonly faucetConfig?: FaucetConfig;\n\n  readonly transactionGenerationConfig?: TransactionGenerationConfig;\n\n  readonly pluginSettings?: PluginSettings;\n};\n\n/**\n * Defines the parameters for paginating query results, including the starting position and maximum number of items to return.\n * @param offset Specifies the starting position of the query result. Default is 0.\n * @param limit Specifies the maximum number of items to return. Default is 25.\n */\nexport interface PaginationArgs {\n  offset?: AnyNumber;\n  limit?: number;\n}\n\n/**\n * Defines the parameters for paginating query results, including the starting position and maximum number of items to return.\n * @param cursor Specifies the starting position of the query result. Default is at the beginning if undefined.  This is not a number and must come from the API.\n * @param limit Specifies the maximum number of items to return. Default is 25.\n */\nexport interface CursorPaginationArgs {\n  cursor?: string;\n  limit?: number;\n}\n\n/**\n * Represents the arguments for specifying a token standard.\n *\n * @param tokenStandard - Optional standard of the token.\n */\nexport interface TokenStandardArg {\n  tokenStandard?: TokenStandard;\n}\n\nexport interface OrderByArg<T extends {}> {\n  orderBy?: OrderBy<T>;\n}\n\nexport interface WhereArg<T extends {}> {\n  where?: T;\n}\n\n/**\n * QUERY TYPES\n */\n\n/**\n * A configuration object for requests to the server, including API key, extra headers, and cookie handling options.\n */\nexport type ClientConfig = ClientHeadersType & {\n  WITH_CREDENTIALS?: boolean;\n  API_KEY?: string;\n};\n\n/**\n * A configuration object for a Fullnode, allowing for the inclusion of extra headers in requests.\n */\nexport type FullNodeConfig = ClientHeadersType;\n\n/**\n * An Indexer configuration object for sending requests with additional headers.\n */\nexport type IndexerConfig = ClientHeadersType;\n\n/**\n * A configuration object for a faucet, including optional authentication and headers for requests.\n */\nexport type FaucetConfig = ClientHeadersType & {\n  AUTH_TOKEN?: string;\n};\n\n/**\n * A configuration object for default parameters for transaction generation.\n */\nexport type TransactionGenerationConfig = {\n  defaultMaxGasAmount?: number;\n  defaultTxnExpirySecFromNow?: number;\n};\n\n/**\n * General type definition for client headers.\n */\nexport type ClientHeadersType = {\n  HEADERS?: Record<string, string | number | boolean>;\n};\n\n/**\n * Config for plugins. This can be used to override certain client behavior.\n */\nexport type PluginConfig = {\n  /**\n   * If given, this will be used for submitting transactions instead of the default\n   * implementation (which submits transactions directly via a node).\n   */\n  TRANSACTION_SUBMITTER?: TransactionSubmitter;\n\n  /**\n   * If true, we won't use the TRANSACTION_SUBMITTER if set.\n   */\n  IGNORE_TRANSACTION_SUBMITTER?: boolean;\n};\n\nexport type PluginSettings = Omit<PluginConfig, \"IGNORE_TRANSACTION_SUBMITTER\">;\n\n/**\n * You can implement this interface and set it in {@link PluginSettings} when building a\n * client to override the default transaction submission behavior. This is useful if\n * you'd like to submit transactions via a gas station for example.\n *\n * @example\n * ```typescript\n * class MyGasStationClient implements TransactionSubmitter {\n *   async submitTransaction(\n *     args: { aptosConfig: AptosConfig } & InputSubmitTransactionData,\n *   ): Promise<PendingTransactionResponse> {\n *     // TODO: Implement the logic to submit the transaction to the gas station\n *   }\n * }\n *\n * const network = Network.MAINNET;\n * const myGasStationClient = new MyGasStationClient(network);\n * const config = new AptosConfig({\n *   network,\n *   pluginConfig: {\n *     transactionSubmitter: myGasStationClient,\n *   },\n * });\n * const aptos = new Aptos(config);\n * ```\n */\nexport interface TransactionSubmitter {\n  /**\n   * Submit a transaction to the Aptos blockchain or something that will do it on your\n   * behalf, for example a gas station. See the comments of {@link TransactionSubmitter} for more.\n   *\n   * @param args - The arguments for submitting the transaction.\n   * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n   * @param args.transaction - The Aptos transaction data to be submitted.\n   * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n   * @param args.secondarySignerAuthenticators - Optional. Authenticators for additional signers in a multi-signer transaction.\n   * @param args.pluginParams - Optional. Additional parameters for the plugin.\n   * @param args.transactionSubmitter - Optional. An override for the transaction submitter.\n   *\n   * @returns PendingTransactionResponse - The response containing the status of the submitted transaction.\n   * @group Implementation\n   */\n  submitTransaction(\n    args: {\n      aptosConfig: AptosConfig;\n    } & Omit<InputSubmitTransactionData, \"transactionSubmitter\">,\n  ): Promise<PendingTransactionResponse>;\n}\n\n/**\n * Represents a client for making requests to a service provider.\n *\n * @param Req - The type of the request payload.\n * @param Res - The type of the response payload.\n */\nexport interface ClientRequest<Req> {\n  url: string;\n  method: \"GET\" | \"POST\";\n  originMethod?: string;\n  body?: Req;\n  contentType?: string;\n  params?: any;\n  overrides?: ClientConfig & FullNodeConfig & IndexerConfig & FaucetConfig;\n  headers?: Record<string, any>;\n}\n\nexport interface ClientResponse<Res> {\n  status: number;\n  statusText: string;\n  data: Res;\n  config?: any;\n  request?: any;\n  response?: any;\n  headers?: any;\n}\n\nexport interface Client {\n  /**\n   * Sends a request to the specified URL with the given options.\n   *\n   * @param requestOptions - The options for the request.\n   * @param requestOptions.url - The URL to send the request to.\n   * @param requestOptions.method - The HTTP method to use, either \"GET\" or \"POST\".\n   * @param requestOptions.path - An optional path to append to the URL.\n   * @param requestOptions.body - The body of the request, applicable for POST requests.\n   * @param requestOptions.contentType - The content type of the request body.\n   * @param requestOptions.acceptType - The expected content type of the response.\n   * @param requestOptions.params - Optional parameters to include in the request.\n   * @param requestOptions.originMethod - An optional method to specify the origin of the request.\n   * @param requestOptions.overrides - Optional configuration overrides for the request.\n   */\n  provider<Req, Res>(requestOptions: ClientRequest<Req>): Promise<ClientResponse<Res>>;\n}\n\n/**\n * The API request type\n *\n * @param url - the url to make the request to, i.e. https://fullnode.devnet.aptoslabs.com/v1\n * @param method - the request method \"GET\" | \"POST\"\n * @param endpoint (optional) - the endpoint to make the request to, i.e. transactions\n * @param body (optional) - the body of the request\n * @param contentType (optional) - the content type to set the `content-type` header to,\n * by default is set to `application/json`\n * @param params (optional) - query params to add to the request\n * @param originMethod (optional) - the local method the request came from\n * @param overrides (optional) - a `ClientConfig` object type to override request data\n */\nexport type AptosRequest = {\n  url: string;\n  method: \"GET\" | \"POST\";\n  path?: string;\n  body?: any;\n  contentType?: string;\n  acceptType?: string;\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  originMethod?: string;\n  overrides?: ClientConfig & FullNodeConfig & IndexerConfig & FaucetConfig;\n};\n\n/**\n * The API response type\n *\n * @param status - the response status. i.e. 200\n * @param statusText - the response message\n * @param data the response data\n * @param url the url the request was made to\n * @param headers the response headers\n * @param config (optional) - the request object\n * @param request (optional) - the request object\n */\nexport interface AptosResponse<Req, Res> {\n  status: number;\n  statusText: string;\n  data: Res;\n  url: string;\n  headers: any;\n  config?: any;\n  request?: Req;\n}\n\n/**\n * The ledger version of transactions, defaulting to the latest version if not specified.\n */\nexport type LedgerVersionArg = {\n  ledgerVersion?: AnyNumber;\n};\n\n/**\n * RESPONSE TYPES\n */\n\n/**\n * The output of the estimate gas API, including the deprioritized estimate for the gas unit price.\n */\nexport type GasEstimation = {\n  /**\n   * The deprioritized estimate for the gas unit price\n   */\n  deprioritized_gas_estimate?: number;\n  /**\n   * The current estimate for the gas unit price\n   */\n  gas_estimate: number;\n  /**\n   * The prioritized estimate for the gas unit price\n   */\n  prioritized_gas_estimate?: number;\n};\n\nexport type MoveResource<T = {}> = {\n  type: MoveStructId;\n  data: T;\n};\n\n/**\n * The data associated with an account, including its sequence number.\n */\nexport type AccountData = {\n  sequence_number: string;\n  authentication_key: string;\n};\n\n/**\n * A Move module containing an address.\n */\nexport type MoveModuleBytecode = {\n  bytecode: string;\n  abi?: MoveModule;\n};\n\n/**\n * TRANSACTION TYPES\n */\n\n/**\n * Different types of transaction responses that can occur in the system.\n */\nexport enum TransactionResponseType {\n  Pending = \"pending_transaction\",\n  User = \"user_transaction\",\n  Genesis = \"genesis_transaction\",\n  BlockMetadata = \"block_metadata_transaction\",\n  StateCheckpoint = \"state_checkpoint_transaction\",\n  Validator = \"validator_transaction\",\n  BlockEpilogue = \"block_epilogue_transaction\",\n}\n\n/**\n * The response for a transaction, which can be either pending or committed.\n */\nexport type TransactionResponse = PendingTransactionResponse | CommittedTransactionResponse;\n\n/**\n * The response for a committed transaction, which can be one of several transaction types.\n */\nexport type CommittedTransactionResponse =\n  | UserTransactionResponse\n  | GenesisTransactionResponse\n  | BlockMetadataTransactionResponse\n  | StateCheckpointTransactionResponse\n  | ValidatorTransactionResponse\n  | BlockEpilogueTransactionResponse;\n\n/**\n * Determine if the given transaction response is currently pending.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the transaction is pending.\n */\nexport function isPendingTransactionResponse(response: TransactionResponse): response is PendingTransactionResponse {\n  return response.type === TransactionResponseType.Pending;\n}\n\n/**\n * Determines if the given transaction response is a user transaction.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the transaction is of type User.\n */\nexport function isUserTransactionResponse(response: TransactionResponse): response is UserTransactionResponse {\n  return response.type === TransactionResponseType.User;\n}\n\n/**\n * Determines if the given transaction response is a Genesis transaction.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the transaction is a Genesis transaction.\n */\nexport function isGenesisTransactionResponse(response: TransactionResponse): response is GenesisTransactionResponse {\n  return response.type === TransactionResponseType.Genesis;\n}\n\n/**\n * Determine if the given transaction response is of type BlockMetadata.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the response is a BlockMetadata transaction.\n */\nexport function isBlockMetadataTransactionResponse(\n  response: TransactionResponse,\n): response is BlockMetadataTransactionResponse {\n  return response.type === TransactionResponseType.BlockMetadata;\n}\n\n/**\n * Determines if the provided transaction response is a state checkpoint transaction.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the transaction response is of type StateCheckpoint.\n */\nexport function isStateCheckpointTransactionResponse(\n  response: TransactionResponse,\n): response is StateCheckpointTransactionResponse {\n  return response.type === TransactionResponseType.StateCheckpoint;\n}\n\n/**\n * Determine if the given transaction response is of type Validator.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the transaction response is a Validator type.\n */\nexport function isValidatorTransactionResponse(\n  response: TransactionResponse,\n): response is ValidatorTransactionResponse {\n  return response.type === TransactionResponseType.Validator;\n}\n\n/**\n * Determines if the given transaction response is of the type Block Epilogue.\n *\n * @param response - The transaction response to evaluate.\n * @returns A boolean indicating whether the response is a Block Epilogue transaction.\n */\nexport function isBlockEpilogueTransactionResponse(\n  response: TransactionResponse,\n): response is BlockEpilogueTransactionResponse {\n  return response.type === TransactionResponseType.BlockEpilogue;\n}\n\n/**\n * The response for a pending transaction, indicating that the transaction is still being processed.\n */\nexport type PendingTransactionResponse = {\n  type: TransactionResponseType.Pending;\n  hash: string;\n  sender: string;\n  sequence_number: string;\n  max_gas_amount: string;\n  gas_unit_price: string;\n  expiration_timestamp_secs: string;\n  payload: TransactionPayloadResponse;\n  signature?: TransactionSignature;\n};\n\n/**\n * The response structure for a user transaction.\n */\nexport type UserTransactionResponse = {\n  type: TransactionResponseType.User;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash: string | null;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  sender: string;\n  sequence_number: string;\n  replay_protection_nonce: string;\n  max_gas_amount: string;\n  gas_unit_price: string;\n  expiration_timestamp_secs: string;\n  payload: TransactionPayloadResponse;\n  signature?: TransactionSignature;\n  /**\n   * Events generated by the transaction\n   */\n  events: Array<Event>;\n  timestamp: string;\n};\n\n/**\n * The response for a genesis transaction, indicating the type of transaction.\n */\nexport type GenesisTransactionResponse = {\n  type: TransactionResponseType.Genesis;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash?: string;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  payload: GenesisPayload;\n  /**\n   * Events emitted during genesis\n   */\n  events: Array<Event>;\n};\n\n/**\n * The structure representing a blockchain block with its height.\n */\nexport type BlockMetadataTransactionResponse = {\n  type: TransactionResponseType.BlockMetadata;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash: string | null;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  id: string;\n  epoch: string;\n  round: string;\n  /**\n   * The events emitted at the block creation\n   */\n  events: Array<Event>;\n  /**\n   * Previous block votes\n   */\n  previous_block_votes_bitvec: Array<number>;\n  proposer: string;\n  /**\n   * The indices of the proposers who failed to propose\n   */\n  failed_proposer_indices: Array<number>;\n  timestamp: string;\n};\n\n/**\n * The response for a state checkpoint transaction, indicating the type of transaction.\n */\nexport type StateCheckpointTransactionResponse = {\n  type: TransactionResponseType.StateCheckpoint;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash: string | null;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  timestamp: string;\n};\n\n/**\n * The response for a validator transaction, indicating the type of transaction.\n */\nexport type ValidatorTransactionResponse = {\n  type: TransactionResponseType.Validator;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash: string | null;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  /**\n   * The events emitted by the validator transaction\n   */\n  events: Array<Event>;\n  timestamp: string;\n};\n\n/**\n * Describes the gas state of the block, indicating whether the block gas limit has been reached.\n */\nexport type BlockEndInfo = {\n  block_gas_limit_reached: boolean;\n  block_output_limit_reached: boolean;\n  block_effective_block_gas_units: number;\n  block_approx_output_size: number;\n};\n\n/**\n * A transaction executed at the end of a block that tracks data from the entire block.\n */\nexport type BlockEpilogueTransactionResponse = {\n  type: TransactionResponseType.BlockEpilogue;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash: string | null;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  timestamp: string;\n  block_end_info: BlockEndInfo | null;\n};\n\n/**\n * WRITESET CHANGE TYPES\n */\n\n/**\n * A union type that encompasses both script and direct write sets for data operations.\n */\nexport type WriteSetChange =\n  | WriteSetChangeDeleteModule\n  | WriteSetChangeDeleteResource\n  | WriteSetChangeDeleteTableItem\n  | WriteSetChangeWriteModule\n  | WriteSetChangeWriteResource\n  | WriteSetChangeWriteTableItem;\n\n/**\n * The structure for a module deletion change in a write set.\n */\nexport type WriteSetChangeDeleteModule = {\n  type: string;\n  address: string;\n  /**\n   * State key hash\n   */\n  state_key_hash: string;\n  module: MoveModuleId;\n};\n\n/**\n * The payload for a resource deletion in a write set change.\n */\nexport type WriteSetChangeDeleteResource = {\n  type: string;\n  address: string;\n  state_key_hash: string;\n  resource: string;\n};\n\n/**\n * The payload for a write set change that deletes a table item.\n */\nexport type WriteSetChangeDeleteTableItem = {\n  type: string;\n  state_key_hash: string;\n  handle: string;\n  key: string;\n  data?: DeletedTableData;\n};\n\n/**\n * The structure for a write module change in a write set.\n */\nexport type WriteSetChangeWriteModule = {\n  type: string;\n  address: string;\n  state_key_hash: string;\n  data: MoveModuleBytecode;\n};\n\n/**\n * The resource associated with a write set change, identified by its type.\n */\nexport type WriteSetChangeWriteResource = {\n  type: string;\n  address: string;\n  state_key_hash: string;\n  data: MoveResource;\n};\n\n/**\n * The structure for a write operation on a table in a write set change.\n */\nexport type WriteSetChangeWriteTableItem = {\n  type: string;\n  state_key_hash: string;\n  handle: string;\n  key: string;\n  value: string;\n  data?: DecodedTableData;\n};\n\n/**\n * The decoded data for a table, including its key in JSON format.\n */\nexport type DecodedTableData = {\n  /**\n   * Key of table in JSON\n   */\n  key: any;\n  /**\n   * Type of key\n   */\n  key_type: string;\n  /**\n   * Value of table in JSON\n   */\n  value: any;\n  /**\n   * Type of value\n   */\n  value_type: string;\n};\n\n/**\n * Data for a deleted table entry.\n */\nexport type DeletedTableData = {\n  /**\n   * Deleted key\n   */\n  key: any;\n  /**\n   * Deleted key type\n   */\n  key_type: string;\n};\n\n/**\n * The payload for a transaction response, which can be an entry function, script, or multisig payload.\n */\nexport type TransactionPayloadResponse = EntryFunctionPayloadResponse | ScriptPayloadResponse | MultisigPayloadResponse;\n\n/**\n * The response payload for an entry function, containing the type of the entry.\n */\nexport type EntryFunctionPayloadResponse = {\n  type: string;\n  function: MoveFunctionId;\n  /**\n   * Type arguments of the function\n   */\n  type_arguments: Array<string>;\n  /**\n   * Arguments of the function\n   */\n  arguments: Array<any>;\n};\n\n/**\n * The payload for a script response, containing the type of the script.\n */\nexport type ScriptPayloadResponse = {\n  type: string;\n  code: MoveScriptBytecode;\n  /**\n   * Type arguments of the function\n   */\n  type_arguments: Array<string>;\n  /**\n   * Arguments of the function\n   */\n  arguments: Array<any>;\n};\n\n/**\n * The response payload for a multisig transaction, containing the type of the transaction.\n */\nexport type MultisigPayloadResponse = {\n  type: string;\n  multisig_address: string;\n  transaction_payload?: EntryFunctionPayloadResponse;\n};\n\n/**\n * The payload for the genesis block containing the type of the payload.\n */\nexport type GenesisPayload = {\n  type: string;\n  write_set: WriteSet;\n};\n\n/**\n * The bytecode for a Move script.\n */\nexport type MoveScriptBytecode = {\n  bytecode: string;\n  abi?: MoveFunction;\n};\n\n/**\n * JSON representations of transaction signatures returned from the node API.\n */\nexport type TransactionSignature =\n  | TransactionEd25519Signature\n  | TransactionSecp256k1Signature\n  | TransactionMultiEd25519Signature\n  | TransactionMultiAgentSignature\n  | TransactionFeePayerSignature\n  | TransactionSingleSenderSignature;\n\n/**\n * Determine if the provided signature is an Ed25519 signature.\n * This function checks for the presence of the \"signature\" property\n * and verifies that its value is \"ed25519_signature\".\n *\n * @param signature - The transaction signature to be checked.\n * @returns A boolean indicating whether the signature is an Ed25519 signature.\n */\nexport function isEd25519Signature(signature: TransactionSignature): signature is TransactionEd25519Signature {\n  return \"signature\" in signature && signature.type === \"ed25519_signature\";\n}\n\n/**\n * Determine if the provided signature is a valid secp256k1 ECDSA signature.\n *\n * @param signature - The transaction signature to validate.\n * @returns A boolean indicating whether the signature is a secp256k1 ECDSA signature.\n */\nexport function isSecp256k1Signature(signature: TransactionSignature): signature is TransactionFeePayerSignature {\n  return \"signature\" in signature && signature.signature === \"secp256k1_ecdsa_signature\";\n}\n\n/**\n * Determine if the provided transaction signature is a multi-agent signature.\n *\n * @param signature - The transaction signature to evaluate.\n * @returns A boolean indicating whether the signature is a multi-agent signature.\n */\nexport function isMultiAgentSignature(signature: TransactionSignature): signature is TransactionMultiAgentSignature {\n  return signature.type === \"multi_agent_signature\";\n}\n\n/**\n * Determine if the provided signature is a fee payer signature.\n *\n * @param signature - The transaction signature to evaluate.\n * @returns A boolean indicating whether the signature is a fee payer signature.\n */\nexport function isFeePayerSignature(signature: TransactionSignature): signature is TransactionFeePayerSignature {\n  return signature.type === \"fee_payer_signature\";\n}\n\n/**\n * Determine if the provided signature is of type \"multi_ed25519_signature\".\n *\n * @param signature - The transaction signature to check.\n * @returns A boolean indicating whether the signature is a multi-ed25519 signature.\n */\nexport function isMultiEd25519Signature(\n  signature: TransactionSignature,\n): signature is TransactionMultiEd25519Signature {\n  return signature.type === \"multi_ed25519_signature\";\n}\n\n/**\n * Determine if the provided signature is of type \"single_sender\".\n *\n * @param signature - The transaction signature to check.\n * @returns A boolean indicating whether the signature is a single-sender signature.\n */\nexport function isSingleSenderSignature(\n  signature: TransactionSignature,\n): signature is TransactionSingleSenderSignature {\n  return signature.type === \"single_sender\";\n}\n\n/**\n * The signature for a transaction using the Ed25519 algorithm.\n */\nexport type TransactionEd25519Signature = {\n  type: string;\n  public_key: string;\n  signature: \"ed25519_signature\";\n};\n\n/**\n * The structure for a Secp256k1 signature in a transaction.\n */\nexport type TransactionSecp256k1Signature = {\n  type: string;\n  public_key: string;\n  signature: \"secp256k1_ecdsa_signature\";\n};\n\n/**\n * The structure for a multi-signature transaction using Ed25519.\n */\nexport type TransactionSingleSenderSignature = {\n  type: \"single_sender\";\n  public_key: { value: string; type: string };\n  signature: { value: string; type: string };\n};\n\n/**\n * The structure for a multi-signature transaction using Ed25519.\n */\nexport type TransactionMultiEd25519Signature = {\n  type: \"multi_ed25519_signature\";\n  /**\n   * The public keys for the Ed25519 signature\n   */\n  public_keys: Array<string>;\n  /**\n   * Signature associated with the public keys in the same order\n   */\n  signatures: Array<string>;\n  /**\n   * The number of signatures required for a successful transaction\n   */\n  threshold: number;\n  bitmap: string;\n};\n\n/**\n * The structure for a multi-agent signature in a transaction.\n */\nexport type TransactionMultiAgentSignature = {\n  type: \"multi_agent_signature\";\n  sender: AccountSignature;\n  /**\n   * The other involved parties' addresses\n   */\n  secondary_signer_addresses: Array<string>;\n  /**\n   * The associated signatures, in the same order as the secondary addresses\n   */\n  secondary_signers: Array<AccountSignature>;\n};\n\n/**\n * The signature of the fee payer in a transaction.\n */\nexport type TransactionFeePayerSignature = {\n  type: \"fee_payer_signature\";\n  sender: AccountSignature;\n  /**\n   * The other involved parties' addresses\n   */\n  secondary_signer_addresses: Array<string>;\n  /**\n   * The associated signatures, in the same order as the secondary addresses\n   */\n  secondary_signers: Array<AccountSignature>;\n  fee_payer_address: string;\n  fee_payer_signer: AccountSignature;\n};\n\n/**\n * The union of all single account signatures, including Ed25519, Secp256k1, and MultiEd25519 signatures.\n */\nexport type AccountSignature =\n  | TransactionEd25519Signature\n  | TransactionSecp256k1Signature\n  | TransactionMultiEd25519Signature;\n\nexport type WriteSet = ScriptWriteSet | DirectWriteSet;\n\n/**\n * The set of properties for writing scripts, including the type of script.\n */\nexport type ScriptWriteSet = {\n  type: string;\n  execute_as: string;\n  script: ScriptPayloadResponse;\n};\n\n/**\n * The set of direct write operations, identified by a type string.\n */\nexport type DirectWriteSet = {\n  type: string;\n  changes: Array<WriteSetChange>;\n  events: Array<Event>;\n};\n\n/**\n * The structure for an event's unique identifier, including its creation number.\n */\n\n/**\n * The structure for an event, identified by a unique GUID.\n */\nexport type EventGuid = {\n  creation_number: string;\n  account_address: string;\n};\n\nexport type Event = {\n  guid: EventGuid;\n  sequence_number: string;\n  type: string;\n  /**\n   * The JSON representation of the event\n   */\n  data: any;\n};\n\n/**\n * A number representing a Move uint8 type.\n */\nexport type MoveUint8Type = number;\n\n/**\n * A 16-bit unsigned integer used in the Move programming language.\n */\nexport type MoveUint16Type = number;\n\n/**\n * A 32-bit unsigned integer type used in Move programming.\n */\nexport type MoveUint32Type = number;\n\n/**\n * A string representation of a 64-bit unsigned integer used in Move programming.\n */\nexport type MoveUint64Type = string;\n\n/**\n * A string representing a 128-bit unsigned integer in the Move programming language.\n */\nexport type MoveUint128Type = string;\n\n/**\n * A string representation of a 256-bit unsigned integer used in Move programming.\n */\nexport type MoveUint256Type = string;\n\n/**\n * A string representing a Move address.\n */\nexport type MoveAddressType = string;\n\n/**\n * The type for identifying objects to be moved within the system.\n */\nexport type MoveObjectType = string;\n\n/**\n * The type for move options, which can be a MoveType, null, or undefined.\n */\nexport type MoveOptionType = MoveType | null | undefined;\n\n/**\n * A structure representing a move with a name.\n */\nexport type MoveStructId = `${string}::${string}::${string}`;\n\n/**\n * The move function containing its name. Same as MoveStructId since it reads weird to take a StructId for a Function.\n */\nexport type MoveFunctionId = MoveStructId;\n\n// TODO: Add support for looking up ABI to add proper typing\nexport type MoveStructType = {};\n\n/**\n * A union type that encompasses various data types used in Move, including primitive types, address types, object types, and\n * arrays of MoveType.\n */\nexport type MoveType =\n  | boolean\n  | string\n  | MoveUint8Type\n  | MoveUint16Type\n  | MoveUint32Type\n  | MoveUint64Type\n  | MoveUint128Type\n  | MoveUint256Type\n  | MoveAddressType\n  | MoveObjectType\n  | MoveStructType\n  | Array<MoveType>;\n\n/**\n * Possible Move values acceptable by move functions (entry, view)\n *\n * Map of a Move value to the corresponding TypeScript value\n *\n * `Bool -> boolean`\n *\n * `u8, u16, u32 -> number`\n *\n * `u64, u128, u256 -> string`\n *\n * `String -> string`\n *\n * `Address -> 0x${string}`\n *\n * `Struct - 0x${string}::${string}::${string}`\n *\n * `Object -> 0x${string}`\n *\n * `Vector -> Array<MoveValue>`\n *\n * `Option -> MoveValue | null | undefined`\n */\nexport type MoveValue =\n  | boolean\n  | string\n  | MoveUint8Type\n  | MoveUint16Type\n  | MoveUint32Type\n  | MoveUint64Type\n  | MoveUint128Type\n  | MoveUint256Type\n  | MoveAddressType\n  | MoveObjectType\n  | MoveStructId\n  | MoveOptionType\n  | Array<MoveValue>;\n\n/**\n * A string representation of a Move module, formatted as `module_name::function_name`.\n * Module names are case-sensitive.\n */\nexport type MoveModuleId = `${string}::${string}`;\n\n/**\n * Specifies the visibility levels for move functions, controlling access permissions.\n */\nexport enum MoveFunctionVisibility {\n  PRIVATE = \"private\",\n  PUBLIC = \"public\",\n  FRIEND = \"friend\",\n}\n\n/**\n * Abilities related to moving items within the system.\n */\nexport enum MoveAbility {\n  STORE = \"store\",\n  DROP = \"drop\",\n  KEY = \"key\",\n  COPY = \"copy\",\n}\n\n/**\n * Move abilities associated with the generic type parameter of a function.\n */\nexport type MoveFunctionGenericTypeParam = {\n  constraints: Array<MoveAbility>;\n};\n\n/**\n * A field in a Move struct, identified by its name.\n */\nexport type MoveStructField = {\n  name: string;\n  type: string;\n};\n\n/**\n * A Move module\n */\nexport type MoveModule = {\n  address: string;\n  name: string;\n  /**\n   * Friends of the module\n   */\n  friends: Array<MoveModuleId>;\n  /**\n   * Public functions of the module\n   */\n  exposed_functions: Array<MoveFunction>;\n  /**\n   * Structs of the module\n   */\n  structs: Array<MoveStruct>;\n};\n\n/**\n * A move struct\n */\nexport type MoveStruct = {\n  name: string;\n  /**\n   * Whether the struct is a native struct of Move\n   */\n  is_native: boolean;\n  /**\n   * Whether the struct is a module event (aka v2 event). This will be false for v1\n   * events because the value is derived from the #[event] attribute on the struct in\n   * the Move source code. This attribute is only relevant for v2 events.\n   */\n  is_event: boolean;\n  /**\n   * Abilities associated with the struct\n   */\n  abilities: Array<MoveAbility>;\n  /**\n   * Generic types associated with the struct\n   */\n  generic_type_params: Array<MoveFunctionGenericTypeParam>;\n  /**\n   * Fields associated with the struct\n   */\n  fields: Array<MoveStructField>;\n};\n\n/**\n * Move function\n */\nexport type MoveFunction = {\n  name: string;\n  visibility: MoveFunctionVisibility;\n  /**\n   * Whether the function can be called as an entry function directly in a transaction\n   */\n  is_entry: boolean;\n  /**\n   * Whether the function is a view function or not\n   */\n  is_view: boolean;\n  /**\n   * Generic type params associated with the Move function\n   */\n  generic_type_params: Array<MoveFunctionGenericTypeParam>;\n  /**\n   * Parameters associated with the move function\n   */\n  params: Array<string>;\n  /**\n   * Return type of the function\n   */\n  return: Array<string>;\n};\n\n/**\n * Roles that can be assigned within the system, indicating different levels of access and functionality.\n */\nexport enum RoleType {\n  VALIDATOR = \"validator\",\n  FULL_NODE = \"full_node\",\n}\n\n/**\n * Information about the current blockchain ledger, including its chain ID.\n */\nexport type LedgerInfo = {\n  /**\n   * Chain ID of the current chain\n   */\n  chain_id: number;\n  epoch: string;\n  ledger_version: string;\n  oldest_ledger_version: string;\n  ledger_timestamp: string;\n  node_role: RoleType;\n  oldest_block_height: string;\n  block_height: string;\n  /**\n   * Git hash of the build of the API endpoint.  Can be used to determine the exact\n   * software version used by the API endpoint.\n   */\n  git_hash?: string;\n};\n\n/**\n * A Block type\n */\nexport type Block = {\n  block_height: string;\n  block_hash: string;\n  block_timestamp: string;\n  first_version: string;\n  last_version: string;\n  /**\n   * The transactions in the block in sequential order\n   */\n  transactions?: Array<TransactionResponse>;\n};\n\n// REQUEST TYPES\n\n/**\n * The request payload for the GetTableItem API.\n */\nexport type TableItemRequest = {\n  key_type: MoveValue;\n  value_type: MoveValue;\n  /**\n   * The value of the table item's key\n   */\n  key: any;\n};\n\n/**\n * A list of supported Authentication Key schemes in Aptos, consisting of combinations of signing schemes and derive schemes.\n */\nexport type AuthenticationKeyScheme = SigningScheme | DeriveScheme;\n\n/**\n * Different schemes for signing keys used in cryptographic operations.\n */\nexport enum SigningScheme {\n  /**\n   * For Ed25519PublicKey\n   */\n  Ed25519 = 0,\n  /**\n   * For MultiEd25519PublicKey\n   */\n  MultiEd25519 = 1,\n  /**\n   * For SingleKey ecdsa\n   */\n  SingleKey = 2,\n\n  MultiKey = 3,\n}\n\n/**\n * Specifies the signing schemes available for cryptographic operations.\n */\nexport enum SigningSchemeInput {\n  /**\n   * For Ed25519PublicKey\n   */\n  Ed25519 = 0,\n  /**\n   * For Secp256k1Ecdsa\n   */\n  Secp256k1Ecdsa = 2,\n}\n\n/**\n * Specifies the schemes for deriving account addresses from various data sources.\n */\nexport enum DeriveScheme {\n  /**\n   * Derives an address using an AUID, used for objects\n   */\n  DeriveAuid = 251,\n  /**\n   * Derives an address from another object address\n   */\n  DeriveObjectAddressFromObject = 252,\n  /**\n   * Derives an address from a GUID, used for objects\n   */\n  DeriveObjectAddressFromGuid = 253,\n  /**\n   * Derives an address from seed bytes, used for named objects\n   */\n  DeriveObjectAddressFromSeed = 254,\n  /**\n   * Derives an address from seed bytes, used for resource accounts\n   */\n  DeriveResourceAccountAddress = 255,\n}\n\n/**\n * Options for configuring the behavior of the waitForTransaction() function.\n */\nexport type WaitForTransactionOptions = {\n  timeoutSecs?: number;\n  checkSuccess?: boolean;\n  // Default behavior is to wait for the indexer. Set this to false to disable waiting.\n  waitForIndexer?: boolean;\n};\n\n/**\n * Input type to generate an account using the Ed25519 signing scheme.\n */\nexport type GenerateAccountWithEd25519 = {\n  scheme: SigningSchemeInput.Ed25519;\n  legacy: boolean;\n};\n\n/**\n * Input type to generate an account with a Single Signer using Secp256k1.\n */\nexport type GenerateAccountWithSingleSignerSecp256k1Key = {\n  scheme: SigningSchemeInput.Secp256k1Ecdsa;\n  legacy?: false;\n};\n\nexport type GenerateAccount = GenerateAccountWithEd25519 | GenerateAccountWithSingleSignerSecp256k1Key;\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n// eslint-disable-next-line max-classes-per-file\nimport { JwtPayload, jwtDecode } from \"jwt-decode\";\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { Hex, hexToAsciiString } from \"../hex\";\nimport {\n  HexInput,\n  EphemeralCertificateVariant,\n  AnyPublicKeyVariant,\n  SigningScheme,\n  ZkpVariant,\n  LedgerVersionArg,\n  MoveResource,\n} from \"../../types\";\nimport { EphemeralPublicKey, EphemeralSignature } from \"./ephemeral\";\nimport { bigIntToBytesLE, bytesToBigIntLE, hashStrToField, padAndPackBytesWithLen, poseidonHash } from \"./poseidon\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Proof } from \"./proof\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport {\n  Groth16VerificationKeyResponse,\n  KeylessConfigurationResponse,\n  MoveAnyStruct,\n  PatchedJWKsResponse,\n} from \"../../types/keyless\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { getAptosFullNode } from \"../../client\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport { base64UrlToBytes, getErrorMessage, nowInSeconds } from \"../../utils\";\nimport { KeylessError, KeylessErrorType } from \"../../errors\";\nimport { bn254 } from \"@noble/curves/bn254\";\nimport { bytesToNumberBE } from \"@noble/curves/abstract/utils\";\nimport { FederatedKeylessPublicKey } from \"./federatedKeyless\";\nimport { encode } from \"js-base64\";\nimport { generateSigningMessage } from \"../..\";\nimport { ProjPointType } from \"@noble/curves/abstract/weierstrass\";\nimport { Fp2 } from \"@noble/curves/abstract/tower\";\n\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const EPK_HORIZON_SECS = 10000000;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_AUD_VAL_BYTES = 120;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_UID_KEY_BYTES = 30;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_UID_VAL_BYTES = 330;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_ISS_VAL_BYTES = 120;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_EXTRA_FIELD_BYTES = 350;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_JWT_HEADER_B64_BYTES = 300;\n/**\n * @group Implementation\n * @category Serialization\n */\nexport const MAX_COMMITED_EPK_BYTES = 93;\n\n/**\n * Represents a Keyless Public Key used for authentication.\n *\n * This class encapsulates the public key functionality for keyless authentication,\n * including methods for generating and verifying signatures, as well as serialization\n * and deserialization of the key. The KeylessPublicKey is represented in the SDK\n * as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class KeylessPublicKey extends AccountPublicKey {\n  /**\n   * The number of bytes that `idCommitment` should be\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly ID_COMMITMENT_LENGTH: number = 32;\n\n  /**\n   * The value of the 'iss' claim on the JWT which identifies the OIDC provider.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly iss: string;\n\n  /**\n   * A value representing a cryptographic commitment to a user identity.\n   *\n   * It is calculated from the aud, uidKey, uidVal, pepper.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly idCommitment: Uint8Array;\n\n  /**\n   * Constructs an instance with the specified parameters for cryptographic operations.\n   *\n   * @param args - The parameters required to initialize the instance.\n   * @param args.alphaG1 - The hex representation of the alpha G1 value.\n   * @param args.betaG2 - The hex representation of the beta G2 value.\n   * @param args.deltaG2 - The hex representation of the delta G2 value.\n   * @param args.gammaAbcG1 - An array containing two hex representations for gamma ABC G1 values.\n   * @param args.gammaG2 - The hex representation of the gamma G2 value.\n   * @group Implementation\n   * @category Serialization\n   */\n  // TODO: Fix the JSDoc for the below values\n  constructor(iss: string, idCommitment: HexInput) {\n    super();\n    const idcBytes = Hex.fromHexInput(idCommitment).toUint8Array();\n    if (idcBytes.length !== KeylessPublicKey.ID_COMMITMENT_LENGTH) {\n      throw new Error(`Id Commitment length in bytes should be ${KeylessPublicKey.ID_COMMITMENT_LENGTH}`);\n    }\n    this.iss = iss;\n    this.idCommitment = idcBytes;\n  }\n\n  /**\n   * Get the authentication key for the keyless public key.\n   *\n   * @returns AuthenticationKey - The authentication key derived from the keyless public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Keyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies the validity of a signature for a given message.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the message.\n   * @param args.jwk - The JWK to use for verification.\n   * @param args.keylessConfig - The keyless configuration to use for verification.\n   * @returns true if the signature is valid; otherwise, false.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: {\n    message: HexInput;\n    signature: Signature;\n    jwk: MoveJWK;\n    keylessConfig: KeylessConfiguration;\n  }): boolean {\n    try {\n      verifyKeylessSignatureWithJwkAndConfig({ ...args, publicKey: this });\n      return true;\n    } catch (error) {\n      if (error instanceof KeylessError) {\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Verifies a keyless signature for a given message.  It will fetch the keyless configuration and the JWK to\n   * use for verification from the appropriate network as defined by the aptosConfig.\n   *\n   * @param args.aptosConfig The aptos config to use for fetching the keyless configuration.\n   * @param args.message The message to verify the signature against.\n   * @param args.signature The signature to verify.\n   * @param args.options.throwErrorWithReason Whether to throw an error with the reason for the failure instead of returning false.\n   * @returns true if the signature is valid\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return verifyKeylessSignature({\n      ...args,\n      publicKey: this,\n    });\n  }\n\n  /**\n   * Serializes the current instance into a format suitable for transmission or storage.\n   * This function ensures that all relevant fields are properly serialized, including the proof and optional fields.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @param serializer.proof - The proof to be serialized.\n   * @param serializer.expHorizonSecs - The expiration horizon in seconds.\n   * @param serializer.extraField - An optional additional field for serialization.\n   * @param serializer.overrideAudVal - An optional override value for auditing.\n   * @param serializer.trainingWheelsSignature - An optional signature for training wheels.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.iss);\n    serializer.serializeBytes(this.idCommitment);\n  }\n\n  /**\n   * Deserializes a ZeroKnowledgeSig object from the provided deserializer.\n   * This function allows you to reconstruct a ZeroKnowledgeSig instance from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @returns A new instance of ZeroKnowledgeSig.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Loads a KeylessPublicKey instance from the provided deserializer.\n   * This function is used to deserialize the necessary components to create a KeylessPublicKey.\n   *\n   * @param deserializer - The deserializer used to extract the string and byte data.\n   * @param deserializer.deserializeStr - A method to deserialize a string value.\n   * @param deserializer.deserializeBytes - A method to deserialize byte data.\n   * @returns A new instance of KeylessPublicKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  static load(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Determines if the provided public key is an instance of KeylessPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @returns A boolean indicating whether the public key is a KeylessPublicKey instance.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is KeylessPublicKey {\n    return publicKey instanceof KeylessPublicKey;\n  }\n\n  /**\n   * Creates a KeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns KeylessPublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n  }): KeylessPublicKey {\n    computeIdCommitment(args);\n    return new KeylessPublicKey(args.iss, computeIdCommitment(args));\n  }\n\n  /**\n   * Creates a KeylessPublicKey instance from a JWT and a pepper value.\n   * This function is useful for generating a public key that can be used for authentication based on the provided JWT claims and pepper.\n   *\n   * @param args - The arguments for creating the KeylessPublicKey.\n   * @param args.jwt - The JSON Web Token to decode.\n   * @param args.pepper - The pepper value used in the key creation process.\n   * @param args.uidKey - An optional key to retrieve the unique identifier from the JWT payload, defaults to \"sub\".\n   * @returns A KeylessPublicKey instance created from the provided JWT and pepper.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromJwtAndPepper(args: { jwt: string; pepper: HexInput; uidKey?: string }): KeylessPublicKey {\n    const { jwt, pepper, uidKey = \"sub\" } = args;\n    const jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n    if (typeof jwtPayload.iss !== \"string\") {\n      throw new Error(\"iss was not found\");\n    }\n    if (typeof jwtPayload.aud !== \"string\") {\n      throw new Error(\"aud was not found or an array of values\");\n    }\n    const uidVal = jwtPayload[uidKey];\n    return KeylessPublicKey.create({ iss: jwtPayload.iss, uidKey, uidVal, aud: jwtPayload.aud, pepper });\n  }\n\n  /**\n   * Checks if the provided public key is a valid instance by verifying its structure and types.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid instance.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"iss\" in publicKey &&\n      typeof publicKey.iss === \"string\" &&\n      \"idCommitment\" in publicKey &&\n      publicKey.idCommitment instanceof Uint8Array\n    );\n  }\n}\n\nexport async function verifyKeylessSignature(args: {\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  aptosConfig: AptosConfig;\n  message: HexInput;\n  signature: Signature;\n  keylessConfig?: KeylessConfiguration;\n  jwk?: MoveJWK;\n  options?: { throwErrorWithReason?: boolean };\n}): Promise<boolean> {\n  const {\n    aptosConfig,\n    publicKey,\n    message,\n    signature,\n    jwk,\n    keylessConfig = await getKeylessConfig({ aptosConfig }),\n    options,\n  } = args;\n  try {\n    if (!(signature instanceof KeylessSignature)) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n        details: \"Not a keyless signature\",\n      });\n    }\n    verifyKeylessSignatureWithJwkAndConfig({\n      message,\n      publicKey,\n      signature,\n      jwk: jwk ? jwk : await fetchJWK({ aptosConfig, publicKey, kid: signature.getJwkKid() }),\n      keylessConfig,\n    });\n    return true;\n  } catch (error) {\n    if (options?.throwErrorWithReason) {\n      throw error;\n    }\n    return false;\n  }\n}\n\n/**\n * Syncronously verifies a keyless signature for a given message.  You need to provide the keyless configuration and the\n * JWK to use for verification.\n *\n * @param args.message The message to verify the signature against.\n * @param args.signature The signature to verify.\n * @param args.keylessConfig The keyless configuration.\n * @param args.jwk The JWK to use for verification.\n * @returns true if the signature is valid\n * @throws KeylessError if the signature is invalid\n */\nexport function verifyKeylessSignatureWithJwkAndConfig(args: {\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  message: HexInput;\n  signature: Signature;\n  keylessConfig: KeylessConfiguration;\n  jwk: MoveJWK;\n}): void {\n  const { publicKey, message, signature, keylessConfig, jwk } = args;\n  const { verificationKey, maxExpHorizonSecs, trainingWheelsPubkey } = keylessConfig;\n  if (!(signature instanceof KeylessSignature)) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n      details: \"Not a keyless signature\",\n    });\n  }\n  if (!(signature.ephemeralCertificate.signature instanceof ZeroKnowledgeSig)) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n      details: \"Unsupported ephemeral certificate variant\",\n    });\n  }\n  const zkSig = signature.ephemeralCertificate.signature;\n  if (!(zkSig.proof.proof instanceof Groth16Zkp)) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_TYPE_INVALID,\n      details: \"Unsupported proof variant for ZeroKnowledgeSig\",\n    });\n  }\n  const groth16Proof = zkSig.proof.proof;\n  if (signature.expiryDateSecs < nowInSeconds()) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.SIGNATURE_EXPIRED,\n      details: \"The expiryDateSecs is in the past\",\n    });\n  }\n  if (zkSig.expHorizonSecs > maxExpHorizonSecs) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.MAX_EXPIRY_HORIZON_EXCEEDED,\n    });\n  }\n  if (!signature.ephemeralPublicKey.verifySignature({ message, signature: signature.ephemeralSignature })) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.EPHEMERAL_SIGNATURE_VERIFICATION_FAILED,\n    });\n  }\n  const publicInputsHash = getPublicInputsHash({ publicKey, signature, jwk, keylessConfig });\n  if (!verificationKey.verifyProof({ publicInputsHash, groth16Proof })) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.PROOF_VERIFICATION_FAILED,\n    });\n  }\n  if (trainingWheelsPubkey) {\n    if (!zkSig.trainingWheelsSignature) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.TRAINING_WHEELS_SIGNATURE_MISSING,\n      });\n    }\n    const proofAndStatement = new Groth16ProofAndStatement(groth16Proof, publicInputsHash);\n    if (\n      !trainingWheelsPubkey.verifySignature({\n        message: proofAndStatement.hash(),\n        signature: zkSig.trainingWheelsSignature,\n      })\n    ) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.TRAINING_WHEELS_SIGNATURE_VERIFICATION_FAILED,\n      });\n    }\n  }\n}\n\n/**\n * Get the public inputs hash for the keyless signature.\n *\n * @param args.signature The signature\n * @param args.jwk The JWK to use for the public inputs hash\n * @param args.keylessConfig The keyless configuration which defines the byte lengths to use when hashing fields.\n * @returns The public inputs hash\n */\nfunction getPublicInputsHash(args: {\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  signature: KeylessSignature;\n  jwk: MoveJWK;\n  keylessConfig: KeylessConfiguration;\n}): bigint {\n  const { publicKey, signature, jwk, keylessConfig } = args;\n  const innerKeylessPublicKey = publicKey instanceof KeylessPublicKey ? publicKey : publicKey.keylessPublicKey;\n  if (!(signature.ephemeralCertificate.signature instanceof ZeroKnowledgeSig)) {\n    throw new Error(\"Signature is not a ZeroKnowledgeSig\");\n  }\n  const proof = signature.ephemeralCertificate.signature;\n  const fields = [];\n  fields.push(\n    ...padAndPackBytesWithLen(signature.ephemeralPublicKey.toUint8Array(), keylessConfig.maxCommitedEpkBytes),\n  );\n  fields.push(bytesToBigIntLE(innerKeylessPublicKey.idCommitment));\n  fields.push(signature.expiryDateSecs);\n  fields.push(proof.expHorizonSecs);\n  fields.push(hashStrToField(innerKeylessPublicKey.iss, keylessConfig.maxIssValBytes));\n  if (!proof.extraField) {\n    fields.push(0n);\n    fields.push(hashStrToField(\" \", keylessConfig.maxExtraFieldBytes));\n  } else {\n    fields.push(1n);\n    fields.push(hashStrToField(proof.extraField, keylessConfig.maxExtraFieldBytes));\n  }\n  fields.push(hashStrToField(encode(signature.jwtHeader, true) + \".\", keylessConfig.maxJwtHeaderB64Bytes));\n  fields.push(jwk.toScalar());\n  if (!proof.overrideAudVal) {\n    fields.push(hashStrToField(\"\", MAX_AUD_VAL_BYTES));\n    fields.push(0n);\n  } else {\n    fields.push(hashStrToField(proof.overrideAudVal, MAX_AUD_VAL_BYTES));\n    fields.push(1n);\n  }\n  return poseidonHash(fields);\n}\n\n/**\n * Fetches the JWK from the issuer's well-known JWKS endpoint.\n *\n * @param args.publicKey The keyless public key which contains the issuer the address to fetch the JWK from (0x1 if not federated).\n * @param args.kid The kid of the JWK to fetch\n * @returns A JWK matching the `kid` in the JWT header.\n * @throws {KeylessError} If the JWK cannot be fetched\n */\nexport async function fetchJWK(args: {\n  aptosConfig: AptosConfig;\n  publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n  kid: string;\n}): Promise<MoveJWK> {\n  const { aptosConfig, publicKey, kid } = args;\n  const keylessPubKey = publicKey instanceof KeylessPublicKey ? publicKey : publicKey.keylessPublicKey;\n  const { iss } = keylessPubKey;\n\n  let allJWKs: Map<string, MoveJWK[]>;\n  const jwkAddr = publicKey instanceof FederatedKeylessPublicKey ? publicKey.jwkAddress : undefined;\n  try {\n    allJWKs = await getKeylessJWKs({ aptosConfig, jwkAddr });\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_JWKS_LOOKUP_ERROR,\n      error,\n      details: `Failed to fetch ${jwkAddr ? \"Federated\" : \"Patched\"}JWKs ${jwkAddr ? `for address ${jwkAddr}` : \"0x1\"}`,\n    });\n  }\n\n  // Find the corresponding JWK set by `iss`\n  const jwksForIssuer = allJWKs.get(iss);\n\n  if (jwksForIssuer === undefined) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.INVALID_JWT_ISS_NOT_RECOGNIZED,\n      details: `JWKs for issuer ${iss} not found.`,\n    });\n  }\n\n  // Find the corresponding JWK by `kid`\n  const jwk = jwksForIssuer.find((key) => key.kid === kid);\n\n  if (jwk === undefined) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.INVALID_JWT_JWK_NOT_FOUND,\n      details: `JWK with kid '${kid}' for issuer '${iss}' not found.`,\n    });\n  }\n\n  return jwk;\n}\n\nfunction computeIdCommitment(args: { uidKey: string; uidVal: string; aud: string; pepper: HexInput }): Uint8Array {\n  const { uidKey, uidVal, aud, pepper } = args;\n\n  const fields = [\n    bytesToBigIntLE(Hex.fromHexInput(pepper).toUint8Array()),\n    hashStrToField(aud, MAX_AUD_VAL_BYTES),\n    hashStrToField(uidVal, MAX_UID_VAL_BYTES),\n    hashStrToField(uidKey, MAX_UID_KEY_BYTES),\n  ];\n\n  return bigIntToBytesLE(poseidonHash(fields), KeylessPublicKey.ID_COMMITMENT_LENGTH);\n}\n\n/**\n * Represents a signature of a message signed via a Keyless Account, utilizing proofs or a JWT token for authentication.\n * @group Implementation\n * @category Serialization\n */\nexport class KeylessSignature extends Signature {\n  /**\n   * The inner signature ZeroKnowledgeSignature or OpenIdSignature\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly ephemeralCertificate: EphemeralCertificate;\n\n  /**\n   * The jwt header in the token used to create the proof/signature.  In json string representation.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly jwtHeader: string;\n\n  /**\n   * The expiry timestamp in seconds of the EphemeralKeyPair used to sign\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The ephemeral public key used to verify the signature\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly ephemeralPublicKey: EphemeralPublicKey;\n\n  /**\n   * The signature resulting from signing with the private key of the EphemeralKeyPair\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly ephemeralSignature: EphemeralSignature;\n\n  constructor(args: {\n    jwtHeader: string;\n    ephemeralCertificate: EphemeralCertificate;\n    expiryDateSecs: number;\n    ephemeralPublicKey: EphemeralPublicKey;\n    ephemeralSignature: EphemeralSignature;\n  }) {\n    super();\n    const { jwtHeader, ephemeralCertificate, expiryDateSecs, ephemeralPublicKey, ephemeralSignature } = args;\n    this.jwtHeader = jwtHeader;\n    this.ephemeralCertificate = ephemeralCertificate;\n    this.expiryDateSecs = expiryDateSecs;\n    this.ephemeralPublicKey = ephemeralPublicKey;\n    this.ephemeralSignature = ephemeralSignature;\n  }\n\n  /**\n   * Get the kid of the JWT used to derive the Keyless Account used to sign.\n   *\n   * @returns the kid as a string\n   */\n  getJwkKid(): string {\n    return parseJwtHeader(this.jwtHeader).kid;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.ephemeralCertificate.serialize(serializer);\n    serializer.serializeStr(this.jwtHeader);\n    serializer.serializeU64(this.expiryDateSecs);\n    this.ephemeralPublicKey.serialize(serializer);\n    this.ephemeralSignature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): KeylessSignature {\n    const ephemeralCertificate = EphemeralCertificate.deserialize(deserializer);\n    const jwtHeader = deserializer.deserializeStr();\n    const expiryDateSecs = deserializer.deserializeU64();\n    const ephemeralPublicKey = EphemeralPublicKey.deserialize(deserializer);\n    const ephemeralSignature = EphemeralSignature.deserialize(deserializer);\n    return new KeylessSignature({\n      jwtHeader,\n      expiryDateSecs: Number(expiryDateSecs),\n      ephemeralCertificate,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  static getSimulationSignature(): KeylessSignature {\n    return new KeylessSignature({\n      jwtHeader: \"{}\",\n      ephemeralCertificate: new EphemeralCertificate(\n        new ZeroKnowledgeSig({\n          proof: new ZkProof(\n            new Groth16Zkp({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }),\n            ZkpVariant.Groth16,\n          ),\n          expHorizonSecs: 0,\n        }),\n        EphemeralCertificateVariant.ZkProof,\n      ),\n      expiryDateSecs: 0,\n      ephemeralPublicKey: new EphemeralPublicKey(new Ed25519PublicKey(new Uint8Array(32))),\n      ephemeralSignature: new EphemeralSignature(new Ed25519Signature(new Uint8Array(64))),\n    });\n  }\n\n  static isSignature(signature: Signature): signature is KeylessSignature {\n    return signature instanceof KeylessSignature;\n  }\n}\n\n/**\n * Represents an ephemeral certificate containing a signature, specifically a ZeroKnowledgeSig.\n * This class can be extended to support additional signature types, such as OpenIdSignature.\n *\n * @extends Signature\n * @group Implementation\n * @category Serialization\n */\nexport class EphemeralCertificate extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly variant: EphemeralCertificateVariant;\n\n  constructor(signature: Signature, variant: EphemeralCertificateVariant) {\n    super();\n    this.signature = signature;\n    this.variant = variant;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.signature.toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): EphemeralCertificate {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case EphemeralCertificateVariant.ZkProof:\n        return new EphemeralCertificate(ZeroKnowledgeSig.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for EphemeralCertificate: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a fixed-size byte array of 32 bytes, extending the Serializable class.\n * This class is used for handling and serializing G1 bytes in cryptographic operations.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nclass G1Bytes extends Serializable {\n  private static readonly B = bn254.fields.Fp.create(3n);\n\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 32) {\n      throw new Error(\"Input needs to be 32 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G1Bytes {\n    const bytes = deserializer.deserializeFixedBytes(32);\n    return new G1Bytes(bytes);\n  }\n\n  // Convert the projective coordinates to strings\n  toArray(): string[] {\n    const point = this.toProjectivePoint();\n    return [point.x.toString(), point.y.toString(), point.pz.toString()];\n  }\n\n  /**\n   * Converts the G1 bytes to a projective point.\n   * @returns The projective point.\n   */\n  toProjectivePoint(): ProjPointType<bigint> {\n    const bytes = new Uint8Array(this.data);\n    // Reverse the bytes to convert from little-endian to big-endian.\n    bytes.reverse();\n    // This gets the flag bit to determine which y to use.\n    const yFlag = (bytes[0] & 0x80) >> 7;\n    const { Fp } = bn254.fields;\n    const x = Fp.create(bytesToBn254FpBE(bytes));\n    const y = Fp.sqrt(Fp.add(Fp.pow(x, 3n), G1Bytes.B));\n    const negY = Fp.neg(y);\n    const yToUse = y > negY === (yFlag === 1) ? y : negY;\n    return bn254.G1.ProjectivePoint.fromAffine({\n      x: x,\n      y: yToUse,\n    });\n  }\n}\n\nfunction bytesToBn254FpBE(bytes: Uint8Array): bigint {\n  if (bytes.length !== 32) {\n    throw new Error(\"Input should be 32 bytes\");\n  }\n  // Clear the first two bits of the first byte which removes any flags.\n  const result = new Uint8Array(bytes);\n  result[0] = result[0] & 0x3f; // 0x3F = 00111111 in binary\n  return bytesToNumberBE(result);\n}\n\n/**\n * Represents a 64-byte G2 element in a cryptographic context.\n * This class provides methods for serialization and deserialization of G2 bytes.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nclass G2Bytes extends Serializable {\n  /**\n   * The constant b value used in G2 point calculations\n   */\n  private static readonly B = bn254.fields.Fp2.fromBigTuple([\n    19485874751759354771024239261021720505790618469301721065564631296452457478373n,\n    266929791119991161246907387137283842545076965332900288569378510910307636690n,\n  ]);\n\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 64) {\n      throw new Error(\"Input needs to be 64 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G2Bytes {\n    const bytes = deserializer.deserializeFixedBytes(64);\n    return new G2Bytes(bytes);\n  }\n\n  // Convert the projective coordinates to strings\n  toArray(): [string, string][] {\n    const point = this.toProjectivePoint();\n    return [\n      [\n        point.x.c0.toString(), // x real part\n        point.x.c1.toString(),\n      ], // x imaginary part\n      [\n        point.y.c0.toString(), // y real part\n        point.y.c1.toString(),\n      ], // y imaginary part\n      [\n        point.pz.c0.toString(), // z real part\n        point.pz.c1.toString(),\n      ], // z imaginary part\n    ];\n  }\n\n  toProjectivePoint(): ProjPointType<Fp2> {\n    const bytes = new Uint8Array(this.data);\n    // Reverse the bytes to convert from little-endian to big-endian for each part of x.\n    const x0 = bytes.slice(0, 32).reverse();\n    const x1 = bytes.slice(32, 64).reverse();\n    // This gets the flag bit to determine which y to use.\n    const yFlag = (x1[0] & 0x80) >> 7;\n    const { Fp2 } = bn254.fields;\n    const x = Fp2.fromBigTuple([bytesToBn254FpBE(x0), bytesToBn254FpBE(x1)]);\n    const y = Fp2.sqrt(Fp2.add(Fp2.pow(x, 3n), G2Bytes.B));\n    const negY = Fp2.neg(y);\n    const isYGreaterThanNegY = y.c1 > negY.c1 || (y.c1 === negY.c1 && y.c0 > negY.c0);\n    const yToUse = isYGreaterThanNegY === (yFlag === 1) ? y : negY;\n    return bn254.G2.ProjectivePoint.fromAffine({\n      x: x,\n      y: yToUse,\n    });\n  }\n}\n\n/**\n * Represents a Groth16 zero-knowledge proof, consisting of three proof points in compressed serialization format.\n * The points are the compressed serialization of affine representation of the proof.\n *\n * @extends Proof\n * @group Implementation\n * @category Serialization\n */\nexport class Groth16Zkp extends Proof {\n  /**\n   * The bytes of G1 proof point a\n   * @group Implementation\n   * @category Serialization\n   */\n  a: G1Bytes;\n\n  /**\n   * The bytes of G2 proof point b\n   * @group Implementation\n   * @category Serialization\n   */\n  b: G2Bytes;\n\n  /**\n   * The bytes of G1 proof point c\n   * @group Implementation\n   * @category Serialization\n   */\n  c: G1Bytes;\n\n  constructor(args: { a: HexInput; b: HexInput; c: HexInput }) {\n    super();\n    const { a, b, c } = args;\n    this.a = new G1Bytes(a);\n    this.b = new G2Bytes(b);\n    this.c = new G1Bytes(c);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.a.serialize(serializer);\n    this.b.serialize(serializer);\n    this.c.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Groth16Zkp {\n    const a = G1Bytes.deserialize(deserializer).bcsToBytes();\n    const b = G2Bytes.deserialize(deserializer).bcsToBytes();\n    const c = G1Bytes.deserialize(deserializer).bcsToBytes();\n    return new Groth16Zkp({ a, b, c });\n  }\n\n  toSnarkJsJson() {\n    return {\n      protocol: \"groth16\",\n      curve: \"bn128\",\n      pi_a: this.a.toArray(),\n      pi_b: this.b.toArray(),\n      pi_c: this.c.toArray(),\n    };\n  }\n}\n\n/**\n * Represents a Groth16 proof and statement, consisting of a Groth16 proof and a public inputs hash.\n * This is used to generate the signing message for the training wheels signature.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nexport class Groth16ProofAndStatement extends Serializable {\n  /**\n   * The Groth16 proof\n   * @group Implementation\n   * @category Serialization\n   */\n  proof: Groth16Zkp;\n\n  /**\n   * The public inputs hash as a 32 byte Uint8Array\n   * @group Implementation\n   * @category Serialization\n   */\n  publicInputsHash: Uint8Array;\n\n  /**\n   * The domain separator prefix used when hashing.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly domainSeparator = \"APTOS::Groth16ProofAndStatement\";\n\n  constructor(proof: Groth16Zkp, publicInputsHash: HexInput | bigint) {\n    super();\n    this.proof = proof;\n    this.publicInputsHash =\n      typeof publicInputsHash === \"bigint\"\n        ? bigIntToBytesLE(publicInputsHash, 32)\n        : Hex.fromHexInput(publicInputsHash).toUint8Array();\n    if (this.publicInputsHash.length !== 32) {\n      throw new Error(\"Invalid public inputs hash\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    this.proof.serialize(serializer);\n    serializer.serializeFixedBytes(this.publicInputsHash);\n  }\n\n  static deserialize(deserializer: Deserializer): Groth16ProofAndStatement {\n    return new Groth16ProofAndStatement(Groth16Zkp.deserialize(deserializer), deserializer.deserializeFixedBytes(32));\n  }\n\n  hash(): Uint8Array {\n    return generateSigningMessage(this.bcsToBytes(), this.domainSeparator);\n  }\n}\n\n/**\n * Represents a container for different types of zero-knowledge proofs.\n *\n * @extends Serializable\n * @group Implementation\n * @category Serialization\n */\nexport class ZkProof extends Serializable {\n  public readonly proof: Proof;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly variant: ZkpVariant;\n\n  constructor(proof: Proof, variant: ZkpVariant) {\n    super();\n    this.proof = proof;\n    this.variant = variant;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.proof.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ZkProof {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case ZkpVariant.Groth16:\n        return new ZkProof(Groth16Zkp.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for ZkProof: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a zero-knowledge signature, encapsulating the proof and its associated metadata.\n *\n * @extends Signature\n * @group Implementation\n * @category Serialization\n */\nexport class ZeroKnowledgeSig extends Signature {\n  /**\n   * The proof\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly proof: ZkProof;\n\n  /**\n   * The max lifespan of the proof\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly expHorizonSecs: number;\n\n  /**\n   * A key value pair on the JWT token that can be specified on the signature which would reveal the value on chain.\n   * Can be used to assert identity or other attributes.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly extraField?: string;\n\n  /**\n   * The 'aud' value of the recovery service which is set when recovering an account.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly overrideAudVal?: string;\n\n  /**\n   * The training wheels signature\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly trainingWheelsSignature?: EphemeralSignature;\n\n  constructor(args: {\n    proof: ZkProof;\n    expHorizonSecs: number;\n    extraField?: string;\n    overrideAudVal?: string;\n    trainingWheelsSignature?: EphemeralSignature;\n  }) {\n    super();\n    const { proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal } = args;\n    this.proof = proof;\n    this.expHorizonSecs = expHorizonSecs;\n    this.trainingWheelsSignature = trainingWheelsSignature;\n    this.extraField = extraField;\n    this.overrideAudVal = overrideAudVal;\n  }\n\n  /**\n   * Deserialize a ZeroKnowledgeSig object from its BCS serialization in bytes.\n   *\n   * @param bytes - The bytes representing the serialized ZeroKnowledgeSig.\n   * @returns ZeroKnowledgeSig - The deserialized ZeroKnowledgeSig object.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromBytes(bytes: Uint8Array): ZeroKnowledgeSig {\n    return ZeroKnowledgeSig.deserialize(new Deserializer(bytes));\n  }\n\n  serialize(serializer: Serializer): void {\n    this.proof.serialize(serializer);\n    serializer.serializeU64(this.expHorizonSecs);\n    serializer.serializeOption(this.extraField);\n    serializer.serializeOption(this.overrideAudVal);\n    serializer.serializeOption(this.trainingWheelsSignature);\n  }\n\n  static deserialize(deserializer: Deserializer): ZeroKnowledgeSig {\n    const proof = ZkProof.deserialize(deserializer);\n    const expHorizonSecs = Number(deserializer.deserializeU64());\n    const extraField = deserializer.deserializeOption(\"string\");\n    const overrideAudVal = deserializer.deserializeOption(\"string\");\n    const trainingWheelsSignature = deserializer.deserializeOption(EphemeralSignature);\n    return new ZeroKnowledgeSig({ proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal });\n  }\n}\n\n/**\n * Represents the on-chain configuration for how Keyless accounts operate.\n *\n * @remarks\n * This class encapsulates the verification key and the maximum lifespan of ephemeral key pairs,\n * which are essential for the functionality of Keyless accounts.\n * @group Implementation\n * @category Serialization\n */\nexport class KeylessConfiguration {\n  /**\n   * The verification key used to verify Groth16 proofs on chain\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly verificationKey: Groth16VerificationKey;\n\n  /**\n   * The maximum lifespan of an ephemeral key pair.  This is configured on chain.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxExpHorizonSecs: number;\n\n  /**\n   * The public key of the training wheels account.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly trainingWheelsPubkey?: EphemeralPublicKey;\n\n  /**\n   * The maximum number of bytes that can be used for the extra field.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxExtraFieldBytes: number;\n\n  /**\n   * The maximum number of bytes that can be used for the JWT header.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxJwtHeaderB64Bytes: number;\n\n  /**\n   * The maximum number of bytes that can be used for the issuer value.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxIssValBytes: number;\n\n  /**\n   * The maximum number of bytes that can be used for the committed ephemeral public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly maxCommitedEpkBytes: number;\n\n  constructor(args: {\n    verificationKey: Groth16VerificationKey;\n    trainingWheelsPubkey?: HexInput;\n    maxExpHorizonSecs?: number;\n    maxExtraFieldBytes?: number;\n    maxJwtHeaderB64Bytes?: number;\n    maxIssValBytes?: number;\n    maxCommitedEpkBytes?: number;\n  }) {\n    const {\n      verificationKey,\n      trainingWheelsPubkey,\n      maxExpHorizonSecs = EPK_HORIZON_SECS,\n      maxExtraFieldBytes = MAX_EXTRA_FIELD_BYTES,\n      maxJwtHeaderB64Bytes = MAX_JWT_HEADER_B64_BYTES,\n      maxIssValBytes = MAX_ISS_VAL_BYTES,\n      maxCommitedEpkBytes = MAX_COMMITED_EPK_BYTES,\n    } = args;\n\n    this.verificationKey = verificationKey;\n    this.maxExpHorizonSecs = maxExpHorizonSecs;\n    if (trainingWheelsPubkey) {\n      this.trainingWheelsPubkey = new EphemeralPublicKey(new Ed25519PublicKey(trainingWheelsPubkey));\n    }\n    this.maxExtraFieldBytes = maxExtraFieldBytes;\n    this.maxJwtHeaderB64Bytes = maxJwtHeaderB64Bytes;\n    this.maxIssValBytes = maxIssValBytes;\n    this.maxCommitedEpkBytes = maxCommitedEpkBytes;\n  }\n\n  /**\n   * Creates a new KeylessConfiguration instance from a Groth16VerificationKeyResponse and a KeylessConfigurationResponse.\n   * @param res - The Groth16VerificationKeyResponse object containing the verification key data.\n   * @param config - The KeylessConfigurationResponse object containing the configuration data.\n   * @returns A new KeylessConfiguration instance.\n   */\n  static create(res: Groth16VerificationKeyResponse, config: KeylessConfigurationResponse): KeylessConfiguration {\n    return new KeylessConfiguration({\n      verificationKey: new Groth16VerificationKey({\n        alphaG1: res.alpha_g1,\n        betaG2: res.beta_g2,\n        deltaG2: res.delta_g2,\n        gammaAbcG1: res.gamma_abc_g1,\n        gammaG2: res.gamma_g2,\n      }),\n      maxExpHorizonSecs: Number(config.max_exp_horizon_secs),\n      trainingWheelsPubkey: config.training_wheels_pubkey.vec[0],\n      maxExtraFieldBytes: config.max_extra_field_bytes,\n      maxJwtHeaderB64Bytes: config.max_jwt_header_b64_bytes,\n      maxIssValBytes: config.max_iss_val_bytes,\n      maxCommitedEpkBytes: config.max_commited_epk_bytes,\n    });\n  }\n}\n\n/**\n * Represents the verification key stored on-chain used to verify Groth16 proofs.\n * @group Implementation\n * @category Serialization\n */\nexport class Groth16VerificationKey {\n  // The docstrings below are borrowed from ark-groth16\n\n  /**\n   * The `alpha * G`, where `G` is the generator of G1\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly alphaG1: G1Bytes;\n\n  /**\n   * The `alpha * H`, where `H` is the generator of G2\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly betaG2: G2Bytes;\n\n  /**\n   * The `delta * H`, where `H` is the generator of G2\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly deltaG2: G2Bytes;\n\n  /**\n   * The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where H is the generator of G1\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly gammaAbcG1: [G1Bytes, G1Bytes];\n\n  /**\n   * The `gamma * H`, where `H` is the generator of G2\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly gammaG2: G2Bytes;\n\n  constructor(args: {\n    alphaG1: HexInput;\n    betaG2: HexInput;\n    deltaG2: HexInput;\n    gammaAbcG1: [HexInput, HexInput];\n    gammaG2: HexInput;\n  }) {\n    const { alphaG1, betaG2, deltaG2, gammaAbcG1, gammaG2 } = args;\n    this.alphaG1 = new G1Bytes(alphaG1);\n    this.betaG2 = new G2Bytes(betaG2);\n    this.deltaG2 = new G2Bytes(deltaG2);\n    this.gammaAbcG1 = [new G1Bytes(gammaAbcG1[0]), new G1Bytes(gammaAbcG1[1])];\n    this.gammaG2 = new G2Bytes(gammaG2);\n  }\n\n  /**\n   * Calculates the hash of the serialized form of the verification key.\n   * This is useful for comparing verification keys or using them as unique identifiers.\n   *\n   * @returns The SHA3-256 hash of the serialized verification key as a Uint8Array\n   */\n  public hash(): Uint8Array {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return sha3_256.create().update(serializer.toUint8Array()).digest();\n  }\n\n  serialize(serializer: Serializer): void {\n    this.alphaG1.serialize(serializer);\n    this.betaG2.serialize(serializer);\n    this.deltaG2.serialize(serializer);\n    this.gammaAbcG1[0].serialize(serializer);\n    this.gammaAbcG1[1].serialize(serializer);\n    this.gammaG2.serialize(serializer);\n  }\n\n  /**\n   * Converts a Groth16VerificationKeyResponse object into a Groth16VerificationKey instance.\n   *\n   * @param res - The Groth16VerificationKeyResponse object containing the verification key data.\n   * @param res.alpha_g1 - The alpha G1 value from the response.\n   * @param res.beta_g2 - The beta G2 value from the response.\n   * @param res.delta_g2 - The delta G2 value from the response.\n   * @param res.gamma_abc_g1 - The gamma ABC G1 value from the response.\n   * @param res.gamma_g2 - The gamma G2 value from the response.\n   * @returns A Groth16VerificationKey instance constructed from the provided response data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromGroth16VerificationKeyResponse(res: Groth16VerificationKeyResponse): Groth16VerificationKey {\n    return new Groth16VerificationKey({\n      alphaG1: res.alpha_g1,\n      betaG2: res.beta_g2,\n      deltaG2: res.delta_g2,\n      gammaAbcG1: res.gamma_abc_g1,\n      gammaG2: res.gamma_g2,\n    });\n  }\n\n  /**\n   * Verifies a Groth16 proof using the verification key given the public inputs hash and the proof.\n   *\n   * @param args.publicInputsHash The public inputs hash\n   * @param args.groth16Proof The Groth16 proof\n   * @returns true if the proof is valid\n   */\n  verifyProof(args: { publicInputsHash: bigint; groth16Proof: Groth16Zkp }): boolean {\n    const { publicInputsHash, groth16Proof } = args;\n\n    try {\n      // Get proof points\n      const proofA = groth16Proof.a.toProjectivePoint();\n      const proofB = groth16Proof.b.toProjectivePoint();\n      const proofC = groth16Proof.c.toProjectivePoint();\n\n      // Get verification key points\n      const vkAlpha1 = this.alphaG1.toProjectivePoint();\n      const vkBeta2 = this.betaG2.toProjectivePoint();\n      const vkGamma2 = this.gammaG2.toProjectivePoint();\n      const vkDelta2 = this.deltaG2.toProjectivePoint();\n      const vkIC = this.gammaAbcG1.map((g1) => g1.toProjectivePoint());\n\n      const { Fp12 } = bn254.fields;\n\n      // Check that the following pairing equation holds:\n      // e(A_1, B_2) = e(\\alpha_1, \\beta_2) + e(\\ic_0 + public_inputs_hash \\ic_1, \\gamma_2) + e(C_1, \\delta_2)\n      // Where A_1, B_2, C_1 are the proof points and \\alpha_1, \\beta_2, \\gamma_2, \\delta_2, \\ic_0, \\ic_1\n      // are the verification key points\n\n      // \\ic_0 + public_inputs_hash \\ic_1\n      let accum = vkIC[0].add(vkIC[1].multiply(publicInputsHash));\n      // e(\\ic_0 + public_inputs_hash \\ic_1, \\gamma_2)\n      const pairingAccumGamma = bn254.pairing(accum, vkGamma2);\n      // e(A_1, B_2)\n      const pairingAB = bn254.pairing(proofA, proofB);\n      // e(\\alpha_1, \\beta_2)\n      const pairingAlphaBeta = bn254.pairing(vkAlpha1, vkBeta2);\n      // e(C_1, \\delta_2)\n      const pairingCDelta = bn254.pairing(proofC, vkDelta2);\n      // Get the result of the right hand side of the pairing equation\n      const product = Fp12.mul(pairingAlphaBeta, Fp12.mul(pairingAccumGamma, pairingCDelta));\n      // Check if the left hand side equals the right hand side\n      return Fp12.eql(pairingAB, product);\n    } catch (error) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_VERIFICATION_FAILED,\n        error,\n        details: \"Error encountered when checking zero knowledge relation\",\n      });\n    }\n  }\n\n  /**\n   * Converts the verification key to a JSON format compatible with snarkjs groth16.verify\n   *\n   * @returns An object containing the verification key in snarkjs format\n   * @group Implementation\n   * @category Serialization\n   */\n  toSnarkJsJson() {\n    return {\n      protocol: \"groth16\",\n      curve: \"bn128\",\n      nPublic: 1,\n      vk_alpha_1: this.alphaG1.toArray(),\n      vk_beta_2: this.betaG2.toArray(),\n      vk_gamma_2: this.gammaG2.toArray(),\n      vk_delta_2: this.deltaG2.toArray(),\n      IC: this.gammaAbcG1.map((g1) => g1.toArray()),\n    };\n  }\n}\n\n/**\n * Retrieves the configuration parameters for Keyless Accounts on the blockchain, including the verifying key and the maximum\n * expiry horizon.\n *\n * @param args - The arguments for retrieving the keyless configuration.\n * @param args.aptosConfig - The Aptos configuration object containing network details.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, the latest version will be used.\n * @returns KeylessConfiguration - The configuration object containing the verifying key and maximum expiry horizon.\n * @group Implementation\n * @category Serialization\n */\nexport async function getKeylessConfig(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfiguration> {\n  const { aptosConfig } = args;\n  try {\n    return await memoizeAsync(\n      async () => {\n        const [config, vk] = await Promise.all([\n          getKeylessConfigurationResource(args),\n          getGroth16VerificationKeyResource(args),\n        ]);\n        return KeylessConfiguration.create(vk, config);\n      },\n      `keyless-configuration-${aptosConfig.network}`,\n      1000 * 60 * 5, // 5 minutes\n    )();\n  } catch (error) {\n    if (error instanceof KeylessError) {\n      throw error;\n    }\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_OTHER,\n      error,\n    });\n  }\n}\n\n/**\n * Parses a JWT and returns the 'iss', 'aud', and 'uid' values.\n *\n * @param args - The arguments for parsing the JWT.\n * @param args.jwt - The JWT to parse.\n * @param args.uidKey - The key to use for the 'uid' value; defaults to 'sub'.\n * @returns The 'iss', 'aud', and 'uid' values from the JWT.\n */\nexport function getIssAudAndUidVal(args: { jwt: string; uidKey?: string }): {\n  iss: string;\n  aud: string;\n  uidVal: string;\n} {\n  const { jwt, uidKey = \"sub\" } = args;\n  let jwtPayload: JwtPayload & { [key: string]: string };\n  try {\n    jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: `Failed to parse JWT - ${getErrorMessage(error)}`,\n    });\n  }\n  if (typeof jwtPayload.iss !== \"string\") {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: \"JWT is missing 'iss' in the payload. This should never happen.\",\n    });\n  }\n  if (typeof jwtPayload.aud !== \"string\") {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWT_PARSING_ERROR,\n      details: \"JWT is missing 'aud' in the payload or 'aud' is an array of values.\",\n    });\n  }\n  const uidVal = jwtPayload[uidKey];\n  return { iss: jwtPayload.iss, aud: jwtPayload.aud, uidVal };\n}\n\n/**\n * Retrieves the KeylessConfiguration set on chain.\n *\n * @param args - The arguments for retrieving the configuration.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns KeylessConfigurationResponse - The response containing the keyless configuration data.\n * @group Implementation\n * @category Serialization\n */\nasync function getKeylessConfigurationResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfigurationResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Configuration\";\n  try {\n    const { data } = await getAptosFullNode<{}, MoveResource<KeylessConfigurationResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessConfigurationResource\",\n      path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    return data.data;\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_CONFIG_LOOKUP_ERROR,\n      error,\n    });\n  }\n}\n\n/**\n * Retrieves the Groth16VerificationKey set on the blockchain.\n *\n * @param args - The arguments for retrieving the verification key.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns Groth16VerificationKeyResponse - The response containing the Groth16 verification key data.\n * @group Implementation\n * @category Serialization\n */\nasync function getGroth16VerificationKeyResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<Groth16VerificationKeyResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Groth16VerificationKey\";\n  try {\n    const { data } = await getAptosFullNode<{}, MoveResource<Groth16VerificationKeyResponse>>({\n      aptosConfig,\n      originMethod: \"getGroth16VerificationKeyResource\",\n      path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    return data.data;\n  } catch (error) {\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR,\n      error,\n    });\n  }\n}\n\nexport async function getKeylessJWKs(args: {\n  aptosConfig: AptosConfig;\n  jwkAddr?: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<Map<string, MoveJWK[]>> {\n  const { aptosConfig, jwkAddr, options } = args;\n  let resource: MoveResource<PatchedJWKsResponse>;\n  if (!jwkAddr) {\n    const resourceType = \"0x1::jwks::PatchedJWKs\";\n    const { data } = await getAptosFullNode<{}, MoveResource<PatchedJWKsResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessJWKs\",\n      path: `accounts/0x1/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    resource = data;\n  } else {\n    const resourceType = \"0x1::jwks::FederatedJWKs\";\n    const { data } = await getAptosFullNode<{}, MoveResource<PatchedJWKsResponse>>({\n      aptosConfig,\n      originMethod: \"getKeylessJWKs\",\n      path: `accounts/${AccountAddress.from(jwkAddr).toString()}/resource/${resourceType}`,\n      params: { ledger_version: options?.ledgerVersion },\n    });\n    resource = data;\n  }\n\n  // Create a map of issuer to JWK arrays\n  const jwkMap = new Map<string, MoveJWK[]>();\n  for (const entry of resource.data.jwks.entries) {\n    const jwks: MoveJWK[] = [];\n    for (const jwkStruct of entry.jwks) {\n      const { data: jwkData } = jwkStruct.variant;\n      const deserializer = new Deserializer(Hex.fromHexInput(jwkData).toUint8Array());\n      const jwk = MoveJWK.deserialize(deserializer);\n      jwks.push(jwk);\n    }\n    jwkMap.set(hexToAsciiString(entry.issuer), jwks);\n  }\n\n  return jwkMap;\n}\n\nexport class MoveJWK extends Serializable {\n  public kid: string;\n\n  public kty: string;\n\n  public alg: string;\n\n  public e: string;\n\n  public n: string;\n\n  constructor(args: { kid: string; kty: string; alg: string; e: string; n: string }) {\n    super();\n    const { kid, kty, alg, e, n } = args;\n    this.kid = kid;\n    this.kty = kty;\n    this.alg = alg;\n    this.e = e;\n    this.n = n;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.kid);\n    serializer.serializeStr(this.kty);\n    serializer.serializeStr(this.alg);\n    serializer.serializeStr(this.e);\n    serializer.serializeStr(this.n);\n  }\n\n  static fromMoveStruct(struct: MoveAnyStruct): MoveJWK {\n    const { data } = struct.variant;\n    const deserializer = new Deserializer(Hex.fromHexInput(data).toUint8Array());\n    return MoveJWK.deserialize(deserializer);\n  }\n\n  toScalar(): bigint {\n    if (this.alg !== \"RS256\") {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_VERIFICATION_FAILED,\n        details:\n          \"Failed to convert JWK to scalar when calculating the public inputs hash. Only RSA 256 is supported currently\",\n      });\n    }\n    const uint8Array = base64UrlToBytes(this.n);\n    const chunks = chunkInto24Bytes(uint8Array.reverse());\n    const scalars = chunks.map((chunk) => bytesToBigIntLE(chunk));\n    scalars.push(256n); // Add the modulus size\n    return poseidonHash(scalars);\n  }\n\n  static deserialize(deserializer: Deserializer): MoveJWK {\n    const kid = deserializer.deserializeStr();\n    const kty = deserializer.deserializeStr();\n    const alg = deserializer.deserializeStr();\n    const e = deserializer.deserializeStr();\n    const n = deserializer.deserializeStr();\n    return new MoveJWK({ kid, kty, alg, n, e });\n  }\n}\n\nfunction chunkInto24Bytes(data: Uint8Array): Uint8Array[] {\n  const chunks: Uint8Array[] = [];\n  for (let i = 0; i < data.length; i += 24) {\n    const chunk = data.slice(i, Math.min(i + 24, data.length));\n    // Pad last chunk with zeros if needed\n    if (chunk.length < 24) {\n      const paddedChunk = new Uint8Array(24);\n      paddedChunk.set(chunk);\n      chunks.push(paddedChunk);\n    } else {\n      chunks.push(chunk);\n    }\n  }\n  return chunks;\n}\n\ninterface JwtHeader {\n  kid: string; // Key ID\n}\n/**\n * Safely parses the JWT header.\n * @param jwtHeader The JWT header string\n * @returns Parsed JWT header as an object.\n */\nexport function parseJwtHeader(jwtHeader: string): JwtHeader {\n  try {\n    const header = JSON.parse(jwtHeader);\n    if (header.kid === undefined) {\n      throw new Error(\"JWT header missing kid\");\n    }\n    return header;\n  } catch (error) {\n    throw new Error(\"Failed to parse JWT header.\");\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { HexInput, AnyPublicKeyVariant, SigningScheme } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport {\n  KeylessConfiguration,\n  KeylessPublicKey,\n  KeylessSignature,\n  MoveJWK,\n  verifyKeylessSignature,\n  verifyKeylessSignatureWithJwkAndConfig,\n} from \"./keyless\";\nimport { AptosConfig } from \"../../api\";\nimport { Signature } from \"..\";\n\n/**\n * Represents the FederatedKeylessPublicKey public key\n *\n * These keys use an on-chain address as a source of truth for the JWK used to verify signatures.\n *\n * FederatedKeylessPublicKey authentication key is represented in the SDK as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class FederatedKeylessPublicKey extends AccountPublicKey {\n  /**\n   * The address that contains the JWK set to be used for verification.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly jwkAddress: AccountAddress;\n\n  /**\n   * The inner public key which contains the standard Keyless public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly keylessPublicKey: KeylessPublicKey;\n\n  constructor(jwkAddress: AccountAddressInput, keylessPublicKey: KeylessPublicKey) {\n    super();\n    this.jwkAddress = AccountAddress.from(jwkAddress);\n    this.keylessPublicKey = keylessPublicKey;\n  }\n\n  /**\n   * Get the authentication key for the federated keyless public key\n   *\n   * @returns AuthenticationKey\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.FederatedKeyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @param args.jwk - The JWK to use for verification.\n   * @param args.keylessConfig - The keyless configuration to use for verification.\n   * @returns true if the signature is valid\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: {\n    message: HexInput;\n    signature: Signature;\n    jwk: MoveJWK;\n    keylessConfig: KeylessConfiguration;\n  }): boolean {\n    try {\n      verifyKeylessSignatureWithJwkAndConfig({ ...args, publicKey: this });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    this.jwkAddress.serialize(serializer);\n    this.keylessPublicKey.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): FederatedKeylessPublicKey {\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const keylessPublicKey = KeylessPublicKey.deserialize(deserializer);\n    return new FederatedKeylessPublicKey(jwkAddress, keylessPublicKey);\n  }\n\n  static isPublicKey(publicKey: PublicKey): publicKey is FederatedKeylessPublicKey {\n    return publicKey instanceof FederatedKeylessPublicKey;\n  }\n\n  /**\n   * Verifies a keyless signature for a given message.  It will fetch the keyless configuration and the JWK to\n   * use for verification from the appropriate network as defined by the aptosConfig.\n   *\n   * @param args.aptosConfig The aptos config to use for fetching the keyless configuration.\n   * @param args.message The message to verify the signature against.\n   * @param args.signature The signature to verify.\n   * @param args.options.throwErrorWithReason Whether to throw an error with the reason for the failure instead of returning false.\n   * @returns true if the signature is valid\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: KeylessSignature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return verifyKeylessSignature({\n      ...args,\n      publicKey: this,\n    });\n  }\n\n  /**\n   * Creates a FederatedKeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns FederatedKeylessPublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n  }): FederatedKeylessPublicKey {\n    return new FederatedKeylessPublicKey(args.jwkAddress, KeylessPublicKey.create(args));\n  }\n\n  static fromJwtAndPepper(args: {\n    jwt: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n  }): FederatedKeylessPublicKey {\n    return new FederatedKeylessPublicKey(args.jwkAddress, KeylessPublicKey.fromJwtAndPepper(args));\n  }\n\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"jwkAddress\" in publicKey &&\n      publicKey.jwkAddress instanceof AccountAddress &&\n      \"keylessPublicKey\" in publicKey &&\n      publicKey.keylessPublicKey instanceof KeylessPublicKey\n    );\n  }\n}\n", "import { Deserializer, Serializer } from \"../../bcs\";\nimport {\n  AnyPublicKeyVariant,\n  AnySignatureVariant,\n  SigningScheme as AuthenticationKeyScheme,\n  HexInput,\n} from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Secp256k1PrivateKey, Secp256k1PublicKey, Secp256k1Signature } from \"./secp256k1\";\nimport { KeylessPublicKey, KeylessSignature } from \"./keyless\";\nimport { Signature } from \"./signature\";\nimport { FederatedKeylessPublicKey } from \"./federatedKeyless\";\nimport { AptosConfig } from \"../../api\";\n\nexport type PrivateKeyInput = Ed25519PrivateKey | Secp256k1PrivateKey;\n\n/**\n * Represents any public key supported by Aptos.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Any unified authentication key is represented in the SDK as `AnyPublicKey`.\n * @group Implementation\n * @category Serialization\n */\nexport class AnyPublicKey extends AccountPublicKey {\n  /**\n   * Reference to the inner public key\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKey: PublicKey;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly variant: AnyPublicKeyVariant;\n\n  // region Constructors\n\n  /**\n   * Creates an instance of the signature class based on the provided signature type.\n   * This allows for the handling of different signature variants such as Ed25519, Secp256k1, and Keyless.\n   *\n   * @param publicKey - The publicKey object which determines the variant to be used.\n   * @throws Error if the provided signature type is unsupported.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(publicKey: PublicKey) {\n    super();\n    this.publicKey = publicKey;\n    if (publicKey instanceof Ed25519PublicKey) {\n      this.variant = AnyPublicKeyVariant.Ed25519;\n    } else if (publicKey instanceof Secp256k1PublicKey) {\n      this.variant = AnyPublicKeyVariant.Secp256k1;\n    } else if (publicKey instanceof KeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.Keyless;\n    } else if (publicKey instanceof FederatedKeylessPublicKey) {\n      this.variant = AnyPublicKeyVariant.FederatedKeyless;\n    } else {\n      throw new Error(\"Unsupported public key type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of AnySignature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: AnySignature }): boolean {\n    const { message, signature } = args;\n    if (this.publicKey instanceof KeylessPublicKey) {\n      throw new Error(\"Use verifySignatureAsync to verify Keyless signatures\");\n    }\n    return this.publicKey.verifySignature({\n      message,\n      signature: signature.signature,\n    });\n  }\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of AnySignature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    if (!(args.signature instanceof AnySignature)) {\n      if (args.options?.throwErrorWithReason) {\n        throw new Error(\"Signature must be an instance of AnySignature\");\n      }\n      return false;\n    }\n    return await this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature.signature,\n    });\n  }\n\n  /**\n   * Generates an authentication key from the current instance's byte representation.\n   * This function is essential for creating a unique identifier for authentication purposes.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.SingleKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * This function is a warning that it will soon return the underlying signature bytes directly.\n   * Use AnySignature.bcsToBytes() instead.\n   *\n   * @returns Uint8Array representation of the signature.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the current object using the provided serializer.\n   * This function helps in converting the object into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.publicKey.serialize(serializer);\n  }\n\n  /**\n   * Deserializes an AnySignature from the provided deserializer.\n   * This function helps in reconstructing the AnySignature object from its serialized form, allowing for further processing or validation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): AnyPublicKey {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let publicKey: PublicKey;\n    switch (variantIndex) {\n      case AnyPublicKeyVariant.Ed25519:\n        publicKey = Ed25519PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Secp256k1:\n        publicKey = Secp256k1PublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.Keyless:\n        publicKey = KeylessPublicKey.deserialize(deserializer);\n        break;\n      case AnyPublicKeyVariant.FederatedKeyless:\n        publicKey = FederatedKeylessPublicKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${variantIndex}`);\n    }\n    return new AnyPublicKey(publicKey);\n  }\n  // endregion\n\n  /**\n   * Determines if the provided public key is an instance of AnyPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @deprecated Use `instanceof AnyPublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is AnyPublicKey {\n    return publicKey instanceof AnyPublicKey;\n  }\n\n  /**\n   * Determines if the current public key is an instance of Ed25519PublicKey.\n   *\n   * @deprecated use `publicKey instanceof Ed25519PublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  isEd25519(): boolean {\n    return this.publicKey instanceof Ed25519PublicKey;\n  }\n\n  /**\n   * Checks if the public key is an instance of Secp256k1PublicKey.\n   *\n   * @deprecated use `publicKey instanceof Secp256k1PublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  isSecp256k1PublicKey(): boolean {\n    return this.publicKey instanceof Secp256k1PublicKey;\n  }\n\n  /**\n   * Determines if the provided publicKey is an instance of a valid PublicKey object.\n   *\n   * @param publicKey - The publicKey to be checked for validity.\n   * @param publicKey.publicKey - The actual publicKey object that needs to be validated.\n   * @returns True if the signature is a valid instance; otherwise, false.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is AnyPublicKey {\n    return \"publicKey\" in publicKey && \"variant\" in publicKey;\n  }\n}\n\n/**\n * Represents a signature that utilizes the SingleKey authentication scheme.\n * This class is designed to encapsulate various types of signatures, which can\n * only be generated by a `SingleKeySigner` due to the shared authentication mechanism.\n *\n * @extends Signature\n * @group Implementation\n * @category Serialization\n */\nexport class AnySignature extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly variant: AnySignatureVariant;\n\n  // region Constructors\n\n  constructor(signature: Signature) {\n    super();\n    this.signature = signature;\n\n    if (signature instanceof Ed25519Signature) {\n      this.variant = AnySignatureVariant.Ed25519;\n    } else if (signature instanceof Secp256k1Signature) {\n      this.variant = AnySignatureVariant.Secp256k1;\n    } else if (signature instanceof KeylessSignature) {\n      this.variant = AnySignatureVariant.Keyless;\n    } else {\n      throw new Error(\"Unsupported signature type\");\n    }\n  }\n\n  // endregion\n\n  // region AccountSignature\n\n  toUint8Array(): Uint8Array {\n    // TODO: keep this warning around for a bit, and eventually change this to return `this.signature.toUint8Array()`.\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. \" +\n        \"Use AnySignature.bcsToBytes() instead.\",\n    );\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): AnySignature {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let signature: Signature;\n    switch (variantIndex) {\n      case AnySignatureVariant.Ed25519:\n        signature = Ed25519Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Secp256k1:\n        signature = Secp256k1Signature.deserialize(deserializer);\n        break;\n      case AnySignatureVariant.Keyless:\n        signature = KeylessSignature.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${variantIndex}`);\n    }\n    return new AnySignature(signature);\n  }\n\n  // endregion\n\n  static isInstance(signature: Signature): signature is AnySignature {\n    return (\n      \"signature\" in signature &&\n      typeof signature.signature === \"object\" &&\n      signature.signature !== null &&\n      \"toUint8Array\" in signature.signature\n    );\n  }\n}\n", "import { AnyPublicKeyVariant, SigningScheme as AuthenticationKeyScheme, HexInput } from \"../../types\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountPublicKey, PublicKey, VerifySignatureAsyncArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { AnyPublicKey, AnySignature } from \"./singleKey\";\nimport { AptosConfig } from \"../../api\";\n\n/**\n * Counts the number of set bits (1s) in a byte.\n * This function can help you determine the population count of a given byte value.\n *\n * @param byte - The byte value for which to count the number of set bits.\n * @group Implementation\n * @category Serialization\n */\n/* eslint-disable no-bitwise */\nfunction bitCount(byte: number) {\n  let n = byte;\n  n -= (n >> 1) & 0x55555555;\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n/* eslint-enable no-bitwise */\n\nconst MAX_NUM_KEYLESS_PUBLIC_FOR_MULTI_KEY = 3;\nexport abstract class AbstractMultiKey extends AccountPublicKey {\n  publicKeys: PublicKey[];\n\n  constructor(args: { publicKeys: PublicKey[] }) {\n    super();\n    this.publicKeys = args.publicKeys;\n  }\n\n  /**\n   * Create a bitmap that holds the mapping from the original public keys\n   * to the signatures passed in\n   *\n   * @param args.bits array of the index mapping to the matching public keys\n   * @returns Uint8array bit map\n   * @group Implementation\n   * @category Serialization\n   */\n  createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, idx: number) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  getIndex(publicKey: PublicKey): number {\n    const index = this.publicKeys.findIndex((pk) => pk.toString() === publicKey.toString());\n\n    if (index !== -1) {\n      return index;\n    }\n    throw new Error(`Public key ${publicKey} not found in multi key set ${this.publicKeys}`);\n  }\n\n  abstract getSignaturesRequired(): number;\n}\n\n/**\n * Represents a multi-key authentication scheme for accounts, allowing multiple public keys\n * to be associated with a single account. This class enforces a minimum number of valid signatures\n * required to authorize actions, ensuring enhanced security for multi-agent accounts.\n *\n * The public keys of each individual agent can be any type of public key supported by Aptos.\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263), Aptos supports\n * `Legacy` and `Unified` authentication keys.\n * @group Implementation\n * @category Serialization\n */\nexport class MultiKey extends AbstractMultiKey {\n  /**\n   * List of any public keys\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKeys: AnyPublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signaturesRequired: number;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   * This constructor initializes a multi-signature transaction with the provided signatures and bitmap.\n   *\n   * @param args An object containing the parameters for the multi-signature transaction.\n   * @param args.signatures A list of signatures.\n   * @param args.bitmap A bitmap represented as a Uint8Array or an array of numbers, where each bit indicates whether a\n   * corresponding signature is present. A maximum of 32 signatures is supported, and the length of the bitmap must be 4 bytes.\n   *\n   * @throws Error if the number of signatures exceeds the maximum supported, if the bitmap length is incorrect, or if the number\n   * of signatures does not match the bitmap.\n   * @group Implementation\n   * @category Serialization\n   */\n  // region Constructors\n  constructor(args: { publicKeys: Array<PublicKey>; signaturesRequired: number }) {\n    const { publicKeys, signaturesRequired } = args;\n    super({ publicKeys });\n\n    // Validate number of public keys is greater than signature required\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater than 0\");\n    }\n\n    // Validate number of public keys is greater than signature required\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(\n        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`,\n      );\n    }\n\n    // Make sure that all keys are normalized to the SingleKey authentication scheme\n    this.publicKeys = publicKeys.map((publicKey) =>\n      publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey),\n    );\n    if (signaturesRequired > MAX_NUM_KEYLESS_PUBLIC_FOR_MULTI_KEY) {\n      const keylessCount = this.publicKeys.filter(\n        (pk) => pk.variant === AnyPublicKeyVariant.Keyless || pk.variant === AnyPublicKeyVariant.FederatedKeyless,\n      ).length;\n      if (keylessCount > MAX_NUM_KEYLESS_PUBLIC_FOR_MULTI_KEY) {\n        throw new Error(\n          `Construction of MultiKey with more than ${MAX_NUM_KEYLESS_PUBLIC_FOR_MULTI_KEY} keyless public keys is not allowed when signaturesRequired \n          is greater than ${MAX_NUM_KEYLESS_PUBLIC_FOR_MULTI_KEY}. This is because a maximum of 3 keyless signatures are supported for a \n          K-of-N MultiKey transaction.`,\n        );\n      }\n    }\n\n    this.signaturesRequired = signaturesRequired;\n  }\n\n  getSignaturesRequired(): number {\n    return this.signaturesRequired;\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.\n   *\n   * Note: This function will fail if a keyless signature is used.  Use `verifySignatureAsync` instead.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: MultiKeySignature }): boolean {\n    const { message, signature } = args;\n    if (signature.signatures.length !== this.signaturesRequired) {\n      throw new Error(\"The number of signatures does not match the number of required signatures\");\n    }\n    const signerIndices = signature.bitMapToSignerIndices();\n    for (let i = 0; i < signature.signatures.length; i += 1) {\n      const singleSignature = signature.signatures[i];\n      const publicKey = this.publicKeys[signerIndices[i]];\n      if (!publicKey.verifySignature({ message, signature: singleSignature })) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The Aptos configuration to use\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    const { signature } = args;\n    try {\n      if (!(signature instanceof MultiKeySignature)) {\n        throw new Error(\"Signature is not a MultiKeySignature\");\n      }\n      if (signature.signatures.length !== this.signaturesRequired) {\n        throw new Error(\"The number of signatures does not match the number of required signatures\");\n      }\n      const signerIndices = signature.bitMapToSignerIndices();\n      for (let i = 0; i < signature.signatures.length; i += 1) {\n        const singleSignature = signature.signatures[i];\n        const publicKey = this.publicKeys[signerIndices[i]];\n        if (!(await publicKey.verifySignatureAsync({ ...args, signature: singleSignature }))) {\n          return false;\n        }\n      }\n      return true;\n    } catch (error) {\n      if (args.options?.throwErrorWithReason) {\n        throw error;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Generates an authentication key based on the current instance's byte representation.\n   * This key can be used for secure authentication processes within the system.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the object by writing its signatures and bitmap to the provided serializer.\n   * This allows the object to be converted into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n\n  /**\n   * Deserializes a MultiKeySignature from the provided deserializer.\n   * This function retrieves the signatures and bitmap necessary for creating a MultiKeySignature object.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): MultiKey {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n\n    return new MultiKey({ publicKeys: keys, signaturesRequired });\n  }\n\n  // endregion\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   */\n  getIndex(publicKey: PublicKey): number {\n    const anyPublicKey = publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey);\n    return super.getIndex(anyPublicKey);\n  }\n\n  public static isInstance(value: PublicKey): value is MultiKey {\n    return \"publicKeys\" in value && \"signaturesRequired\" in value;\n  }\n}\n\n/**\n * Represents a multi-signature transaction using Ed25519 signatures.\n * This class allows for the creation and management of a K-of-N multi-signature scheme,\n * where a specified number of signatures are required to authorize a transaction.\n *\n * It includes functionality to validate the number of signatures against a bitmap,\n * which indicates which public keys have signed the transaction.\n * @group Implementation\n * @category Serialization\n */\nexport class MultiKeySignature extends Signature {\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   * @group Implementation\n   * @category Serialization\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * Maximum number of Ed25519 signatures supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static MAX_SIGNATURES_SUPPORTED = MultiKeySignature.BITMAP_LEN * 8;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signatures: AnySignature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { signatures: Array<Signature | AnySignature>; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(`The number of signatures cannot be greater than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED}`);\n    }\n\n    // Make sure that all signatures are normalized to the SingleKey authentication scheme\n    this.signatures = signatures.map((signature) =>\n      signature instanceof AnySignature ? signature : new AnySignature(signature),\n    );\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiKeySignature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiKeySignature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiKeySignature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n\n    const nSignatures = this.bitmap.reduce((acc, byte) => acc + bitCount(byte), 0);\n    if (nSignatures !== this.signatures.length) {\n      throw new Error(`Expecting ${nSignatures} signatures from the bitmap, but got ${this.signatures.length}`);\n    }\n  }\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   * @group Implementation\n   * @category Serialization\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number) => {\n      if (bit >= MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  /**\n   * Converts the bitmap to an array of signer indices.\n   *\n   * Example:\n   *\n   * bitmap: [0b10001000, 0b01000000, 0b00000000, 0b00000000]\n   * signerIndices: [0, 4, 9]\n   *\n   * @returns An array of signer indices.\n   * @group Implementation\n   * @category Serialization\n   */\n  bitMapToSignerIndices(): number[] {\n    const signerIndices: number[] = [];\n    for (let i = 0; i < this.bitmap.length; i += 1) {\n      const byte = this.bitmap[i];\n      for (let bit = 0; bit < 8; bit += 1) {\n        if ((byte & (128 >> bit)) !== 0) {\n          signerIndices.push(i * 8 + bit);\n        }\n      }\n    }\n    return signerIndices;\n  }\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    // Note: we should not need to serialize the vector length, as it can be derived from the bitmap\n    serializer.serializeVector(this.signatures);\n    serializer.serializeBytes(this.bitmap);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiKeySignature {\n    const signatures = deserializer.deserializeVector(AnySignature);\n    const bitmap = deserializer.deserializeBytes();\n    return new MultiKeySignature({ signatures, bitmap });\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../../api\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { SigningScheme as AuthenticationKeyScheme, HexInput } from \"../../types\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { AbstractMultiKey } from \"./multiKey\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents the public key of a K-of-N Ed25519 multi-sig transaction.\n *\n * A K-of-N multi-sig transaction requires at least K out of N authorized signers to sign the transaction\n * for it to be executed. This class encapsulates the logic for managing the public keys and the threshold\n * for valid signatures.\n *\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n * @group Implementation\n * @category Serialization\n */\nexport class MultiEd25519PublicKey extends AbstractMultiKey {\n  /**\n   * Maximum number of public keys supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly MAX_KEYS = 32;\n\n  /**\n   * Minimum number of public keys needed\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly MIN_KEYS = 2;\n\n  /**\n   * Minimum threshold for the number of valid signatures required\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly MIN_THRESHOLD = 1;\n\n  /**\n   * List of Ed25519 public keys for this LegacyMultiEd25519PublicKey\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKeys: Ed25519PublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly threshold: number;\n\n  /**\n   * Public key for a K-of-N multi-sig transaction. A K-of-N multi-sig transaction means that for such a\n   * transaction to be executed, at least K out of the N authorized signers have signed the transaction\n   * and passed the check conducted by the chain.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n   * @param args - A wrapper to let you choose the param order.\n   * @param args.publicKeys A list of public keys\n   * @param args.threshold At least \"threshold\" signatures must be valid\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { publicKeys: Ed25519PublicKey[]; threshold: number }) {\n    const { publicKeys, threshold } = args;\n    super({ publicKeys });\n\n    // Validate number of public keys\n    if (publicKeys.length > MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(\n        `Must have between ${MultiEd25519PublicKey.MIN_KEYS} and ` +\n          `${MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`,\n      );\n    }\n\n    // Validate threshold: must be between 1 and the number of public keys, inclusive\n    if (threshold < MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(\n        `Threshold must be between ${MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`,\n      );\n    }\n\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n\n  getSignaturesRequired(): number {\n    return this.threshold;\n  }\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies a multi-signature against a given message.\n   * This function ensures that the provided signatures meet the required threshold and are valid for the given message.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The multi-signature containing multiple signatures and a bitmap indicating which signatures are valid.\n   * @returns True if the signature is valid; otherwise, false.\n   * @throws Error if the bitmap and signatures length mismatch or if there are not enough valid signatures.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: Signature }): boolean {\n    const { message, signature } = args;\n    if (!(signature instanceof MultiEd25519Signature)) {\n      return false;\n    }\n\n    const indices: number[] = [];\n    for (let i = 0; i < 4; i += 1) {\n      for (let j = 0; j < 8; j += 1) {\n        // eslint-disable-next-line no-bitwise\n        const bitIsSet = (signature.bitmap[i] & (1 << (7 - j))) !== 0;\n        if (bitIsSet) {\n          const index = i * 8 + j;\n          indices.push(index);\n        }\n      }\n    }\n\n    if (indices.length !== signature.signatures.length) {\n      throw new Error(\"Bitmap and signatures length mismatch\");\n    }\n\n    if (indices.length < this.threshold) {\n      throw new Error(\"Not enough signatures\");\n    }\n\n    for (let i = 0; i < indices.length; i += 1) {\n      const publicKey = this.publicKeys[indices[i]];\n      if (!publicKey.verifySignature({ message, signature: signature.signatures[i] })) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n  }): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Generates an authentication key based on the current instance's byte representation.\n   * This function is essential for creating a secure authentication key that can be used for various cryptographic operations.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiEd25519,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Converts a PublicKeys into Uint8Array (bytes) with: bytes = p1_bytes | ... | pn_bytes | threshold\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k: Ed25519PublicKey, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n\n    return bytes;\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the current instance into bytes using the provided serializer.\n   * This allows for the conversion of the instance's data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer used to convert the instance into bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  /**\n   * Deserializes a MultiEd25519Signature from the provided deserializer.\n   * This function helps in reconstructing a MultiEd25519Signature object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): MultiEd25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n\n    const keys: Ed25519PublicKey[] = [];\n\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new MultiEd25519PublicKey({ publicKeys: keys, threshold });\n  }\n\n  /**\n   * Deserializes a MultiEd25519Signature from the provided deserializer.\n   * This function helps in reconstructing a MultiEd25519Signature object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserializeWithoutLength(deserializer: Deserializer): MultiEd25519PublicKey {\n    const length = deserializer.remaining();\n    const bytes = deserializer.deserializeFixedBytes(length);\n    const threshold = bytes[bytes.length - 1];\n\n    const keys: Ed25519PublicKey[] = [];\n\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new MultiEd25519PublicKey({ publicKeys: keys, threshold });\n  }\n\n  // endregion\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   */\n  getIndex(publicKey: Ed25519PublicKey): number {\n    return super.getIndex(publicKey);\n  }\n}\n\n/**\n * Represents the signature of a K-of-N Ed25519 multi-sig transaction.\n *\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n * @group Implementation\n * @category Serialization\n */\nexport class MultiEd25519Signature extends Signature {\n  /**\n   * Maximum number of Ed25519 signatures supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static MAX_SIGNATURES_SUPPORTED = 32;\n\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   * @group Implementation\n   * @category Serialization\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signatures: Ed25519Signature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right.\n   * Alternatively, you can specify an array of bitmap positions.\n   * Valid position should range between 0 and 31.\n   * @see MultiEd25519Signature.createBitmap\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { signatures: Ed25519Signature[]; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(\n        `The number of signatures cannot be greater than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`,\n      );\n    }\n    this.signatures = signatures;\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiEd25519Signature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiEd25519Signature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n  }\n\n  // region AccountSignature\n\n  /**\n   * Converts a MultiSignature into Uint8Array (bytes) with `bytes = s1_bytes | ... | sn_bytes | bitmap`\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k: Ed25519Signature, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n\n    return bytes;\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n\n    const signatures: Ed25519Signature[] = [];\n\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap });\n  }\n\n  // endregion\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions.\n   * This function allows you to set specific bits in a 32-bit long bitmap based on the provided positions.\n   *\n   * @param args The arguments for creating the bitmap.\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0. Valid positions should range between 0 and 31.\n   *\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32 bits long.\n   * @group Implementation\n   * @category Serialization\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, index) => {\n      if (bit >= MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      if (index > 0 && bit <= bits[index - 1]) {\n        throw new Error(\"The bits need to be sorted in ascending order.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n}\n", "import {\n  AnyPublicKey,\n  Ed25519PublicKey,\n  MultiKey,\n  KeylessPublicKey,\n  MultiEd25519PublicKey,\n  FederatedKeylessPublicKey,\n  Secp256k1PublicKey,\n  Signature,\n  PublicKey,\n  Ed25519Signature,\n  Secp256k1Signature,\n  KeylessSignature,\n  AnySignature,\n  MultiEd25519Signature,\n  MultiKeySignature,\n} from \"..\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { HexInput } from \"../../types\";\n\nconst MULTIPLE_DESERIALIZATIONS_ERROR_MSG = \"Multiple possible deserializations found\";\n\n/**\n * Deserializes a public key from a hex string.\n * Attempts to deserialize using various public key types in sequence until one succeeds.\n *\n * @param publicKey - The hex string representation of the public key to deserialize\n * @returns The deserialized public key\n * @throws Error if deserialization fails for all supported key types or if multiple deserializations are found\n */\nexport function deserializePublicKey(publicKey: HexInput): PublicKey {\n  const publicKeyTypes = [\n    Ed25519PublicKey,\n    AnyPublicKey,\n    MultiEd25519PublicKey,\n    MultiKey,\n    KeylessPublicKey,\n    FederatedKeylessPublicKey,\n    Secp256k1PublicKey,\n  ];\n\n  let result: PublicKey | undefined;\n  for (const KeyType of publicKeyTypes) {\n    try {\n      const deserializer = Deserializer.fromHex(publicKey);\n      const key = KeyType.deserialize(deserializer);\n      deserializer.assertFinished();\n      if (result) {\n        throw new Error(`${MULTIPLE_DESERIALIZATIONS_ERROR_MSG}: ${publicKey}`);\n      }\n      result = key;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(MULTIPLE_DESERIALIZATIONS_ERROR_MSG)) {\n        throw error;\n      }\n    }\n  }\n\n  if (!result) {\n    throw new Error(`Failed to deserialize public key: ${publicKey}`);\n  }\n\n  return result;\n}\n\n/**\n * Deserializes a signature from a hex string.\n * Attempts to deserialize using various signature types in sequence until one succeeds.\n *\n * @param signature - The hex string representation of the signature to deserialize\n * @returns The deserialized signature\n * @throws Error if deserialization fails for all supported signature types or if multiple deserializations are found\n */\nexport function deserializeSignature(signature: HexInput): Signature {\n  const signatureTypes = [\n    Ed25519Signature,\n    AnySignature,\n    MultiEd25519Signature,\n    MultiKeySignature,\n    KeylessSignature,\n    Secp256k1Signature,\n  ];\n\n  let result: Signature | undefined;\n  for (const SignatureType of signatureTypes) {\n    try {\n      const deserializer = Deserializer.fromHex(signature);\n      const sig = SignatureType.deserialize(deserializer);\n      deserializer.assertFinished();\n      if (result) {\n        throw new Error(`${MULTIPLE_DESERIALIZATIONS_ERROR_MSG}: ${signature}`);\n      }\n      result = sig;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes(MULTIPLE_DESERIALIZATIONS_ERROR_MSG)) {\n        throw error;\n      }\n    }\n  }\n\n  if (!result) {\n    throw new Error(`Failed to deserialize signature: ${signature}`);\n  }\n\n  return result;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Serializer, Deserializer, Serializable } from \"../../bcs\";\nimport { AnyPublicKey, AnySignature } from \"../../core/crypto\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../../core/crypto/multiEd25519\";\nimport { MultiKey, MultiKeySignature } from \"../../core/crypto/multiKey\";\nimport { AccountAuthenticatorVariant, HexInput, MoveFunctionId } from \"../../types\";\nimport { AbstractionAuthDataVariant } from \"../../types/abstraction\";\nimport { AccountAddress, Hex } from \"../../core\";\nimport { getFunctionParts, isValidFunctionInfo } from \"../../utils/helpers\";\n\n/**\n * Represents an account authenticator that can handle multiple authentication variants.\n * This class serves as a base for different types of account authenticators, allowing for serialization\n * and deserialization of various authenticator types.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class AccountAuthenticator extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes an AccountAuthenticator from the provided deserializer.\n   * This function helps in reconstructing the AccountAuthenticator object based on the variant index.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): AccountAuthenticator {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AccountAuthenticatorVariant.Ed25519:\n        return AccountAuthenticatorEd25519.load(deserializer);\n      case AccountAuthenticatorVariant.MultiEd25519:\n        return AccountAuthenticatorMultiEd25519.load(deserializer);\n      case AccountAuthenticatorVariant.SingleKey:\n        return AccountAuthenticatorSingleKey.load(deserializer);\n      case AccountAuthenticatorVariant.MultiKey:\n        return AccountAuthenticatorMultiKey.load(deserializer);\n      case AccountAuthenticatorVariant.NoAccountAuthenticator:\n        return AccountAuthenticatorNoAccountAuthenticator.load(deserializer);\n      case AccountAuthenticatorVariant.Abstraction:\n        return AccountAuthenticatorAbstraction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);\n    }\n  }\n\n  /**\n   * Determines if the current instance is an Ed25519 account authenticator.\n   *\n   * @returns {boolean} True if the instance is of type AccountAuthenticatorEd25519, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isEd25519(): this is AccountAuthenticatorEd25519 {\n    return this instanceof AccountAuthenticatorEd25519;\n  }\n\n  /**\n   * Determines if the current instance is of type AccountAuthenticatorMultiEd25519.\n   *\n   * @returns {boolean} True if the instance is a multi-signature Ed25519 account authenticator, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isMultiEd25519(): this is AccountAuthenticatorMultiEd25519 {\n    return this instanceof AccountAuthenticatorMultiEd25519;\n  }\n\n  /**\n   * Determines if the current instance is of the type AccountAuthenticatorSingleKey.\n   *\n   * @returns {boolean} True if the instance is an AccountAuthenticatorSingleKey, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isSingleKey(): this is AccountAuthenticatorSingleKey {\n    return this instanceof AccountAuthenticatorSingleKey;\n  }\n\n  /**\n   * Determine if the current instance is of type AccountAuthenticatorMultiKey.\n   *\n   * @returns {boolean} Returns true if the instance is an AccountAuthenticatorMultiKey, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isMultiKey(): this is AccountAuthenticatorMultiKey {\n    return this instanceof AccountAuthenticatorMultiKey;\n  }\n}\n\n/**\n * Represents an Ed25519 transaction authenticator for multi-signer transactions.\n * This class encapsulates the account's Ed25519 public key and signature.\n *\n * @param public_key - The Ed25519 public key associated with the account.\n * @param signature - The Ed25519 signature for the account.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorEd25519 extends AccountAuthenticator {\n  public readonly public_key: Ed25519PublicKey;\n\n  public readonly signature: Ed25519Signature;\n\n  /**\n   * Creates an instance of the class with the specified public keys and signatures.\n   *\n   * @param public_key The public key used for verification.\n   * @param signature The signatures corresponding to the public keys.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  /**\n   * Serializes the account authenticator data into the provided serializer.\n   * This function captures the multi-key variant, public keys, and signatures for serialization.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.Ed25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  /**\n   * Loads an instance of AccountAuthenticatorMultiKey from the provided deserializer.\n   * This function helps in reconstructing the authenticator object using the deserialized public keys and signatures.\n   *\n   * @param deserializer - The deserializer used to extract the necessary data for loading the authenticator.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): AccountAuthenticatorEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents a transaction authenticator for Multi Ed25519, designed for multi-signer transactions.\n *\n * @param public_key - The MultiEd25519 public key of the account.\n * @param signature - The MultiEd25519 signature of the account.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {\n  public readonly public_key: MultiEd25519PublicKey;\n\n  public readonly signature: MultiEd25519Signature;\n\n  constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.MultiEd25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents an account authenticator that utilizes a single key for signing.\n * This class is designed to handle authentication using a public key and its corresponding signature.\n *\n * @param public_key - The public key used for authentication.\n * @param signature - The signature associated with the public key.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorSingleKey extends AccountAuthenticator {\n  public readonly public_key: AnyPublicKey;\n\n  public readonly signature: AnySignature;\n\n  constructor(public_key: AnyPublicKey, signature: AnySignature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.SingleKey);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorSingleKey {\n    const public_key = AnyPublicKey.deserialize(deserializer);\n    const signature = AnySignature.deserialize(deserializer);\n    return new AccountAuthenticatorSingleKey(public_key, signature);\n  }\n}\n\n/**\n * Represents an account authenticator that supports multiple keys and signatures for multi-signature scenarios.\n *\n * @param public_keys - The public keys used for authentication.\n * @param signatures - The signatures corresponding to the public keys.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountAuthenticatorMultiKey extends AccountAuthenticator {\n  public readonly public_keys: MultiKey;\n\n  public readonly signatures: MultiKeySignature;\n\n  constructor(public_keys: MultiKey, signatures: MultiKeySignature) {\n    super();\n    this.public_keys = public_keys;\n    this.signatures = signatures;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.MultiKey);\n    this.public_keys.serialize(serializer);\n    this.signatures.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorMultiKey {\n    const public_keys = MultiKey.deserialize(deserializer);\n    const signatures = MultiKeySignature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiKey(public_keys, signatures);\n  }\n}\n\n/**\n * AccountAuthenticatorNoAccountAuthenticator for no account authenticator\n * It represents the absence of a public key for transaction simulation.\n * It allows skipping the public/auth key check during the simulation.\n */\nexport class AccountAuthenticatorNoAccountAuthenticator extends AccountAuthenticator {\n  // eslint-disable-next-line class-methods-use-this\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.NoAccountAuthenticator);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static load(deserializer: Deserializer): AccountAuthenticatorNoAccountAuthenticator {\n    return new AccountAuthenticatorNoAccountAuthenticator();\n  }\n}\n\nexport class AccountAuthenticatorAbstraction extends AccountAuthenticator {\n  public readonly functionInfo: string;\n\n  public readonly signingMessageDigest: Hex;\n\n  public readonly authenticator: Uint8Array;\n\n  /**\n   * DAA, which is extended of the AA module, requires an account identity\n   */\n  public readonly accountIdentity?: Uint8Array;\n\n  constructor(\n    functionInfo: string,\n    signingMessageDigest: HexInput,\n    authenticator: Uint8Array,\n    accountIdentity?: Uint8Array,\n  ) {\n    super();\n    if (!isValidFunctionInfo(functionInfo)) {\n      throw new Error(`Invalid function info ${functionInfo} passed into AccountAuthenticatorAbstraction`);\n    }\n    this.functionInfo = functionInfo;\n    this.authenticator = authenticator;\n    this.signingMessageDigest = Hex.fromHexInput(Hex.fromHexInput(signingMessageDigest).toUint8Array());\n    this.accountIdentity = accountIdentity;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.Abstraction);\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(this.functionInfo as MoveFunctionId);\n    AccountAddress.fromString(moduleAddress).serialize(serializer);\n    serializer.serializeStr(moduleName);\n    serializer.serializeStr(functionName);\n    if (this.accountIdentity) {\n      serializer.serializeU32AsUleb128(AbstractionAuthDataVariant.DerivableV1);\n    } else {\n      serializer.serializeU32AsUleb128(AbstractionAuthDataVariant.V1);\n    }\n    serializer.serializeBytes(this.signingMessageDigest.toUint8Array());\n    if (this.accountIdentity) {\n      serializer.serializeBytes(this.authenticator);\n    } else {\n      serializer.serializeFixedBytes(this.authenticator);\n    }\n\n    if (this.accountIdentity) {\n      serializer.serializeBytes(this.accountIdentity);\n    }\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorAbstraction {\n    const moduleAddress = AccountAddress.deserialize(deserializer);\n    const moduleName = deserializer.deserializeStr();\n    const functionName = deserializer.deserializeStr();\n    const variant = deserializer.deserializeUleb128AsU32();\n    if (variant === AbstractionAuthDataVariant.V1) {\n      const signingMessageDigest = deserializer.deserializeBytes();\n      const authenticator = deserializer.deserializeFixedBytes(deserializer.remaining());\n      return new AccountAuthenticatorAbstraction(\n        `${moduleAddress}::${moduleName}::${functionName}`,\n        signingMessageDigest,\n        authenticator,\n      );\n    }\n    if (variant === AbstractionAuthDataVariant.DerivableV1) {\n      const signingMessageDigest = deserializer.deserializeBytes();\n      const abstractSignature = deserializer.deserializeBytes();\n\n      const abstractPublicKey = deserializer.deserializeBytes();\n      return new AccountAuthenticatorAbstraction(\n        `${moduleAddress}::${moduleName}::${functionName}`,\n        signingMessageDigest,\n        abstractSignature,\n        abstractPublicKey,\n      );\n    }\n    throw new Error(`Unknown variant index for AccountAuthenticatorAbstraction: ${variant}`);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the generation of the signing message.\n * @group Implementation\n * @category Transactions\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { RAW_TRANSACTION_SALT, RAW_TRANSACTION_WITH_DATA_SALT } from \"../../utils/const\";\nimport { FeePayerRawTransaction, MultiAgentRawTransaction } from \"../instances\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../types\";\nimport { Serializable } from \"../../bcs\";\n\n/**\n * Derives the appropriate raw transaction type based on the provided transaction details.\n * This function helps in identifying whether the transaction is a FeePayerRawTransaction,\n * MultiAgentRawTransaction, or a standard RawTransaction.\n *\n * @param transaction - An object representing an Aptos transaction, which may include:\n *   - feePayerAddress - The address of the fee payer (optional).\n *   - secondarySignerAddresses - An array of secondary signer addresses (optional).\n *   - rawTransaction - The raw transaction data.\n *\n * @returns FeePayerRawTransaction | MultiAgentRawTransaction | RawTransaction\n * @group Implementation\n * @category Transactions\n */\nexport function deriveTransactionType(transaction: AnyRawTransaction): AnyRawTransactionInstance {\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(transaction.rawTransaction, transaction.secondarySignerAddresses);\n  }\n\n  return transaction.rawTransaction;\n}\n\n/**\n * Generates the 'signing message' form of a message to be signed.\n * This function combines a domain separator with the byte representation of the message to create a signing message.\n *\n * @param bytes - The byte representation of the message to be signed and sent to the chain.\n * @param domainSeparator - A domain separator that starts with 'APTOS::'.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessage(bytes: Uint8Array, domainSeparator: string): Uint8Array {\n  const hash = sha3Hash.create();\n\n  if (!domainSeparator.startsWith(\"APTOS::\")) {\n    throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${domainSeparator}`);\n  }\n\n  hash.update(domainSeparator);\n\n  const prefix = hash.digest();\n\n  const body = bytes;\n\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n\n  return mergedArray;\n}\n\n/**\n * @deprecated\n * Use CryptoHashable instead by having your class implement it and call hash() to get the signing message.\n *\n * Generates the 'signing message' form of a serializable value by serializing it and using the constructor name as the domain\n * separator.\n *\n * @param serializable - An object that has a BCS serialized form.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessageForSerializable(serializable: Serializable): Uint8Array {\n  return generateSigningMessage(serializable.bcsToBytes(), `APTOS::${serializable.constructor.name}`);\n}\n\n/**\n * Generates the 'signing message' form of a transaction by deriving the type of transaction and applying the appropriate domain\n * separator based on the presence of a fee payer or secondary signers.\n *\n * @param transaction - A transaction that is to be signed, which can include a fee payer address or secondary signer addresses.\n *\n * @returns The Uint8Array of the signing message.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSigningMessageForTransaction(transaction: AnyRawTransaction): Uint8Array {\n  const rawTxn = deriveTransactionType(transaction);\n  if (transaction.feePayerAddress) {\n    return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_WITH_DATA_SALT);\n  }\n  if (transaction.secondarySignerAddresses) {\n    return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_WITH_DATA_SALT);\n  }\n  return generateSigningMessage(rawTxn.bcsToBytes(), RAW_TRANSACTION_SALT);\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { MoveModuleId } from \"../../types\";\n\n/**\n * Represents a ModuleId that can be serialized and deserialized.\n * A ModuleId consists of a module address (e.g., \"0x1\") and a module name (e.g., \"coin\").\n * @group Implementation\n * @category Transactions\n */\nexport class ModuleId extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly name: Identifier;\n\n  /**\n   * Initializes a new instance of the module with the specified account address and name.\n   *\n   * @param address - The account address, e.g., \"0x1\".\n   * @param name - The module name under the specified address, e.g., \"coin\".\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(address: AccountAddress, name: Identifier) {\n    super();\n    this.address = address;\n    this.name = name;\n  }\n\n  /**\n   * Converts a string literal in the format \"account_address::module_name\" to a ModuleId.\n   * @param moduleId - A string literal representing the module identifier.\n   * @throws Error if the provided moduleId is not in the correct format.\n   * @returns ModuleId - The corresponding ModuleId object.\n   * @group Implementation\n   * @category Transactions\n   */\n  static fromStr(moduleId: MoveModuleId): ModuleId {\n    const parts = moduleId.split(\"::\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid module id.\");\n    }\n    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));\n  }\n\n  /**\n   * Serializes the address and name properties using the provided serializer.\n   * This function is essential for converting the object's data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.address.serialize(serializer);\n    this.name.serialize(serializer);\n  }\n\n  /**\n   * Deserializes a ModuleId from the provided deserializer.\n   * This function retrieves the account address and identifier to construct a ModuleId instance.\n   *\n   * @param deserializer - The deserializer instance used to read the data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): ModuleId {\n    const address = AccountAddress.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    return new ModuleId(address, name);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\nimport { TypeTagVariants } from \"../../types\";\n\n/**\n * Represents a type tag in the serialization framework, serving as a base class for various specific type tags.\n * This class provides methods for serialization and deserialization of type tags, as well as type checking methods\n * to determine the specific type of the tag at runtime.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class TypeTag extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes a StructTag from the provided deserializer.\n   * This function allows you to reconstruct a StructTag object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n\n  static deserialize(deserializer: Deserializer): TypeTag {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TypeTagVariants.Bool:\n        return TypeTagBool.load(deserializer);\n      case TypeTagVariants.U8:\n        return TypeTagU8.load(deserializer);\n      case TypeTagVariants.U64:\n        return TypeTagU64.load(deserializer);\n      case TypeTagVariants.U128:\n        return TypeTagU128.load(deserializer);\n      case TypeTagVariants.Address:\n        return TypeTagAddress.load(deserializer);\n      case TypeTagVariants.Signer:\n        return TypeTagSigner.load(deserializer);\n      case TypeTagVariants.Vector:\n        return TypeTagVector.load(deserializer);\n      case TypeTagVariants.Struct:\n        return TypeTagStruct.load(deserializer);\n      case TypeTagVariants.U16:\n        return TypeTagU16.load(deserializer);\n      case TypeTagVariants.U32:\n        return TypeTagU32.load(deserializer);\n      case TypeTagVariants.U256:\n        return TypeTagU256.load(deserializer);\n      case TypeTagVariants.Generic:\n        // This is only used for ABI representation, and cannot actually be used as a type.\n        return TypeTagGeneric.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TypeTag: ${index}`);\n    }\n  }\n\n  abstract toString(): string;\n\n  /**\n   * Determines if the current instance is of type TypeTagBool.\n   *\n   * @returns {boolean} True if the instance is a TypeTagBool, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isBool(): this is TypeTagBool {\n    return this instanceof TypeTagBool;\n  }\n\n  /**\n   * Determines if the current instance is of type TypeTagAddress.\n   *\n   * @returns {boolean} True if the instance is a TypeTagAddress, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isAddress(): this is TypeTagAddress {\n    return this instanceof TypeTagAddress;\n  }\n\n  /**\n   * Determines if the current instance is of type TypeTagGeneric.\n   *\n   * @returns {boolean} Returns true if the instance is a TypeTagGeneric, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isGeneric(): this is TypeTagGeneric {\n    return this instanceof TypeTagGeneric;\n  }\n\n  /**\n   * Determine if the current instance is a TypeTagSigner.\n   *\n   * @returns {boolean} Returns true if the instance is a TypeTagSigner, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isSigner(): this is TypeTagSigner {\n    return this instanceof TypeTagSigner;\n  }\n\n  /**\n   * Checks if the current instance is a vector type.\n   * This can help determine the specific type of data structure being used.\n   *\n   * @returns {boolean} True if the instance is of type TypeTagVector, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isVector(): this is TypeTagVector {\n    return this instanceof TypeTagVector;\n  }\n\n  /**\n   * Determines if the current instance is a structure type.\n   *\n   * @returns {boolean} True if the instance is of type TypeTagStruct, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isStruct(): this is TypeTagStruct {\n    return this instanceof TypeTagStruct;\n  }\n\n  /**\n   * Determines if the current instance is of type `TypeTagU8`.\n   *\n   * @returns {boolean} Returns true if the instance is of type `TypeTagU8`, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU8(): this is TypeTagU8 {\n    return this instanceof TypeTagU8;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU16.\n   *\n   * @returns {boolean} True if the instance is TypeTagU16, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU16(): this is TypeTagU16 {\n    return this instanceof TypeTagU16;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU32.\n   *\n   * @returns {boolean} Returns true if the instance is TypeTagU32, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU32(): this is TypeTagU32 {\n    return this instanceof TypeTagU32;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU64.\n   *\n   * @returns {boolean} True if the instance is a TypeTagU64, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU64(): this is TypeTagU64 {\n    return this instanceof TypeTagU64;\n  }\n\n  /**\n   * Determines if the current instance is of the TypeTagU128 type.\n   *\n   * @returns {boolean} True if the instance is of TypeTagU128, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU128(): this is TypeTagU128 {\n    return this instanceof TypeTagU128;\n  }\n\n  /**\n   * Checks if the current instance is of type TypeTagU256.\n   *\n   * @returns {boolean} Returns true if the instance is of type TypeTagU256, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isU256(): this is TypeTagU256 {\n    return this instanceof TypeTagU256;\n  }\n\n  isPrimitive(): boolean {\n    return (\n      this instanceof TypeTagSigner ||\n      this instanceof TypeTagAddress ||\n      this instanceof TypeTagBool ||\n      this instanceof TypeTagU8 ||\n      this instanceof TypeTagU16 ||\n      this instanceof TypeTagU32 ||\n      this instanceof TypeTagU64 ||\n      this instanceof TypeTagU128 ||\n      this instanceof TypeTagU256\n    );\n  }\n}\n\n/**\n * Represents a boolean type tag in the type system.\n * This class extends the base TypeTag class and provides\n * methods for serialization and deserialization of the boolean\n * type tag.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagBool extends TypeTag {\n  /**\n   * Returns the string representation of the object.\n   *\n   * @returns {string} The string representation of the object.\n   * @group Implementation\n   * @category Transactions\n   */\n  toString(): string {\n    return \"bool\";\n  }\n\n  /**\n   * Serializes the current instance's properties into a provided serializer.\n   * This function ensures that the address, module name, name, and type arguments are properly serialized.\n   *\n   * @param serializer - The serializer instance used to serialize the properties.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Bool);\n  }\n\n  /**\n   * Deserializes a StructTag and returns a new TypeTagStruct instance.\n   *\n   * @param _deserializer - The deserializer used to read the StructTag data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(_deserializer: Deserializer): TypeTagBool {\n    return new TypeTagBool();\n  }\n}\n\n/**\n * Represents a type tag for an 8-bit unsigned integer (u8).\n * This class extends the base TypeTag class and provides methods\n * for serialization and deserialization specific to the u8 type.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU8 extends TypeTag {\n  toString(): string {\n    return \"u8\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U8);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU8 {\n    return new TypeTagU8();\n  }\n}\n\n/**\n * Represents a type tag for unsigned 16-bit integers (u16).\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU16 extends TypeTag {\n  toString(): string {\n    return \"u16\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U16);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU16 {\n    return new TypeTagU16();\n  }\n}\n\n/**\n * Represents a type tag for a 32-bit unsigned integer (u32).\n * This class extends the base TypeTag class and provides methods for serialization\n * and deserialization specific to the u32 type.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU32 extends TypeTag {\n  toString(): string {\n    return \"u32\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U32);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU32 {\n    return new TypeTagU32();\n  }\n}\n\n/**\n * Represents a type tag for 64-bit unsigned integers (u64).\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU64 extends TypeTag {\n  toString(): string {\n    return \"u64\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U64);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU64 {\n    return new TypeTagU64();\n  }\n}\n\n/**\n * Represents a type tag for the u128 data type.\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU128 extends TypeTag {\n  toString(): string {\n    return \"u128\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U128);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU128 {\n    return new TypeTagU128();\n  }\n}\n\n/**\n * Represents a type tag for the U256 data type.\n * This class extends the base TypeTag class and provides methods for serialization and deserialization.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagU256 extends TypeTag {\n  toString(): string {\n    return \"u256\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U256);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU256 {\n    return new TypeTagU256();\n  }\n}\n\n/**\n * Represents a type tag for an address in the system.\n * This class extends the TypeTag class and provides functionality\n * to serialize the address type and load it from a deserializer.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagAddress extends TypeTag {\n  toString(): string {\n    return \"address\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Address);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagAddress {\n    return new TypeTagAddress();\n  }\n}\n\n/**\n * Represents a type tag for a signer in the system.\n * This class extends the base TypeTag and provides specific functionality\n * related to the signer type.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagSigner extends TypeTag {\n  toString(): string {\n    return \"signer\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Signer);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagSigner {\n    return new TypeTagSigner();\n  }\n}\n\n/**\n * Represents a reference to a type tag in the type system.\n * This class extends the TypeTag class and provides functionality\n * to serialize and deserialize type tag references.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagReference extends TypeTag {\n  toString(): `&${string}` {\n    return `&${this.value.toString()}`;\n  }\n\n  /**\n   * Initializes a new instance of the class with the specified parameters.\n   *\n   * @param value - The TypeTag to reference.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Reference);\n  }\n\n  static load(deserializer: Deserializer): TypeTagReference {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagReference(value);\n  }\n}\n\n/**\n * Represents a generic type tag used for type parameters in entry functions.\n * Generics are not serialized into a real type, so they cannot be used as a type directly.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagGeneric extends TypeTag {\n  toString(): `T${number}` {\n    return `T${this.value}`;\n  }\n\n  constructor(public readonly value: number) {\n    super();\n    if (value < 0) throw new Error(\"Generic type parameter index cannot be negative\");\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Generic);\n    serializer.serializeU32(this.value);\n  }\n\n  static load(deserializer: Deserializer): TypeTagGeneric {\n    const value = deserializer.deserializeU32();\n    return new TypeTagGeneric(value);\n  }\n}\n\n/**\n * Represents a vector type tag, which encapsulates a single type tag value.\n * This class extends the base TypeTag class and provides methods for serialization,\n * deserialization, and string representation of the vector type tag.\n *\n * @extends TypeTag\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagVector extends TypeTag {\n  toString(): `vector<${string}>` {\n    return `vector<${this.value.toString()}>`;\n  }\n\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  /**\n   * Creates a new TypeTagVector instance with a TypeTagU8 type.\n   *\n   * @returns {TypeTagVector} A new TypeTagVector initialized with TypeTagU8.\n   * @group Implementation\n   * @category Transactions\n   */\n  static u8(): TypeTagVector {\n    return new TypeTagVector(new TypeTagU8());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Vector);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVector {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVector(value);\n  }\n}\n\n/**\n * Represents a structured type tag in the system, extending the base TypeTag class.\n * This class encapsulates information about a specific structure, including its address,\n * module name, and type arguments, and provides methods for serialization and type checking.\n *\n * @param value - The StructTag instance containing the details of the structured type.\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagStruct extends TypeTag {\n  toString(): `0x${string}::${string}::${string}` {\n    // Collect type args and add it if there are any\n    let typePredicate = \"\";\n    if (this.value.typeArgs.length > 0) {\n      typePredicate = `<${this.value.typeArgs.map((typeArg) => typeArg.toString()).join(\", \")}>`;\n    }\n\n    return `${this.value.address.toString()}::${this.value.moduleName.identifier}::${\n      this.value.name.identifier\n    }${typePredicate}`;\n  }\n\n  constructor(public readonly value: StructTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Struct);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagStruct {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagStruct(value);\n  }\n\n  /**\n   * Determines if the provided address, module name, and struct name match the current type tag.\n   *\n   * @param address - The account address to compare against the type tag.\n   * @param moduleName - The name of the module to compare against the type tag.\n   * @param structName - The name of the struct to compare against the type tag.\n   * @returns True if the address, module name, and struct name match the type tag; otherwise, false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isTypeTag(address: AccountAddress, moduleName: string, structName: string): boolean {\n    return (\n      this.value.moduleName.identifier === moduleName &&\n      this.value.name.identifier === structName &&\n      this.value.address.equals(address)\n    );\n  }\n\n  /**\n   * Checks if the provided value is of type string.\n   * This function can help ensure that the data being processed is in the correct format before further operations.\n   *\n   * @returns {boolean} Returns true if the value is a string, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isString(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"string\", \"String\");\n  }\n\n  /**\n   * Checks if the specified account address is of type \"option\".\n   *\n   * @returns {boolean} Returns true if the account address is an option type, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isOption(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"option\", \"Option\");\n  }\n\n  /**\n   * Checks if the provided value is of type 'object'.\n   * This function helps determine if a value can be treated as an object type in the context of the SDK.\n   *\n   * @returns {boolean} Returns true if the value is an object, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isObject(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"object\", \"Object\");\n  }\n\n  /**\n   * Checks if the provided value is a 'DelegationKey' for permissioned signers.\n   *\n   * @returns {boolean} Returns true if the value is a DelegationKey, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isDelegationKey(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"permissioned_delegation\", \"DelegationKey\");\n  }\n\n  /**\n   * Checks if the provided value is of type `RateLimiter`.\n   *\n   * @returns {boolean} Returns true if the value is a RateLimiter, otherwise false.\n   * @group Implementation\n   * @category Transactions\n   */\n  isRateLimiter(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"rate_limiter\", \"RateLimiter\");\n  }\n}\n\n/**\n * Represents a structured tag that includes an address, module name,\n * name, and type arguments. This class is used to define and manage\n * structured data types within the SDK.\n *\n * @property {AccountAddress} address - The address associated with the struct tag.\n * @property {Identifier} moduleName - The name of the module that contains the struct.\n * @property {Identifier} name - The name of the struct.\n * @property {Array<TypeTag>} typeArgs - An array of type arguments associated with the struct.\n * @group Implementation\n * @category Transactions\n */\nexport class StructTag extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly moduleName: Identifier;\n\n  public readonly name: Identifier;\n\n  public readonly typeArgs: Array<TypeTag>;\n\n  constructor(address: AccountAddress, module_name: Identifier, name: Identifier, type_args: Array<TypeTag>) {\n    super();\n    this.address = address;\n    this.moduleName = module_name;\n    this.name = name;\n    this.typeArgs = type_args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.address);\n    serializer.serialize(this.moduleName);\n    serializer.serialize(this.name);\n    serializer.serializeVector(this.typeArgs);\n  }\n\n  static deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n}\n\n/**\n * Retrieves the StructTag for the AptosCoin, which represents the Aptos Coin in the Aptos blockchain.\n *\n * @returns {StructTag} The StructTag for the AptosCoin.\n * @group Implementation\n * @category Transactions\n */\nexport function aptosCoinStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"aptos_coin\"), new Identifier(\"AptosCoin\"), []);\n}\n\n/**\n * Returns a new StructTag representing a string type.\n *\n * @returns {StructTag} A StructTag for the string type.\n * @group Implementation\n * @category Transactions\n */\nexport function stringStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"string\"), new Identifier(\"String\"), []);\n}\n\n/**\n * Creates a new StructTag for the Option type with the specified type argument.\n * This can help in defining a specific instance of an Option type in your application.\n *\n * @param typeArg - The type tag that specifies the type of the value contained in the Option.\n * @group Implementation\n * @category Transactions\n */\nexport function optionStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"option\"), new Identifier(\"Option\"), [typeArg]);\n}\n\n/**\n * Creates a new StructTag for the Object type with the specified type argument.\n * This function helps in defining a structured representation of an Object with a specific type.\n *\n * @param typeArg - The type tag that specifies the type of the Object.\n * @group Implementation\n * @category Transactions\n */\nexport function objectStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"object\"), new Identifier(\"Object\"), [typeArg]);\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { EntryFunctionBytes } from \"../../bcs/serializable/entryFunctionBytes\";\nimport { Bool, U128, U16, U256, U32, U64, U8 } from \"../../bcs/serializable/movePrimitives\";\nimport { MoveVector, Serialized } from \"../../bcs/serializable/moveStructs\";\nimport { AccountAddress, Hex } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { ModuleId } from \"./moduleId\";\nimport type { EntryFunctionArgument, ScriptFunctionArgument, TransactionArgument } from \"./transactionArgument\";\nimport {\n  AnyNumber,\n  MoveModuleId,\n  ScriptTransactionArgumentVariants,\n  TransactionExecutableVariants,\n  TransactionExtraConfigVariants,\n  TransactionInnerPayloadVariants,\n  TransactionPayloadVariants,\n} from \"../../types\";\nimport { TypeTag } from \"../typeTag\";\n\n/**\n * Deserialize a Script Transaction Argument.\n * This function retrieves and deserializes various types of script transaction arguments based on the provided deserializer.\n *\n * @param deserializer - The deserializer used to read the script transaction argument.\n * @returns The deserialized script transaction argument.\n * @throws Error if the variant index is unknown.\n * @group Implementation\n * @category Transactions\n */\nexport function deserializeFromScriptArgument(deserializer: Deserializer): TransactionArgument {\n  // index enum variant\n  const index = deserializer.deserializeUleb128AsU32();\n  switch (index) {\n    case ScriptTransactionArgumentVariants.U8:\n      return U8.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U64:\n      return U64.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U128:\n      return U128.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.Address:\n      return AccountAddress.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U8Vector:\n      return MoveVector.deserialize(deserializer, U8);\n    case ScriptTransactionArgumentVariants.Bool:\n      return Bool.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U16:\n      return U16.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U32:\n      return U32.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U256:\n      return U256.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.Serialized:\n      return Serialized.deserialize(deserializer);\n    default:\n      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);\n  }\n}\n\n/**\n * Represents a supported Transaction Payload that can be serialized and deserialized.\n *\n * This class serves as a base for different types of transaction payloads, allowing for\n * their serialization into a format suitable for transmission and deserialization back\n * into their original form.\n * @group Implementation\n * @category Transactions\n */\nexport abstract class TransactionPayload extends Serializable {\n  /**\n   * Serialize a Transaction Payload\n   * @group Implementation\n   * @category Transactions\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Transaction Payload\n   * @group Implementation\n   * @category Transactions\n   */\n\n  /**\n   * Deserializes a multisig transaction payload from the provided deserializer.\n   * This function enables the reconstruction of a MultiSigTransactionPayload object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): TransactionPayload {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionPayloadVariants.Script:\n        return TransactionPayloadScript.load(deserializer);\n      case TransactionPayloadVariants.EntryFunction:\n        return TransactionPayloadEntryFunction.load(deserializer);\n      case TransactionPayloadVariants.Multisig:\n        return TransactionPayloadMultiSig.load(deserializer);\n      case TransactionPayloadVariants.Payload:\n        return TransactionInnerPayload.deserialize(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);\n    }\n  }\n}\n\n/**\n * Represents a transaction payload script that can be serialized and deserialized.\n *\n * This class encapsulates a script that defines the logic for a transaction payload.\n *\n * @extends TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionPayloadScript extends TransactionPayload {\n  public readonly script: Script;\n\n  /**\n   * Initializes a multi-sig account transaction with the provided payload.\n   *\n   * @param script - The payload of the multi-sig transaction. This can only be an EntryFunction for now, but Script might be\n   * supported in the future.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(script: Script) {\n    super();\n    this.script = script;\n  }\n\n  /**\n   * Serializes the transaction payload, enabling future support for multiple types of inner transaction payloads.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Script);\n    this.script.serialize(serializer);\n  }\n\n  /**\n   * Loads a MultiSig transaction payload from the provided deserializer.\n   * This function helps in reconstructing a MultiSig transaction payload from its serialized form.\n   *\n   * @param deserializer - The deserializer used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): TransactionPayloadScript {\n    const script = Script.deserialize(deserializer);\n    return new TransactionPayloadScript(script);\n  }\n}\n\n/**\n * Represents a transaction payload entry function that can be serialized and deserialized.\n *\n * @extends TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionPayloadEntryFunction extends TransactionPayload {\n  public readonly entryFunction: EntryFunction;\n\n  constructor(entryFunction: EntryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.EntryFunction);\n    this.entryFunction.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadEntryFunction {\n    const entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionPayloadEntryFunction(entryFunction);\n  }\n}\n\n/**\n * Represents a multi-signature transaction payload that can be serialized and deserialized.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionPayloadMultiSig extends TransactionPayload {\n  public readonly multiSig: MultiSig;\n\n  constructor(multiSig: MultiSig) {\n    super();\n    this.multiSig = multiSig;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Multisig);\n    this.multiSig.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadMultiSig {\n    const value = MultiSig.deserialize(deserializer);\n    return new TransactionPayloadMultiSig(value);\n  }\n}\n\n/**\n * Represents an entry function that can be serialized and deserialized.\n * This class encapsulates the details required to invoke a function within a module,\n * including the module name, function name, type arguments, and function arguments.\n *\n * @param module_name - Fully qualified module name in the format \"account_address::module_name\" (e.g., \"0x1::coin\").\n * @param function_name - The name of the function (e.g., \"transfer\").\n * @param type_args - Type arguments required by the Move function.\n * @param args - Arguments to the Move function.\n * @group Implementation\n * @category Transactions\n */\nexport class EntryFunction {\n  public readonly module_name: ModuleId;\n\n  public readonly function_name: Identifier;\n\n  public readonly type_args: Array<TypeTag>;\n\n  public readonly args: Array<EntryFunctionArgument>;\n\n  /**\n   * Contains the payload to run a function within a module.\n   * @param module_name Fully qualified module name in format \"account_address::module_name\" e.g. \"0x1::coin\"\n   * @param function_name The function name. e.g \"transfer\"\n   * @param type_args Type arguments that move function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @param args arguments to the move function.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    module_name: ModuleId,\n    function_name: Identifier,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ) {\n    this.module_name = module_name;\n    this.function_name = function_name;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  /**\n   * Build an EntryFunction payload from raw primitive values.\n   *\n   * @param module_id - Fully qualified module name in the format \"AccountAddress::module_id\", e.g., \"0x1::coin\".\n   * @param function_name - The name of the function to be called.\n   * @param type_args - Type arguments that the Move function requires.\n   * @param args - Arguments to the Move function.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   *\n   * A coin transfer function has three arguments \"from\", \"to\", and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   *\n   * @returns EntryFunction\n   * @group Implementation\n   * @category Transactions\n   */\n  static build(\n    module_id: MoveModuleId,\n    function_name: string,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ): EntryFunction {\n    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.module_name.serialize(serializer);\n    this.function_name.serialize(serializer);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: EntryFunctionArgument) => {\n      item.serializeForEntryFunction(serializer);\n    });\n  }\n\n  /**\n   * Deserializes an entry function payload with the arguments represented as EntryFunctionBytes instances.\n   * @see EntryFunctionBytes\n   *\n   * NOTE: When you deserialize an EntryFunction payload with this method, the entry function\n   * arguments are populated into the deserialized instance as type-agnostic, raw fixed bytes\n   * in the form of the EntryFunctionBytes class.\n   *\n   * In order to correctly deserialize these arguments as their actual type representations, you\n   * must know the types of the arguments beforehand and deserialize them yourself individually.\n   *\n   * One way you could achieve this is by using the ABIs for an entry function and deserializing each\n   * argument as its given, corresponding type.\n   *\n   * @param deserializer\n   * @returns A deserialized EntryFunction payload for a transaction.\n   *\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): EntryFunction {\n    const module_name = ModuleId.deserialize(deserializer);\n    const function_name = Identifier.deserialize(deserializer);\n    const type_args = deserializer.deserializeVector(TypeTag);\n\n    const length = deserializer.deserializeUleb128AsU32();\n    const args: Array<EntryFunctionArgument> = new Array<EntryFunctionBytes>();\n\n    for (let i = 0; i < length; i += 1) {\n      const fixedBytesLength = deserializer.deserializeUleb128AsU32();\n      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);\n      args.push(fixedBytes);\n    }\n\n    return new EntryFunction(module_name, function_name, type_args, args);\n  }\n}\n\n/**\n * Represents a Script that can be serialized and deserialized.\n * Scripts contain the Move bytecode payload that can be submitted to the Aptos chain for execution.\n * @group Implementation\n * @category Transactions\n */\nexport class Script {\n  /**\n   * The move module bytecode\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly bytecode: Uint8Array;\n\n  /**\n   * The type arguments that the bytecode function requires.\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly type_args: Array<TypeTag>;\n\n  /**\n   * The arguments that the bytecode function requires.\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly args: Array<ScriptFunctionArgument>;\n\n  /**\n   * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.\n   *\n   * @param bytecode The move module bytecode\n   * @param type_args The type arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @param args The arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(bytecode: Uint8Array, type_args: Array<TypeTag>, args: Array<ScriptFunctionArgument>) {\n    this.bytecode = bytecode;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.bytecode);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: ScriptFunctionArgument) => {\n      item.serializeForScriptFunction(serializer);\n    });\n  }\n\n  static deserialize(deserializer: Deserializer): Script {\n    const bytecode = deserializer.deserializeBytes();\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array<ScriptFunctionArgument>();\n    for (let i = 0; i < length; i += 1) {\n      // Note that we deserialize directly to the Move value, not its Script argument representation.\n      // We are abstracting away the Script argument representation because knowing about it is\n      // functionally useless.\n      const scriptArgument = deserializeFromScriptArgument(deserializer);\n      args.push(scriptArgument);\n    }\n    return new Script(bytecode, type_args, args);\n  }\n}\n\n/**\n * Represents a MultiSig account that can be serialized and deserialized.\n *\n * This class encapsulates the functionality to manage multi-signature transactions, including the address of the\n * multi-sig account and the associated transaction payload.\n * @group Implementation\n * @category Transactions\n */\nexport class MultiSig {\n  public readonly multisig_address: AccountAddress;\n\n  public readonly transaction_payload?: MultiSigTransactionPayload;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param multisig_address The multi-sig account address the transaction will be executed as.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction. This is optional when executing a multi-sig\n   *  transaction whose payload is already stored on chain.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(multisig_address: AccountAddress, transaction_payload?: MultiSigTransactionPayload) {\n    this.multisig_address = multisig_address;\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.multisig_address.serialize(serializer);\n    // Options are encoded with an extra u8 field before the value - 0x0 is none and 0x1 is present.\n    // We use serializeBool below to create this prefix value.\n    if (this.transaction_payload === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.transaction_payload.serialize(serializer);\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSig {\n    const multisig_address = AccountAddress.deserialize(deserializer);\n    const payloadPresent = deserializer.deserializeBool();\n    let transaction_payload;\n    if (payloadPresent) {\n      transaction_payload = MultiSigTransactionPayload.deserialize(deserializer);\n    }\n    return new MultiSig(multisig_address, transaction_payload);\n  }\n}\n\n/**\n * Represents a multi-signature transaction payload that can be serialized and deserialized.\n * This class is designed to encapsulate the transaction payload for multi-sig account transactions\n * as defined in the `multisig_account.move` module. Future enhancements may allow support for script\n * payloads as the `multisig_account.move` module evolves.\n * @group Implementation\n * @category Transactions\n */\nexport class MultiSigTransactionPayload extends Serializable {\n  public readonly transaction_payload: EntryFunction;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction.\n   * This can only be EntryFunction for now but,\n   * Script might be supported in the future.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(transaction_payload: EntryFunction) {\n    super();\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    /**\n     * We can support multiple types of inner transaction payload in the future.\n     * For now, it's only EntryFunction but if we support more types,\n     * we need to serialize with the right enum values here\n     * @group Implementation\n     * @category Transactions\n     */\n    serializer.serializeU32AsUleb128(0);\n    this.transaction_payload.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSigTransactionPayload {\n    // TODO: Support other types of payload beside EntryFunction.\n    // This is the enum value indicating which type of payload the multisig tx contains.\n    deserializer.deserializeUleb128AsU32();\n    return new MultiSigTransactionPayload(EntryFunction.deserialize(deserializer));\n  }\n}\n\n/**\n * Represents any transaction payload that can be submitted to the Aptos chain for execution.\n *\n * This is specifically required for orderless transactions, but can be used for any transaction payload.\n */\nexport abstract class TransactionInnerPayload extends TransactionPayload {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionInnerPayload {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionInnerPayloadVariants.V1:\n        return TransactionInnerPayloadV1.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionInnerPayload: ${index}`);\n    }\n  }\n}\n\nexport class TransactionInnerPayloadV1 extends TransactionInnerPayload {\n  executable: TransactionExecutable;\n  extra_config: TransactionExtraConfig;\n\n  constructor(executable: TransactionExecutable, extra_config: TransactionExtraConfig) {\n    super();\n    this.executable = executable;\n    this.extra_config = extra_config;\n  }\n\n  serialize(serializer: Serializer): void {\n    // This payload must be serialized as a top level TransactionPayload, so we add that here\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Payload);\n    // V1 is serialized as 0\n    serializer.serializeU32AsUleb128(TransactionInnerPayloadVariants.V1);\n    this.executable.serialize(serializer);\n    this.extra_config.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionInnerPayloadV1 {\n    let executable = TransactionExecutable.deserialize(deserializer);\n    let extra_config = TransactionExtraConfig.deserialize(deserializer);\n    return new TransactionInnerPayloadV1(executable, extra_config);\n  }\n}\n\nexport abstract class TransactionExecutable {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionExecutable {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionExecutableVariants.Script:\n        return TransactionExecutableScript.load(deserializer);\n      case TransactionExecutableVariants.EntryFunction:\n        return TransactionExecutableEntryFunction.load(deserializer);\n      case TransactionExecutableVariants.Empty:\n        return TransactionExecutableEmpty.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionExecutable: ${index}`);\n    }\n  }\n}\n\nexport class TransactionExecutableScript extends TransactionExecutable {\n  script: Script;\n\n  constructor(script: Script) {\n    super();\n    this.script = script;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionExecutableVariants.Script);\n    this.script.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionExecutableScript {\n    let script = Script.deserialize(deserializer);\n    return new TransactionExecutableScript(script);\n  }\n}\n\nexport class TransactionExecutableEntryFunction extends TransactionExecutable {\n  entryFunction: EntryFunction;\n\n  constructor(entryFunction: EntryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionExecutableVariants.EntryFunction);\n    this.entryFunction.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionExecutableEntryFunction {\n    let entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionExecutableEntryFunction(entryFunction);\n  }\n}\n\nexport class TransactionExecutableEmpty extends TransactionExecutable {\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionExecutableVariants.Empty);\n  }\n\n  static load(_: Deserializer): TransactionExecutableEmpty {\n    return new TransactionExecutableEmpty();\n  }\n}\n\nexport abstract class TransactionExtraConfig {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionExtraConfig {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionExtraConfigVariants.V1:\n        return TransactionExtraConfigV1.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionExtraConfig: ${index}`);\n    }\n  }\n}\n\nexport class TransactionExtraConfigV1 extends TransactionExtraConfig {\n  multisigAddress?: AccountAddress;\n  replayProtectionNonce?: bigint;\n\n  constructor(multisigAddress?: AccountAddress, replayProtectionNonce?: AnyNumber) {\n    super();\n    this.multisigAddress = multisigAddress;\n    this.replayProtectionNonce = replayProtectionNonce !== undefined ? BigInt(replayProtectionNonce) : undefined;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionExtraConfigVariants.V1);\n    serializer.serializeOption<AccountAddress>(this.multisigAddress);\n    serializer.serializeOption<U64>(\n      this.replayProtectionNonce !== undefined ? new U64(this.replayProtectionNonce) : undefined,\n    );\n  }\n\n  static load(deserializer: Deserializer): TransactionExtraConfigV1 {\n    const multisigAddress = deserializer.deserializeOption(AccountAddress);\n    const replayProtectionNonce = deserializer.deserializeOption(U64);\n    return new TransactionExtraConfigV1(multisigAddress, replayProtectionNonce?.value);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { ChainId } from \"./chainId\";\nimport { AccountAddress } from \"../../core\";\nimport { TransactionPayload } from \"./transactionPayload\";\nimport { TransactionVariants } from \"../../types\";\n\n/**\n * Represents a raw transaction that can be serialized and deserialized.\n * Raw transactions contain the metadata and payloads that can be submitted to the Aptos chain for execution.\n * They must be signed before the Aptos chain can execute them.\n * @group Implementation\n * @category Transactions\n */\nexport class RawTransaction extends Serializable {\n  public readonly sender: AccountAddress;\n\n  public readonly sequence_number: bigint;\n\n  public readonly payload: TransactionPayload;\n\n  public readonly max_gas_amount: bigint;\n\n  public readonly gas_unit_price: bigint;\n\n  public readonly expiration_timestamp_secs: bigint;\n\n  public readonly chain_id: ChainId;\n\n  /**\n   * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.\n   * RawTransactions must be signed before Aptos chain can execute them.\n   *\n   * @param sender The sender Account Address\n   * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in\n   *   the sender's account at the time the transaction executes.\n   * @param payload Instructions for the Aptos Blockchain, including publishing a module,\n   *   execute an entry function or execute a script payload.\n   * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more\n   *   than this gas or the transaction will be discarded during validation.\n   * @param gas_unit_price Price to be paid per gas unit.\n   * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.\n   * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    sender: AccountAddress,\n    sequence_number: bigint,\n    payload: TransactionPayload,\n    max_gas_amount: bigint,\n    gas_unit_price: bigint,\n    expiration_timestamp_secs: bigint,\n    chain_id: ChainId,\n  ) {\n    super();\n    this.sender = sender;\n    this.sequence_number = sequence_number;\n    this.payload = payload;\n    this.max_gas_amount = max_gas_amount;\n    this.gas_unit_price = gas_unit_price;\n    this.expiration_timestamp_secs = expiration_timestamp_secs;\n    this.chain_id = chain_id;\n  }\n\n  /**\n   * Serializes the transaction data, including the fee payer transaction type, raw transaction, secondary signer addresses,\n   * and fee payer address.\n   * This function is essential for preparing the transaction for transmission or storage in a serialized format.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.sender.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.payload.serialize(serializer);\n    serializer.serializeU64(this.max_gas_amount);\n    serializer.serializeU64(this.gas_unit_price);\n    serializer.serializeU64(this.expiration_timestamp_secs);\n    this.chain_id.serialize(serializer);\n  }\n\n  /**\n   * Deserialize a Raw Transaction With Data.\n   * This function retrieves the appropriate raw transaction based on the variant index provided by the deserializer.\n   *\n   * @param deserializer - An instance of the Deserializer used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): RawTransaction {\n    const sender = AccountAddress.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const payload = TransactionPayload.deserialize(deserializer);\n    const max_gas_amount = deserializer.deserializeU64();\n    const gas_unit_price = deserializer.deserializeU64();\n    const expiration_timestamp_secs = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    return new RawTransaction(\n      sender,\n      sequence_number,\n      payload,\n      max_gas_amount,\n      gas_unit_price,\n      expiration_timestamp_secs,\n      chain_id,\n    );\n  }\n}\n\n/**\n * Represents a raw transaction with associated data that can be serialized and deserialized.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class RawTransactionWithData extends Serializable {\n  /**\n   * Serialize a Raw Transaction With Data\n   * @group Implementation\n   * @category Transactions\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Raw Transaction With Data\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): RawTransactionWithData {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionVariants.MultiAgentTransaction:\n        return MultiAgentRawTransaction.load(deserializer);\n      case TransactionVariants.FeePayerTransaction:\n        return FeePayerRawTransaction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);\n    }\n  }\n}\n\n/**\n * Represents a multi-agent transaction that can be serialized and deserialized.\n *\n * @extends RawTransactionWithData\n * @group Implementation\n * @category Transactions\n */\nexport class MultiAgentRawTransaction extends RawTransactionWithData {\n  /**\n   * The raw transaction\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly raw_txn: RawTransaction;\n\n  /**\n   * The secondary signers on this transaction\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  constructor(raw_txn: RawTransaction, secondary_signer_addresses: Array<AccountAddress>) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionVariants.MultiAgentTransaction);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n  }\n\n  /**\n   * Deserializes a Fee Payer Raw Transaction from the provided deserializer.\n   * This function allows you to reconstruct a Fee Payer Raw Transaction object, which includes the raw transaction data,\n   * secondary signer addresses, and the fee payer address.\n   *\n   * @param deserializer - The deserializer used to read the raw transaction data.\n   * @returns A FeePayerRawTransaction object constructed from the deserialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): MultiAgentRawTransaction {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n\n    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);\n  }\n}\n\n/**\n * Represents a Fee Payer Transaction that can be serialized and deserialized.\n * @group Implementation\n * @category Transactions\n */\nexport class FeePayerRawTransaction extends RawTransactionWithData {\n  /**\n   * The raw transaction\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly raw_txn: RawTransaction;\n\n  /**\n   * The secondary signers on this transaction - optional and can be empty\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  /**\n   * The fee payer account address\n   * @group Implementation\n   * @category Transactions\n   */\n  public readonly fee_payer_address: AccountAddress;\n\n  constructor(\n    raw_txn: RawTransaction,\n    secondary_signer_addresses: Array<AccountAddress>,\n    fee_payer_address: AccountAddress,\n  ) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.fee_payer_address = fee_payer_address;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionVariants.FeePayerTransaction);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    this.fee_payer_address.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): FeePayerRawTransaction {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    const feePayerAddress = AccountAddress.deserialize(deserializer);\n\n    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { AccountAuthenticator } from \"./account\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../../core/crypto/multiEd25519\";\nimport { TransactionAuthenticatorVariant } from \"../../types\";\n\n/**\n * Represents an abstract base class for transaction authenticators.\n * This class provides methods for serializing and deserializing different types of transaction authenticators.\n *\n * @extends Serializable\n * @group Implementation\n * @category Transactions\n */\nexport abstract class TransactionAuthenticator extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserializes a TransactionAuthenticator from the provided deserializer.\n   * This function helps in reconstructing the TransactionAuthenticator based on the variant index found in the serialized data.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): TransactionAuthenticator {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionAuthenticatorVariant.Ed25519:\n        return TransactionAuthenticatorEd25519.load(deserializer);\n      case TransactionAuthenticatorVariant.MultiEd25519:\n        return TransactionAuthenticatorMultiEd25519.load(deserializer);\n      case TransactionAuthenticatorVariant.MultiAgent:\n        return TransactionAuthenticatorMultiAgent.load(deserializer);\n      case TransactionAuthenticatorVariant.FeePayer:\n        return TransactionAuthenticatorFeePayer.load(deserializer);\n      case TransactionAuthenticatorVariant.SingleSender:\n        return TransactionAuthenticatorSingleSender.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);\n    }\n  }\n\n  isEd25519(): this is TransactionAuthenticatorEd25519 {\n    return this instanceof TransactionAuthenticatorEd25519;\n  }\n\n  isMultiEd25519(): this is TransactionAuthenticatorMultiEd25519 {\n    return this instanceof TransactionAuthenticatorMultiEd25519;\n  }\n\n  isMultiAgent(): this is TransactionAuthenticatorMultiAgent {\n    return this instanceof TransactionAuthenticatorMultiAgent;\n  }\n\n  isFeePayer(): this is TransactionAuthenticatorFeePayer {\n    return this instanceof TransactionAuthenticatorFeePayer;\n  }\n\n  isSingleSender(): this is TransactionAuthenticatorSingleSender {\n    return this instanceof TransactionAuthenticatorSingleSender;\n  }\n}\n\n/**\n * Represents a transaction authenticator using Ed25519 for a single signer transaction.\n * This class encapsulates the client's public key and the Ed25519 signature of a raw transaction.\n *\n * @param public_key - The client's public key.\n * @param signature - The Ed25519 signature of a raw transaction.\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n * for details about generating a signature.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorEd25519 extends TransactionAuthenticator {\n  public readonly public_key: Ed25519PublicKey;\n\n  public readonly signature: Ed25519Signature;\n\n  /**\n   * Creates an instance of the class with the specified account authenticator.\n   *\n   * @param public_key - The Ed25519PublicKey that will be used for authentication.\n   * @param signature - The Ed25519Signature that will be used for authentication.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  /**\n   * Serializes the transaction authenticator by encoding the sender information.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.Ed25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  /**\n   * Loads a TransactionAuthenticatorSingleSender instance from the provided deserializer.\n   * This function helps in deserializing the sender information to create a transaction authenticator.\n   *\n   * @param deserializer - The deserializer used to extract the sender data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static load(deserializer: Deserializer): TransactionAuthenticatorEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents a transaction authenticator for multi-signature transactions using Ed25519.\n * This class is used to validate transactions that require multiple signatures from different signers.\n *\n * @param public_key - The public key of the client involved in the transaction.\n * @param signature - The multi-signature of the raw transaction.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorMultiEd25519 extends TransactionAuthenticator {\n  public readonly public_key: MultiEd25519PublicKey;\n\n  public readonly signature: MultiEd25519Signature;\n\n  constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.MultiEd25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorMultiEd25519(public_key, signature);\n  }\n}\n\n/**\n * Represents a transaction authenticator for a multi-agent transaction.\n *\n * This class manages the authentication process involving a primary sender and multiple secondary signers.\n *\n * @param sender - The authenticator for the sender account.\n * @param secondary_signer_addresses - An array of addresses for the secondary signers.\n * @param secondary_signers - An array of authenticators for the secondary signer accounts.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorMultiAgent extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  public readonly secondary_signers: Array<AccountAuthenticator>;\n\n  constructor(\n    sender: AccountAuthenticator,\n    secondary_signer_addresses: Array<AccountAddress>,\n    secondary_signers: Array<AccountAuthenticator>,\n  ) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.MultiAgent);\n    this.sender.serialize(serializer);\n    serializer.serializeVector<AccountAddress>(this.secondary_signer_addresses);\n    serializer.serializeVector<AccountAuthenticator>(this.secondary_signers);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);\n  }\n}\n\n/**\n * Represents a transaction authenticator specifically for fee payer transactions.\n * It encapsulates the sender's account authenticator, addresses of secondary signers,\n * their respective authenticators, and the fee payer's account information.\n *\n * @param sender - The authenticator for the sender's account.\n * @param secondary_signer_addresses - An array of addresses for secondary signers.\n * @param secondary_signers - An array of authenticators for secondary signers' accounts.\n * @param fee_payer - An object containing the fee payer's account address and authenticator.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorFeePayer extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  public readonly secondary_signers: Array<AccountAuthenticator>;\n\n  public readonly fee_payer: {\n    address: AccountAddress;\n    authenticator: AccountAuthenticator;\n  };\n\n  constructor(\n    sender: AccountAuthenticator,\n    secondary_signer_addresses: Array<AccountAddress>,\n    secondary_signers: Array<AccountAuthenticator>,\n    fee_payer: { address: AccountAddress; authenticator: AccountAuthenticator },\n  ) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n    this.fee_payer = fee_payer;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.FeePayer);\n    this.sender.serialize(serializer);\n    serializer.serializeVector<AccountAddress>(this.secondary_signer_addresses);\n    serializer.serializeVector<AccountAuthenticator>(this.secondary_signers);\n    this.fee_payer.address.serialize(serializer);\n    this.fee_payer.authenticator.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    const address = AccountAddress.deserialize(deserializer);\n    const authenticator = AccountAuthenticator.deserialize(deserializer);\n    const fee_payer = { address, authenticator };\n    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);\n  }\n}\n\n/**\n * Represents a single sender authenticator for transactions that require a single signer.\n * This class is responsible for managing the authentication of a transaction initiated by a single sender.\n *\n * @param sender - An instance of AccountAuthenticator that represents the account of the sender.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionAuthenticatorSingleSender extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  constructor(sender: AccountAuthenticator) {\n    super();\n    this.sender = sender;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.SingleSender);\n    this.sender.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorSingleSender {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    return new TransactionAuthenticatorSingleSender(sender);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { TransactionAuthenticator } from \"../authenticator/transaction\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { RawTransaction } from \"./rawTransaction\";\n\n/**\n * Represents a signed transaction that includes a raw transaction and an authenticator.\n * The authenticator contains a client's public key and the signature of the raw transaction.\n *\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n * @param raw_txn - The raw transaction to be signed.\n * @param authenticator - Contains a client's public key and the signature of the raw transaction.\n * Authenticator can have three variations: single signature, multi-signature, and multi-agent.\n * @see {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs} for details.\n * @group Implementation\n * @category Transactions\n */\nexport class SignedTransaction extends Serializable {\n  public readonly raw_txn: RawTransaction;\n\n  public readonly authenticator: TransactionAuthenticator;\n\n  /**\n   * Represents a signed transaction that includes a raw transaction and an authenticator.\n   * The authenticator contains a client's public key and the signature of the raw transaction,\n   * which can be of three types: single signature, multi-signature, and multi-agent.\n   *\n   * @param raw_txn The raw transaction to be signed.\n   * @param authenticator Contains a client's public key and the signature of the raw transaction. The authenticator has 3\n   * flavors: single signature, multi-signature and multi-agent.\n   * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n   * @see {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs} for details.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(raw_txn: RawTransaction, authenticator: TransactionAuthenticator) {\n    super();\n    this.raw_txn = raw_txn;\n    this.authenticator = authenticator;\n  }\n\n  /**\n   * Serializes the raw transaction and its authenticator using the provided serializer.\n   * This function is essential for preparing the transaction data for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction and authenticator.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.raw_txn.serialize(serializer);\n    this.authenticator.serialize(serializer);\n  }\n\n  /**\n   * Deserializes a signed transaction from the provided deserializer.\n   * This function allows you to reconstruct a SignedTransaction object from its serialized form, enabling further processing or validation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): SignedTransaction {\n    const raw_txn = RawTransaction.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    return new SignedTransaction(raw_txn, authenticator);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { RawTransaction } from \"./rawTransaction\";\n\n/**\n * Represents a simple transaction type that can be submitted to the Aptos chain for execution.\n *\n * This transaction type is designed for a single signer and includes metadata such as the Raw Transaction\n * and an optional sponsor Account Address to cover gas fees.\n *\n * @param rawTransaction - The Raw Transaction.\n * @param feePayerAddress - The optional sponsor Account Address.\n * @group Implementation\n * @category Transactions\n */\nexport class SimpleTransaction extends Serializable {\n  public rawTransaction: RawTransaction;\n\n  public feePayerAddress?: AccountAddress | undefined;\n\n  // We don't really need it, we add it for type checking we do\n  // throughout the SDK\n  public readonly secondarySignerAddresses: undefined;\n\n  /**\n   * SimpleTransaction represents a transaction signed by a single account that\n   * can be submitted to the Aptos chain for execution.\n   *\n   * @param rawTransaction The Raw Transaction.\n   * @param feePayerAddress The optional sponsor Account Address to pay the gas fees.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(rawTransaction: RawTransaction, feePayerAddress?: AccountAddress) {\n    super();\n    this.rawTransaction = rawTransaction;\n    this.feePayerAddress = feePayerAddress;\n  }\n\n  /**\n   * Serializes the transaction data using the provided serializer.\n   * This function ensures that the raw transaction and fee payer address are properly serialized for further processing.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.rawTransaction.serialize(serializer);\n\n    if (this.feePayerAddress === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.feePayerAddress.serialize(serializer);\n    }\n  }\n\n  /**\n   * Deserializes a SimpleTransaction from the given deserializer.\n   * This function helps in reconstructing a SimpleTransaction object from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): SimpleTransaction {\n    const rawTransaction = RawTransaction.deserialize(deserializer);\n    const feePayerPresent = deserializer.deserializeBool();\n    let feePayerAddress;\n    if (feePayerPresent) {\n      feePayerAddress = AccountAddress.deserialize(deserializer);\n    }\n\n    return new SimpleTransaction(rawTransaction, feePayerAddress);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { RawTransaction } from \"./rawTransaction\";\n\n/**\n * Represents a multi-agent transaction that can be serialized and deserialized.\n * This transaction includes a raw transaction, optional fee payer address, and multiple secondary signer addresses.\n *\n * @param rawTransaction The raw transaction to be executed.\n * @param secondarySignerAddresses An array of secondary signer addresses involved in the transaction.\n * @param feePayerAddress An optional account address that sponsors the transaction's gas fees.\n * @group Implementation\n * @category Transactions\n */\nexport class MultiAgentTransaction extends Serializable {\n  public rawTransaction: RawTransaction;\n\n  public feePayerAddress?: AccountAddress | undefined;\n\n  public secondarySignerAddresses: AccountAddress[];\n\n  /**\n   * Represents a MultiAgentTransaction that can be submitted to the Aptos chain for execution.\n   * This class encapsulates the raw transaction data, the secondary signer addresses, and an optional fee payer address.\n   *\n   * @param rawTransaction The raw transaction data.\n   * @param secondarySignerAddresses An array of secondary signer addresses.\n   * @param feePayerAddress An optional account address that sponsors the gas fees.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    rawTransaction: RawTransaction,\n    secondarySignerAddresses: AccountAddress[],\n    feePayerAddress?: AccountAddress,\n  ) {\n    super();\n    this.rawTransaction = rawTransaction;\n    this.feePayerAddress = feePayerAddress;\n    this.secondarySignerAddresses = secondarySignerAddresses;\n  }\n\n  /**\n   * Serializes the transaction data, including the raw transaction, secondary signer addresses, and fee payer address.\n   * This function is essential for preparing the transaction for transmission or storage in a serialized format.\n   *\n   * @param serializer - The serializer instance used to serialize the transaction data.\n   * @group Implementation\n   * @category Transactions\n   */\n  serialize(serializer: Serializer): void {\n    this.rawTransaction.serialize(serializer);\n\n    serializer.serializeVector<AccountAddress>(this.secondarySignerAddresses);\n\n    if (this.feePayerAddress === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.feePayerAddress.serialize(serializer);\n    }\n  }\n\n  /**\n   * Deserializes a MultiAgentTransaction from the provided deserializer.\n   * This function allows you to reconstruct a MultiAgentTransaction object from its serialized form, including any secondary\n   * signer addresses and the fee payer address if present.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Transactions\n   */\n  static deserialize(deserializer: Deserializer): MultiAgentTransaction {\n    const rawTransaction = RawTransaction.deserialize(deserializer);\n\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n\n    const feePayerPresent = deserializer.deserializeBool();\n    let feePayerAddress;\n    if (feePayerPresent) {\n      feePayerAddress = AccountAddress.deserialize(deserializer);\n    }\n\n    return new MultiAgentTransaction(rawTransaction, secondarySignerAddresses, feePayerAddress);\n  }\n}\n", "import { AccountAuthenticatorEd25519 } from \"../transactions/authenticator/account\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature, Signature } from \"../core/crypto\";\nimport type { Account } from \"./Account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AptosConfig } from \"../api\";\n\n/**\n * Arguments required to create an instance of an Ed25519 signer.\n *\n * @param privateKey - The private key used for signing.\n * @param address - Optional account address associated with the signer.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface Ed25519SignerConstructorArgs {\n  privateKey: Ed25519PrivateKey;\n  address?: AccountAddressInput;\n}\n\n/**\n * Arguments for creating an Ed25519 signer from a derivation path.\n *\n * @param path - The derivation path for the Ed25519 key.\n * @param mnemonic - The mnemonic phrase used to generate the key.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface Ed25519SignerFromDerivationPathArgs {\n  path: string;\n  mnemonic: string;\n}\n\n/**\n * Arguments required to verify an Ed25519 signature against a given message.\n *\n * @param message - The message to be verified, represented in hexadecimal format.\n * @param signature - The Ed25519 signature to validate.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifyEd25519SignatureArgs {\n  message: HexInput;\n  signature: Ed25519Signature;\n}\n\n/**\n * Represents an Ed25519 account that provides signing capabilities through an Ed25519 private key.\n * This class allows for the creation of accounts, signing messages and transactions, and verifying signatures.\n *\n * Note: Generating an instance of this class does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class Ed25519Account implements Account {\n  /**\n   * Private key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly privateKey: Ed25519PrivateKey;\n\n  readonly publicKey: Ed25519PublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.Ed25519;\n\n  // region Constructors\n\n  /**\n   * Creates an instance of the Ed25519Signer with the specified parameters.\n   * This constructor initializes the private key, public key, and account address for the signer.\n   *\n   * @param args - The constructor arguments for the Ed25519Signer.\n   * @param args.privateKey - The private key used for signing.\n   * @param args.address - The optional account address; if not provided, it will derive the address from the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: Ed25519SignerConstructorArgs) {\n    const { privateKey, address } = args;\n    this.privateKey = privateKey;\n    this.publicKey = privateKey.publicKey();\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n  }\n\n  /**\n   * Generates a new Ed25519 account using a randomly generated private key.\n   * This function is useful for creating a signer that can be used for cryptographic operations.\n   *\n   * @returns {Ed25519Account} The newly generated Ed25519 account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(): Ed25519Account {\n    const privateKey = Ed25519PrivateKey.generate();\n    return new Ed25519Account({ privateKey });\n  }\n\n  /**\n   * Derives an Ed25519 account using a specified BIP44 path and mnemonic seed phrase.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.path - The BIP44 derive hardened path, e.g., m/44'/637'/0'/0'/0'.\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic - The mnemonic seed phrase of the account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromDerivationPath(args: Ed25519SignerFromDerivationPathArgs) {\n    const { path, mnemonic } = args;\n    const privateKey = Ed25519PrivateKey.fromDerivationPath(path, mnemonic);\n    return new Ed25519Account({ privateKey });\n  }\n  // endregion\n\n  // region Account\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifyEd25519SignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * Ed25519 signatures do not depend on chain state, so this function is equivalent to the synchronous verifySignature method.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature,\n    });\n  }\n\n  /**\n   * Sign a message using the account's Ed25519 private key.\n   * This function returns an AccountAuthenticator containing the signature along with the account's public key.\n   *\n   * @param message - The signing message, represented as hexadecimal input.\n   * @returns An AccountAuthenticator containing the signature and the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorEd25519 {\n    return new AccountAuthenticatorEd25519(this.publicKey, this.privateKey.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's Ed25519 private key.\n   * This function returns an AccountAuthenticator that contains the signature of the transaction along with the account's public key.\n   *\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticator containing the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorEd25519 {\n    return new AccountAuthenticatorEd25519(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's Ed25519 private key.\n   * @param message - The message to be signed in HexInput format.\n   * @returns Signature - The resulting signature of the signed message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): Ed25519Signature {\n    return this.privateKey.sign(message);\n  }\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * This function helps ensure that the transaction is properly authenticated before submission.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns Signature - The resulting signature for the transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): Ed25519Signature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n}\n", "import { AccountAuthenticatorSingleKey } from \"../transactions/authenticator/account\";\nimport { type HexInput, SigningScheme, SigningSchemeInput } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  Ed25519PrivateKey,\n  KeylessSignature,\n  PrivateKeyInput,\n  Secp256k1PrivateKey,\n  Signature,\n} from \"../core/crypto\";\nimport type { Account } from \"./Account\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { AptosConfig } from \"../api\";\n\n/**\n * An interface which defines if an Account utilizes SingleKey signing.\n *\n * Such an account will use the AnyPublicKey enum to represent its public key when deriving the auth key.\n */\nexport interface SingleKeySigner extends Account {\n  getAnyPublicKey(): AnyPublicKey;\n}\n\nexport function isSingleKeySigner(obj: unknown): obj is SingleKeySigner {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"getAnyPublicKey\" in obj &&\n    typeof (obj as any).getAnyPublicKey === \"function\"\n  );\n}\n\nexport type SingleKeySignerOrLegacyEd25519Account = SingleKeySigner | Ed25519Account;\n\n/**\n * Arguments required to create a single key signer.\n *\n * @param privateKey - The private key used for signing.\n * @param address - Optional account address associated with the signer.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface SingleKeySignerConstructorArgs {\n  privateKey: PrivateKeyInput;\n  address?: AccountAddressInput;\n}\n\n/**\n * Arguments for generating a single key signer.\n *\n * @param scheme - The signing scheme to be used.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface SingleKeySignerGenerateArgs {\n  scheme?: SigningSchemeInput;\n}\n\n/**\n * The arguments for generating a single key signer from a specified derivation path.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type SingleKeySignerFromDerivationPathArgs = SingleKeySignerGenerateArgs & {\n  path: string;\n  mnemonic: string;\n};\n\n/**\n * Arguments required to verify a single key signature for a given message.\n *\n * @param message - The message to be verified, represented in hexadecimal format.\n * @param signature - The signature that corresponds to the message.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifySingleKeySignatureArgs {\n  message: HexInput;\n  signature: AnySignature;\n}\n\n/**\n * Signer implementation for the SingleKey authentication scheme.\n * This class extends a SingleKeyAccount by adding signing capabilities through a valid private key.\n * Currently, the only supported signature schemes are Ed25519 and Secp256k1.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class SingleKeyAccount implements Account, SingleKeySigner {\n  /**\n   * Private key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly privateKey: PrivateKeyInput;\n\n  readonly publicKey: AnyPublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.SingleKey;\n\n  /**\n   * Creates an instance of the SingleKeySigner using the provided private key and address.\n   * This allows for signing transactions and messages with the specified private key.\n   *\n   * @param args - The constructor arguments for initializing the SingleKeySigner.\n   * @param args.privateKey - The private key used for signing.\n   * @param args.address - The optional account address; if not provided, it will derive the address from the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: SingleKeySignerConstructorArgs) {\n    const { privateKey, address } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new AnyPublicKey(privateKey.publicKey());\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n  }\n\n  getAnyPublicKey(): AnyPublicKey {\n    return this.publicKey;\n  }\n\n  /**\n   * Derives an account from a randomly generated private key based on the specified signing scheme.\n   * The default generation scheme is Ed25519, but it can also support Secp256k1Ecdsa.\n   *\n   * @param args - The arguments for generating the account.\n   * @param args.scheme - The signing scheme to use for generating the private key. Defaults to SigningSchemeInput.Ed25519.\n   * @returns An account with the generated private key based on the specified signing scheme.\n   * @throws Error if an unsupported signature scheme is provided.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(args: SingleKeySignerGenerateArgs = {}) {\n    const { scheme = SigningSchemeInput.Ed25519 } = args;\n    let privateKey: PrivateKeyInput;\n    switch (scheme) {\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.generate();\n        break;\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.generate();\n        break;\n      default:\n        throw new Error(`Unsupported signature scheme ${scheme}`);\n    }\n    return new SingleKeyAccount({ privateKey });\n  }\n\n  /**\n   * Derives an account using a specified BIP44 path and mnemonic seed phrase, defaulting to the Ed25519 signature scheme.\n   * This function allows you to create a single key account based on the provided derivation path and mnemonic.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.scheme - The signature scheme to derive the private key with. Defaults to Ed25519.\n   * @param args.path - The BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519, or non-hardened path\n   * (e.g. m/44'/637'/0'/0/0) for secp256k1.\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic - The mnemonic seed phrase of the account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromDerivationPath(args: SingleKeySignerFromDerivationPathArgs) {\n    const { scheme = SigningSchemeInput.Ed25519, path, mnemonic } = args;\n    let privateKey: PrivateKeyInput;\n    switch (scheme) {\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      default:\n        throw new Error(`Unsupported signature scheme ${scheme}`);\n    }\n    return new SingleKeyAccount({ privateKey });\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifySingleKeySignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the account's public key.\n   *\n   * This function checks if the provided signature is valid for the given message using the account's public key.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message signature.\n   * @param args.options.throwErrorWithReason - Whether to throw an error with the reason for the verification failure.\n   * @returns A boolean indicating whether the signature is valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature,\n    });\n  }\n\n  /**\n   * Sign a message using the account's private key and return an AccountAuthenticator containing the signature along with the\n   * account's public key.\n   * @param message - The signing message, represented as binary input in hexadecimal format.\n   * @returns An instance of AccountAuthenticatorSingleKey containing the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey {\n    return new AccountAuthenticatorSingleKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's private key.\n   * This function returns an AccountAuthenticator that contains the signature of the transaction along with the account's public key.\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticatorSingleKey containing the signature of the transaction and the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey {\n    return new AccountAuthenticatorSingleKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's private key.\n   * @param message - The message to be signed in HexInput format.\n   * @returns A new AnySignature containing the signature of the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): AnySignature {\n    return new AnySignature(this.privateKey.sign(message));\n  }\n\n  /**\n   * Sign the given transaction using the account's private key.\n   * This function generates a signing message for the transaction and then signs it.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns Signature - The resulting signature for the signed transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): AnySignature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n\n  static fromEd25519Account(account: Ed25519Account): SingleKeyAccount {\n    return new SingleKeyAccount({ privateKey: account.privateKey, address: account.accountAddress });\n  }\n}\n", "import type { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { HexInput, SigningScheme, SigningSchemeInput } from \"../types\";\nimport type { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { AuthenticationKey } from \"../core/authenticationKey\";\nimport { AccountPublicKey, Ed25519PrivateKey, PrivateKeyInput, Signature, VerifySignatureArgs } from \"../core/crypto\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { SingleKeyAccount } from \"./SingleKeyAccount\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { AptosConfig } from \"../api\";\n\n/**\n * Arguments for creating an `Ed25519Account` from an `Ed25519PrivateKey`.\n * To use the SingleKey authentication scheme, set `legacy` to false.\n *\n * @param privateKey - The private key used to create the account.\n * @param address - Optional address for the account.\n * @param legacy - Indicates whether to use legacy authentication (default is true).\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateEd25519AccountFromPrivateKeyArgs {\n  privateKey: Ed25519PrivateKey;\n  address?: AccountAddressInput;\n  legacy?: true;\n}\n\n/**\n * Arguments for creating a `SingleKeyAccount` using an `Ed25519PrivateKey`.\n * The `legacy` property must be set to false to utilize the `SingleKey` authentication scheme.\n *\n * @param privateKey - The Ed25519 private key used for account creation.\n * @param address - Optional account address input.\n * @param legacy - Must be false to enable the `SingleKey` authentication scheme.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateEd25519SingleKeyAccountFromPrivateKeyArgs {\n  privateKey: Ed25519PrivateKey;\n  address?: AccountAddressInput;\n  legacy: false;\n}\n\n/**\n * Arguments for creating a `SingleKeyAccount` from a supported private key, excluding `Ed25519PrivateKey`.\n * The `legacy` argument is always false and cannot be set to true.\n *\n * @param privateKey - The private key used to create the account.\n * @param address - Optional address input for the account.\n * @param legacy - Always false; cannot be explicitly set to true.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateSingleKeyAccountFromPrivateKeyArgs {\n  privateKey: PrivateKeyInput;\n  address?: AccountAddressInput;\n  legacy?: false;\n}\n\n/**\n * Arguments for creating an `Account` from a private key when the key type is unknown at compile time.\n *\n * @param privateKey - The private key used to create the account.\n * @param address - Optional address for the account.\n * @param legacy - Optional flag indicating if the account is a legacy account.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface CreateAccountFromPrivateKeyArgs {\n  privateKey: PrivateKeyInput;\n  address?: AccountAddressInput;\n  legacy?: boolean;\n}\n\n/**\n * Arguments for generating an Ed25519 account, specifying the signing scheme and legacy option.\n *\n * @param scheme - The signing scheme to use for the account.\n * @param legacy - Indicates if the account should be created in legacy mode.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateEd25519AccountArgs {\n  scheme?: SigningSchemeInput.Ed25519;\n  legacy?: true;\n}\n\n/**\n * Arguments for generating a `SingleKeyAccount` with an underlying `Ed25519PrivateKey`.\n * The `legacy` argument must be set to false to ensure an `Ed25519SingleKeyAccount` is returned.\n *\n * @param scheme - Optional signing scheme input for the account.\n * @param legacy - Indicates whether to use legacy account generation.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateEd25519SingleKeyAccountArgs {\n  scheme?: SigningSchemeInput.Ed25519;\n  legacy: false;\n}\n\n/**\n * Arguments for generating a `SingleKeyAccount` using a supported private key other than `Ed25519PrivateKey`.\n * The `legacy` argument is optional and defaults to false, and cannot be set to true.\n *\n * @param scheme - The signing scheme to use for the account.\n * @param legacy - Indicates whether to use legacy account generation (defaults to false).\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateSingleKeyAccountArgs {\n  scheme: Exclude<SigningSchemeInput, SigningSchemeInput.Ed25519>;\n  legacy?: false;\n}\n\n/**\n * Arguments for generating an opaque `Account` when the input signature scheme is unknown at compile time.\n *\n * @param scheme - The signing scheme to use for account generation.\n * @param legacy - Indicates whether to use legacy account generation methods.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface GenerateAccountArgs {\n  scheme?: SigningSchemeInput;\n  legacy?: boolean;\n}\n\n/**\n * Arguments for deriving a private key using a mnemonic phrase and a specified BIP44 path.\n *\n * @param path - The BIP44 derivation path for the key.\n * @param mnemonic - The mnemonic phrase used for key generation.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface PrivateKeyFromDerivationPathArgs {\n  path: string;\n  mnemonic: string;\n}\n\n/**\n * Abstract class representing a generic Aptos account.\n *\n * This class serves as a single entry point for account generation, allowing accounts to be created\n * either through `Account.generate()` or `Account.fromDerivationPath`. Although it is defined as an\n * abstract class, it should be treated as an interface and enforced using the `implements` keyword.\n *\n * Note: Generating an account instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport abstract class Account {\n  /**\n   * Public key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract readonly publicKey: AccountPublicKey;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signingScheme: SigningScheme;\n\n  /**\n   * Generates a new account based on the specified signing scheme and legacy option.\n   * This function allows you to create an account with either the Ed25519 signing scheme or a different scheme as specified.\n   *\n   * @param args - The arguments for generating the account.\n   * @param args.scheme - The signing scheme to use for account generation. Defaults to Ed25519.\n   * @param args.legacy - Indicates whether to use the legacy account generation method. Defaults to true.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(args?: GenerateEd25519AccountArgs): Ed25519Account;\n  static generate(args: GenerateEd25519SingleKeyAccountArgs): SingleKeyAccount;\n  static generate(args: GenerateSingleKeyAccountArgs): SingleKeyAccount;\n  static generate(args: GenerateAccountArgs): Account;\n  static generate(args: GenerateAccountArgs = {}) {\n    const { scheme = SigningSchemeInput.Ed25519, legacy = true } = args;\n    if (scheme === SigningSchemeInput.Ed25519 && legacy) {\n      return Ed25519Account.generate();\n    }\n    return SingleKeyAccount.generate({ scheme });\n  }\n\n  /**\n   * Creates an account from a given private key and address.\n   * This function allows you to instantiate an account based on the provided private key,\n   * and it can differentiate between legacy and non-legacy accounts.\n   *\n   * @param args - The arguments for creating the account.\n   * @param args.privateKey - The private key used to create the account.\n   * @param args.address - The address associated with the account.\n   * @param args.legacy - A boolean indicating whether to create a legacy account (default is true).\n   * @returns An instance of either Ed25519Account or SingleKeyAccount based on the provided private key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPrivateKey(args: CreateEd25519AccountFromPrivateKeyArgs): Ed25519Account;\n  static fromPrivateKey(args: CreateSingleKeyAccountFromPrivateKeyArgs): SingleKeyAccount;\n  static fromPrivateKey(args: CreateAccountFromPrivateKeyArgs): SingleKeyAccount;\n  static fromPrivateKey(args: CreateAccountFromPrivateKeyArgs): Ed25519Account | SingleKeyAccount {\n    const { privateKey, address, legacy = true } = args;\n    if (privateKey instanceof Ed25519PrivateKey && legacy) {\n      return new Ed25519Account({\n        privateKey,\n        address,\n      });\n    }\n    return new SingleKeyAccount({ privateKey, address });\n  }\n\n  /**\n   * @deprecated use `fromPrivateKey` instead.\n   * Instantiates an account using a private key and a specified account address. This is primarily used to instantiate an\n   * `Account` that has had its authentication key rotated.\n   *\n   * @param args - The arguments required to create an account from a private key.\n   * @param args.privateKey - The underlying private key for the account.\n   * @param args.address - The account address the `Account` will sign for.\n   * @param args.legacy - Optional. If set to false, the keypair generated is a Unified keypair. Defaults to generating a Legacy\n   * Ed25519 keypair.\n   *\n   * @returns Account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPrivateKeyAndAddress(args: CreateAccountFromPrivateKeyArgs) {\n    return this.fromPrivateKey(args);\n  }\n\n  /**\n   * Generates an account from a specified derivation path and mnemonic.\n   * This function allows you to create an account using different signing schemes based on the provided arguments.\n   *\n   * @param args - The arguments for generating the account.\n   * @param args.scheme - The signing scheme to use for account generation. Defaults to Ed25519.\n   * @param args.mnemonic - The mnemonic phrase used to derive the account.\n   * @param args.path - The derivation path used to generate the account.\n   * @param args.legacy - A boolean indicating whether to use the legacy account generation method. Defaults to true.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromDerivationPath(args: GenerateEd25519AccountArgs & PrivateKeyFromDerivationPathArgs): Ed25519Account;\n  static fromDerivationPath(\n    args: GenerateEd25519SingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs,\n  ): SingleKeyAccount;\n  static fromDerivationPath(args: GenerateSingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs): SingleKeyAccount;\n  static fromDerivationPath(args: GenerateAccountArgs & PrivateKeyFromDerivationPathArgs): Account;\n  static fromDerivationPath(args: GenerateAccountArgs & PrivateKeyFromDerivationPathArgs) {\n    const { scheme = SigningSchemeInput.Ed25519, mnemonic, path, legacy = true } = args;\n    if (scheme === SigningSchemeInput.Ed25519 && legacy) {\n      return Ed25519Account.fromDerivationPath({ mnemonic, path });\n    }\n    return SingleKeyAccount.fromDerivationPath({ scheme, mnemonic, path });\n  }\n\n  /**\n   * Retrieve the authentication key for the associated account using the provided public key.\n   * This key enables account owners to rotate their private key(s) associated with the account without changing the address that\n   * hosts their account.\n   * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}\n   *\n   * @param args - The arguments for retrieving the authentication key.\n   * @param args.publicKey - The public key of the account.\n   * @returns The authentication key for the associated account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static authKey(args: { publicKey: AccountPublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n    return publicKey.authKey();\n  }\n\n  /**\n   * Sign a message using the available signing capabilities.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signWithAuthenticator(message: HexInput): AccountAuthenticator;\n\n  /**\n   * Sign a transaction using the available signing capabilities.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticator;\n\n  /**\n   * Sign the given message using the available signing capabilities.\n   * @param message in HexInput format\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract sign(message: HexInput): Signature;\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * @param transaction the transaction to be signed\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  abstract signTransaction(transaction: AnyRawTransaction): Signature;\n\n  /**\n   * Verify the given message and signature with the public key.\n   * This function helps ensure the integrity and authenticity of a message by validating its signature.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: VerifySignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public key. It fetches any on chain state if needed for verification.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync(args);\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { randomBytes } from \"@noble/hashes/utils\";\n\nimport {\n  bytesToBigIntLE,\n  padAndPackBytesWithLen,\n  poseidonHash,\n  Ed25519PrivateKey,\n  EphemeralPublicKey,\n  EphemeralSignature,\n  PrivateKey,\n} from \"../core/crypto\";\nimport { Hex } from \"../core/hex\";\nimport { EphemeralPublicKeyVariant, HexInput } from \"../types\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { floorToWholeHour, nowInSeconds } from \"../utils/helpers\";\n\nconst TWO_WEEKS_IN_SECONDS = 1_209_600;\n\n/**\n * Represents an ephemeral key pair used for signing transactions via the Keyless authentication scheme.\n * This key pair is temporary and includes an expiration time.\n * For more details on how this class is used, refer to the documentation:\n * https://aptos.dev/guides/keyless-accounts/#1-present-the-user-with-a-sign-in-with-idp-button-on-the-ui\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class EphemeralKeyPair extends Serializable {\n  static readonly BLINDER_LENGTH: number = 31;\n\n  /**\n   * A byte array of length BLINDER_LENGTH used to obfuscate the public key from the IdP.\n   * Used in calculating the nonce passed to the IdP and as a secret witness in proof generation.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly blinder: Uint8Array;\n\n  /**\n   * A timestamp in seconds indicating when the ephemeral key pair is expired.  After expiry, a new\n   * EphemeralKeyPair must be generated and a new JWT needs to be created.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The value passed to the IdP when the user authenticates.  It consists of a hash of the\n   * ephemeral public key, expiry date, and blinder.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly nonce: string;\n\n  /**\n   * A private key used to sign transactions.  This private key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private privateKey: PrivateKey;\n\n  /**\n   * A public key used to verify transactions.  This public key is not tied to any account on the chain as it\n   * is ephemeral (not permanent) in nature.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private publicKey: EphemeralPublicKey;\n\n  /**\n   * Creates an instance of the class with a specified private key, optional expiry date, and optional blinder.\n   * This constructor initializes the public key, sets the expiry date to a default value if not provided,\n   * generates a blinder if not supplied, and calculates the nonce based on the public key, expiry date, and blinder.\n   *\n   * @param args - The parameters for constructing the instance.\n   * @param args.privateKey - The private key used for creating the instance.\n   * @param args.expiryDateSecs - Optional expiry date in seconds from the current time. Defaults to two weeks from now.\n   * @param args.blinder - Optional blinder value. If not provided, a new blinder will be generated.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: { privateKey: PrivateKey; expiryDateSecs?: number; blinder?: HexInput }) {\n    super();\n    const { privateKey, expiryDateSecs, blinder } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new EphemeralPublicKey(privateKey.publicKey());\n    // By default, we set the expiry date to be two weeks in the future floored to the nearest hour\n    this.expiryDateSecs = expiryDateSecs || floorToWholeHour(nowInSeconds() + TWO_WEEKS_IN_SECONDS);\n    // Generate the blinder if not provided\n    this.blinder = blinder !== undefined ? Hex.fromHexInput(blinder).toUint8Array() : generateBlinder();\n    // Calculate the nonce\n    const fields = padAndPackBytesWithLen(this.publicKey.bcsToBytes(), 93);\n    fields.push(BigInt(this.expiryDateSecs));\n    fields.push(bytesToBigIntLE(this.blinder));\n    const nonceHash = poseidonHash(fields);\n    this.nonce = nonceHash.toString();\n  }\n\n  /**\n   * Returns the public key of the key pair.\n   * @return EphemeralPublicKey\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  getPublicKey(): EphemeralPublicKey {\n    return this.publicKey;\n  }\n\n  /**\n   * Checks if the current time has surpassed the expiry date of the key pair.\n   * @return boolean - Returns true if the key pair is expired, otherwise false.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  isExpired(): boolean {\n    const currentTimeSecs: number = Math.floor(Date.now() / 1000);\n    return currentTimeSecs > this.expiryDateSecs;\n  }\n\n  /**\n   * Serializes the object's properties into a format suitable for transmission or storage.\n   * This function is essential for preparing the object data for serialization processes.\n   *\n   * @param serializer - The serializer instance used to serialize the object's properties.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.publicKey.variant);\n    serializer.serializeBytes(this.privateKey.toUint8Array());\n    serializer.serializeU64(this.expiryDateSecs);\n    serializer.serializeFixedBytes(this.blinder);\n  }\n\n  /**\n   * Deserializes an ephemeral key pair from the provided deserializer.\n   * This function helps in reconstructing an ephemeral key pair, which is essential for cryptographic operations.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static deserialize(deserializer: Deserializer): EphemeralKeyPair {\n    const variantIndex = deserializer.deserializeUleb128AsU32();\n    let privateKey: PrivateKey;\n    switch (variantIndex) {\n      case EphemeralPublicKeyVariant.Ed25519:\n        privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        break;\n      default:\n        throw new Error(`Unknown variant index for EphemeralPublicKey: ${variantIndex}`);\n    }\n    const expiryDateSecs = deserializer.deserializeU64();\n    const blinder = deserializer.deserializeFixedBytes(31);\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: Number(expiryDateSecs), blinder });\n  }\n\n  /**\n   * Deserialize a byte array into an EphemeralKeyPair object.\n   * This function allows you to reconstruct an EphemeralKeyPair from its serialized byte representation.\n   *\n   * @param bytes - The byte array representing the serialized EphemeralKeyPair.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromBytes(bytes: Uint8Array): EphemeralKeyPair {\n    return EphemeralKeyPair.deserialize(new Deserializer(bytes));\n  }\n\n  /**\n   * Generates a new ephemeral key pair with an optional expiry date.\n   * This function allows you to create a temporary key pair for secure operations.\n   *\n   * @param args - Optional parameters for key pair generation.\n   * @param args.scheme - The type of key pair to use for the EphemeralKeyPair. Only Ed25519 is supported for now.\n   * @param args.expiryDateSecs - The date of expiry for the key pair in seconds.\n   * @returns An instance of EphemeralKeyPair containing the generated private key and expiry date.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static generate(args?: { scheme?: EphemeralPublicKeyVariant; expiryDateSecs?: number }): EphemeralKeyPair {\n    let privateKey: PrivateKey;\n\n    switch (args?.scheme) {\n      case EphemeralPublicKeyVariant.Ed25519:\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n\n    return new EphemeralKeyPair({ privateKey, expiryDateSecs: args?.expiryDateSecs });\n  }\n\n  /**\n   * Sign the given data using the private key, returning an ephemeral signature.\n   * This function is essential for creating a secure signature that can be used for authentication or verification purposes.\n   *\n   * @param data - The data to be signed, provided in HexInput format.\n   * @returns EphemeralSignature - The resulting ephemeral signature.\n   * @throws Error - Throws an error if the EphemeralKeyPair has expired.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(data: HexInput): EphemeralSignature {\n    if (this.isExpired()) {\n      throw new Error(\"EphemeralKeyPair has expired\");\n    }\n    return new EphemeralSignature(this.privateKey.sign(data));\n  }\n}\n\n/**\n * Generates a random byte array of length EphemeralKeyPair.BLINDER_LENGTH.\n * @returns Uint8Array A random byte array used for blinding.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nfunction generateBlinder(): Uint8Array {\n  return randomBytes(EphemeralKeyPair.BLINDER_LENGTH);\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport EventEmitter from \"eventemitter3\";\nimport { jwtDecode } from \"jwt-decode\";\nimport { EphemeralCertificateVariant, HexInput, SigningScheme } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  EphemeralCertificate,\n  ZeroKnowledgeSig,\n  ZkProof,\n  MoveJWK,\n  getKeylessConfig,\n  fetchJWK,\n  KeylessConfiguration,\n} from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Hex } from \"../core/hex\";\nimport { AccountAuthenticatorSingleKey } from \"../transactions/authenticator/account\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { deriveTransactionType, generateSigningMessage } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../transactions/types\";\nimport { base64UrlDecode } from \"../utils/helpers\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { Account } from \"./Account\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { KeylessError, KeylessErrorType } from \"../errors\";\nimport type { SingleKeySigner } from \"./SingleKeyAccount\";\n\n/**\n * An interface which defines if an Account utilizes Keyless signing.\n */\nexport interface KeylessSigner extends Account {\n  checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void>;\n}\n\nexport function isKeylessSigner(obj: any): obj is KeylessSigner {\n  return obj !== null && obj !== undefined && typeof obj.checkKeylessAccountValidity === \"function\";\n}\n\n/**\n * Account implementation for the Keyless authentication scheme.  This abstract class is used for standard Keyless Accounts\n * and Federated Keyless Accounts.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport abstract class AbstractKeylessAccount extends Serializable implements KeylessSigner, SingleKeySigner {\n  static readonly PEPPER_LENGTH: number = 31;\n\n  /**\n   * The KeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n\n  /**\n   * The EphemeralKeyPair used to generate sign.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly ephemeralKeyPair: EphemeralKeyPair;\n\n  /**\n   * The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly uidKey: string;\n\n  /**\n   * The value of the uidKey claim on the JWT.  This intended to be a stable user identifier.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly uidVal: string;\n\n  /**\n   * The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly aud: string;\n\n  /**\n   * A value contains 31 bytes of entropy that preserves privacy of the account. Typically fetched from a pepper provider.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly pepper: Uint8Array;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * The zero knowledge signature (if ready) which contains the proof used to validate the EphemeralKeyPair.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  proof: ZeroKnowledgeSig | undefined;\n\n  /**\n   * The proof of the EphemeralKeyPair or a promise that provides the proof.  This is used to allow for awaiting on\n   * fetching the proof.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly proofOrPromise: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signingScheme: SigningScheme = SigningScheme.SingleKey;\n\n  /**\n   * The JWT token used to derive the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly jwt: string;\n\n  /**\n   * The hash of the verification key used to verify the proof. This is optional and can be used to check verifying key\n   * rotations which may invalidate the proof.\n   */\n  readonly verificationKeyHash?: Uint8Array;\n\n  /**\n   * An event emitter used to assist in handling asynchronous proof fetching.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private readonly emitter: EventEmitter<ProofFetchEvents>;\n\n  /**\n   * Use the static generator `create(...)` instead.\n   * Creates an instance of the KeylessAccount with an optional proof.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.publicKey - A KeylessPublicKey or FederatedKeylessPublicKey.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.iss - A JWT issuer.\n   * @param args.uidKey - The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @param args.uidVal - The unique id for this user, intended to be a stable user identifier.\n   * @param args.aud - The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.verificationKeyHash Optional 32-byte verification key hash as hex input used to check proof validity.\n   */\n  protected constructor(args: {\n    address?: AccountAddress;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n  }) {\n    super();\n    const {\n      address,\n      ephemeralKeyPair,\n      publicKey,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      proof,\n      proofFetchCallback,\n      jwt,\n      verificationKeyHash,\n    } = args;\n    this.ephemeralKeyPair = ephemeralKeyPair;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n    this.uidKey = uidKey;\n    this.uidVal = uidVal;\n    this.aud = aud;\n    this.jwt = jwt;\n    this.emitter = new EventEmitter<ProofFetchEvents>();\n    this.proofOrPromise = proof;\n    if (proof instanceof ZeroKnowledgeSig) {\n      this.proof = proof;\n    } else {\n      if (proofFetchCallback === undefined) {\n        throw new Error(\"Must provide callback for async proof fetch\");\n      }\n      this.emitter.on(\"proofFetchFinish\", async (status) => {\n        await proofFetchCallback(status);\n        this.emitter.removeAllListeners();\n      });\n      // Note, this is purposely not awaited to be non-blocking.  The caller should await on the proofFetchCallback.\n      this.init(proof);\n    }\n    const pepperBytes = Hex.fromHexInput(pepper).toUint8Array();\n    if (pepperBytes.length !== AbstractKeylessAccount.PEPPER_LENGTH) {\n      throw new Error(`Pepper length in bytes should be ${AbstractKeylessAccount.PEPPER_LENGTH}`);\n    }\n    this.pepper = pepperBytes;\n    if (verificationKeyHash !== undefined) {\n      if (Hex.hexInputToUint8Array(verificationKeyHash).length !== 32) {\n        throw new Error(\"verificationKeyHash must be 32 bytes\");\n      }\n      this.verificationKeyHash = Hex.hexInputToUint8Array(verificationKeyHash);\n    }\n  }\n\n  getAnyPublicKey(): AnyPublicKey {\n    return new AnyPublicKey(this.publicKey);\n  }\n\n  /**\n   * This initializes the asynchronous proof fetch\n   * @return Emits whether the proof succeeds or fails, but has no return.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async init(promise: Promise<ZeroKnowledgeSig>) {\n    try {\n      this.proof = await promise;\n      this.emitter.emit(\"proofFetchFinish\", { status: \"Success\" });\n    } catch (error) {\n      if (error instanceof Error) {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: error.toString() });\n      } else {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: \"Unknown\" });\n      }\n    }\n  }\n\n  /**\n   * Serializes the jwt data into a format suitable for transmission or storage.\n   * This function ensures that both the jwt data and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the jwt data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    this.accountAddress.serialize(serializer);\n    serializer.serializeStr(this.jwt);\n    serializer.serializeStr(this.uidKey);\n    serializer.serializeFixedBytes(this.pepper);\n    this.ephemeralKeyPair.serialize(serializer);\n    if (this.proof === undefined) {\n      throw new Error(\"Cannot serialize - proof undefined\");\n    }\n    this.proof.serialize(serializer);\n    serializer.serializeOption(this.verificationKeyHash, 32);\n  }\n\n  static partialDeserialize(deserializer: Deserializer): {\n    address: AccountAddress;\n    jwt: string;\n    uidKey: string;\n    pepper: Uint8Array;\n    ephemeralKeyPair: EphemeralKeyPair;\n    proof: ZeroKnowledgeSig;\n    verificationKeyHash?: Uint8Array;\n  } {\n    const address = AccountAddress.deserialize(deserializer);\n    const jwt = deserializer.deserializeStr();\n    const uidKey = deserializer.deserializeStr();\n    const pepper = deserializer.deserializeFixedBytes(31);\n    const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n    const proof = ZeroKnowledgeSig.deserialize(deserializer);\n    const verificationKeyHash = deserializer.deserializeOption(\"fixedBytes\", 32);\n\n    return { address, jwt, uidKey, pepper, ephemeralKeyPair, proof, verificationKeyHash };\n  }\n\n  /**\n   * Checks if the proof is expired.  If so the account must be re-derived with a new EphemeralKeyPair\n   * and JWT token.\n   * @return boolean\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  isExpired(): boolean {\n    return this.ephemeralKeyPair.isExpired();\n  }\n\n  /**\n   * Sign a message using Keyless.\n   * @param message the message to sign, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.sign(message));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Sign a transaction using Keyless.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.signTransaction(transaction));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Waits for asynchronous proof fetching to finish.\n   * @return\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async waitForProofFetch() {\n    if (this.proofOrPromise instanceof Promise) {\n      await this.proofOrPromise;\n    }\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    if (this.isExpired()) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED,\n      });\n    }\n    await this.waitForProofFetch();\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.ASYNC_PROOF_FETCH_FAILED,\n      });\n    }\n    const header = jwtDecode(this.jwt, { header: true });\n    if (header.kid === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.JWT_PARSING_ERROR,\n        details: \"checkKeylessAccountValidity failed. JWT is missing 'kid' in header. This should never happen.\",\n      });\n    }\n    if (this.verificationKeyHash !== undefined) {\n      const { verificationKey } = await getKeylessConfig({ aptosConfig });\n      if (Hex.hexInputToString(verificationKey.hash()) !== Hex.hexInputToString(this.verificationKeyHash)) {\n        throw KeylessError.fromErrorType({\n          type: KeylessErrorType.INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND,\n        });\n      }\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"[Aptos SDK] The verification key hash was not set. Proof may be invalid if the verification key has rotated.\",\n      );\n    }\n    await AbstractKeylessAccount.fetchJWK({ aptosConfig, publicKey: this.publicKey, kid: header.kid });\n  }\n\n  /**\n   * Sign the given message using Keyless.\n   * @param message in HexInput format\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): KeylessSignature {\n    const { expiryDateSecs } = this.ephemeralKeyPair;\n    if (this.isExpired()) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED,\n      });\n    }\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const ephemeralPublicKey = this.ephemeralKeyPair.getPublicKey();\n    const ephemeralSignature = this.ephemeralKeyPair.sign(message);\n\n    return new KeylessSignature({\n      jwtHeader: base64UrlDecode(this.jwt.split(\".\")[0]),\n      ephemeralCertificate: new EphemeralCertificate(this.proof, EphemeralCertificateVariant.ZkProof),\n      expiryDateSecs,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  /**\n   * Sign the given transaction with Keyless.\n   * Signs the transaction and proof to guard against proof malleability.\n   * @param transaction the transaction to be signed\n   * @returns KeylessSignature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): KeylessSignature {\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const raw = deriveTransactionType(transaction);\n    const txnAndProof = new TransactionAndProof(raw, this.proof.proof);\n    const signMess = txnAndProof.hash();\n    return this.sign(signMess);\n  }\n\n  getSigningMessage(transaction: AnyRawTransaction): Uint8Array {\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const raw = deriveTransactionType(transaction);\n    const txnAndProof = new TransactionAndProof(raw, this.proof.proof);\n    return txnAndProof.hash();\n  }\n\n  /**\n   * Note - This function is currently incomplete and should only be used to verify ownership of the KeylessAccount\n   *\n   * Verifies a signature given the message.\n   *\n   * @param args.message the message that was signed.\n   * @param args.signature the KeylessSignature to verify\n   * @returns boolean\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: {\n    message: HexInput;\n    signature: KeylessSignature;\n    jwk: MoveJWK;\n    keylessConfig: KeylessConfiguration;\n  }): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: KeylessSignature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n    });\n  }\n\n  /**\n   * Fetches the JWK from the issuer's well-known JWKS endpoint.\n   *\n   * @param args.publicKey The keyless public key to query\n   * @param args.kid The kid of the JWK to fetch\n   * @returns A JWK matching the `kid` in the JWT header.\n   * @throws {KeylessError} If the JWK cannot be fetched\n   */\n  static async fetchJWK(args: {\n    aptosConfig: AptosConfig;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    kid: string;\n  }): Promise<MoveJWK> {\n    return fetchJWK(args);\n  }\n}\n\n/**\n * A container class to hold a transaction and a proof.  It implements CryptoHashable which is used to create\n * the signing message for Keyless transactions.  We sign over the proof to ensure non-malleability.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class TransactionAndProof extends Serializable {\n  /**\n   * The transaction to sign.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  transaction: AnyRawTransactionInstance;\n\n  /**\n   * The zero knowledge proof used in signing the transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  proof?: ZkProof;\n\n  /**\n   * The domain separator prefix used when hashing.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly domainSeparator = \"APTOS::TransactionAndProof\";\n\n  constructor(transaction: AnyRawTransactionInstance, proof?: ZkProof) {\n    super();\n    this.transaction = transaction;\n    this.proof = proof;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.transaction.bcsToBytes());\n    serializer.serializeOption(this.proof);\n  }\n\n  /**\n   * Hashes the bcs serialized from of the class. This is the typescript corollary to the BCSCryptoHash macro in aptos-core.\n   *\n   * @returns Uint8Array\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  hash(): Uint8Array {\n    return generateSigningMessage(this.bcsToBytes(), this.domainSeparator);\n  }\n}\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchSuccess = {\n  status: \"Success\";\n};\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchFailure = {\n  status: \"Failed\";\n  error: string;\n};\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchStatus = ProofFetchSuccess | ProofFetchFailure;\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchCallback = (status: ProofFetchStatus) => Promise<void>;\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface ProofFetchEvents {\n  proofFetchFinish: (status: ProofFetchStatus) => void;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HexInput } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { getIssAudAndUidVal, Groth16VerificationKey, KeylessPublicKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\nimport { Hex } from \"../core/hex\";\n\n/**\n * Account implementation for the Keyless authentication scheme.\n *\n * Used to represent a Keyless based account and sign transactions with it.\n *\n * Use `KeylessAccount.create()` to instantiate a KeylessAccount with a JWT, proof and EphemeralKeyPair.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class KeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The KeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: KeylessPublicKey;\n\n  // Use the static constructor 'create' instead.\n\n  /**\n   * Use the static generator `create(...)` instead.\n   * Creates an instance of the KeylessAccount with an optional proof.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.iss - A JWT issuer.\n   * @param args.uidKey - The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @param args.uidVal - The unique id for this user, intended to be a stable user identifier.\n   * @param args.aud - The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n  }) {\n    const publicKey = KeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  serialize(serializer: Serializer): void {\n    super.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static deserialize(deserializer: Deserializer): KeylessAccount {\n    const { address, proof, ephemeralKeyPair, jwt, uidKey, pepper, verificationKeyHash } =\n      AbstractKeylessAccount.partialDeserialize(deserializer);\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      verificationKeyHash,\n    });\n  }\n\n  /**\n   * Deserialize bytes using this account's information.\n   *\n   * @param bytes The bytes being interpreted.\n   * @returns\n   */\n  static fromBytes(bytes: HexInput): KeylessAccount {\n    return KeylessAccount.deserialize(new Deserializer(Hex.hexInputToUint8Array(bytes)));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   * This is used instead of the KeylessAccount constructor.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n    verificationKey?: Groth16VerificationKey;\n    verificationKeyHash?: Uint8Array;\n  }): KeylessAccount {\n    const {\n      address,\n      proof,\n      jwt,\n      ephemeralKeyPair,\n      pepper,\n      uidKey = \"sub\",\n      proofFetchCallback,\n      verificationKey,\n      verificationKeyHash,\n    } = args;\n\n    if (verificationKeyHash && verificationKey) {\n      throw new Error(\"Cannot provide both verificationKey and verificationKeyHash\");\n    }\n\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      proofFetchCallback,\n      verificationKeyHash: verificationKeyHash ?? (verificationKey ? verificationKey.hash() : undefined),\n    });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HexInput } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { getIssAudAndUidVal, Groth16VerificationKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\n\n/**\n * Account implementation for the FederatedKeyless authentication scheme.\n *\n * Used to represent a FederatedKeyless based account and sign transactions with it.\n *\n * Use `FederatedKeylessAccount.create()` to instantiate a KeylessAccount with a JSON Web Token (JWT), proof, EphemeralKeyPair and the\n * address the JSON Web Key Set (JWKS) are installed that will be used to verify the JWT.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class FederatedKeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The FederatedKeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: FederatedKeylessPublicKey;\n\n  readonly audless: boolean;\n\n  /**\n   * Use the static generator `FederatedKeylessAccount.create(...)` instead.\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.jwkAddress - The address which stores the JSON Web Key Set (JWKS) used to verify the JWT.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n    audless?: boolean;\n  }) {\n    const publicKey = FederatedKeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n    this.audless = args.audless ?? false;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    super.serialize(serializer);\n    this.publicKey.jwkAddress.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   */\n  static deserialize(deserializer: Deserializer): FederatedKeylessAccount {\n    const { address, proof, ephemeralKeyPair, jwt, uidKey, pepper, verificationKeyHash } =\n      AbstractKeylessAccount.partialDeserialize(deserializer);\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwt,\n      verificationKeyHash,\n      jwkAddress,\n    });\n  }\n\n  /**\n   * Deserialize bytes using this account's information.\n   *\n   * @param bytes The bytes being interpreted.\n   * @returns\n   */\n  static fromBytes(bytes: HexInput): FederatedKeylessAccount {\n    return FederatedKeylessAccount.deserialize(Deserializer.fromHex(bytes));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   * This is used instead of the KeylessAccount constructor.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.jwkAddress - The address which stores the JSON Web Key Set (JWKS) used to verify the JWT.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n    verificationKey?: Groth16VerificationKey;\n    verificationKeyHash?: Uint8Array;\n  }): FederatedKeylessAccount {\n    const {\n      address,\n      proof,\n      jwt,\n      ephemeralKeyPair,\n      pepper,\n      jwkAddress,\n      uidKey = \"sub\",\n      proofFetchCallback,\n      verificationKey,\n      verificationKeyHash,\n    } = args;\n\n    if (verificationKeyHash && verificationKey) {\n      throw new Error(\"Cannot provide both verificationKey and verificationKeyHash\");\n    }\n\n    const { iss, aud, uidVal } = getIssAudAndUidVal({ jwt, uidKey });\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      jwkAddress: AccountAddress.from(jwkAddress),\n      jwt,\n      proofFetchCallback,\n      verificationKeyHash: verificationKeyHash ?? (verificationKey ? verificationKey.hash() : undefined),\n    });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Account } from \"./Account\";\nimport { MultiKey, MultiKeySignature, PublicKey } from \"../core/crypto\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAuthenticatorMultiKey } from \"../transactions/authenticator/account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { AbstractKeylessAccount, KeylessSigner } from \"./AbstractKeylessAccount\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { SingleKeyAccount, SingleKeySigner, SingleKeySignerOrLegacyEd25519Account } from \"./SingleKeyAccount\";\nimport { Ed25519Account } from \"./Ed25519Account\";\n\n/**\n * Arguments required to verify a multi-key signature against a given message.\n *\n * @param message - The original message that was signed.\n * @param signature - The multi-key signature to be verified.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface VerifyMultiKeySignatureArgs {\n  message: HexInput;\n  signature: MultiKeySignature;\n}\n\n/**\n * Signer implementation for the MultiKey authentication scheme.\n *\n * This account utilizes an M of N signing scheme, where M and N are specified in the {@link MultiKey}.\n * It signs messages using an array of M accounts, each corresponding to a public key in the {@link MultiKey}.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class MultiKeyAccount implements Account, KeylessSigner {\n  /**\n   * Public key associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: MultiKey;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signingScheme: SigningScheme = SigningScheme.MultiKey;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiKeyAccount's public key.  The number of signers should be equal to this.publicKey.signaturesRequired.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signers: Account[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  // TODO: Rename Indicies to Indices\n  readonly signerIndicies: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  /**\n   * Constructs a MultiKeyAccount instance, which requires multiple signatures for transactions.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.multiKey - The multikey of the account consisting of N public keys and a number M representing the required signatures.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @param args.address - An optional account address input. If not provided, the derived address from the public key will be used.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  constructor(args: {\n    multiKey: MultiKey;\n    signers: SingleKeySignerOrLegacyEd25519Account[];\n    address?: AccountAddressInput;\n  }) {\n    const { multiKey, address } = args;\n\n    const signers: SingleKeySigner[] = args.signers.map((signer) =>\n      signer instanceof Ed25519Account ? SingleKeyAccount.fromEd25519Account(signer) : signer,\n    );\n\n    if (multiKey.signaturesRequired > signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `Not enough signers provided to satisfy the required signatures. Need ${multiKey.signaturesRequired} signers, but only ${signers.length} provided`,\n      );\n    } else if (multiKey.signaturesRequired < signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `More signers provided than required. Need ${multiKey.signaturesRequired} signers, but ${signers.length} provided`,\n      );\n    }\n\n    this.publicKey = multiKey;\n\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    // For each signer, find its corresponding position in the MultiKey's public keys array\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.getAnyPublicKey()));\n    }\n\n    // Create pairs of [signer, position] and sort them by position\n    // This sorting is critical because:\n    // 1. The on-chain verification expects signatures to be in ascending order by bit position\n    // 2. The bitmap must match the order of signatures when verifying\n    const signersAndBitPosition: [Account, number][] = signers.map((signer, index) => [signer, bitPositions[index]]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n\n    // Extract the sorted signers and their positions into separate arrays\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndicies = signersAndBitPosition.map((value) => value[1]);\n\n    // Create a bitmap representing which public keys from the MultiKey are being used\n    // This bitmap is used during signature verification to identify which public keys\n    // should be used to verify each signature\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  /**\n   * Static constructor to create a MultiKeyAccount using the provided public keys and signers.\n   *\n   * @param args - The arguments for creating a MultiKeyAccount.\n   * @param args.publicKeys - The N public keys of the MultiKeyAccount.\n   * @param args.signaturesRequired - The number of signatures required to authorize a transaction.\n   * @param args.signers - An array of M signers that will be used to sign the transaction.\n   * @returns MultiKeyAccount - The newly created MultiKeyAccount.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static fromPublicKeysAndSigners(args: {\n    address?: AccountAddressInput;\n    publicKeys: PublicKey[];\n    signaturesRequired: number;\n    signers: SingleKeySignerOrLegacyEd25519Account[];\n  }): MultiKeyAccount {\n    const { address, publicKeys, signaturesRequired, signers } = args;\n    const multiKey = new MultiKey({ publicKeys, signaturesRequired });\n    return new MultiKeyAccount({ multiKey, signers, address });\n  }\n\n  /**\n   * Determines if the provided account is a multi-key account.\n   *\n   * @param account - The account to check.\n   * @returns A boolean indicating whether the account is a multi-key account.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  static isMultiKeySigner(account: Account): account is MultiKeyAccount {\n    return account instanceof MultiKeyAccount;\n  }\n\n  /**\n   * Sign a message using the account's signers and return an AccountAuthenticator containing the signature along with the\n   * account's public key.\n   * @param message - The signing message, represented as binary input in hexadecimal format.\n   * @returns An instance of AccountAuthenticatorMultiKey that includes the signature and the public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's signers, returning an AccountAuthenticator that contains the signature and the\n   * account's public key.\n   * @param transaction - The raw transaction to be signed.\n   * @returns An AccountAuthenticatorMultiKey containing the signature of the transaction along with the account's public key.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiKey {\n    return new AccountAuthenticatorMultiKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Waits for any proofs on KeylessAccount signers to be fetched. This ensures that signing with the KeylessAccount does not\n   * fail due to missing proofs.\n   * @return {Promise<void>} A promise that resolves when all proofs have been fetched.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async waitForProofFetch(): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map(async (signer) => signer.waitForProofFetch());\n    await Promise.all(promises);\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    const keylessSigners = this.signers.filter(\n      (signer) => signer instanceof AbstractKeylessAccount,\n    ) as AbstractKeylessAccount[];\n    const promises = keylessSigners.map((signer) => signer.checkKeylessAccountValidity(aptosConfig));\n    await Promise.all(promises);\n  }\n\n  /**\n   * Sign the given message using the MultiKeyAccount's signers\n   * @param data - The data to be signed in HexInput format.\n   * @returns MultiKeySignature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(data: HexInput): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(data));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the MultiKeyAccount's signers.\n   * This function aggregates signatures from all signers associated with the MultiKeyAccount.\n   *\n   * @param transaction - The transaction to be signed.\n   * @returns MultiKeySignature - An object containing the aggregated signatures and a bitmap of the signatures.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.signTransaction(transaction));\n    }\n    return new MultiKeySignature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Verify the given message and signature with the public keys.\n   *\n   * This function checks if the provided signatures are valid for the given message using the corresponding public keys.\n   * Note: If you are using KeylessAccounts, you must use `verifySignatureAsync` instead.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message MultiKeySignature containing multiple signatures.\n   * @returns A boolean indicating whether the signatures are valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: { message: HexInput; signature: MultiKeySignature }): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public keys.\n   *\n   * This function checks if the provided signatures are valid for the given message using the corresponding public keys.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The raw message data in HexInput format.\n   * @param args.signature - The signed message MultiKeySignature containing multiple signatures.\n   * @param args.options.throwErrorWithReason - Whether to throw an error with the reason for the verification failure.\n   * @returns A boolean indicating whether the signatures are valid for the message.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: MultiKeySignature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return await this.publicKey.verifySignatureAsync(args);\n  }\n}\n", "import { AptosConfig } from \"../api\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Ed25519PrivateKey, Signature } from \"../core/crypto\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../core/crypto/multiEd25519\";\nimport { AccountAuthenticatorMultiEd25519 } from \"../transactions/authenticator/account\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport type { Account } from \"./Account\";\n\nexport interface MultiEd25519SignerConstructorArgs {\n  publicKey: MultiEd25519PublicKey;\n  signers: Ed25519PrivateKey[];\n  address?: AccountAddressInput;\n}\n\nexport interface VerifyMultiEd25519SignatureArgs {\n  message: HexInput;\n  signature: MultiEd25519Signature;\n}\n\n/**\n * Signer implementation for the Multi-Ed25519 authentication scheme.\n *\n * Note: This authentication scheme is a legacy authentication scheme.  Prefer using MultiKeyAccounts as a\n * MultiKeyAccount can support any type of signer, not just Ed25519.  Generating a signer instance does not\n * create the account on-chain.\n */\nexport class MultiEd25519Account implements Account {\n  readonly publicKey: MultiEd25519PublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.MultiEd25519;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiEd25519Account.  The number of signers should be equal to this.publicKey.threshold.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signers: Ed25519PrivateKey[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signerIndices: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  // region Constructors\n\n  constructor(args: MultiEd25519SignerConstructorArgs) {\n    const { signers, publicKey, address } = args;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    if (publicKey.threshold > signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `Not enough signers provided to satisfy the required signatures. Need ${publicKey.threshold} signers, but only ${signers.length} provided`,\n      );\n    } else if (publicKey.threshold < signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `More signers provided than required. Need ${publicKey.threshold} signers, but ${signers.length} provided`,\n      );\n    }\n\n    // For each signer, find its corresponding position in the public keys array\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.publicKey()));\n    }\n\n    // Create pairs of [signer, position] and sort them by position\n    // This sorting is critical because:\n    // 1. The on-chain verification expects signatures to be in ascending order by bit position\n    // 2. The bitmap must match the order of signatures when verifying\n    const signersAndBitPosition: [Ed25519PrivateKey, number][] = signers.map((signer, index) => [\n      signer,\n      bitPositions[index],\n    ]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n\n    // Extract the sorted signers and their positions into separate arrays\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndices = signersAndBitPosition.map((value) => value[1]);\n\n    // Create a bitmap representing which public keys from the MultiEd25519PublicKey are being used\n    // This bitmap is used during signature verification to identify which public keys\n    // should be used to verify each signature\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  // endregion\n\n  // region Account\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signature signed message Signature\n   * @returns\n   */\n  verifySignature(args: VerifyMultiEd25519SignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * MultiEd25519 signatures do not depend on chain state, so this function is\n   * equivalent to the synchronous verifySignature method.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - Raw message data in HexInput format.\n   * @param args.signature - Signed message signature.\n   * @returns A boolean indicating whether the signature is valid.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Signature;\n    options?: { throwErrorWithReason?: boolean };\n  }): Promise<boolean> {\n    return this.publicKey.verifySignatureAsync({\n      ...args,\n      signature: args.signature,\n    });\n  }\n\n  /**\n   * Sign a message using the account's Ed25519 private key.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiEd25519 {\n    return new AccountAuthenticatorMultiEd25519(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's Ed25519 private keys.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiEd25519 {\n    return new AccountAuthenticatorMultiEd25519(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's Ed25519 private keys.\n   * @param message in HexInput format\n   * @returns MultiEd25519Signature\n   */\n  sign(message: HexInput): MultiEd25519Signature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(message));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * @param transaction the transaction to be signed\n   * @returns Signature\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiEd25519Signature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n}\n", "import { SigningScheme } from \"../types\";\nimport { AccountAddress } from \"../core\";\nimport { Deserializer } from \"../bcs/deserializer\";\n\nexport function deserializeSchemeAndAddress(deserializer: Deserializer): {\n  address: AccountAddress;\n  signingScheme: SigningScheme;\n} {\n  const signingScheme = deserializer.deserializeUleb128AsU32();\n  // Validate that signingScheme is a valid SigningScheme value\n  if (!Object.values(SigningScheme).includes(signingScheme)) {\n    throw new Error(`Deserialization of Account failed: SigningScheme variant ${signingScheme} is invalid`);\n  }\n  const address = AccountAddress.deserialize(deserializer);\n  return { address, signingScheme };\n}\n", "import { Deserializer, Serializer } from \"../bcs\";\nimport { AnyPublicKeyVariant, HexInput, SigningScheme } from \"../types\";\nimport { MultiKeyAccount } from \"./MultiKeyAccount\";\nimport { Account } from \"./Account\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { isSingleKeySigner, SingleKeyAccount, SingleKeySignerOrLegacyEd25519Account } from \"./SingleKeyAccount\";\nimport { KeylessAccount } from \"./KeylessAccount\";\nimport { FederatedKeylessAccount } from \"./FederatedKeylessAccount\";\nimport { AbstractKeylessAccount } from \"./AbstractKeylessAccount\";\nimport {\n  AccountAddress,\n  Ed25519PrivateKey,\n  getIssAudAndUidVal,\n  Hex,\n  MultiKey,\n  Secp256k1PrivateKey,\n  ZeroKnowledgeSig,\n} from \"../core\";\nimport { deserializeSchemeAndAddress } from \"./utils\";\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\n\nfunction serializeKeylessAccountCommon(account: AbstractKeylessAccount, serializer: Serializer): void {\n  serializer.serializeStr(account.jwt);\n  serializer.serializeStr(account.uidKey);\n  serializer.serializeFixedBytes(account.pepper);\n  account.ephemeralKeyPair.serialize(serializer);\n  if (account.proof === undefined) {\n    throw new Error(\"Cannot serialize - proof undefined\");\n  }\n  account.proof.serialize(serializer);\n  serializer.serializeOption(account.verificationKeyHash, 32);\n}\n\nfunction deserializeKeylessAccountCommon(deserializer: Deserializer): {\n  jwt: string;\n  uidKey: string;\n  pepper: Uint8Array;\n  ephemeralKeyPair: EphemeralKeyPair;\n  proof: ZeroKnowledgeSig;\n  verificationKeyHash?: Uint8Array;\n} {\n  const jwt = deserializer.deserializeStr();\n  const uidKey = deserializer.deserializeStr();\n  const pepper = deserializer.deserializeFixedBytes(31);\n  const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n  const proof = ZeroKnowledgeSig.deserialize(deserializer);\n  const verificationKeyHash = deserializer.deserializeOption(\"fixedBytes\", 32);\n  return { jwt, uidKey, pepper, ephemeralKeyPair, proof, verificationKeyHash };\n}\n\n/**\n * Utility functions for working with accounts.\n */\nexport namespace AccountUtils {\n  export function toBytes(account: Account): Uint8Array {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(account.signingScheme);\n    account.accountAddress.serialize(serializer);\n    switch (account.signingScheme) {\n      case SigningScheme.Ed25519:\n        (account as Ed25519Account).privateKey.serialize(serializer);\n        return serializer.toUint8Array();\n      case SigningScheme.SingleKey: {\n        if (!isSingleKeySigner(account)) {\n          throw new Error(\"Account is not a SingleKeySigner\");\n        }\n        const anyPublicKey = account.getAnyPublicKey();\n        serializer.serializeU32AsUleb128(anyPublicKey.variant);\n        switch (anyPublicKey.variant) {\n          case AnyPublicKeyVariant.Keyless: {\n            const keylessAccount = account as KeylessAccount;\n            serializeKeylessAccountCommon(keylessAccount, serializer);\n            return serializer.toUint8Array();\n          }\n          case AnyPublicKeyVariant.FederatedKeyless: {\n            const federatedKeylessAccount = account as FederatedKeylessAccount;\n            serializeKeylessAccountCommon(federatedKeylessAccount, serializer);\n            federatedKeylessAccount.publicKey.jwkAddress.serialize(serializer);\n            serializer.serializeBool(federatedKeylessAccount.audless);\n            return serializer.toUint8Array();\n          }\n          case AnyPublicKeyVariant.Secp256k1:\n          case AnyPublicKeyVariant.Ed25519: {\n            const singleKeyAccount = account as SingleKeyAccount;\n            singleKeyAccount.privateKey.serialize(serializer);\n            return serializer.toUint8Array();\n          }\n          default: {\n            throw new Error(`Invalid public key variant: ${anyPublicKey.variant}`);\n          }\n        }\n      }\n      case SigningScheme.MultiKey: {\n        const multiKeyAccount = account as MultiKeyAccount;\n        multiKeyAccount.publicKey.serialize(serializer);\n        serializer.serializeU32AsUleb128(multiKeyAccount.signers.length);\n        multiKeyAccount.signers.forEach((signer) => {\n          serializer.serializeFixedBytes(toBytes(signer));\n        });\n        return serializer.toUint8Array();\n      }\n      default:\n        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${account.signingScheme}`);\n    }\n  }\n\n  export function toHexStringWithoutPrefix(account: Account): string {\n    return Hex.hexInputToStringWithoutPrefix(toBytes(account));\n  }\n\n  export function toHexString(account: Account): string {\n    return Hex.hexInputToString(toBytes(account));\n  }\n\n  export function deserialize(deserializer: Deserializer): Account {\n    const { address, signingScheme } = deserializeSchemeAndAddress(deserializer);\n    switch (signingScheme) {\n      case SigningScheme.Ed25519: {\n        const privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        return new Ed25519Account({ privateKey, address });\n      }\n      case SigningScheme.SingleKey: {\n        const variantIndex = deserializer.deserializeUleb128AsU32();\n        switch (variantIndex) {\n          case AnyPublicKeyVariant.Ed25519: {\n            const privateKey = Ed25519PrivateKey.deserialize(deserializer);\n            return new SingleKeyAccount({ privateKey, address });\n          }\n          case AnyPublicKeyVariant.Secp256k1: {\n            const privateKey = Secp256k1PrivateKey.deserialize(deserializer);\n            return new SingleKeyAccount({ privateKey, address });\n          }\n          case AnyPublicKeyVariant.Keyless: {\n            const keylessComponents = deserializeKeylessAccountCommon(deserializer);\n            const jwtClaims = getIssAudAndUidVal(keylessComponents);\n            return new KeylessAccount({ ...keylessComponents, ...jwtClaims });\n          }\n          case AnyPublicKeyVariant.FederatedKeyless: {\n            const keylessComponents = deserializeKeylessAccountCommon(deserializer);\n            const jwkAddress = AccountAddress.deserialize(deserializer);\n            const audless = deserializer.deserializeBool();\n            const jwtClaims = getIssAudAndUidVal(keylessComponents);\n            return new FederatedKeylessAccount({ ...keylessComponents, ...jwtClaims, jwkAddress, audless });\n          }\n          default:\n            throw new Error(`Unsupported public key variant ${variantIndex}`);\n        }\n      }\n      case SigningScheme.MultiKey: {\n        const multiKey = MultiKey.deserialize(deserializer);\n        const length = deserializer.deserializeUleb128AsU32();\n        const signers = new Array<SingleKeySignerOrLegacyEd25519Account>();\n        for (let i = 0; i < length; i += 1) {\n          const signer = deserialize(deserializer);\n          if (!isSingleKeySigner(signer) && !(signer instanceof Ed25519Account)) {\n            throw new Error(\n              \"Deserialization of MultiKeyAccount failed. Signer is not a SingleKeySigner or Ed25519Account\",\n            );\n          }\n          signers.push(signer);\n        }\n        return new MultiKeyAccount({ multiKey, signers, address });\n      }\n      default:\n        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${signingScheme}`);\n    }\n  }\n\n  export function keylessAccountFromHex(hex: HexInput): KeylessAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof KeylessAccount)) {\n      throw new Error(\"Deserialization of KeylessAccount failed\");\n    }\n    return account;\n  }\n\n  export function federatedKeylessAccountFromHex(hex: HexInput): FederatedKeylessAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof FederatedKeylessAccount)) {\n      throw new Error(\"Deserialization of FederatedKeylessAccount failed\");\n    }\n    return account;\n  }\n\n  export function multiKeyAccountFromHex(hex: HexInput): MultiKeyAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof MultiKeyAccount)) {\n      throw new Error(\"Deserialization of MultiKeyAccount failed\");\n    }\n    return account;\n  }\n\n  export function singleKeyAccountFromHex(hex: HexInput): SingleKeyAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof SingleKeyAccount)) {\n      throw new Error(\"Deserialization of SingleKeyAccount failed\");\n    }\n    return account;\n  }\n\n  export function ed25519AccountFromHex(hex: HexInput): Ed25519Account {\n    const account = fromHex(hex);\n    if (!(account instanceof Ed25519Account)) {\n      throw new Error(\"Deserialization of Ed25519Account failed\");\n    }\n    return account;\n  }\n\n  export function fromHex(hex: HexInput): Account {\n    return deserialize(Deserializer.fromHex(hex));\n  }\n\n  export function fromBytes(bytes: Uint8Array): Account {\n    return fromHex(bytes);\n  }\n}\n", "import { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"../core\";\nimport { AbstractPublicKey, AbstractSignature } from \"../core/crypto/abstraction\";\nimport { SigningScheme, HexInput } from \"../types\";\nimport { Account } from \"./Account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AccountAuthenticatorAbstraction } from \"../transactions/authenticator/account\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { Serializer } from \"../bcs/serializer\";\nimport { isValidFunctionInfo } from \"../utils/helpers\";\n\ntype AbstractedAccountConstructorArgs = {\n  /**\n   * The account address of the account.\n   */\n  accountAddress: AccountAddress;\n  /**\n   * The signer function signs transactions and returns the `authenticator` bytes in the `AbstractionAuthData`.\n   *\n   * @param digest - The SHA256 hash of the transaction signing message\n   * @returns The `authenticator` bytes that can be used to verify the signature.\n   */\n  signer: (digest: HexInput) => Uint8Array;\n  /**\n   * The authentication function that will be used to verify the signature.\n   *\n   * @example\n   * ```ts\n   * const authenticationFunction = `${accountAddress}::permissioned_delegation::authenticate`;\n   * ```\n   */\n  authenticationFunction: string;\n};\n\nexport class AbstractedAccount extends Account {\n  public readonly publicKey: AbstractPublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly authenticationFunction: string;\n\n  readonly signingScheme = SigningScheme.SingleKey;\n\n  constructor({ signer, accountAddress, authenticationFunction }: AbstractedAccountConstructorArgs) {\n    super();\n\n    if (!isValidFunctionInfo(authenticationFunction)) {\n      throw new Error(`Invalid authentication function ${authenticationFunction} passed into AbstractedAccount`);\n    }\n\n    this.authenticationFunction = authenticationFunction;\n    this.accountAddress = accountAddress;\n    this.publicKey = new AbstractPublicKey(this.accountAddress);\n    this.sign = (digest: HexInput) => new AbstractSignature(signer(digest));\n  }\n\n  /**\n   * Creates an `AbstractedAccount` from an `Ed25519Account` that has a permissioned signer function and\n   * using the `0x1::permissioned_delegation::authenticate` function to verify the signature.\n   *\n   * @param signer - The `Ed25519Account` that can be used to sign permissioned transactions.\n   * @returns The `AbstractedAccount`\n   */\n  public static fromPermissionedSigner({\n    signer,\n    accountAddress,\n  }: {\n    signer: Ed25519Account;\n    accountAddress?: AccountAddress;\n  }) {\n    return new AbstractedAccount({\n      signer: (digest: HexInput) => {\n        const serializer = new Serializer();\n        signer.publicKey.serialize(serializer);\n        signer.sign(digest).serialize(serializer);\n        return serializer.toUint8Array();\n      },\n      accountAddress: accountAddress ?? signer.accountAddress,\n      authenticationFunction: \"0x1::permissioned_delegation::authenticate\",\n    });\n  }\n\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorAbstraction {\n    return new AccountAuthenticatorAbstraction(\n      this.authenticationFunction,\n      sha3_256(message),\n      this.sign(sha3_256(message)).toUint8Array(),\n    );\n  }\n\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorAbstraction {\n    return this.signWithAuthenticator(generateSigningMessageForTransaction(transaction));\n  }\n\n  sign: (message: HexInput) => AbstractSignature;\n\n  signTransaction(transaction: AnyRawTransaction): AbstractSignature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  /**\n   * Update the signer function for the account. This can be done after asynchronous operations are complete\n   * to update the context of the signer function.\n   *\n   * @param signer - The new signer function to use for the account.\n   */\n  public setSigner(signer: (digest: HexInput) => HexInput): void {\n    this.sign = (digest: HexInput) => new AbstractSignature(signer(digest));\n  }\n}\n", "import { sha3_256 } from \"@noble/hashes/sha3\";\nimport { Serializer } from \"../bcs/serializer\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { AccountAuthenticatorAbstraction } from \"../transactions/authenticator/account\";\nimport { HexInput } from \"../types\";\nimport { isValidFunctionInfo } from \"../utils/helpers\";\nimport { AbstractedAccount } from \"./AbstractedAccount\";\n\ntype DerivableAbstractedAccountArgs = {\n  /**\n   * The signer function signs transactions and returns the `authenticator` bytes in the `AbstractionAuthData`.\n   *\n   * @param digest - The SHA256 hash of the transaction signing message\n   * @returns The `authenticator` bytes that can be used to verify the signature.\n   */\n  signer: (digest: HexInput) => Uint8Array;\n\n  /**\n   * The authentication function that will be used to verify the signature.\n   *\n   * @example\n   * ```ts\n   * const authenticationFunction = `${accountAddress}::permissioned_delegation::authenticate`;\n   * ```\n   */\n  authenticationFunction: string;\n\n  /**\n   * The abstract public key that is used to identify the account.\n   * Depends on the use cases, most of the time it is the public key of the source wallet\n   */\n  abstractPublicKey: Uint8Array;\n};\n\nexport class DerivableAbstractedAccount extends AbstractedAccount {\n  /**\n   * The abstract public key that is used to identify the account.\n   * Depends on the use cases, most of the time it is the public key of the source wallet\n   */\n  readonly abstractPublicKey: Uint8Array;\n\n  /**\n   * The domain separator used to calculate the DAA account address.\n   */\n  static readonly ADDRESS_DOMAIN_SEPERATOR: number = 5;\n\n  constructor({ signer, authenticationFunction, abstractPublicKey }: DerivableAbstractedAccountArgs) {\n    const daaAccountAddress = new AccountAddress(\n      DerivableAbstractedAccount.computeAccountAddress(authenticationFunction, abstractPublicKey),\n    );\n    super({\n      accountAddress: daaAccountAddress,\n      signer,\n      authenticationFunction,\n    });\n    this.abstractPublicKey = abstractPublicKey;\n  }\n\n  /**\n   * Compute the account address of the DAA\n   * The DAA account address is computed by hashing the function info and the account identity\n   * and appending the domain separator (5)\n   *\n   * @param functionInfo - The authentication function\n   * @param accountIdentifier - The account identity\n   * @returns The account address\n   */\n  static computeAccountAddress(functionInfo: string, accountIdentifier: Uint8Array): Uint8Array {\n    if (!isValidFunctionInfo(functionInfo)) {\n      throw new Error(`Invalid authentication function ${functionInfo} passed into DerivableAbstractedAccount`);\n    }\n    const [moduleAddress, moduleName, functionName] = functionInfo.split(\"::\");\n\n    const hash = sha3_256.create();\n    // Serialize and append the function info\n    const serializer = new Serializer();\n    AccountAddress.fromString(moduleAddress).serialize(serializer);\n    serializer.serializeStr(moduleName);\n    serializer.serializeStr(functionName);\n    hash.update(serializer.toUint8Array());\n\n    // Serialize and append the account identity\n    const s2 = new Serializer();\n    s2.serializeBytes(accountIdentifier);\n    hash.update(s2.toUint8Array());\n\n    // Append the domain separator\n    hash.update(new Uint8Array([DerivableAbstractedAccount.ADDRESS_DOMAIN_SEPERATOR]));\n\n    return hash.digest();\n  }\n\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorAbstraction {\n    return new AccountAuthenticatorAbstraction(\n      this.authenticationFunction,\n      sha3_256(message),\n      this.sign(sha3_256(message)).value,\n      this.abstractPublicKey,\n    );\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the transaction creation lifecycle.\n * It holds different operations to generate a transaction payload, a raw transaction,\n * and a signed transaction that can be simulated, signed and submitted to chain.\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput, Hex, PublicKey } from \"../../core\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  Secp256k1PublicKey,\n  FederatedKeylessPublicKey,\n  MultiKey,\n  MultiKeySignature,\n} from \"../../core/crypto\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { getInfo } from \"../../internal/utils\";\nimport { getLedgerInfo } from \"../../internal/general\";\nimport { getGasPriceEstimation } from \"../../internal/transaction\";\nimport { NetworkToChainId } from \"../../utils/apiEndpoints\";\nimport { normalizeBundle } from \"../../utils/normalizeBundle\";\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  AccountAuthenticatorMultiEd25519,\n  AccountAuthenticatorMultiKey,\n  AccountAuthenticatorNoAccountAuthenticator,\n  AccountAuthenticatorSingleKey,\n} from \"../authenticator/account\";\nimport {\n  TransactionAuthenticator,\n  TransactionAuthenticatorEd25519,\n  TransactionAuthenticatorFeePayer,\n  TransactionAuthenticatorMultiAgent,\n  TransactionAuthenticatorMultiEd25519,\n  TransactionAuthenticatorSingleSender,\n} from \"../authenticator/transaction\";\nimport {\n  ChainId,\n  EntryFunction,\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  RawTransaction,\n  Script,\n  TransactionInnerPayload,\n  TransactionPayloadEntryFunction,\n  TransactionPayloadMultiSig,\n  TransactionPayloadScript,\n} from \"../instances\";\nimport { SignedTransaction } from \"../instances/signedTransaction\";\nimport {\n  AnyRawTransaction,\n  AnyTransactionPayloadInstance,\n  EntryFunctionArgumentTypes,\n  InputGenerateMultiAgentRawTransactionArgs,\n  InputGenerateRawTransactionArgs,\n  InputGenerateSingleSignerRawTransactionArgs,\n  InputGenerateTransactionOptions,\n  InputScriptData,\n  InputSimulateTransactionData,\n  InputMultiSigDataWithRemoteABI,\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateTransactionPayloadDataWithABI,\n  InputEntryFunctionDataWithABI,\n  InputMultiSigDataWithABI,\n  InputViewFunctionDataWithRemoteABI,\n  InputViewFunctionDataWithABI,\n  FunctionABI,\n} from \"../types\";\nimport { convertArgument, fetchEntryFunctionAbi, fetchViewFunctionAbi, standardizeTypeTags } from \"./remoteAbi\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { isScriptDataInput } from \"./helpers\";\nimport { SimpleTransaction } from \"../instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../instances/multiAgentTransaction\";\nimport { getFunctionParts } from \"../../utils/helpers\";\nimport {\n  TransactionExecutable,\n  TransactionExecutableEmpty,\n  TransactionExecutableEntryFunction,\n  TransactionExecutableScript,\n  TransactionExtraConfigV1,\n  TransactionInnerPayloadV1,\n} from \"../instances/transactionPayload\";\n\n/**\n * Builds a transaction payload based on the provided arguments and returns a transaction payload.\n * This function uses the RemoteABI by default, but can also utilize a specified ABI.\n * When we call our `generateTransactionPayload` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @param args - The input data for generating the transaction payload.\n * @param args.function - The function to be called, specified in the format \"moduleAddress::moduleName::functionName\".\n * @param args.functionArguments - The arguments to pass to the function.\n * @param args.typeArguments - The type arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.abi - The ABI to use for the transaction, if not using the RemoteABI.\n *\n * @returns TransactionPayload - The generated transaction payload, which can be of type TransactionPayloadScript,\n * TransactionPayloadMultiSig, or TransactionPayloadEntryFunction.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(args: InputScriptData): Promise<TransactionPayloadScript>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputEntryFunctionDataWithRemoteABI,\n): Promise<TransactionPayloadEntryFunction>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputMultiSigDataWithRemoteABI,\n): Promise<TransactionPayloadMultiSig>;\n\n/**\n * Builds a transaction payload based on the data argument and returns\n * a transaction payload - TransactionPayloadScript | TransactionPayloadMultiSig | TransactionPayloadEntryFunction\n *\n * This uses the RemoteABI by default, and the remote ABI can be skipped by using generateTransactionPayloadWithABI\n *\n * @param args.data GenerateTransactionPayloadData\n *\n * @return TransactionPayload\n * @group Implementation\n * @category Transactions\n */\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance> {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"entry-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchEntryFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateTransactionPayloadWithABI({ ...args, abi: functionAbi });\n}\n\n/**\n * Generates a transaction payload using the provided ABI and function details.\n * This function helps create a properly structured transaction payload for executing a specific function on a module.\n *\n * @param args - The input data required to generate the transaction payload.\n * @param args.abi - The ABI of the function to be executed.\n * @param args.function - The fully qualified name of the function in the format `moduleAddress::moduleName::functionName`.\n * @param args.typeArguments - An array of type arguments that correspond to the function's type parameters.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n * @param args.multisigAddress - (Optional) The address for a multisig transaction if applicable.\n *\n * @throws Error if the type argument count does not match the ABI or if the number of function arguments is incorrect.\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(args: InputEntryFunctionDataWithABI): TransactionPayloadEntryFunction;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(args: InputMultiSigDataWithABI): TransactionPayloadMultiSig;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadDataWithABI,\n): AnyTransactionPayloadInstance {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> = args.functionArguments.map((arg, i) =>\n    /**\n     * Converts the argument for a specified function using its ABI and type arguments.\n     * This function helps ensure that the correct number of arguments is provided for the function call.\n     *\n     * @param args - The arguments for the function call.\n     * @param args.function - The specific function to be invoked.\n     * @param functionAbi - The ABI (Application Binary Interface) of the function, which includes parameter details.\n     * @param arg - The argument to be converted.\n     * @param i - The index of the argument in the function call.\n     * @param typeArguments - Additional type arguments that may be required for the conversion.\n     * @group Implementation\n     * @category Transactions\n     */\n    // TODO: Fix JSDoc\n    convertArgument(args.function, functionAbi, arg, i, typeArguments),\n  );\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  const entryFunctionPayload = EntryFunction.build(\n    `${moduleAddress}::${moduleName}`,\n    functionName,\n    typeArguments,\n    functionArguments,\n  );\n\n  // Send it as multi sig if it's a multisig payload\n  if (\"multisigAddress\" in args) {\n    const multisigAddress = AccountAddress.from(args.multisigAddress);\n    return new TransactionPayloadMultiSig(\n      new MultiSig(multisigAddress, new MultiSigTransactionPayload(entryFunctionPayload)),\n    );\n  }\n\n  // Otherwise send as an entry function\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\n\n/**\n * Generates the payload for a view function call using the provided arguments.\n * This function helps in preparing the necessary data to interact with a specific view function on the blockchain.\n *\n * @param args - The input data required to generate the view function payload.\n * @param args.function - The function identifier in the format \"moduleAddress::moduleName::functionName\".\n * @param args.aptosConfig - Configuration settings for the Aptos client.\n * @param args.abi - The ABI (Application Binary Interface) of the module.\n *\n * @returns The generated payload for the view function call.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateViewFunctionPayload(args: InputViewFunctionDataWithRemoteABI): Promise<EntryFunction> {\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  const functionAbi = await fetchAbi({\n    key: \"view-function\",\n    moduleAddress,\n    moduleName,\n    functionName,\n    aptosConfig: args.aptosConfig,\n    abi: args.abi,\n    fetch: fetchViewFunctionAbi,\n  });\n\n  // Fill in the ABI\n  return generateViewFunctionPayloadWithABI({ abi: functionAbi, ...args });\n}\n\n/**\n * Generates a payload for a view function call using the provided ABI and arguments.\n * This function ensures that the type arguments and function arguments are correctly formatted\n * and match the expected counts as defined in the ABI.\n *\n * @param args - The input data for generating the view function payload.\n * @param args.abi - The ABI of the function to be called.\n * @param args.function - The full name of the function in the format \"moduleAddress::moduleName::functionName\".\n * @param args.typeArguments - An array of type arguments to be used in the function call.\n * @param args.functionArguments - An array of arguments to be passed to the function.\n *\n * @throws Error if the type argument count does not match the ABI or if the function arguments\n * do not match the expected parameters defined in the ABI.\n * @group Implementation\n * @category Transactions\n */\nexport function generateViewFunctionPayloadWithABI(args: InputViewFunctionDataWithABI): EntryFunction {\n  const functionAbi = args.abi;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> =\n    args?.functionArguments?.map((arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments)) ?? [];\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  return EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);\n}\n\n/**\n * Generates a transaction payload script based on the provided input data.\n * This function helps in creating a structured script for transaction processing.\n *\n * @param args - The input data required to generate the transaction payload script.\n * @param args.bytecode - The bytecode to be converted into a Uint8Array.\n * @param args.typeArguments - The type arguments that will be standardized.\n * @param args.functionArguments - The arguments for the function being called.\n * @returns A new instance of TransactionPayloadScript.\n * @group Implementation\n * @category Transactions\n */\nfunction generateTransactionPayloadScript(args: InputScriptData) {\n  return new TransactionPayloadScript(\n    new Script(\n      Hex.fromHexInput(args.bytecode).toUint8Array(),\n      standardizeTypeTags(args.typeArguments),\n      args.functionArguments,\n    ),\n  );\n}\n\n/**\n * Generates a raw transaction that can be sent to the Aptos network.\n *\n * @param args - The arguments for generating the raw transaction.\n * @param args.aptosConfig - The configuration for the Aptos network.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using generateTransactionPayload().\n * @param args.options - Optional parameters for transaction generation.\n * @param args.feePayerAddress - The address of the fee payer for sponsored transactions.\n *\n * @returns RawTransaction - The generated raw transaction.\n * @group Implementation\n * @category Transactions\n */\nexport async function generateRawTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  payload: AnyTransactionPayloadInstance;\n  options?: InputGenerateTransactionOptions;\n  feePayerAddress?: AccountAddressInput;\n}): Promise<RawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n\n  if (options?.replayProtectionNonce !== undefined && options?.accountSequenceNumber !== undefined) {\n    throw new Error(\"Cannot specify both replayProtectionNonce and accountSequenceNumber in options.\");\n  }\n\n  const getChainId = async () => {\n    if (NetworkToChainId[aptosConfig.network]) {\n      return { chainId: NetworkToChainId[aptosConfig.network] };\n    }\n    const info = await getLedgerInfo({ aptosConfig });\n    return { chainId: info.chain_id };\n  };\n\n  const getGasUnitPrice = async () => {\n    if (options?.gasUnitPrice) {\n      return { gasEstimate: options.gasUnitPrice };\n    }\n    const estimation = await getGasPriceEstimation({ aptosConfig });\n    return { gasEstimate: estimation.gas_estimate };\n  };\n\n  const getSequenceNumberForAny = async () => {\n    const getSequenceNumber = async () => {\n      if (options?.accountSequenceNumber !== undefined) {\n        return options.accountSequenceNumber;\n      } else if (options?.replayProtectionNonce !== undefined) {\n        // If replay nonce is provided, use it as the sequence number\n        // This is an unused value, so it's specifically to show that the sequence number is not used\n        return 0xdeadbeefn;\n      }\n\n      return (await getInfo({ aptosConfig, accountAddress: sender })).sequence_number;\n    };\n\n    /**\n     * Check if is sponsored transaction to honor AIP-52\n     * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-52.md}\n     * @group Implementation\n     * @category Transactions\n     */\n    if (feePayerAddress && AccountAddress.from(feePayerAddress).equals(AccountAddress.ZERO)) {\n      // Handle sponsored transaction generation with the option that\n      // the main signer has not been created on chain\n      try {\n        // Check if main signer has been created on chain, if not assign sequence number 0\n        return await getSequenceNumber();\n      } catch (e: any) {\n        return 0;\n      }\n    } else {\n      return getSequenceNumber();\n    }\n  };\n  const [{ chainId }, { gasEstimate }, sequenceNumber] = await Promise.all([\n    getChainId(),\n    getGasUnitPrice(),\n    getSequenceNumberForAny(),\n  ]);\n\n  const { maxGasAmount, gasUnitPrice, expireTimestamp, replayProtectionNonce } = {\n    maxGasAmount: options?.maxGasAmount ? BigInt(options.maxGasAmount) : BigInt(aptosConfig.getDefaultMaxGasAmount()),\n    gasUnitPrice: options?.gasUnitPrice ?? BigInt(gasEstimate),\n    expireTimestamp:\n      options?.expireTimestamp ?? BigInt(Math.floor(Date.now() / 1000) + aptosConfig.getDefaultTxnExpirySecFromNow()),\n    replayProtectionNonce: options?.replayProtectionNonce ? BigInt(options.replayProtectionNonce) : undefined,\n  };\n\n  // If we're using replay nonce, we must convert the original payload\n  let txnPayload = payload;\n  if (replayProtectionNonce !== undefined) {\n    txnPayload = convertPayloadToInnerPayload(payload, replayProtectionNonce);\n  }\n\n  return new RawTransaction(\n    AccountAddress.from(sender),\n    BigInt(sequenceNumber),\n    txnPayload,\n    BigInt(maxGasAmount),\n    BigInt(gasUnitPrice),\n    BigInt(expireTimestamp),\n    new ChainId(chainId),\n  );\n}\n\nexport function convertPayloadToInnerPayload(\n  payload: AnyTransactionPayloadInstance,\n  replayProtectionNonce?: bigint,\n): TransactionInnerPayload {\n  if (payload instanceof TransactionPayloadScript) {\n    return new TransactionInnerPayloadV1(\n      new TransactionExecutableScript(payload.script),\n      new TransactionExtraConfigV1(undefined, replayProtectionNonce),\n    );\n  } else if (payload instanceof TransactionPayloadEntryFunction) {\n    return new TransactionInnerPayloadV1(\n      new TransactionExecutableEntryFunction(payload.entryFunction),\n      new TransactionExtraConfigV1(undefined, replayProtectionNonce),\n    );\n  } else if (payload instanceof TransactionPayloadMultiSig) {\n    const innerPayload = payload.multiSig.transaction_payload;\n    let executable: TransactionExecutable;\n    if (innerPayload === undefined || innerPayload?.transaction_payload === undefined) {\n      executable = new TransactionExecutableEmpty();\n    } else if (innerPayload.transaction_payload instanceof EntryFunction) {\n      executable = new TransactionExecutableEntryFunction(innerPayload.transaction_payload);\n    } else {\n      // TODO For now, scripts are not supported in multi-sig transactions, so it's always entry function\n      throw new Error(\"Scripts are not supported in multi-sig transactions.\");\n    }\n\n    return new TransactionInnerPayloadV1(\n      executable,\n      new TransactionExtraConfigV1(payload.multiSig.multisig_address, replayProtectionNonce),\n    );\n  } else {\n    throw new Error(`Unsupported payload type: ${payload}`);\n  }\n}\n\n/**\n * Generates a transaction based on the provided arguments.\n * This function can create both simple and multi-agent transactions, allowing for flexible transaction handling.\n *\n * @param args - The input arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The transaction's sender account address as a hex input.\n * @param args.payload - The transaction payload, which can be created using `generateTransactionPayload()`.\n * @param args.options - Optional. Transaction options object.\n * @param args.secondarySignerAddresses - Optional. An array of addresses for additional signers in a multi-signature transaction.\n * @param args.feePayerAddress - Optional. The address of the fee payer for sponsored transactions.\n * @returns An instance of a transaction, which may include secondary signer addresses and a fee payer address.\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateSingleSignerRawTransactionArgs): Promise<SimpleTransaction>;\n/**\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateMultiAgentRawTransactionArgs): Promise<MultiAgentTransaction>;\n\n/**\n * Generates a transaction based on the provided arguments\n *\n * Note: we can start with one function to support all different payload/transaction types,\n * and if to complex to use, we could have function for each type\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n * @param args.options optional. Transaction options object\n * @param args.secondarySignerAddresses optional. For when want to create a multi signers transaction\n * @param args.feePayerAddress optional. For when want to create a fee payer (aka sponsored) transaction\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n * @group Implementation\n * @category Transactions\n */\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n  // generate raw transaction\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n\n  // if multi agent transaction\n  if (\"secondarySignerAddresses\" in args) {\n    const signers: Array<AccountAddress> =\n      args.secondarySignerAddresses?.map((signer) => AccountAddress.from(signer)) ?? [];\n\n    return new MultiAgentTransaction(\n      rawTxn,\n      signers,\n      args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined,\n    );\n  }\n  // return the raw transaction\n  return new SimpleTransaction(rawTxn, args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined);\n}\n\n/**\n * Generate a signed transaction for simulation before submitting it to the chain.\n * This function helps in preparing a transaction that can be simulated, allowing users to verify its validity and expected behavior.\n *\n * @param args - The input data required to generate the signed transaction for simulation.\n * @param args.transaction - An Aptos transaction type to sign.\n * @param args.signerPublicKey - The public key of the signer.\n * @param args.secondarySignersPublicKeys - Optional. The public keys of secondary signers if it is a multi-signer transaction.\n * @param args.feePayerPublicKey - Optional. The public key of the fee payer in a sponsored transaction.\n * @param args.options - Optional. Additional options for simulating the transaction.\n *\n * @returns A signed serialized transaction that can be simulated.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSignedTransactionForSimulation(args: InputSimulateTransactionData): Uint8Array {\n  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;\n\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n\n  // fee payer transaction\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n    if (transaction.secondarySignerAddresses) {\n      if (secondarySignersPublicKeys) {\n        secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n          getAuthenticatorForSimulation(publicKey),\n        );\n      } else {\n        secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n          getAuthenticatorForSimulation(undefined),\n        );\n      }\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);\n\n    const transactionAuthenticator = new TransactionAuthenticatorFeePayer(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      secondaryAccountAuthenticators,\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // multi agent transaction\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n        getAuthenticatorForSimulation(publicKey),\n      );\n    } else {\n      secondaryAccountAuthenticators = Array.from({ length: transaction.secondarySignerAddresses.length }, () =>\n        getAuthenticatorForSimulation(undefined),\n      );\n    }\n\n    const transactionAuthenticator = new TransactionAuthenticatorMultiAgent(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses,\n      secondaryAccountAuthenticators,\n    );\n\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // single signer raw transaction\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      accountAuthenticator.public_key,\n      accountAuthenticator.signature,\n    );\n  } else if (\n    accountAuthenticator instanceof AccountAuthenticatorSingleKey ||\n    accountAuthenticator instanceof AccountAuthenticatorMultiKey\n  ) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else if (accountAuthenticator instanceof AccountAuthenticatorNoAccountAuthenticator) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();\n}\n\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function getAuthenticatorForSimulation(publicKey?: PublicKey) {\n  if (!publicKey) {\n    return new AccountAuthenticatorNoAccountAuthenticator();\n  }\n\n  // Wrap the public key types below with AnyPublicKey as they are only support through single sender.\n  // Learn more about AnyPublicKey here - https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-55.md\n  const convertToAnyPublicKey =\n    KeylessPublicKey.isInstance(publicKey) ||\n    FederatedKeylessPublicKey.isInstance(publicKey) ||\n    Secp256k1PublicKey.isInstance(publicKey);\n  const accountPublicKey = convertToAnyPublicKey ? new AnyPublicKey(publicKey) : publicKey;\n\n  // No need to for the signature to be matching in scheme. All that matters for simulations is that it's not valid\n  const invalidSignature = new Ed25519Signature(new Uint8Array(64));\n\n  if (Ed25519PublicKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorEd25519(accountPublicKey, invalidSignature);\n  }\n\n  if (AnyPublicKey.isInstance(accountPublicKey)) {\n    if (KeylessPublicKey.isInstance(accountPublicKey.publicKey)) {\n      return new AccountAuthenticatorSingleKey(\n        accountPublicKey,\n        new AnySignature(KeylessSignature.getSimulationSignature()),\n      );\n    }\n    return new AccountAuthenticatorSingleKey(accountPublicKey, new AnySignature(invalidSignature));\n  }\n\n  if (MultiKey.isInstance(accountPublicKey)) {\n    return new AccountAuthenticatorMultiKey(\n      accountPublicKey,\n      new MultiKeySignature({\n        signatures: accountPublicKey.publicKeys.map((pubKey) => {\n          if (KeylessPublicKey.isInstance(pubKey.publicKey) || FederatedKeylessPublicKey.isInstance(pubKey.publicKey)) {\n            return new AnySignature(KeylessSignature.getSimulationSignature());\n          }\n          return new AnySignature(invalidSignature);\n        }),\n        bitmap: accountPublicKey.createBitmap({\n          bits: Array(accountPublicKey.publicKeys.length)\n            .fill(0)\n            .map((_, i) => i),\n        }),\n      }),\n    );\n  }\n\n  throw new Error(\"Unsupported PublicKey used for simulations\");\n}\n\n/**\n * Generate a signed transaction ready for submission to the blockchain.\n * This function prepares the transaction by authenticating the sender and any additional signers based on the provided arguments.\n *\n * @param args - The input data required to generate the signed transaction.\n * @param args.transaction - An Aptos transaction type containing the details of the transaction.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.feePayerAuthenticator - The authenticator for the fee payer, required if the transaction has a fee payer address.\n * @param args.additionalSignersAuthenticators - Optional authenticators for additional signers in a multi-signer transaction.\n *\n * @returns A Uint8Array representing the signed transaction in bytes.\n *\n * @throws Error if the feePayerAuthenticator is not provided for a fee payer transaction.\n * @throws Error if additionalSignersAuthenticators are not provided for a multi-signer transaction.\n * @group Implementation\n * @category Transactions\n */\nexport function generateSignedTransaction(args: InputSubmitTransactionData): Uint8Array {\n  const { transaction, feePayerAuthenticator, additionalSignersAuthenticators } = args;\n  const senderAuthenticator = normalizeBundle(AccountAuthenticator, args.senderAuthenticator);\n\n  let txnAuthenticator: TransactionAuthenticator;\n  if (transaction.feePayerAddress) {\n    if (!feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    txnAuthenticator = new TransactionAuthenticatorFeePayer(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      additionalSignersAuthenticators ?? [],\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n  } else if (transaction.secondarySignerAddresses) {\n    if (!additionalSignersAuthenticators) {\n      throw new Error(\n        \"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\",\n      );\n    }\n    txnAuthenticator = new TransactionAuthenticatorMultiAgent(\n      senderAuthenticator,\n      transaction.secondarySignerAddresses,\n      additionalSignersAuthenticators,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else if (senderAuthenticator instanceof AccountAuthenticatorMultiEd25519) {\n    txnAuthenticator = new TransactionAuthenticatorMultiEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n  } else {\n    txnAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n  }\n\n  return new SignedTransaction(transaction.rawTransaction, txnAuthenticator).bcsToBytes();\n}\n\n/**\n * Hashes the set of values using a SHA-3 256 hash algorithm.\n * @param input - An array of UTF-8 strings or Uint8Array byte arrays to be hashed.\n * @group Implementation\n * @category Transactions\n */\nexport function hashValues(input: (Uint8Array | string)[]): Uint8Array {\n  const hash = sha3Hash.create();\n  for (const item of input) {\n    hash.update(item);\n  }\n  return hash.digest();\n}\n\n/**\n * The domain separated prefix for hashing transactions\n * @group Implementation\n * @category Transactions\n */\nconst TRANSACTION_PREFIX = hashValues([\"APTOS::Transaction\"]);\n\n/**\n * Generates a user transaction hash for the provided transaction payload, which must already have an authenticator.\n * This function helps ensure the integrity and uniqueness of the transaction by producing a hash based on the signed transaction data.\n *\n * @param args - The input data required to submit the transaction.\n * @param args.authenticator - The authenticator for the transaction.\n * @param args.payload - The payload containing the transaction details.\n * @param args.sender - The address of the sender initiating the transaction.\n * @param args.sequenceNumber - The sequence number of the transaction for the sender.\n * @group Implementation\n * @category Transactions\n */\nexport function generateUserTransactionHash(args: InputSubmitTransactionData): string {\n  const signedTransaction = generateSignedTransaction(args);\n\n  // Transaction signature is defined as, the domain separated prefix based on struct (Transaction)\n  // Then followed by the type of the transaction for the enum, UserTransaction is 0\n  // Then followed by BCS encoded bytes of the signed transaction\n  return new Hex(hashValues([TRANSACTION_PREFIX, new Uint8Array([0]), signedTransaction])).toString();\n}\n\n/**\n * Fetches and caches ABIs while allowing for pass-through on provided ABIs.\n *\n * @param key - A unique identifier for the cached ABI.\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is being fetched.\n * @param aptosConfig - Configuration settings for Aptos.\n * @param abi - An optional ABI to use if already available.\n * @param fetch - A function to fetch the ABI if it is not provided.\n * @group Implementation\n * @category Transactions\n */\nasync function fetchAbi<T extends FunctionABI>({\n  key,\n  moduleAddress,\n  moduleName,\n  functionName,\n  aptosConfig,\n  abi,\n  fetch,\n}: {\n  key: string;\n  moduleAddress: string;\n  moduleName: string;\n  functionName: string;\n  aptosConfig: AptosConfig;\n  abi?: T;\n  fetch: (moduleAddress: string, moduleName: string, functionName: string, aptosConfig: AptosConfig) => Promise<T>;\n}): Promise<T> {\n  if (abi !== undefined) {\n    return abi;\n  }\n\n  // We fetch the entry function ABI, and then pretend that we already had the ABI\n  return memoizeAsync(\n    async () => fetch(moduleAddress, moduleName, functionName, aptosConfig),\n    `${key}-${aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  StructTag,\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagGeneric,\n  TypeTagReference,\n  TypeTagSigner,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n  TypeTagVector,\n} from \".\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\n\n/**\n * Determines if the provided string is a valid Move identifier, which can only contain alphanumeric characters and underscores.\n * @param str - The string to validate as a Move identifier.\n * @group Implementation\n * @category Transactions\n */\nfunction isValidIdentifier(str: string) {\n  return !!str.match(/^[_a-zA-Z0-9]+$/);\n}\n\n/**\n * Determines if the provided character is a whitespace character. This function only works for single characters.\n * @param char - The character to check for whitespace.\n * @group Implementation\n * @category Transactions\n */\nfunction isValidWhitespaceCharacter(char: string) {\n  return !!char.match(/\\s/);\n}\n\n/**\n * Determines if a given string represents a generic type from the ABI, specifically in the format T0, T1, etc.\n * @param str - The string to evaluate for generic type format.\n * @group Implementation\n * @category Transactions\n */\nfunction isGeneric(str: string) {\n  return !!str.match(/^T[0-9]+$/);\n}\n\n/**\n * Determines if the provided string is a reference type, which is indicated by starting with an ampersand (&).\n * @param str - The string to evaluate for reference type.\n * @group Implementation\n * @category Transactions\n */\nfunction isRef(str: string) {\n  return !!str.match(/^&.+$/);\n}\n\n/**\n * Determines if the provided string represents a primitive type.\n * @param str - The string to evaluate as a potential primitive type.\n * @returns A boolean indicating whether the string is a primitive type.\n * @group Implementation\n * @category Transactions\n */\nfunction isPrimitive(str: string) {\n  switch (str) {\n    case \"signer\":\n    case \"address\":\n    case \"bool\":\n    case \"u8\":\n    case \"u16\":\n    case \"u32\":\n    case \"u64\":\n    case \"u128\":\n    case \"u256\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Consumes all whitespace characters in a string starting from a specified position.\n *\n * @param tagStr - The string from which to consume whitespace.\n * @param pos - The position in the string to start consuming whitespace from.\n * @returns The new position in the string after consuming whitespace.\n * @group Implementation\n * @category Transactions\n */\nfunction consumeWhitespace(tagStr: string, pos: number) {\n  let i = pos;\n  for (; i < tagStr.length; i += 1) {\n    const innerChar = tagStr[i];\n\n    if (!isValidWhitespaceCharacter(innerChar)) {\n      // If it's not colons, and it's an invalid character, we will stop here\n      break;\n    }\n  }\n  return i;\n}\n\n/**\n * State for TypeTag parsing, maintained on a stack to track the current parsing state.\n * @group Implementation\n * @category Transactions\n */\ntype TypeTagState = {\n  savedExpectedTypes: number;\n  savedStr: string;\n  savedTypes: Array<TypeTag>;\n};\n\n/**\n * Error types related to parsing type tags, indicating various issues encountered during the parsing process.\n * @group Implementation\n * @category Transactions\n */\nexport enum TypeTagParserErrorType {\n  InvalidTypeTag = \"unknown type\",\n  UnexpectedGenericType = \"unexpected generic type\",\n  UnexpectedTypeArgumentClose = \"unexpected '>'\",\n  UnexpectedWhitespaceCharacter = \"unexpected whitespace character\",\n  UnexpectedComma = \"unexpected ','\",\n  TypeArgumentCountMismatch = \"type argument count doesn't match expected amount\",\n  MissingTypeArgumentClose = \"no matching '>' for '<'\",\n  MissingTypeArgument = \"no type argument before ','\",\n  UnexpectedPrimitiveTypeArguments = \"primitive types not expected to have type arguments\",\n  UnexpectedVectorTypeArgumentCount = \"vector type expected to have exactly one type argument\",\n  UnexpectedStructFormat = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\",\n  InvalidModuleNameCharacter = \"module name must only contain alphanumeric or '_' characters\",\n  InvalidStructNameCharacter = \"struct name must only contain alphanumeric or '_' characters\",\n  InvalidAddress = \"struct address must be valid\",\n}\n\n/**\n * Represents an error that occurs during the parsing of a type tag.\n * This error extends the built-in Error class and provides additional context\n * regarding the specific type tag that failed to parse and the reason for the failure.\n *\n * @param typeTagStr - The type tag string that failed to be parsed.\n * @param invalidReason - The reason why the type tag string is considered invalid.\n * @group Implementation\n * @category Transactions\n */\nexport class TypeTagParserError extends Error {\n  /**\n   * Constructs an error indicating a failure to parse a type tag.\n   * This error provides details about the specific type tag that could not be parsed and the reason for the failure.\n   *\n   * @param typeTagStr - The string representation of the type tag that failed to parse.\n   * @param invalidReason - The reason why the type tag is considered invalid.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(typeTagStr: string, invalidReason: TypeTagParserErrorType) {\n    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);\n  }\n}\n\n/**\n * Parses a type string into a structured representation of type tags, accommodating various formats including generics and\n * nested types.\n *\n * This function can help you accurately interpret type strings, which can include simple types, standalone structs, and complex\n * nested generics.\n * It supports multiple generics, spacing within generics, and nested generics of varying depths.\n * All types are made of a few parts they're either:\n * 1. A simple type e.g. u8\n * 2. A standalone struct e.g. 0x1::account::Account\n * 3. A nested struct e.g. 0x1::coin::Coin<0x1234::coin::MyCoin>\n *\n * There are a few more special cases that need to be handled, however.\n * 1. Multiple generics e.g. 0x1::pair::Pair<u8, u16>\n * 2. Spacing in the generics e.g. 0x1::pair::Pair< u8 , u16>\n * 3. Nested generics of different depths e.g. 0x1::pair::Pair<0x1::coin::Coin<0x1234::coin::MyCoin>, u8>\n * 4. Generics for types in ABIs are filled in with placeholders e.g. T1, T2, T3\n * @param typeStr - The string representation of the type to be parsed.\n * @param options - Optional settings for parsing behavior.\n * @param options.allowGenerics - A flag indicating whether to allow generics in the parsing process.\n * @returns The parsed type tag representation.\n * @throws TypeTagParserError if the type string is malformed or does not conform to expected formats.\n * @group Implementation\n * @category Transactions\n */\nexport function parseTypeTag(typeStr: string, options?: { allowGenerics?: boolean }) {\n  const allowGenerics = options?.allowGenerics ?? false;\n\n  const saved: Array<TypeTagState> = [];\n  // This represents the internal types for a type tag e.g. '0x1::coin::Coin<innerTypes>'\n  let innerTypes: Array<TypeTag> = [];\n  // This represents the current parsed types in a comma list e.g. 'u8, u8'\n  let curTypes: Array<TypeTag> = [];\n  // This represents the current character index\n  let cur: number = 0;\n  // This represents the current working string as a type or struct name\n  let currentStr: string = \"\";\n  let expectedTypes: number = 1;\n\n  // Iterate through each character, and handle the border conditions\n  while (cur < typeStr.length) {\n    const char = typeStr[cur];\n\n    if (char === \"<\") {\n      // Start of a type argument, push current state onto a stack\n      saved.push({\n        savedExpectedTypes: expectedTypes,\n        savedStr: currentStr,\n        savedTypes: curTypes,\n      });\n\n      // Clear current state\n      currentStr = \"\";\n      curTypes = [];\n      expectedTypes = 1;\n    } else if (char === \">\") {\n      // Process last type, if there is no type string, then don't parse it\n      if (currentStr !== \"\") {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        curTypes.push(newType);\n      }\n\n      // Pop off stack outer type, if there's nothing left, there were too many '>'\n      const savedPop = saved.pop();\n      if (savedPop === undefined) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedTypeArgumentClose);\n      }\n\n      // If the expected types don't match the number of commas, then we also fail\n      if (expectedTypes !== curTypes.length) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.TypeArgumentCountMismatch);\n      }\n\n      // Add in the new created type, shifting the current types to the inner types\n      const { savedStr, savedTypes, savedExpectedTypes } = savedPop;\n      innerTypes = curTypes;\n      curTypes = savedTypes;\n      currentStr = savedStr;\n      expectedTypes = savedExpectedTypes;\n    } else if (char === \",\") {\n      // Comma means we need to start parsing a new tag, push the previous one to the curTypes\n\n      // No top level commas (not in a type <> are allowed)\n      if (saved.length === 0) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n      }\n      // If there was no actual value before the comma, then it's missing a type argument\n      if (currentStr.length === 0) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgument);\n      }\n\n      // Process characters before as a type\n      const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n      // parse type tag and push it on the types\n      innerTypes = [];\n      curTypes.push(newType);\n      currentStr = \"\";\n      expectedTypes += 1;\n    } else if (isValidWhitespaceCharacter(char)) {\n      // This means we should save what we have and everything else should skip until the next\n      let parsedTypeTag = false;\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n        // parse type tag and push it on the types\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        parsedTypeTag = true;\n      }\n\n      // Skip ahead on any more whitespace\n      cur = consumeWhitespace(typeStr, cur);\n\n      // The next space MUST be a comma, or a closing > if there was something parsed before\n      // e.g. `u8 u8` is invalid but `u8, u8` is valid\n      const nextChar = typeStr[cur];\n      if (cur < typeStr.length && parsedTypeTag && nextChar !== \",\" && nextChar !== \">\") {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n      }\n\n      // eslint-disable-next-line no-continue\n      continue;\n    } else {\n      // Any other characters just append to the current string\n      currentStr += char;\n    }\n\n    cur += 1;\n  }\n\n  // This prevents a missing '>' on type arguments\n  if (saved.length > 0) {\n    throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgumentClose);\n  }\n\n  // This prevents 'u8, u8' as an input\n  switch (curTypes.length) {\n    case 0:\n      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n    case 1:\n      if (currentStr === \"\") {\n        return curTypes[0];\n      }\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n    default:\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n  }\n}\n\n/**\n * Parses a type tag with internal types associated, allowing for the inclusion of generics if specified. This function helps in\n * constructing the appropriate type tags based on the provided string representation and associated types.\n *\n * @param str - The string representation of the type tag to parse.\n * @param types - An array of TypeTag instances that represent internal types associated with the type tag.\n * @param allowGenerics - A boolean indicating whether generics are allowed in the parsing of the type tag.\n * @group Implementation\n * @category Transactions\n */\nfunction parseTypeTagInner(str: string, types: Array<TypeTag>, allowGenerics: boolean): TypeTag {\n  const trimmedStr = str.trim();\n  const lowerCaseTrimmed = trimmedStr.toLowerCase();\n  if (isPrimitive(lowerCaseTrimmed)) {\n    if (types.length > 0) {\n      throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n    }\n  }\n\n  switch (trimmedStr.toLowerCase()) {\n    case \"signer\":\n      return new TypeTagSigner();\n    case \"bool\":\n      return new TypeTagBool();\n    case \"address\":\n      return new TypeTagAddress();\n    case \"u8\":\n      return new TypeTagU8();\n    case \"u16\":\n      return new TypeTagU16();\n    case \"u32\":\n      return new TypeTagU32();\n    case \"u64\":\n      return new TypeTagU64();\n    case \"u128\":\n      return new TypeTagU128();\n    case \"u256\":\n      return new TypeTagU256();\n    case \"vector\":\n      if (types.length !== 1) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedVectorTypeArgumentCount);\n      }\n      return new TypeTagVector(types[0]);\n    default:\n      // Reference will have to handle the inner type\n      if (isRef(trimmedStr)) {\n        const actualType = trimmedStr.substring(1);\n        return new TypeTagReference(parseTypeTagInner(actualType, types, allowGenerics));\n      }\n\n      // Generics are always expected to be T0 or T1\n      if (isGeneric(trimmedStr)) {\n        if (allowGenerics) {\n          return new TypeTagGeneric(Number(trimmedStr.split(\"T\")[1]));\n        }\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedGenericType);\n      }\n\n      // If the value doesn't contain a colon, then we'll assume it isn't trying to be a struct\n      if (!trimmedStr.match(/:/)) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidTypeTag);\n      }\n\n      // Parse for a struct tag\n      // eslint-disable-next-line no-case-declarations\n      const structParts = trimmedStr.split(\"::\");\n      if (structParts.length !== 3) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedStructFormat);\n      }\n\n      // Validate struct address\n      // eslint-disable-next-line no-case-declarations\n      let address: AccountAddress;\n      try {\n        address = AccountAddress.fromString(structParts[0]);\n      } catch (error: any) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidAddress);\n      }\n\n      // Validate identifier characters\n      if (!isValidIdentifier(structParts[1])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidModuleNameCharacter);\n      }\n      if (!isValidIdentifier(structParts[2])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidStructNameCharacter);\n      }\n\n      return new TypeTagStruct(\n        new StructTag(address, new Identifier(structParts[1]), new Identifier(structParts[2]), types),\n      );\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  EntryFunctionArgumentTypes,\n  InputGenerateTransactionPayloadData,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputScriptData,\n  SimpleEntryFunctionArgumentTypes,\n} from \"../types\";\nimport { Bool, FixedBytes, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { MoveFunction } from \"../../types\";\n\n/**\n * Determines if the provided argument is of type boolean.\n * This can help in validating input types before processing them further.\n *\n * @param arg - The argument to check, which can be of various types.\n * @returns A boolean indicating whether the argument is a boolean.\n * @group Implementation\n * @category Transactions\n */\nexport function isBool(arg: SimpleEntryFunctionArgumentTypes): arg is boolean {\n  return typeof arg === \"boolean\";\n}\n\n/**\n * Checks if the provided argument is of type string.\n *\n * @param arg - The value to be checked for string type.\n * @returns A boolean indicating whether the argument is a string.\n * @group Implementation\n * @category Transactions\n */\nexport function isString(arg: any): arg is string {\n  return typeof arg === \"string\";\n}\n\n/**\n * Determines if the provided argument is of type number.\n *\n * @param arg - The argument to check, which can be of various types.\n * @returns A boolean indicating whether the argument is a number.\n * @group Implementation\n * @category Transactions\n */\nexport function isNumber(arg: SimpleEntryFunctionArgumentTypes): arg is number {\n  return typeof arg === \"number\";\n}\n\n/**\n * Converts a number or a string representation of a number into a number type.\n * This function is useful for ensuring that the input is in a consistent numeric format,\n * which can help prevent type mismatches in further processing.\n *\n * @param arg - The input value to be converted. This can be a number, a string representing a number, or any other type.\n * @returns Returns the converted number if the input is valid; otherwise, it returns undefined.\n * @group Implementation\n * @category Transactions\n */\nexport function convertNumber(arg: SimpleEntryFunctionArgumentTypes): number | undefined {\n  if (isNumber(arg)) {\n    return arg;\n  }\n  if (isString(arg) && arg !== \"\") {\n    return Number.parseInt(arg, 10);\n  }\n\n  return undefined;\n}\n\n/**\n * Determines if the provided argument is a large number, which can be a number, bigint, or string representation of a number.\n *\n * @param arg - The argument to check, which can be of type number, bigint, or string.\n * @group Implementation\n * @category Transactions\n */\nexport function isLargeNumber(arg: SimpleEntryFunctionArgumentTypes): arg is number | bigint | string {\n  return typeof arg === \"number\" || typeof arg === \"bigint\" || typeof arg === \"string\";\n}\n\n/**\n * Checks if the provided argument is empty, meaning it is either null or undefined.\n *\n * @param arg - The argument to check for emptiness.\n * @returns A boolean indicating whether the argument is empty.\n * @group Implementation\n * @category Transactions\n */\nexport function isEmptyOption(arg: SimpleEntryFunctionArgumentTypes): arg is null | undefined {\n  return arg === null || arg === undefined;\n}\n\n/**\n * Determines if the provided argument is a valid encoded entry function argument type.\n * This function helps validate that the argument conforms to the expected types for entry function parameters.\n *\n * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n * @group Implementation\n * @category Transactions\n */\nexport function isEncodedEntryFunctionArgument(\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n): arg is EntryFunctionArgumentTypes {\n  return (\n    /**\n     * Determines if the provided argument is an instance of the Bool class.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsBool(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U8.\n     * This function helps validate the type of the argument passed to ensure it is a U8 type.\n     *\n     * @param arg - The argument to be checked, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU8(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U16.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU16(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U32.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @returns A boolean indicating whether the argument is a U32 instance.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU32(arg) ||\n    /**\n     * Determine if the provided argument is an instance of U64.\n     * This function helps validate that the argument conforms to the expected U64 type.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU64(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U128.\n     * This function helps validate the type of the argument passed to ensure it is a U128 type.\n     *\n     * @param arg - The argument to be checked, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU128(arg) ||\n    /**\n     * Determines if the provided argument is an instance of U256.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @returns A boolean indicating whether the argument is a U256 instance.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsU256(arg) ||\n    /**\n     * Determines if the provided argument is an instance of AccountAddress.\n     * This function helps validate whether a given input corresponds to a valid BCS address type.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsAddress(arg) ||\n    /**\n     * Determine if the provided argument is an instance of MoveString.\n     *\n     * @param arg - The argument to check, which can be of types EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsString(arg) ||\n    /**\n     * Determine if the provided argument is an instance of FixedBytes.\n     * This function helps to validate the type of the argument being passed.\n     *\n     * @param arg - The argument to check, which can be of type EntryFunctionArgumentTypes or SimpleEntryFunctionArgumentTypes.\n     * @group Implementation\n     * @category Transactions\n     */\n    isBcsFixedBytes(arg) ||\n    arg instanceof MoveVector ||\n    arg instanceof MoveOption\n  );\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsBool(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is Bool {\n  return arg instanceof Bool;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsAddress(\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n): arg is AccountAddress {\n  return arg instanceof AccountAddress;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsString(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is MoveString {\n  return arg instanceof MoveString;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsFixedBytes(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is FixedBytes {\n  return arg instanceof FixedBytes;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU8(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U8 {\n  return arg instanceof U8;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU16(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U16 {\n  return arg instanceof U16;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU32(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U32 {\n  return arg instanceof U32;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU64(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U64 {\n  return arg instanceof U64;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU128(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U128 {\n  return arg instanceof U128;\n}\n/**\n * @group Implementation\n * @category Transactions\n */\nexport function isBcsU256(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U256 {\n  return arg instanceof U256;\n}\n\n/**\n * Determines if the provided argument contains script data input by checking for the presence of bytecode.\n *\n * @param arg - The input data to be checked, which can either be a payload with remote ABI or a standard payload.\n * @param arg.bytecode - The bytecode of the script, present if the input is script data.\n * @param arg.function - The function associated with the transaction, which is relevant for standard payloads.\n * @param arg.args - The arguments for the function, applicable in the context of standard payloads.\n * @group Implementation\n * @category Transactions\n */\nexport function isScriptDataInput(\n  arg: InputGenerateTransactionPayloadDataWithRemoteABI | InputGenerateTransactionPayloadData,\n): arg is InputScriptData {\n  return \"bytecode\" in arg;\n}\n\n/**\n * Throws an error indicating a type mismatch for a specified argument position.\n * This function helps in debugging by providing clear feedback on expected types.\n *\n * @param expectedType - The type that was expected for the argument.\n * @param position - The position of the argument that caused the type mismatch.\n * @group Implementation\n * @category Transactions\n */\nexport function throwTypeMismatch(expectedType: string, position: number) {\n  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);\n}\n\n/**\n * Finds the index of the first non-signer argument in the function ABI parameters.\n *\n * A function is often defined with a `signer` or `&signer` arguments at the start, which are filled in\n * by signatures and not by the caller. This function helps identify the position of the first argument that\n * can be provided by the caller, allowing for easier handling of function parameters.\n *\n * @param functionAbi - The ABI of the function to analyze.\n * @returns The index of the first non-signer argument, or the length of the parameters array if none are found.\n * @group Implementation\n * @category Transactions\n */\nexport function findFirstNonSignerArg(functionAbi: MoveFunction): number {\n  const index = functionAbi.params.findIndex((param) => param !== \"signer\" && param !== \"&signer\");\n  if (index < 0) {\n    return functionAbi.params.length;\n  }\n  return index;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport {\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n} from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport {\n  EntryFunctionArgumentTypes,\n  SimpleEntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  ViewFunctionABI,\n  FunctionABI,\n  TypeArgument,\n} from \"../types\";\nimport { Bool, FixedBytes, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isEncodedEntryFunctionArgument,\n  isLargeNumber,\n  isEmptyOption,\n  isString,\n  throwTypeMismatch,\n  convertNumber,\n} from \"./helpers\";\nimport { MoveFunction, MoveModule } from \"../../types\";\n\nconst TEXT_ENCODER = new TextEncoder();\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags.\n *\n * @param typeArguments - An optional array of type arguments that may include string representations.\n * @returns An array of TypeTag objects derived from the provided type arguments.\n * @group Implementation\n * @category Transactions\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeArgument>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: TypeArgument): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI of a specified module from the on-chain module ABI.\n *\n * @param moduleAddress - The address of the module from which to fetch the ABI.\n * @param moduleName - The name of the module containing the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchModuleAbi(\n  moduleAddress: string,\n  moduleName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveModule | undefined> {\n  const moduleBytecode = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n  return moduleBytecode.abi;\n}\n\n/**\n * Fetches the ABI of a specified function from the on-chain module ABI. This function allows you to access the details of a\n * specific function within a module.\n *\n * @param moduleAddress - The address of the module from which to fetch the function ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is to be fetched.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveFunction | undefined> {\n  const moduleAbi = await fetchModuleAbi(moduleAddress, moduleName, aptosConfig);\n  if (!moduleAbi) throw new Error(`Could not find module ABI for '${moduleAddress}::${moduleName}'`);\n  return moduleAbi.exposed_functions.find((func) => func.name === functionName);\n}\n\n/**\n * @deprecated Use `fetchFunctionAbi` instead and manually parse the type tags.\n */\nexport async function fetchMoveFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<FunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n  if (!functionAbi) {\n    throw new Error(`Could not find function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for an entry function from the specified module address.\n * This function validates if the ABI corresponds to an entry function and retrieves its parameters.\n *\n * @param moduleAddress - The address of the module containing the entry function.\n * @param moduleName - The name of the module containing the entry function.\n * @param functionName - The name of the entry function to fetch the ABI for.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the number of signers, type parameters, and function parameters.\n * @throws Error if the ABI cannot be found or if the function is not an entry function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const numSigners = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = numSigners; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    signers: numSigners,\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for a view function from the specified module address.\n * This function ensures that the ABI is valid and retrieves the type parameters, parameters, and return types for the view function.\n *\n * @param moduleAddress - The address of the module containing the view function.\n * @param moduleName - The name of the module containing the view function.\n * @param functionName - The name of the view function for which to fetch the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the type parameters, parameters, and return types of the view function.\n * @throws Error if the ABI cannot be found or if the function is not a view function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchViewFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<ViewFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find view function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-view functions can't be used\n  if (!functionAbi.is_view) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an view function`);\n  }\n\n  // Type tag parameters for the function\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  // The return types of the view function\n  const returnTypes: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.return.length; i += 1) {\n    returnTypes.push(parseTypeTag(functionAbi.return[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n    returnTypes,\n  };\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary.\n * This function checks the provided argument against the expected parameter type and converts it accordingly.\n *\n * @param functionName - The name of the function for which the argument is being converted.\n * @param functionAbiOrModuleAbi - The ABI (Application Binary Interface) of the function, which defines its parameters.\n * @param arg - The argument to be converted, which can be of various types.\n * @param position - The index of the argument in the function's parameter list.\n * @param genericTypeParams - An array of type tags for any generic type parameters.\n * @param options - Options for the conversion process.\n * @param options.allowUnknownStructs - If true, unknown structs will be allowed and converted to a `FixedBytes`.\n * @group Implementation\n * @category Transactions\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbiOrModuleAbi: MoveModule | FunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  options?: { allowUnknownStructs?: boolean },\n) {\n  let param: TypeTag;\n\n  if (\"exposed_functions\" in functionAbiOrModuleAbi) {\n    const functionAbi = functionAbiOrModuleAbi.exposed_functions.find((func) => func.name === functionName);\n    if (!functionAbi) {\n      throw new Error(\n        `Could not find function ABI for '${functionAbiOrModuleAbi.address}::${functionAbiOrModuleAbi.name}::${functionName}'`,\n      );\n    }\n\n    if (position >= functionAbi.params.length) {\n      throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.params.length}`);\n    }\n\n    param = parseTypeTag(functionAbi.params[position], { allowGenerics: true });\n  } else {\n    if (position >= functionAbiOrModuleAbi.parameters.length) {\n      throw new Error(`Too many arguments for '${functionName}', expected ${functionAbiOrModuleAbi.parameters.length}`);\n    }\n\n    param = functionAbiOrModuleAbi.parameters[position];\n  }\n\n  return checkOrConvertArgument(\n    arg,\n    param,\n    position,\n    genericTypeParams,\n    \"exposed_functions\" in functionAbiOrModuleAbi ? functionAbiOrModuleAbi : undefined,\n    options,\n  );\n}\n\n/**\n * Checks if the provided argument is BCS encoded and converts it if necessary, ensuring type compatibility with the ABI.\n * This function helps in validating and converting arguments for entry functions based on their expected types.\n *\n * @param arg - The argument to check or convert, which can be either a simple or entry function argument type.\n * @param param - The expected type tag for the argument.\n * @param position - The position of the argument in the function call.\n * @param genericTypeParams - An array of generic type parameters that may be used for conversion.\n * @group Implementation\n * @category Transactions\n */\nexport function checkOrConvertArgument(\n  arg: SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  moduleAbi?: MoveModule,\n  options?: { allowUnknownStructs?: boolean },\n) {\n  // If the argument is bcs encoded, we can just use it directly\n  if (isEncodedEntryFunctionArgument(arg)) {\n    // Ensure the type matches the ABI\n\n    /**\n     * Checks the type of the provided argument against the expected type.\n     * This function helps validate that the argument conforms to the specified type requirements.\n     *\n     * @param typeArgs - The expected type arguments.\n     * @param arg - The argument to be checked.\n     * @param position - The position of the argument in the context of the check.\n     * @param moduleAbi - The ABI of the module containing the function, used for type checking.\n     *                    This will typically have information about structs, enums, and other types.\n     * @group Implementation\n     * @category Transactions\n     */\n    checkType(param, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, param, position, genericTypeParams, moduleAbi, options);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively.\n * This function helps convert various types of input arguments into their corresponding BCS encoded formats based on the\n * specified parameter type.\n *\n * @param arg - The argument to be parsed, which can be of various types.\n * @param param - The type tag that defines the expected type of the argument.\n * @param position - The position of the argument in the function call, used for error reporting.\n * @param genericTypeParams - An array of type tags for generic type parameters, used when the parameter type is generic.\n * @param moduleAbi - The ABI of the module containing the function, used for type checking.\n *                    This will typically have information about structs, enums, and other types.\n * @param options - Options for the conversion process.\n * @param options.allowUnknownStructs - If true, unknown structs will be allowed and converted to a `FixedBytes`.\n * @group Implementation\n * @category Transactions\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n  moduleAbi?: MoveModule,\n  options?: { allowUnknownStructs?: boolean },\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    if (isString(arg)) {\n      if (arg === \"true\") return new Bool(true);\n      if (arg === \"false\") return new Bool(false);\n    }\n\n    /**\n     * Throws a type mismatch error for the specified move option.\n     *\n     * @param moveOption - The name of the move option that caused the type mismatch.\n     * @param position - The position where the error occurred.\n     * @group Implementation\n     * @category Transactions\n     */\n    throwTypeMismatch(\"boolean\", position);\n  }\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    // Support for Uint8Array coming from external sources\n    // Usually, dapps will be getting the account address as a Uint8Array from the wallet (following\n    // the wallet standard).\n    if (arg && typeof arg === \"object\" && \"data\" in arg && arg.data instanceof Uint8Array) {\n      return new AccountAddress(arg.data);\n    }\n    throwTypeMismatch(\"string | AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U8(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU16()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U16(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU32()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U32(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the subtype\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams, moduleAbi);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8()) {\n      // We don't allow vector<u8>, but we convert strings to UTF8 Uint8Array\n      // This is legacy behavior from the original SDK\n      if (isString(arg)) {\n        return MoveVector.U8(TEXT_ENCODER.encode(arg));\n      }\n      if (arg instanceof Uint8Array) {\n        return MoveVector.U8(arg);\n      }\n      if (arg instanceof ArrayBuffer) {\n        return MoveVector.U8(new Uint8Array(arg));\n      }\n    }\n\n    if (isString(arg)) {\n      // In a web env, arguments are passing as strings\n      if (arg.startsWith(\"[\")) {\n        return checkOrConvertArgument(JSON.parse(arg), param, position, genericTypeParams);\n      }\n    }\n\n    // TODO: Support Uint16Array, Uint32Array, BigUint64Array?\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(\n        arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams, moduleAbi)),\n      );\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      // Support for Uint8Array coming from external sources\n      if (arg && typeof arg === \"object\" && \"data\" in arg && arg.data instanceof Uint8Array) {\n        return new AccountAddress(arg.data);\n      }\n      throwTypeMismatch(\"string | AccountAddress\", position);\n    }\n    // Handle known enum types from Aptos framework\n    if (param.isDelegationKey() || param.isRateLimiter()) {\n      if (arg instanceof Uint8Array) {\n        return new FixedBytes(arg);\n      }\n      throwTypeMismatch(\"Uint8Array\", position);\n    }\n\n    if (param.isOption()) {\n      if (isEmptyOption(arg)) {\n        // Here we attempt to reconstruct the underlying type\n        // Note, for some reason the `isBool` etc. does not work with the compiler\n        const innerParam = param.value.typeArgs[0];\n        if (innerParam instanceof TypeTagBool) {\n          return new MoveOption<Bool>(null);\n        }\n        if (innerParam instanceof TypeTagAddress) {\n          return new MoveOption<AccountAddress>(null);\n        }\n        if (innerParam instanceof TypeTagU8) {\n          return new MoveOption<U8>(null);\n        }\n        if (innerParam instanceof TypeTagU16) {\n          return new MoveOption<U16>(null);\n        }\n        if (innerParam instanceof TypeTagU32) {\n          return new MoveOption<U32>(null);\n        }\n        if (innerParam instanceof TypeTagU64) {\n          return new MoveOption<U64>(null);\n        }\n        if (innerParam instanceof TypeTagU128) {\n          return new MoveOption<U128>(null);\n        }\n        if (innerParam instanceof TypeTagU256) {\n          return new MoveOption<U256>(null);\n        }\n\n        // In all other cases, we will use a placeholder, it doesn't actually matter what the type is, but it will be obvious\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<MoveString>(null);\n      }\n\n      return new MoveOption(\n        checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams, moduleAbi),\n      );\n    }\n\n    // We are assuming that fieldless structs are enums, and therefore we cannot typecheck any further due\n    // to limited information from the ABI. This does not work for structs on other modules.\n    const structDefinition = moduleAbi?.structs.find((s) => s.name === param.value.name.identifier);\n    if (structDefinition?.fields.length === 0 && arg instanceof Uint8Array) {\n      return new FixedBytes(arg);\n    }\n\n    if (arg instanceof Uint8Array && options?.allowUnknownStructs) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        // eslint-disable-next-line max-len\n        `Unsupported struct input type for argument ${position}. Continuing since 'allowUnknownStructs' is enabled.`,\n      );\n      return new FixedBytes(arg);\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of the BCS encoded argument matches the ABI\n * @param param\n * @param arg\n * @param position\n * @group Implementation\n * @category Transactions\n */\nfunction checkType(param: TypeTag, arg: EntryFunctionArgumentTypes, position: number) {\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // If there's anything in it, check that the inner types match\n      // Note that since it's typed, the first item should be the same as the rest\n      if (arg.values.length > 0) {\n        checkType(param.value, arg.values[0], position);\n      }\n\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // If there's a value, we can check the inner type (otherwise it doesn't really matter)\n        if (arg.value !== undefined) {\n          checkType(param.value.typeArgs[0], arg.value, position);\n        }\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n", "/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Deserializer, MoveVector } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account, AbstractKeylessAccount, isKeylessSigner } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { FederatedKeylessPublicKey, KeylessPublicKey, KeylessSignature } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  AnyTransactionPayloadInstance,\n  EntryFunctionABI,\n  InputTransactionPluginData,\n} from \"../transactions/types\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput } from \"../types\";\nimport { SignedTransaction, TypeTagVector, generateSigningMessageForTransaction } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../transactions/instances/multiAgentTransaction\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n * @group Implementation\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses?: Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n * @group Implementation\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\n/**\n * Builds a transaction payload based on the provided configuration and input data.\n * This function is essential for preparing transaction data for execution on the Aptos blockchain.\n *\n * @param args - The arguments for building the transaction payload.\n * @param args.aptosConfig - Configuration settings for the Aptos network.\n * @param args.data - Input data required to generate the transaction payload, which may include bytecode, multisig address,\n * function name, function arguments, type arguments, and ABI.\n * @returns A promise that resolves to the generated transaction payload instance.\n * @group Implementation\n */\nexport async function buildTransactionPayload(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { aptosConfig, data } = args;\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n\n  if (\"bytecode\" in data) {\n    // TODO: Add ABI checking later\n    payload = await generateTransactionPayload(data);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\n/**\n * Builds a raw transaction based on the provided configuration and payload.\n * This function helps in creating a transaction that can be sent to the Aptos blockchain.\n *\n * @param args - The arguments for generating the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The address of the sender of the transaction.\n * @param args.options - Additional options for the transaction.\n * @param payload - The payload of the transaction, which defines the action to be performed.\n * @group Implementation\n */\nexport async function buildRawTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\n/**\n * Determine if the transaction input includes a fee payer.\n *\n * @param data - The input data for generating a transaction.\n * @param data.withFeePayer - Indicates whether a fee payer is included in the transaction input.\n * @returns A boolean value indicating if the transaction input has a fee payer.\n * @group Implementation\n */\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\n/**\n * Determines whether the provided transaction input data includes multiple agent signatures.\n *\n * @param data - The transaction input data to evaluate.\n * @param data.secondarySignerAddresses - An array of secondary signer addresses, indicating multiple agents.\n * @group Implementation\n */\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers.\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK.\n *\n * @param args - The arguments for generating the signing message.\n * @param args.transaction - AnyRawTransaction, as generated by `generateTransaction()`.\n *\n * @returns The message to be signed.\n * @group Implementation\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessageForTransaction(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to the chain.\n *\n * @param args The arguments for signing the transaction.\n * @param args.signer The signer account to sign the transaction.\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n *\n * @return The signer AccountAuthenticator.\n * @group Implementation\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n  return signer.signTransactionWithAuthenticator(transaction);\n}\n\nexport function signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n\n  // if transaction doesn't hold a \"feePayerAddress\" prop it means\n  // this is not a fee payer transaction\n  if (!transaction.feePayerAddress) {\n    throw new Error(`Transaction ${transaction} is not a Fee Payer transaction`);\n  }\n\n  // Set the feePayerAddress to the signer account address\n  transaction.feePayerAddress = signer.accountAddress;\n\n  return signTransaction({\n    signer,\n    transaction,\n  });\n}\n\n/**\n * Simulates a transaction before signing it to evaluate its potential outcome.\n *\n * @param args The arguments for simulating the transaction.\n * @param args.aptosConfig The configuration for the Aptos network.\n * @param args.transaction The raw transaction to simulate.\n * @param args.signerPublicKey Optional. The signer public key.\n * @param args.secondarySignersPublicKeys Optional. For when the transaction involves multiple signers.\n * @param args.feePayerPublicKey Optional. For when the transaction is sponsored by a fee payer.\n * @param args.options Optional. A configuration object to customize the simulation process.\n * @param args.options.estimateGasUnitPrice Optional. Indicates whether to estimate the gas unit price.\n * @param args.options.estimateMaxGasAmount Optional. Indicates whether to estimate the maximum gas amount.\n * @param args.options.estimatePrioritizedGasUnitPrice Optional. Indicates whether to estimate the prioritized gas unit price.\n * @group Implementation\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit a transaction to the Aptos blockchain.\n *\n * @param args - The arguments for submitting the transaction.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.transaction - The Aptos transaction data to be submitted.\n * @param args.senderAuthenticator - The account authenticator of the transaction sender.\n * @param args.secondarySignerAuthenticators - Optional. Authenticators for additional signers in a multi-signer transaction.\n *\n * @returns PendingTransactionResponse - The response containing the status of the submitted transaction.\n * @group Implementation\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, transactionSubmitter } = args;\n  const maybeTransactionSubmitter =\n    transactionSubmitter === undefined ? aptosConfig.getTransactionSubmitter() : transactionSubmitter;\n  if (maybeTransactionSubmitter) {\n    return maybeTransactionSubmitter.submitTransaction(args);\n  }\n  const signedTransaction = generateSignedTransaction({ ...args });\n  try {\n    const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n      aptosConfig,\n      body: signedTransaction,\n      path: \"transactions\",\n      originMethod: \"submitTransaction\",\n      contentType: MimeType.BCS_SIGNED_TRANSACTION,\n    });\n    return data;\n  } catch (e) {\n    const signedTxn = SignedTransaction.deserialize(new Deserializer(signedTransaction));\n    if (\n      signedTxn.authenticator.isSingleSender() &&\n      signedTxn.authenticator.sender.isSingleKey() &&\n      (signedTxn.authenticator.sender.public_key.publicKey instanceof KeylessPublicKey ||\n        signedTxn.authenticator.sender.public_key.publicKey instanceof FederatedKeylessPublicKey)\n    ) {\n      await AbstractKeylessAccount.fetchJWK({\n        aptosConfig,\n        publicKey: signedTxn.authenticator.sender.public_key.publicKey,\n        kid: (signedTxn.authenticator.sender.signature.signature as KeylessSignature).getJwkKid(),\n      });\n    }\n    throw e;\n  }\n}\n\nexport type FeePayerOrFeePayerAuthenticatorOrNeither =\n  | { feePayer: Account; feePayerAuthenticator?: never }\n  | { feePayer?: never; feePayerAuthenticator: AccountAuthenticator }\n  | { feePayer?: never; feePayerAuthenticator?: never };\n\nexport async function signAndSubmitTransaction(\n  args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n    aptosConfig: AptosConfig;\n    signer: Account;\n    transaction: AnyRawTransaction;\n  } & InputTransactionPluginData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, feePayer, transaction, ...rest } = args;\n  // If the signer contains a KeylessAccount, await proof fetching in case the proof\n  // was fetched asynchronously.\n  if (isKeylessSigner(signer)) {\n    await signer.checkKeylessAccountValidity(aptosConfig);\n  }\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n  const feePayerAuthenticator =\n    args.feePayerAuthenticator || (feePayer && signAsFeePayer({ signer: feePayer, transaction }));\n\n  const senderAuthenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n    ...rest,\n  });\n}\n\nexport async function signAndSubmitAsFeePayer(\n  args: {\n    aptosConfig: AptosConfig;\n    feePayer: Account;\n    senderAuthenticator: AccountAuthenticator;\n    transaction: AnyRawTransaction;\n  } & InputTransactionPluginData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, senderAuthenticator, feePayer, transaction, ...rest } = args;\n\n  if (isKeylessSigner(feePayer)) {\n    await feePayer.checkKeylessAccountValidity(aptosConfig);\n  }\n\n  const feePayerAuthenticator = signAsFeePayer({ signer: feePayer, transaction });\n\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator,\n    feePayerAuthenticator,\n    ...rest,\n  });\n}\n\nconst packagePublishAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8(), new TypeTagVector(TypeTagVector.u8())],\n};\n\n/**\n * Publishes a package transaction to the Aptos blockchain.\n * This function allows you to create and send a transaction that publishes a package with the specified metadata and bytecode.\n *\n * @param args - The arguments for the package transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.account - The address of the account sending the transaction.\n * @param args.metadataBytes - The metadata associated with the package, represented as hexadecimal input.\n * @param args.moduleBytecode - An array of module bytecode, each represented as hexadecimal input.\n * @param args.options - Optional parameters for generating the transaction.\n * @group Implementation\n */\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  return generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n      abi: packagePublishAbi,\n    },\n    options,\n  });\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n * @group Implementation\n */\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  getAptosFullNode,\n  getPageWithObfuscatedCursor,\n  paginateWithCursor,\n  paginateWithObfuscatedCursor,\n} from \"../client\";\nimport {\n  AccountData,\n  AnyNumber,\n  anyPublicKeyVariantToString,\n  CommittedTransactionResponse,\n  CursorPaginationArgs,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TokenStandardArg,\n  WhereArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport {\n  Account,\n  Ed25519Account,\n  FederatedKeylessAccount,\n  KeylessAccount,\n  MultiEd25519Account,\n  MultiKeyAccount,\n  SingleKeyAccount,\n} from \"../account\";\nimport {\n  AbstractMultiKey,\n  AccountPublicKey,\n  AnyPublicKey,\n  BaseAccountPublicKey,\n  Ed25519PublicKey,\n  MultiEd25519PublicKey,\n  MultiKey,\n  PrivateKeyInput,\n} from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport { getModule as getModuleUtil, getInfo as getInfoUtil } from \"./utils\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetObjectDataQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n  GetAuthKeysForPublicKeyQuery,\n  GetAccountAddressesForAuthKeyQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetObjectData,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n  GetAuthKeysForPublicKey,\n  GetAccountAddressesForAuthKey,\n} from \"../types/generated/queries\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey, createObjectAddress, Hex } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\nimport { APTOS_COIN } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\nimport { Deserializer } from \"../bcs\";\nimport { signAndSubmitTransaction, generateTransaction } from \"./transactionSubmission\";\nimport {\n  EntryFunctionABI,\n  InputGenerateTransactionOptions,\n  RotationProofChallenge,\n  TypeTagU8,\n  TypeTagVector,\n} from \"../transactions\";\nimport { U8, MoveVector } from \"../bcs\";\nimport { waitForTransaction, waitForIndexer } from \"./transaction\";\nimport { view } from \"./view\";\nimport { getLedgerInfo } from \"./general\";\n\n/**\n * Retrieves account information for a specified account address.\n *\n * @param args - The arguments for retrieving account information.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.accountAddress - The address of the account to retrieve information for.\n * @group Implementation\n */\nexport async function getInfo(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  return getInfoUtil(args);\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 1000).\n * @param args.options.offset - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: { limit?: number } & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Retrieves the modules associated with a specified account address.\n *\n * @param args - The arguments for retrieving modules.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account whose modules are to be retrieved.\n * @param args.options - Optional parameters for pagination and ledger version.\n * @param args.options.cursor - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.limit - The maximum number of modules to retrieve (default is 100).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getModulesPage(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: CursorPaginationArgs & LedgerVersionArg;\n}): Promise<{ modules: MoveModuleBytecode[]; cursor: string | undefined }> {\n  const { aptosConfig, accountAddress, options } = args;\n  const { response, cursor } = await getPageWithObfuscatedCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModulesPage\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      cursor: options?.cursor,\n      limit: options?.limit ?? 100,\n    },\n  });\n\n  return { modules: response.data, cursor };\n}\n\n/**\n * Queries for a move module given an account address and module name.\n * This function can help you retrieve the module's ABI and other relevant information.\n *\n * @param args - The arguments for retrieving the module.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The account address in hex-encoded 32 byte format.\n * @param args.moduleName - The name of the module to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - Specifies the ledger version of transactions. By default, the latest version will be used.\n * @returns The move module.\n * @group Implementation\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  return getModuleUtil(args);\n}\n\n/**\n * Retrieves a list of transactions associated with a specific account address.\n * This function allows you to paginate through the transactions for better performance and usability.\n *\n * @param args - The arguments for retrieving transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The account address for which to retrieve transactions.\n * @param args.options - Optional pagination parameters.\n * @param args.options.offset - The starting point for pagination.\n * @param args.options.limit - The maximum number of transactions to retrieve.\n * @group Implementation\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<CommittedTransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, CommittedTransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves a list of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 999).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: { limit?: number } & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithObfuscatedCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\n/**\n * Retrieves a page of resources associated with a specific account address.\n *\n * @param args - The arguments for retrieving resources.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account to fetch resources for.\n * @param args.options - Optional pagination and ledger version parameters.\n * @param args.options.cursor - The starting point for pagination.  Note, this is obfuscated and is not an index.\n * @param args.options.limit - The maximum number of resources to retrieve (default is 100).\n * @param args.options.ledgerVersion - The specific ledger version to query.\n * @group Implementation\n */\nexport async function getResourcesPage(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: CursorPaginationArgs & LedgerVersionArg;\n}): Promise<{ resources: MoveResource[]; cursor: string | undefined }> {\n  const { aptosConfig, accountAddress, options } = args;\n  const { response, cursor } = await getPageWithObfuscatedCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResourcesPage\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      cursor: options?.cursor,\n      limit: options?.limit ?? 100,\n    },\n  });\n\n  return { resources: response.data, cursor };\n}\n\n/**\n * Retrieves a specific resource of a given type for the specified account address.\n *\n * @param args - The arguments for retrieving the resource.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account from which to retrieve the resource.\n * @param args.resourceType - The type of the resource to retrieve, specified as a MoveStructId.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @group Implementation\n */\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\n/**\n * Retrieves the original account address associated with a given authentication key, which is useful for handling key rotations.\n *\n * @param args - The arguments for the lookup.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.authenticationKey - The authentication key for which to look up the original address.\n * @param args.options - Optional parameters for specifying the ledger version.\n * @returns The original account address or the provided authentication key address if not found.\n * @throws Throws an error if the lookup fails for reasons other than the address not being found.\n * @group Implementation\n */\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      aptosConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Retrieves the count of tokens owned by a specific account address.\n *\n * @param args - The arguments for retrieving the account tokens count.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to count the tokens.\n * @returns The count of tokens owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\n/**\n * Retrieves the tokens owned by a specified account address.\n *\n * @param args - The arguments for retrieving the account's tokens.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The specific token standard to filter the results.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @returns A promise that resolves to the current token ownerships of the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n    {\n      owner_address: { _eq: address },\n      amount: { _gt: 0 },\n    };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the tokens owned by a specific account from a particular collection address.\n *\n * @param args - The parameters required to fetch the owned tokens.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account whose tokens are being queried.\n * @param args.collectionAddress - The address of the collection from which tokens are being retrieved.\n * @param args.options - Optional parameters for filtering and pagination, including token standard, pagination arguments, and\n * order by options.\n * @group Implementation\n */\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the collections owned by a specified account along with the tokens in those collections.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose collections are being queried.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - An optional token standard to filter the collections.\n * @param args.options.offset - An optional offset for pagination.\n * @param args.options.limit - An optional limit for the number of results returned.\n * @param args.options.orderBy - An optional parameter to specify the order of the results.\n * @group Implementation\n */\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\n/**\n * Retrieves the count of transactions associated with a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.accountAddress - The address of the account for which to retrieve the transaction count.\n * @returns The number of transactions associated with the specified account.\n * @group Implementation\n */\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\n/**\n * Retrieves the amount of a specific coin held by an account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.accountAddress - The address of the account to query.\n * @param args.coinType - Optional; the type of coin to check the amount for.\n * @param args.faMetadataAddress - Optional; the address of the fungible asset metadata.\n * @returns The amount of the specified coin held by the account, or 0 if none is found.\n * @throws Error if neither coinType nor faMetadataAddress is provided.\n * @group Implementation\n */\nexport async function getAccountCoinAmount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  coinType?: MoveStructId;\n  faMetadataAddress?: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress, coinType, faMetadataAddress } = args;\n\n  let coinAssetType: string | undefined = coinType;\n  let faAddress: string;\n\n  if (coinType !== undefined && faMetadataAddress !== undefined) {\n    faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n  } else if (coinType !== undefined && faMetadataAddress === undefined) {\n    // TODO Move to a separate function as defined in the AIP for coin migration\n    if (coinType === APTOS_COIN) {\n      faAddress = AccountAddress.A.toStringLong();\n    } else {\n      faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n    }\n  } else if (coinType === undefined && faMetadataAddress !== undefined) {\n    const addr = AccountAddress.from(faMetadataAddress);\n    faAddress = addr.toStringLong();\n    if (addr === AccountAddress.A) {\n      coinAssetType = APTOS_COIN;\n    }\n    // The paired CoinType should be populated outside of this function in another\n    // async call. We cannot do this internally due to dependency cycles issue.\n  } else {\n    throw new Error(\"Either coinType, fungibleAssetAddress, or both must be provided\");\n  }\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  // Search by fungible asset address, unless it has a coin it migrated from\n  let where: any = { asset_type: { _eq: faAddress } };\n  if (coinAssetType !== undefined) {\n    where = { asset_type: { _in: [coinAssetType, faAddress] } };\n  }\n\n  const data = await getAccountCoinsData({\n    aptosConfig,\n    accountAddress: address,\n    options: {\n      where,\n    },\n  });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data[0] ? data[0].amount : 0;\n}\n\n/**\n * Retrieves the current fungible asset balances for a specified account.\n *\n * @param args - The arguments for retrieving account coins data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve coin data.\n * @param args.options - Optional parameters for pagination and filtering the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n * @param args.options.where - Conditions to filter the results based on the current fungible asset balances.\n * @group Implementation\n */\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountCoinsDataResponse[0]> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    ...options?.where,\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\n/**\n * Retrieves the count of fungible asset coins held by a specified account.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The address of the account for which to retrieve the coin count.\n * @throws Error if the count of account coins cannot be retrieved.\n * @group Implementation\n */\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\n/**\n * Retrieves the objects owned by a specified account.\n *\n * @param args - The parameters for the request.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account whose owned objects are to be retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @param args.options.offset - The number of items to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of items to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to the current objects owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Derives an account from the provided private key and Aptos configuration.\n *\n * This function queries all owned accounts for the provided private key and returns the most\n * recently used account. If no account is found, it will throw an error unless `throwIfNoAccountFound` is set to false.\n *\n * If `throwIfNoAccountFound` is set to false, the function will return the default account for the private key via `Account.fromPrivateKey`.\n *\n * NOTE: There is a potential issue once the unified single signer scheme is adopted by the community.\n * Because one could create two accounts with the same private key with this new authenticator type,\n * we'll need to determine the order in which we look up the accounts: first unified scheme and then legacy scheme,\n * or first legacy scheme and then unified scheme.\n *\n * @param args - The arguments for deriving the account.\n * @param args.aptosConfig - The Aptos configuration used for account lookup.\n * @param args.privateKey - The private key used to derive the account.\n * @param args.options.throwIfNoAccountFound - If true, throw an error if no existing account is found on chain. Default is false.\n * @throws Error if the account cannot be derived from the private key.\n * @group Implementation\n * @deprecated Note that more inspection is needed by the user to determine which account exists on-chain\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKeyInput;\n  options?: {\n    throwIfNoAccountFound?: boolean;\n  };\n}): Promise<Account> {\n  const { aptosConfig, privateKey, options } = args;\n  const throwIfNoAccountFound = options?.throwIfNoAccountFound ?? false;\n\n  const accounts = await deriveOwnedAccountsFromPrivateKey({ aptosConfig, privateKey });\n  if (accounts.length === 0) {\n    if (throwIfNoAccountFound) {\n      throw new Error(`No existing account found for private key.`);\n    }\n    // If no account is found, return the default account. This is a legacy account for Ed25519 private keys.\n    return Account.fromPrivateKey({ privateKey });\n  }\n  return accounts[0];\n}\n\n/**\n * Checks if an account exists by verifying its information against the Aptos blockchain.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.authKey - The authentication key used to derive the account address.\n * @returns A promise that resolves to a boolean indicating whether the account exists.\n *\n * @throws Throws an Error if there is an issue while looking for account information.\n * @group Implementation\n */\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  return doesAccountExistAtAddress({ aptosConfig, accountAddress });\n}\n\n/**\n * Checks if an account exists at a given address.\n *\n * @param args - The arguments for checking account existence.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param args.accountAddress - The address of the account to check.\n * @param args.options.withAuthKey - An optional authentication key which will also be checked against if provided.\n * @returns A promise that resolves to a boolean indicating whether the account exists.\n * @group Implementation\n */\nasync function doesAccountExistAtAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddress;\n  options?: { withAuthKey?: AuthenticationKey };\n}): Promise<boolean> {\n  const { aptosConfig, accountAddress, options } = args;\n  try {\n    // Get the account resources and the balance of the account.  We need to check both because\n    // an account resource can exist with 0 balance and a balance can exist without an account resource (light accounts).\n    const [resources, ownedObjects] = await Promise.all([\n      getResources({\n        aptosConfig,\n        accountAddress,\n      }),\n      getAccountOwnedObjects({\n        aptosConfig,\n        accountAddress,\n        options: {\n          limit: 1,\n        },\n      }),\n    ]);\n\n    const accountResource: MoveResource<{ authentication_key: string }> | undefined = resources.find(\n      (r) => r.type === \"0x1::account::Account\",\n    ) as MoveResource<{ authentication_key: string }> | undefined;\n\n    // If the account resource is not found and the balance is 0, then the account does not exist.\n    if (!accountResource && ownedObjects.length === 0) {\n      return false;\n    }\n\n    // If no auth key is provided as an argument, return true.\n    if (!options?.withAuthKey) {\n      return true;\n    }\n\n    // Get the auth key from the account resource if it exists. If the account resource does not exist,\n    // then the auth key is the account address by default.\n    let authKey;\n    if (accountResource) {\n      authKey = accountResource.data.authentication_key;\n    } else {\n      authKey = accountAddress.toStringLong();\n    }\n\n    if (authKey !== options.withAuthKey.toString()) {\n      return false;\n    }\n\n    // Else the account exists and the auth key matches.\n    return true;\n  } catch (error: any) {\n    throw new Error(`Error while checking if account exists at ${accountAddress.toString()}: ${error}`);\n  }\n}\n\nconst rotateAuthKeyAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Rotates the authentication key for a given account.\n *\n * @param args - The arguments for rotating the authentication key.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.fromAccount - The account from which the authentication key will be rotated.\n * @param args.toAccount - (Optional) The target account to rotate to. Required if not using toNewPrivateKey or toAuthKey.\n * @param args.toNewPrivateKey - (Optional) The new private key to rotate to. Required if not using toAccount or toAuthKey.\n * @param args.toAuthKey - (Optional) The new authentication key to rotate to. Can only be used with dangerouslySkipVerification=true.\n * @param args.dangerouslySkipVerification - (Optional) If true, skips verification steps after rotation. Required when using toAuthKey.\n *\n * @remarks\n * This function supports three modes of rotation:\n * 1. Using a target Account object (toAccount)\n * 2. Using a new private key (toNewPrivateKey)\n * 3. Using a raw authentication key (toAuthKey) - requires dangerouslySkipVerification=true\n *\n * When not using dangerouslySkipVerification, the function performs additional safety checks and account setup.\n *\n * If the new key is a multi key, skipping verification is dangerous because verification will publish the public key onchain and\n * prevent users from being locked out of the account from loss of knowledge of one of the public keys.\n *\n * @returns A promise that resolves to the pending transaction response.\n * @throws Error if the rotation fails or verification fails.\n *\n * @group Implementation\n */\nexport async function rotateAuthKey(\n  args: {\n    aptosConfig: AptosConfig;\n    fromAccount: Account;\n    options?: InputGenerateTransactionOptions;\n  } & (\n    | { toAccount: Account; dangerouslySkipVerification?: never }\n    | { toNewPrivateKey: Ed25519PrivateKey; dangerouslySkipVerification?: never }\n    | { toAuthKey: AuthenticationKey; dangerouslySkipVerification: true }\n  ),\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, dangerouslySkipVerification, options } = args;\n  if (\"toNewPrivateKey\" in args) {\n    return rotateAuthKeyWithChallenge({\n      aptosConfig,\n      fromAccount,\n      toNewPrivateKey: args.toNewPrivateKey,\n      options,\n    });\n  }\n  let authKey: AuthenticationKey;\n  if (\"toAccount\" in args) {\n    if (args.toAccount instanceof Ed25519Account) {\n      return rotateAuthKeyWithChallenge({\n        aptosConfig,\n        fromAccount,\n        toNewPrivateKey: args.toAccount.privateKey,\n        options,\n      });\n    }\n    if (args.toAccount instanceof MultiEd25519Account) {\n      return rotateAuthKeyWithChallenge({ aptosConfig, fromAccount, toAccount: args.toAccount, options });\n    }\n    authKey = args.toAccount.publicKey.authKey();\n  } else if (\"toAuthKey\" in args) {\n    authKey = args.toAuthKey;\n  } else {\n    throw new Error(\"Invalid arguments\");\n  }\n\n  const pendingTxn = await rotateAuthKeyUnverified({\n    aptosConfig,\n    fromAccount,\n    toAuthKey: authKey,\n    options,\n  });\n\n  if (dangerouslySkipVerification === true) {\n    return pendingTxn;\n  }\n\n  const rotateAuthKeyTxnResponse = await waitForTransaction({\n    aptosConfig,\n    transactionHash: pendingTxn.hash,\n  });\n  if (!rotateAuthKeyTxnResponse.success) {\n    throw new Error(`Failed to rotate authentication key - ${rotateAuthKeyTxnResponse}`);\n  }\n\n  // Verify the rotation by setting the originating address to the new account.\n  // This verifies the rotation even if the transaction payload fails to execute successfully.\n  const verificationTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::set_originating_address\",\n      functionArguments: [],\n    },\n  });\n\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: args.toAccount, // Use the new account to sign\n    transaction: verificationTxn,\n  });\n}\n\nasync function rotateAuthKeyWithChallenge(\n  args: {\n    aptosConfig: AptosConfig;\n    fromAccount: Account;\n    options?: InputGenerateTransactionOptions;\n  } & ({ toNewPrivateKey: Ed25519PrivateKey } | { toAccount: MultiEd25519Account }),\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, options } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  let newAccount: Account;\n  if (\"toNewPrivateKey\" in args) {\n    newAccount = Account.fromPrivateKey({ privateKey: args.toNewPrivateKey, legacy: true });\n  } else {\n    newAccount = args.toAccount;\n  }\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewKey.toUint8Array()),\n      ],\n      abi: rotateAuthKeyAbi,\n    },\n    options,\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n\nconst rotateAuthKeyUnverifiedAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8()],\n};\n\nasync function rotateAuthKeyUnverified(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toAuthKey: AuthenticationKey;\n  options?: InputGenerateTransactionOptions;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, fromAccount, toAuthKey, options } = args;\n  const authKey = toAuthKey;\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key_call\",\n      functionArguments: [MoveVector.U8(authKey.toUint8Array())],\n      abi: rotateAuthKeyUnverifiedAbi,\n    },\n    options,\n  });\n  return signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n\nexport type AccountInfo = {\n  accountAddress: AccountAddress;\n  publicKey: BaseAccountPublicKey;\n  lastTransactionVersion: number;\n};\n\nexport async function getAccountsForPublicKey(args: {\n  aptosConfig: AptosConfig;\n  publicKey: BaseAccountPublicKey;\n  options?: { includeUnverified?: boolean; noMultiKey?: boolean };\n}): Promise<AccountInfo[]> {\n  const { aptosConfig, publicKey, options } = args;\n  const noMultiKey = options?.noMultiKey ?? false;\n  if (noMultiKey && publicKey instanceof AbstractMultiKey) {\n    throw new Error(\"Multi-key accounts are not supported when noMultiKey is true.\");\n  }\n  const allPublicKeys: BaseAccountPublicKey[] = [publicKey];\n\n  // For Ed25519, we add the both the legacy Ed25519PublicKey and the new AnyPublicKey form.\n  if (publicKey instanceof AnyPublicKey && publicKey.publicKey instanceof Ed25519PublicKey) {\n    allPublicKeys.push(publicKey.publicKey);\n  } else if (publicKey instanceof Ed25519PublicKey) {\n    allPublicKeys.push(new AnyPublicKey(publicKey));\n  }\n\n  // Run both operations in parallel\n  const [defaultAccountData, multiPublicKeys] = await Promise.all([\n    // Check the provided public key for the default account. In the case of Ed25519, this will check both the legacy Ed25519PublicKey\n    // and the AnyPublicKey form and may an existing account for each.\n    Promise.all(\n      allPublicKeys.map(async (publicKey) => {\n        const addressAndLastTxnVersion = await getDefaultAccountInfoForPublicKey({ aptosConfig, publicKey });\n        if (addressAndLastTxnVersion) {\n          return { ...addressAndLastTxnVersion, publicKey };\n        }\n        return undefined;\n      }),\n    ),\n    // Get multi-keys for the provided public key if not already a multi-key.\n    !(publicKey instanceof AbstractMultiKey) && !noMultiKey\n      ? getMultiKeysForPublicKey({ aptosConfig, publicKey, options })\n      : Promise.resolve([]),\n  ]);\n\n  const result: {\n    accountAddress: AccountAddress;\n    publicKey: BaseAccountPublicKey;\n    lastTransactionVersion: number;\n  }[] = [];\n\n  // Add any default accounts that exist to the result.\n  for (const data of defaultAccountData) {\n    if (data) {\n      result.push(data);\n    }\n  }\n\n  // Add any multi-keys to allPublicKeys\n  allPublicKeys.push(...multiPublicKeys);\n\n  // Get a map of the auth key to the public key for all public keys.\n  const authKeyToPublicKey = new Map(allPublicKeys.map((key) => [key.authKey().toString(), key]));\n\n  // Get the account addresses for the auth keys.\n  const authKeyAccountAddressPairs = await getAccountAddressesForAuthKeys({\n    aptosConfig,\n    authKeys: allPublicKeys.map((key) => key.authKey()),\n    options,\n  });\n\n  for (const authKeyAccountAddressPair of authKeyAccountAddressPairs) {\n    // Skip if the account address is already in the result.\n    // This can happen in the rare edge case where the default account has been rotated but has been rotated back to the original auth key.\n    if (result.find((r) => r.accountAddress === authKeyAccountAddressPair.accountAddress)) {\n      continue;\n    }\n    // Get the public key for the auth key using the map we created earlier.\n    const publicKey = authKeyToPublicKey.get(authKeyAccountAddressPair.authKey.toString());\n    if (!publicKey) {\n      throw new Error(\n        `No publicKey found for authentication key ${authKeyAccountAddressPair.authKey}. This should never happen.`,\n      );\n    }\n    result.push({\n      accountAddress: authKeyAccountAddressPair.accountAddress,\n      publicKey,\n      lastTransactionVersion: authKeyAccountAddressPair.lastTransactionVersion,\n    });\n  }\n  // Sort the result by the last transaction version in descending order (most recent first).\n  return result.sort((a, b) => b.lastTransactionVersion - a.lastTransactionVersion);\n}\n\nexport async function deriveOwnedAccountsFromSigner(args: {\n  aptosConfig: AptosConfig;\n  signer: Account | PrivateKeyInput;\n  options?: { includeUnverified?: boolean; noMultiKey?: boolean };\n}): Promise<Account[]> {\n  const { aptosConfig, signer, options } = args;\n\n  if (signer instanceof Ed25519PrivateKey || signer instanceof Secp256k1PrivateKey) {\n    return deriveOwnedAccountsFromPrivateKey({ aptosConfig, privateKey: signer, options });\n  }\n\n  if (signer instanceof Ed25519Account || signer instanceof SingleKeyAccount) {\n    return deriveOwnedAccountsFromPrivateKey({ aptosConfig, privateKey: signer.privateKey, options });\n  }\n\n  if (signer instanceof KeylessAccount || signer instanceof FederatedKeylessAccount) {\n    return deriveOwnedAccountsFromKeylessSigner({ aptosConfig, keylessAccount: signer, options });\n  }\n\n  if (signer instanceof MultiKeyAccount) {\n    if (signer.signers.length === 1) {\n      return deriveOwnedAccountsFromSigner({ aptosConfig, signer: signer.signers[0], options });\n    }\n  }\n\n  if (signer instanceof MultiEd25519Account) {\n    if (signer.signers.length === 1) {\n      return deriveOwnedAccountsFromPrivateKey({ aptosConfig, privateKey: signer.signers[0], options });\n    }\n  }\n\n  throw new Error(\"Unknown signer type\");\n}\n\nasync function deriveOwnedAccountsFromKeylessSigner(args: {\n  aptosConfig: AptosConfig;\n  keylessAccount: KeylessAccount | FederatedKeylessAccount;\n  options?: { includeUnverified?: boolean; noMultiKey?: boolean };\n}): Promise<Account[]> {\n  const { aptosConfig, keylessAccount, options } = args;\n  const addressesAndPublicKeys = await getAccountsForPublicKey({\n    aptosConfig,\n    publicKey: keylessAccount.getAnyPublicKey(),\n    options,\n  });\n\n  const keylessAccountParams = {\n    proof: keylessAccount.proofOrPromise,\n    jwt: keylessAccount.jwt,\n    ephemeralKeyPair: keylessAccount.ephemeralKeyPair,\n    pepper: keylessAccount.pepper,\n    verificationKeyHash: keylessAccount.verificationKeyHash,\n  };\n\n  const accounts: Account[] = [];\n  for (const { accountAddress, publicKey } of addressesAndPublicKeys) {\n    if (publicKey instanceof AbstractMultiKey) {\n      if (publicKey.getSignaturesRequired() > 1) {\n        continue;\n      }\n      if (publicKey instanceof MultiEd25519PublicKey) {\n        throw new Error(\"Keyless authentication cannot be used for multi-ed25519 accounts. This should never happen.\");\n      } else if (publicKey instanceof MultiKey) {\n        accounts.push(new MultiKeyAccount({ multiKey: publicKey, signers: [keylessAccount], address: accountAddress }));\n      }\n    } else {\n      if (keylessAccount instanceof FederatedKeylessAccount) {\n        accounts.push(\n          FederatedKeylessAccount.create({\n            ...keylessAccountParams,\n            address: accountAddress,\n            jwkAddress: keylessAccount.publicKey.jwkAddress,\n          }),\n        );\n      } else {\n        accounts.push(\n          KeylessAccount.create({\n            ...keylessAccountParams,\n            address: accountAddress,\n          }),\n        );\n      }\n    }\n  }\n  return accounts;\n}\n\nasync function deriveOwnedAccountsFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: Ed25519PrivateKey | Secp256k1PrivateKey;\n  options?: { includeUnverified?: boolean; noMultiKey?: boolean };\n}): Promise<Account[]> {\n  const { aptosConfig, privateKey, options } = args;\n  const singleKeyAccount = Account.fromPrivateKey({ privateKey, legacy: false });\n  const addressesAndPublicKeys = await getAccountsForPublicKey({\n    aptosConfig,\n    publicKey: new AnyPublicKey(privateKey.publicKey()),\n    options,\n  });\n\n  const accounts: Account[] = [];\n\n  // Iterate through the addressesAndPublicKeys and construct the accounts.\n  for (const { accountAddress, publicKey } of addressesAndPublicKeys) {\n    if (publicKey instanceof AbstractMultiKey) {\n      // Skip multi-key accounts with more than 1 signature required as the user does not have full ownership with just 1 private key.\n      if (publicKey.getSignaturesRequired() > 1) {\n        continue;\n      }\n      // Construct the appropriate multi-key type.\n      if (publicKey instanceof MultiEd25519PublicKey) {\n        accounts.push(\n          new MultiEd25519Account({ publicKey, signers: [privateKey as Ed25519PrivateKey], address: accountAddress }),\n        );\n      } else if (publicKey instanceof MultiKey) {\n        accounts.push(\n          new MultiKeyAccount({ multiKey: publicKey, signers: [singleKeyAccount], address: accountAddress }),\n        );\n      }\n    } else {\n      // Check if the public key is a legacy Ed25519PublicKey, if so, we need to use the legacy account constructor.\n      const isLegacy = publicKey instanceof Ed25519PublicKey;\n      accounts.push(Account.fromPrivateKey({ privateKey, address: accountAddress, legacy: isLegacy }));\n    }\n  }\n  return accounts;\n}\n\n/**\n * Gets the multi-keys for a given public key.\n *\n * This function retrieves the multi-keys that contain the provided public key.\n * It performs the following steps:\n * 1. Constructs a where condition for the public key where the public key matches the provided public key.\n * 2. Queries the indexer for the multi-keys.\n * 3. Returns the multi-keys.\n *\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.publicKey - The public key to get the multi-keys for. This public key cannot itself be a multi-key.\n * @returns The multi-keys (MultiKey or MultiEd25519PublicKey) that contain the given public key.\n */\nasync function getMultiKeysForPublicKey(args: {\n  aptosConfig: AptosConfig;\n  publicKey: Ed25519PublicKey | AnyPublicKey;\n  options?: { includeUnverified?: boolean };\n}): Promise<(MultiKey | MultiEd25519PublicKey)[]> {\n  const { aptosConfig, publicKey, options } = args;\n  if (publicKey instanceof AbstractMultiKey) {\n    throw new Error(\"Public key is a multi-key.\");\n  }\n  const includeUnverified = options?.includeUnverified ?? false;\n  const anyPublicKey = publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey);\n  const baseKey = anyPublicKey.publicKey;\n  const variant = anyPublicKeyVariantToString(anyPublicKey.variant);\n\n  const whereCondition: any = {\n    public_key: { _eq: baseKey.toString() },\n    public_key_type: { _eq: variant },\n    ...(includeUnverified ? {} : { is_public_key_used: { _eq: true } }),\n  };\n\n  const graphqlQuery = {\n    query: GetAuthKeysForPublicKey,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const { public_key_auth_keys: data } = await queryIndexer<GetAuthKeysForPublicKeyQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getMultiKeysForPublicKey\",\n  });\n\n  const authKeys = data.map((entry) => {\n    switch (entry.signature_type) {\n      case \"multi_ed25519_signature\":\n        return MultiEd25519PublicKey.deserializeWithoutLength(Deserializer.fromHex(entry.account_public_key!));\n      case \"multi_key_signature\":\n        return MultiKey.deserialize(Deserializer.fromHex(entry.account_public_key!));\n      default:\n        throw new Error(`Unknown multi-signature type: ${entry.signature_type}`);\n    }\n  });\n  return authKeys;\n}\n\n/**\n * Gets the account addresses for the given authentication keys.\n *\n * This function retrieves the account addresses that are associated with the provided authentication keys.\n * It performs the following steps:\n * 1. Constructs a where condition for the authentication keys where auth key matches any of the provided auth keys.\n * 2. Queries the indexer for the account addresses and gets the results ordered by the last transaction version (most recent first).\n * 3. Returns the account addresses.\n *\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.authKeys - The authentication keys to get the account addresses for.\n * @param args.options.includeUnverified - Whether to include unverified accounts in the results. Unverified accounts\n * are accounts that can be authenticated with the signer, but there is no history of the signer using the account.\n * Default is false.\n * @returns The account addresses associated with the given authentication keys.\n */\nasync function getAccountAddressesForAuthKeys(args: {\n  aptosConfig: AptosConfig;\n  authKeys: AuthenticationKey[];\n  options?: { includeUnverified?: boolean };\n}): Promise<{ authKey: AuthenticationKey; accountAddress: AccountAddress; lastTransactionVersion: number }[]> {\n  const { aptosConfig, authKeys, options } = args;\n  const includeUnverified = options?.includeUnverified ?? false;\n  if (authKeys.length === 0) {\n    throw new Error(\"No authentication keys provided\");\n  }\n  const whereCondition: any = {\n    auth_key: { _in: authKeys.map((authKey) => authKey.toString()) },\n    ...(includeUnverified ? {} : { is_auth_key_used: { _eq: true } }),\n  };\n\n  const graphqlQuery = {\n    query: GetAccountAddressesForAuthKey,\n    variables: {\n      where_condition: whereCondition,\n      order_by: [{ last_transaction_version: \"desc\" }],\n    },\n  };\n  const { auth_key_account_addresses: data } = await queryIndexer<GetAccountAddressesForAuthKeyQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountAddressesForAuthKeys\",\n  });\n  return data.map((entry) => ({\n    authKey: new AuthenticationKey({ data: entry.auth_key }),\n    accountAddress: new AccountAddress(Hex.hexInputToUint8Array(entry.account_address)),\n    lastTransactionVersion: Number(entry.last_transaction_version),\n  }));\n}\n\n/**\n * Returns the last transaction version that was signed by an account.\n *\n * If an account was created but has not signed any transactions, the last transaction version will be 0.\n *\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.accountAddress - The account address to get the latest transaction version for.\n * @returns The last transaction version that was signed by the account.\n */\nasync function getLatestTransactionVersionForAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const transactions = await getTransactions({ aptosConfig, accountAddress, options: { limit: 1 } });\n  if (transactions.length === 0) {\n    return 0;\n  }\n  return Number(transactions[0].version);\n}\n\n/**\n * Gets the default account info for a given public key. 'Default account' means the account\n * is address is the same as the auth key derived from the public key and the account auth key has\n * not been rotated.\n *\n * @param args - The arguments for getting the default account info for a given public key.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.publicKey - The public key to use to derive the address.\n * @returns An object containing the account address and the last transaction version, or undefined if the account does not exist.\n */\nasync function getDefaultAccountInfoForPublicKey(args: {\n  aptosConfig: AptosConfig;\n  publicKey: AccountPublicKey;\n}): Promise<{ accountAddress: AccountAddress; lastTransactionVersion: number } | undefined> {\n  const { aptosConfig, publicKey } = args;\n  const derivedAddress = publicKey.authKey().derivedAddress();\n\n  const [lastTransactionVersion, exists] = await Promise.all([\n    getLatestTransactionVersionForAddress({\n      aptosConfig,\n      accountAddress: derivedAddress,\n    }),\n    doesAccountExistAtAddress({\n      aptosConfig,\n      accountAddress: derivedAddress,\n      options: { withAuthKey: publicKey.authKey() },\n    }),\n  ]);\n  if (exists) {\n    return { accountAddress: derivedAddress, lastTransactionVersion };\n  }\n  return undefined;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { LedgerVersionArg, MimeType, MoveValue } from \"../types\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  generateViewFunctionPayload,\n  InputViewFunctionData,\n  InputViewFunctionJsonData,\n  ViewFunctionJsonPayload,\n} from \"../transactions\";\nimport { Serializer } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\n\nexport async function view<T extends Array<MoveValue> = Array<MoveValue>>(args: {\n  aptosConfig: AptosConfig;\n  payload: InputViewFunctionData;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, payload, options } = args;\n  const viewFunctionPayload = await generateViewFunctionPayload({\n    ...payload,\n    aptosConfig,\n  });\n\n  const serializer = new Serializer();\n  viewFunctionPayload.serialize(serializer);\n  const bytes = serializer.toUint8Array();\n\n  const { data } = await postAptosFullNode<Uint8Array, MoveValue[]>({\n    aptosConfig,\n    path: \"view\",\n    originMethod: \"view\",\n    contentType: MimeType.BCS_VIEW_FUNCTION,\n    params: { ledger_version: options?.ledgerVersion },\n    body: bytes,\n  });\n\n  return data as T;\n}\n\nexport async function viewJson<T extends Array<MoveValue> = Array<MoveValue>>(args: {\n  aptosConfig: AptosConfig;\n  payload: InputViewFunctionJsonData;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { aptosConfig, payload, options } = args;\n  const { data } = await postAptosFullNode<ViewFunctionJsonPayload, MoveValue[]>({\n    aptosConfig,\n    originMethod: \"viewJson\",\n    path: \"view\",\n    params: { ledger_version: options?.ledgerVersion },\n    body: {\n      function: payload.function,\n      type_arguments: payload.typeArguments ?? [],\n      arguments: payload.functionArguments ?? [],\n    },\n  });\n\n  return data as T;\n}\n", "import {\n  SimpleTransaction,\n  InputGenerateTransactionOptions,\n  TypeTagAddress,\n  TypeTagStruct,\n  stringStructTag,\n} from \"../transactions\";\nimport { AccountAddressInput } from \"../core\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { MoveFunctionId } from \"../types\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getFunctionParts } from \"../utils/helpers\";\n\nexport async function addAuthenticationFunctionTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  authenticationFunction: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, authenticationFunction, options } = args;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(authenticationFunction as MoveFunctionId);\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::account_abstraction::add_authentication_function\",\n      typeArguments: [],\n      functionArguments: [moduleAddress, moduleName, functionName],\n      abi: {\n        typeParameters: [],\n        parameters: [new TypeTagAddress(), new TypeTagStruct(stringStructTag()), new TypeTagStruct(stringStructTag())],\n      },\n    },\n    options,\n  });\n}\n\nexport async function removeAuthenticationFunctionTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  authenticationFunction: string;\n  options?: InputGenerateTransactionOptions;\n}) {\n  const { aptosConfig, sender, authenticationFunction, options } = args;\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(authenticationFunction as MoveFunctionId);\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::account_abstraction::remove_authentication_function\",\n      typeArguments: [],\n      functionArguments: [moduleAddress, moduleName, functionName],\n      abi: {\n        typeParameters: [],\n        parameters: [new TypeTagAddress(), new TypeTagStruct(stringStructTag()), new TypeTagStruct(stringStructTag())],\n      },\n    },\n    options,\n  });\n}\n\nexport async function removeDispatchableAuthenticatorTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}) {\n  const { aptosConfig, sender, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::account_abstraction::remove_authenticator\",\n      typeArguments: [],\n      functionArguments: [],\n      abi: { typeParameters: [], parameters: [] },\n    },\n    options,\n  });\n}\n", "import { AccountAddress, AccountAddressInput } from \"../../core\";\nimport {\n  addAuthenticationFunctionTransaction,\n  removeAuthenticationFunctionTransaction,\n  removeDispatchableAuthenticatorTransaction,\n} from \"../../internal/abstraction\";\nimport { view } from \"../../internal/view\";\nimport { InputGenerateTransactionOptions, TypeTagAddress } from \"../../transactions\";\nimport { MoveFunctionId } from \"../../types\";\nimport { getFunctionParts } from \"../../utils/helpers\";\nimport { AptosConfig } from \"../aptosConfig\";\n\nexport class AccountAbstraction {\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Adds a dispatchable authentication function to the account.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.addAuthenticationFunctionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn =  await aptos.signAndSubmitTransaction({ signer: alice, transaction});\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to add the authentication function to.\n   * @param args.authenticationFunction - The authentication function info to add.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to add the authentication function to the account.\n   */\n  public async addAuthenticationFunctionTransaction(args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction: string;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    const { accountAddress, authenticationFunction, options } = args;\n    return addAuthenticationFunctionTransaction({\n      aptosConfig: this.config,\n      authenticationFunction,\n      sender: accountAddress,\n      options,\n    });\n  }\n\n  /**\n   * Removes a dispatchable authentication function from the account.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.removeAuthenticationFunctionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to remove the authentication function from.\n   * @param args.authenticationFunction - The authentication function info to remove.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to remove the authentication function from the account.\n   */\n  public async removeAuthenticationFunctionTransaction(args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction: string;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    const { accountAddress, authenticationFunction, options } = args;\n    return removeAuthenticationFunctionTransaction({\n      aptosConfig: this.config,\n      sender: accountAddress,\n      authenticationFunction,\n      options,\n    });\n  }\n\n  /**\n   * Removes a dispatchable authenticator from the account.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.removeDispatchableAuthenticatorTransaction({\n   *   accountAddress: alice.accountAddress,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to remove the authenticator from.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to remove the authenticator from the account.\n   */\n  public async removeDispatchableAuthenticatorTransaction(args: {\n    accountAddress: AccountAddressInput;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    const { accountAddress, options } = args;\n    return removeDispatchableAuthenticatorTransaction({ aptosConfig: this.config, sender: accountAddress, options });\n  }\n\n  /**\n   * Gets the dispatchable authentication function for the account.\n   *\n   * @example\n   * ```ts\n   * const functionInfos = await aptos.abstraction.getAuthenticationFunction({\n   *   accountAddress: alice.accountAddress,\n   * });\n   *\n   * if (functionInfos) {\n   *   console.log(`Account ${alice.accountAddress.toString()} is using account abstraction!`);\n   * } else {\n   *   console.log(`Account ${alice.accountAddress.toString()} is not using account abstraction.`);\n   * }\n   * ```\n   *\n   * @param args.accountAddress - The account to get the dispatchable authentication function for.\n   * @returns The dispatchable authentication function for the account.\n   */\n  public async getAuthenticationFunction(args: { accountAddress: AccountAddressInput }) {\n    const { accountAddress } = args;\n    const [{ vec: functionInfoOption }] = await view<\n      [{ vec: { function_name: string; module_name: string; module_address: string }[][] }]\n    >({\n      aptosConfig: this.config,\n      payload: {\n        function: \"0x1::account_abstraction::dispatchable_authenticator\",\n        functionArguments: [AccountAddress.from(accountAddress)],\n        abi: { typeParameters: [], parameters: [new TypeTagAddress()], returnTypes: [] },\n      },\n    });\n\n    if (functionInfoOption.length === 0) return undefined;\n\n    return functionInfoOption[0].map((functionInfo) => ({\n      moduleAddress: AccountAddress.fromString(functionInfo.module_address),\n      moduleName: functionInfo.module_name,\n      functionName: functionInfo.function_name,\n    }));\n  }\n\n  /**\n   * Will return true if the account is abstracted, otherwise false.\n   *\n   * @example\n   * ```ts\n   * const isAccountAbstractionEnabled = await aptos.abstraction.isAccountAbstractionEnabled({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   * if (isAccountAbstractionEnabled) {\n   *   console.log(`Account ${alice.accountAddress.toString()} is using account abstraction!`);\n   * } else {\n   *   console.log(`Account ${alice.accountAddress.toString()} is not using account abstraction.`);\n   * }\n   * ```\n   *\n   * @param args.accountAddress - The account to check.\n   * @returns Whether the account is abstracted.\n   */\n  public isAccountAbstractionEnabled = async (args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction: string;\n  }) => {\n    const functionInfos = await this.getAuthenticationFunction(args);\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(args.authenticationFunction as MoveFunctionId);\n    return (\n      functionInfos?.some(\n        (functionInfo) =>\n          AccountAddress.fromString(moduleAddress).equals(functionInfo.moduleAddress) &&\n          moduleName === functionInfo.moduleName &&\n          functionName === functionInfo.functionName,\n      ) ?? false\n    );\n  };\n\n  /**\n   * Creates a transaction to enable account abstraction with the given authentication function.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.enableAccountAbstractionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `{alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to enable account abstraction for.\n   * @param args.authenticationFunction - The authentication function info to use.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to enable account abstraction for the account.\n   */\n  public enableAccountAbstractionTransaction = this.addAuthenticationFunctionTransaction;\n\n  /**\n   * Creates a transaction to disable account abstraction. If an authentication function is provided, it will specify to\n   * remove the authentication function.\n   *\n   * @example\n   * ```ts\n   * const txn = await aptos.abstraction.disableAccountAbstractionTransaction({\n   *   accountAddress: alice.accountAddress,\n   *   authenticationFunction: `${alice.accountAddress}::any_authenticator::authenticate`,\n   * });\n   *\n   * const txn = await aptos.signAndSubmitTransaction({ signer: alice, transaction: txn });\n   * await aptos.waitForTransaction({ transactionHash: txn.hash });\n   * ```\n   *\n   * @param args.accountAddress - The account to disable account abstraction for.\n   * @param args.authenticationFunction - The authentication function info to remove.\n   * @param args.options - The options for the transaction.\n   * @returns A transaction to disable account abstraction for the account.\n   */\n  public disableAccountAbstractionTransaction = async (args: {\n    accountAddress: AccountAddressInput;\n    authenticationFunction?: string;\n    options?: InputGenerateTransactionOptions;\n  }) => {\n    const { accountAddress, authenticationFunction, options } = args;\n    if (authenticationFunction) {\n      return this.removeAuthenticationFunctionTransaction({\n        accountAddress,\n        authenticationFunction,\n        options,\n      });\n    }\n    return this.removeDispatchableAuthenticatorTransaction({ accountAddress, options });\n  };\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account as AccountModule } from \"../account\";\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  createObjectAddress,\n  BaseAccountPublicKey,\n  PrivateKeyInput,\n} from \"../core\";\nimport {\n  AccountData,\n  AnyNumber,\n  CursorPaginationArgs,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  GetObjectDataQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  MoveValue,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n} from \"../types\";\nimport {\n  deriveAccountFromPrivateKey,\n  getAccountCoinsCount,\n  getAccountCoinsData,\n  getAccountCollectionsWithOwnedTokens,\n  getAccountOwnedObjects,\n  getAccountOwnedTokens,\n  getAccountOwnedTokensFromCollectionAddress,\n  getAccountsForPublicKey,\n  getAccountTokensCount,\n  getAccountTransactionsCount,\n  getInfo,\n  getModule,\n  getModules,\n  getModulesPage,\n  getResource,\n  getResources,\n  getResourcesPage,\n  getTransactions,\n  lookupOriginalAccountAddress,\n  deriveOwnedAccountsFromSigner,\n  AccountInfo,\n} from \"../internal/account\";\nimport { APTOS_COIN, APTOS_FA, ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { view } from \"../internal/view\";\nimport { isEncodedStruct, parseEncodedStruct } from \"../utils\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { AccountAbstraction } from \"./account/abstraction\";\n\n/**\n * A class to query all `Account` related queries on Aptos.\n * @group Account\n */\nexport class Account {\n  abstraction: AccountAbstraction;\n\n  /**\n   * Creates an instance of the Aptos client with the provided configuration.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Initialize the Aptos client with testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // specify your own network if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  constructor(readonly config: AptosConfig) {\n    this.abstraction = new AccountAbstraction(config);\n  }\n\n  /**\n   * Queries the current state for an Aptos account given its account address.\n   *\n   * @param args - The arguments for retrieving account information.\n   * @param args.accountAddress - The Aptos account address to query.\n   * @returns The account data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Retrieve account information for a specific address\n   *     const accountInfo = await aptos.getAccountInfo({ accountAddress: \"0x1\" }); // replace with a real account address\n   *     console.log(accountInfo);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountInfo(args: { accountAddress: AccountAddressInput }): Promise<AccountData> {\n    return getInfo({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for all modules in an account given an account address.\n   * This function may call the API multiple times to auto paginate through results.\n   *\n   * @param args.accountAddress - The Aptos account address to query modules for.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it retrieves the latest version.\n   *\n   * @returns - The account modules associated with the specified address.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account modules for a specific account\n   *   const accountModules = await aptos.getAccountModules({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // limiting to 10 modules\n   *     },\n   *   });\n   *\n   *   console.log(accountModules);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountModules(args: {\n    accountAddress: AccountAddressInput;\n    options?: { limit?: number } & LedgerVersionArg;\n  }): Promise<MoveModuleBytecode[]> {\n    return getModules({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a page of modules in an account given an account address.\n   *\n   * @param args.accountAddress - The Aptos account address to query modules for.\n   * @param args.options.cursor - The cursor to start returning results from.  Note, this is obfuscated and is not an index.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it retrieves the latest version.\n   *\n   * @returns - The account modules associated with the specified address. Along with a cursor for future pagination. If the cursor is undefined, it means there are no more modules to fetch.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account modules for a specific account\n   *   const {modules, cursor} = await aptos.getAccountModulesPage({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       cursor: undefined, // starting from the first module\n   *       limit: 10, // limiting to 10 modules\n   *     },\n   *   });\n   *\n   *   console.log(modules);\n   *   console.log(`More to fetch: ${cursor !== undefined}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountModulesPage(args: {\n    accountAddress: AccountAddressInput;\n    options?: CursorPaginationArgs & LedgerVersionArg;\n  }): Promise<{ modules: MoveModuleBytecode[]; cursor: string | undefined }> {\n    return getModulesPage({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a specific account module given an account address and module name.\n   *\n   * @param args.accountAddress - The Aptos account address.\n   * @param args.moduleName - The name of the module.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   *\n   * @returns The account module associated with the specified account address and module name.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the account module for a specific account address and module name\n   *   const module = await aptos.getAccountModule({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     moduleName: \"MyModule\" // specify the module name\n   *   });\n   *\n   *   console.log(module);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountModule(args: {\n    accountAddress: AccountAddressInput;\n    moduleName: string;\n    options?: LedgerVersionArg;\n  }): Promise<MoveModuleBytecode> {\n    return getModule({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries account transactions given an account address.\n   * This function may call the API multiple times to auto paginate and retrieve all account transactions.\n   *\n   * @param args.accountAddress - The Aptos account address to query transactions for.\n   * @param args.options - Optional pagination arguments.\n   * @param args.options.offset - The number of transactions to start returning results from.\n   * @param args.options.limit - The maximum number of results to return.\n   *\n   * @returns The account transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch transactions for a specific account\n   *   const transactions = await aptos.getAccountTransactions({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       offset: 0, // starting from the first transaction\n   *       limit: 10, // limiting to 10 transactions\n   *     },\n   *   });\n   *\n   *   console.log(transactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountTransactions(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs;\n  }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all account resources given an account address.\n   * This function may call the API multiple times to auto paginate through results.\n   *\n   * @param args.accountAddress - The Aptos account address to query resources for.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Account resources.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account resources for a specific account address\n   *   const resources = await aptos.getAccountResources({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(resources);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountResources(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs & LedgerVersionArg;\n  }): Promise<MoveResource[]> {\n    return getResources({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a page of account resources given an account address.\n   *\n   * @param args.accountAddress - The Aptos account address to query resources for.\n   * @param args.options.cursor - The cursor to start returning results from.  Note, this is obfuscated and is not an index.\n   * @param args.options.limit - The maximum number of results to return.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Account resources.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching account resources for a specific account address\n   *   const resources = await aptos.getAccountResourcesPage({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       cursor: undefined, // starting from the first resource\n   *       limit: 10, // limiting to 10 resources\n   *     },\n   *   });\n   *   console.log(resources);\n   *   console.log(`More to fetch: ${resources.cursor !== undefined}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountResourcesPage(args: {\n    accountAddress: AccountAddressInput;\n    options?: CursorPaginationArgs & LedgerVersionArg;\n  }): Promise<{ resources: MoveResource[]; cursor: string | undefined }> {\n    return getResourcesPage({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a specific account resource given an account address and resource type.\n   *\n   * @template T - The typed output of the resource.\n   * @param args.accountAddress - The Aptos account address to query.\n   * @param args.resourceType - The string representation of an on-chain Move struct type, e.g., \"0x1::aptos_coin::AptosCoin\".\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns The account resource of the specified type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the account resource for a specific account address and resource type\n   *   const resource = await aptos.getAccountResource({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     resourceType: \"0x1::aptos_coin::AptosCoin\"\n   *   });\n   *\n   *   console.log(resource);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountResource<T extends {} = any>(args: {\n    accountAddress: AccountAddressInput;\n    resourceType: MoveStructId;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return getResource<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Looks up the account address for a given authentication key, handling both rotated and non-rotated keys.\n   *\n   * @param args.authenticationKey - The authentication key for which to look up the account address.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n   * @returns Promise<AccountAddress> - The account address associated with the authentication key.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Look up the original account address for a given authentication key\n   *   const accountAddress = await aptos.lookupOriginalAccountAddress({\n   *     authenticationKey: \"0x1\", // replace with a real authentication key\n   *   });\n   *\n   *   console.log(\"Original Account Address:\", accountAddress);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async lookupOriginalAccountAddress(args: {\n    authenticationKey: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: LedgerVersionArg;\n  }): Promise<AccountAddress> {\n    return lookupOriginalAccountAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the current count of tokens owned by a specified account.\n   *\n   * @param args - The parameters for the query.\n   * @param args.accountAddress - The account address to query the token count for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The current count of tokens owned by the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the count of tokens owned by the account\n   *   const tokensCount = await aptos.getAccountTokensCount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(`Tokens Count: ${tokensCount}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountTokensCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTokensCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the tokens currently owned by a specified account, including NFTs and fungible tokens.\n   * If desired, you can filter the results by a specific token standard.\n   *\n   * @param args.accountAddress The account address for which to retrieve owned tokens.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard Optional filter for the NFT standard to query for.\n   * @param args.options.offset Optional number to start returning results from.\n   * @param args.options.limit Optional number of results to return.\n   * @param args.options.orderBy Optional order to sort the tokens by.\n   * @returns An array of tokens with their respective data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the tokens owned by a specific account\n   *   const accountOwnedTokens = await aptos.getAccountOwnedTokens({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify how many tokens to return\n   *       orderBy: \"created_at\", // specify the order of the results\n   *     },\n   *   });\n   *\n   *   console.log(accountOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n  }): Promise<GetAccountOwnedTokensQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all current tokens of a specific collection that an account owns by the collection address.\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard parameter.\n   *\n   * @param args.accountAddress - The account address we want to get the tokens for.\n   * @param args.collectionAddress - The address of the collection being queried.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to, before querying.\n   * @param args.options.tokenStandard - The NFT standard to query for.\n   * @param args.options.offset - The number token to start returning results from.\n   * @param args.options.limit - The number of results to return.\n   * @param args.options.orderBy - The order to sort the tokens by.\n   * @returns Tokens array with the token data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get tokens owned by a specific account in a specific collection\n   *   const accountOwnedTokens = await aptos.getAccountOwnedTokensFromCollectionAddress({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     collectionAddress: \"0x2\", // replace with a real collection address\n   *   });\n   *\n   *   console.log(accountOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountOwnedTokensFromCollectionAddress(args: {\n    accountAddress: AccountAddressInput;\n    collectionAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n  }): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokensFromCollectionAddress({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for all collections that an account currently has tokens for, including NFTs, fungible tokens, and soulbound tokens.\n   * If you want to filter by a specific token standard, you can pass an optional tokenStandard parameter.\n   *\n   * @param args.accountAddress - The account address we want to get the collections for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - The NFT standard to query for.\n   * @param args.options.offset - The number of the collection to start returning results from.\n   * @param args.options.limit - The number of results to return.\n   * @param args.options.orderBy - The order to sort the tokens by.\n   * @returns Collections array with the collections data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get account collections with owned tokens for a specific account\n   *   const accountCollectionsWithOwnedTokens = await aptos.getAccountCollectionsWithOwnedTokens({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       tokenStandard: \"NFT\", // specify the token standard if needed\n   *       limit: 10, // specify the number of results to return\n   *     },\n   *   });\n   *\n   *   console.log(accountCollectionsWithOwnedTokens);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCollectionsWithOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n  }): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountCollectionsWithOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of transactions submitted by an account.\n   *\n   * @param args - The parameters for the query.\n   * @param args.accountAddress - The account address we want to get the total count for.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns Current count of transactions made by an account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the count of transactions for a specific account\n   *   const accountTransactionsCount = await aptos.getAccountTransactionsCount({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     minimumLedgerVersion: 1, // specify your own minimum ledger version if needed\n   *   });\n   *\n   *   console.log(accountTransactionsCount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountTransactionsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTransactionsCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves the coins data for a specified account.\n   *\n   * @param args.accountAddress - The account address for which to retrieve the coin's data.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.offset - Optional. The number of coins to start returning results from.\n   * @param args.options.limit - Optional. The number of results to return.\n   * @param args.options.orderBy - Optional. The order to sort the coins by.\n   * @param args.options.where - Optional. Filter the results by specific criteria.\n   * @returns An array containing the coins data for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching coins data for a specific account\n   *   const accountCoinsData = await aptos.getAccountCoinsData({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify the number of results to return\n   *       orderBy: { asset_type: \"asc\" }, // specify the order of results\n   *     },\n   *   });\n   *\n   *   console.log(accountCoinsData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCoinsData(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs &\n      OrderByArg<GetAccountCoinsDataResponse[0]> &\n      WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetAccountCoinsDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsData({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves the current count of an account's coins aggregated across all types.\n   *\n   * @param args The parameters for the account coins count query.\n   * @param args.accountAddress The account address we want to get the total count for.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @returns The current count of the aggregated coins for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the account coins count for a specific account\n   *   const accountCoinsCount = await aptos.getAccountCoinsCount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(\"Account Coins Count:\", accountCoinsCount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCoinsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsCount({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current amount of APT for a specified account. If the account does not exist, it will return 0.\n   *\n   * @param args The arguments for the account query.\n   * @param args.accountAddress The account address for which to retrieve the APT amount.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @returns The current amount of APT for the specified account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the APT amount for a specific account\n   *   const accountAPTAmount = await aptos.getAccountAPTAmount({ accountAddress: \"0x1\" }); // replace with a real account address\n   *   console.log(\"Account APT Amount:\", accountAPTAmount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountAPTAmount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    return this.getAccountCoinAmount({ coinType: APTOS_COIN, faMetadataAddress: APTOS_FA, ...args });\n  }\n\n  /**\n   * Queries the current amount of a specified coin held by an account.\n   *\n   * @param args The parameters for querying the account's coin amount.\n   * @param args.accountAddress The account address to query for the coin amount.\n   * @param args.coinType The coin type to query. Note: If not provided, it may be automatically populated if `faMetadataAddress`\n   * is specified.\n   * @param args.faMetadataAddress The fungible asset metadata address to query. Note: If not provided, it may be automatically\n   * populated if `coinType` is specified.\n   * @param args.minimumLedgerVersion Not used anymore, here for backward compatibility\n   * see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, will be removed in the near future.\n   * Optional ledger version to sync up to before querying.\n   * @returns The current amount of the specified coin held by the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Query the account's coin amount for a specific coin type\n   *   const accountCoinAmount = await aptos.getAccountCoinAmount({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     coinType: \"0x1::aptos_coin::AptosCoin\" // specify the coin type\n   *   });\n   *\n   *   console.log(`Account coin amount: ${accountCoinAmount}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountCoinAmount(args: {\n    accountAddress: AccountAddressInput;\n    coinType?: MoveStructId;\n    faMetadataAddress?: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    const { accountAddress, coinType, faMetadataAddress, minimumLedgerVersion } = args;\n\n    if (minimumLedgerVersion) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `minimumLedgerVersion is not used anymore, here for backward \n        compatibility see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, \n        will be removed in the near future`,\n      );\n    }\n    // Attempt to populate the CoinType field if the FA address is provided.\n    // We cannot do this internally due to dependency cycles issue.\n    let coinAssetType: MoveStructId | undefined = coinType;\n    if (coinType === undefined && faMetadataAddress !== undefined) {\n      coinAssetType = await memoizeAsync(\n        async () => {\n          try {\n            const pairedCoinTypeStruct = (\n              await view({\n                aptosConfig: this.config,\n                payload: { function: \"0x1::coin::paired_coin\", functionArguments: [faMetadataAddress] },\n              })\n            ).at(0) as { vec: MoveValue[] };\n\n            // Check if the Option has a value, and if so, parse the struct\n            if (pairedCoinTypeStruct.vec.length > 0 && isEncodedStruct(pairedCoinTypeStruct.vec[0])) {\n              return parseEncodedStruct(pairedCoinTypeStruct.vec[0]) as MoveStructId;\n            }\n          } catch (error) {\n            /* No paired coin type found */\n          }\n          return undefined;\n        },\n        `coin-mapping-${faMetadataAddress.toString()}`,\n        1000 * 60 * 5, // 5 minutes\n      )();\n    }\n\n    let faAddress: string;\n\n    if (coinType !== undefined && faMetadataAddress !== undefined) {\n      faAddress = AccountAddress.from(faMetadataAddress).toStringLong();\n    } else if (coinType !== undefined && faMetadataAddress === undefined) {\n      // TODO Move to a separate function as defined in the AIP for coin migration\n      if (coinType === APTOS_COIN) {\n        faAddress = AccountAddress.A.toStringLong();\n      } else {\n        faAddress = createObjectAddress(AccountAddress.A, coinType).toStringLong();\n      }\n    } else if (coinType === undefined && faMetadataAddress !== undefined) {\n      const addr = AccountAddress.from(faMetadataAddress);\n      faAddress = addr.toStringLong();\n      if (addr === AccountAddress.A) {\n        coinAssetType = APTOS_COIN;\n      }\n      // The paired CoinType should be populated outside of this function in another\n      // async call. We cannot do this internally due to dependency cycles issue.\n    } else {\n      throw new Error(\"Either coinType, faMetadataAddress, or both must be provided\");\n    }\n\n    // When there is a coin mapping, use that first, otherwise use the fungible asset address\n    // TODO: This function's signature at the top, returns number, but it could be greater than can be represented\n    if (coinAssetType !== undefined) {\n      const [balanceStr] = await view<[string]>({\n        aptosConfig: this.config,\n        payload: {\n          function: \"0x1::coin::balance\",\n          typeArguments: [coinAssetType],\n          functionArguments: [accountAddress],\n        },\n      });\n      return parseInt(balanceStr, 10);\n    }\n    const [balanceStr] = await view<[string]>({\n      aptosConfig: this.config,\n      payload: {\n        function: \"0x1::primary_fungible_store::balance\",\n        typeArguments: [\"0x1::object::ObjectCore\"],\n        functionArguments: [accountAddress, faAddress],\n      },\n    });\n    return parseInt(balanceStr, 10);\n  }\n\n  /**\n   * Queries an account's owned objects.\n   *\n   * @param args.accountAddress The account address we want to get the objects for.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options.offset The starting position to start returning results from.\n   * @param args.options.limit The number of results to return.\n   * @param args.options.orderBy The order to sort the objects by.\n   * @returns Objects array with the object data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the objects owned by the specified account\n   *   const accountOwnedObjects = await aptos.getAccountOwnedObjects({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *     options: {\n   *       offset: 0, // optional, specify if needed\n   *       limit: 10, // optional, specify if needed\n   *       orderBy: \"created_at\", // optional, specify if needed\n   *     },\n   *   });\n   *\n   *   console.log(accountOwnedObjects);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   */\n  async getAccountOwnedObjects(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n  }): Promise<GetObjectDataQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.DEFAULT,\n    });\n    return getAccountOwnedObjects({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Derives an account by providing a private key. This function resolves the provided private key type and derives the public\n   * key from it.\n   *\n   * If the privateKey is a Secp256k1 type, it derives the account using the derived public key and auth key using the SingleKey\n   * scheme locally.\n   * If the privateKey is an ED25519 type, it looks up the authentication key on chain to determine whether it is a Legacy ED25519\n   * key or a Unified ED25519 key, and then derives the account based on that.\n   *\n   * @param args - The arguments for deriving the account.\n   * @param args.privateKey - An account private key.\n   * @returns The derived Account type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Ed25519PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Deriving an account from a private key\n   *     const account = await aptos.deriveAccountFromPrivateKey({\n   *         privateKey: new Ed25519PrivateKey(\"0x123\") // replace with a real private key\n   *     });\n   *\n   *     console.log(account);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Account\n   * @deprecated Note that more inspection is needed by the user to determine which account exists on-chain\n   */\n  async deriveAccountFromPrivateKey(args: {\n    privateKey: PrivateKeyInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: {\n      throwIfNoAccountFound?: boolean;\n    };\n  }): Promise<AccountModule> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_RESTORATION_PROCESSOR,\n    });\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.OBJECT_PROCESSOR,\n    });\n    return deriveAccountFromPrivateKey({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Derives all accounts owned by a signer. This function takes a signer (either an Account or PrivateKey)\n   * and returns all accounts that can be derived from it, ordered by the most recently used account first.\n   *\n   * Note, this function will not return accounts that require more than one signer to be used.\n   *\n   * @param args - The arguments for deriving owned accounts\n   * @param args.signer - The signer to derive accounts from (Account or PrivateKey)\n   * @param args.minimumLedgerVersion - The minimum ledger version to wait for before querying\n   * @param args.options.includeUnverified - Whether to include unverified accounts in the results. Unverified accounts\n   * are accounts that can be authenticated with the signer, but there is no history of the signer using the account.\n   * Default is false.\n   * @param args.options.noMultiKey - If true, do not include multi-key accounts in the results. Default is false.\n   * @returns Promise resolving to an array of derived Account objects\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Ed25519Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function getOwnedAccounts() {\n   *   const signer = Ed25519Account.generate();\n   *   const accounts = await aptos.deriveOwnedAccountsFromSigner({\n   *     signer\n   *   });\n   *   const account = accounts[0];\n   *   console.log(account);\n   * }\n   * ```\n   * @group Account\n   */\n  async deriveOwnedAccountsFromSigner(args: {\n    signer: AccountModule | PrivateKeyInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: { includeUnverified?: boolean; noMultiKey?: boolean };\n  }): Promise<AccountModule[]> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_RESTORATION_PROCESSOR,\n    });\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.OBJECT_PROCESSOR,\n    });\n    return deriveOwnedAccountsFromSigner({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Gets all account info (address, account public key, last transaction version) that have are associated with a public key and **related public keys**\n   *\n   * For a given public key, it will query all multikeys that the public key is part of.  Then for the provided public key and\n   * any multikeys found in the previous step, it will query for any accounts that have an auth key that matches any of the\n   * public keys.\n   *\n   * Note: If an Ed25519PublicKey or an AnyPublicKey that wraps Ed25519PublicKey is passed in, it will query for both legacy and single singer cases.\n   *\n   * @param args - The arguments for getting accounts for a public key\n   * @param args.publicKey - The public key to look up accounts for\n   * @param args.minimumLedgerVersion - The minimum ledger version to wait for before querying\n   * @param args.options.includeUnverified - Whether to include unverified accounts in the results. Unverified accounts\n   * are accounts that can be authenticated with the signer, but there is no history of the signer using the account. Default\n   * is false.\n   * @param args.options.noMultiKey - Whether to exclude multi-key accounts in the results. Default is false.\n   * @returns Promise resolving to an array of account addresses and their associated public keys\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Ed25519PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function getAccounts() {\n   *   const privateKey = Ed25519PrivateKey.generate();\n   *   const publicKey = privateKey.publicKey();\n   *   const accounts = await aptos.getAccountsForPublicKey({\n   *     publicKey\n   *   });\n   *   console.log(accounts);\n   * }\n   * ```\n   * @group Account\n   */\n  async getAccountsForPublicKey(args: {\n    publicKey: BaseAccountPublicKey;\n    minimumLedgerVersion?: AnyNumber;\n    options?: { includeUnverified?: boolean; noMultiKey?: boolean };\n  }): Promise<AccountInfo[]> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_RESTORATION_PROCESSOR,\n    });\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.OBJECT_PROCESSOR,\n    });\n    return getAccountsForPublicKey({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n}\n", "import { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddressInput } from \"../core\";\nimport { EntryFunctionABI, InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AnyNumber, MoveStructId } from \"../types\";\nimport { APTOS_COIN } from \"../utils/const\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { TypeTagAddress, TypeTagU64 } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\nconst coinTransferAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [] }],\n  parameters: [new TypeTagAddress(), new TypeTagU64()],\n};\n\n/**\n * Generates a transaction to transfer coins from one account to another.\n * This function allows you to specify the sender, recipient, amount, and coin type for the transaction.\n *\n * @param args - The parameters for the transaction.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.sender - The address of the account sending the coins.\n * @param args.recipient - The address of the account receiving the coins.\n * @param args.amount - The amount of coins to transfer.\n * @param args.coinType - (Optional) The type of coin to transfer, defaults to Aptos Coin if not specified.\n * @param args.options - (Optional) Options for generating the transaction.\n * @group Implementation\n */\nexport async function transferCoinTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  recipient: AccountAddressInput;\n  amount: AnyNumber;\n  coinType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, recipient, amount, coinType, options } = args;\n  const coinStructType = coinType ?? APTOS_COIN;\n  return generateTransaction({\n    aptosConfig,\n    sender,\n    data: {\n      function: \"0x1::aptos_account::transfer_coins\",\n      typeArguments: [coinStructType],\n      functionArguments: [recipient, amount],\n      abi: coinTransferAbi,\n    },\n    options,\n  });\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddressInput } from \"../core\";\nimport { transferCoinTransaction } from \"../internal/coin\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AnyNumber, MoveStructId } from \"../types\";\nimport { AptosConfig } from \"./aptosConfig\";\n\n/**\n * A class to handle all `Coin` operations.\n * @group Coin\n */\nexport class Coin {\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Coin\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Generate a transfer coin transaction that can be simulated, signed, and submitted.\n   * This function helps you create a transaction to transfer a specified amount of coins\n   * from one account to another within the Aptos network.\n   *\n   * @param args The arguments for the transfer transaction.\n   * @param args.sender The sender account address.\n   * @param args.recipient The recipient account address.\n   * @param args.amount The amount of coins to transfer.\n   * @param args.coinType Optional. The coin struct type to transfer. Defaults to 0x1::aptos_coin::AptosCoin.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Generate a transfer coin transaction\n   *   const transaction = await aptos.transferCoinTransaction({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     recipient: \"0x2\", // replace with a real recipient account address\n   *     amount: 10,\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Coin\n   */\n  async transferCoinTransaction(args: {\n    sender: AccountAddressInput;\n    recipient: AccountAddressInput;\n    amount: AnyNumber;\n    coinType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferCoinTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/digitalAsset}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * digitalAsset namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Bool, MoveString, MoveVector, U64 } from \"../bcs\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { Account } from \"../account\";\nimport { EntryFunctionABI, InputGenerateTransactionOptions } from \"../transactions/types\";\nimport {\n  AnyNumber,\n  GetCollectionDataResponse,\n  GetCurrentTokenOwnershipResponse,\n  GetOwnedTokensResponse,\n  GetTokenActivityResponse,\n  GetTokenDataResponse,\n  MoveAbility,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  WhereArg,\n} from \"../types\";\nimport {\n  GetCollectionDataQuery,\n  GetCurrentTokenOwnershipQuery,\n  GetTokenActivityQuery,\n  GetTokenDataQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetCollectionData,\n  GetCurrentTokenOwnership,\n  GetTokenActivity,\n  GetTokenData,\n} from \"../types/generated/queries\";\nimport { queryIndexer } from \"./general\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { MAX_U64_BIG_INT } from \"../bcs/consts\";\nimport {\n  CurrentCollectionsV2BoolExp,\n  CurrentTokenOwnershipsV2BoolExp,\n  TokenActivitiesV2BoolExp,\n} from \"../types/generated/types\";\nimport {\n  checkOrConvertArgument,\n  objectStructTag,\n  parseTypeTag,\n  stringStructTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagGeneric,\n  TypeTagStruct,\n  TypeTagU64,\n  TypeTagVector,\n} from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n// A property type map for the user input and what Move expects\nconst PropertyTypeMap = {\n  BOOLEAN: \"bool\",\n  U8: \"u8\",\n  U16: \"u16\",\n  U32: \"u32\",\n  U64: \"u64\",\n  U128: \"u128\",\n  U256: \"u256\",\n  ADDRESS: \"address\",\n  STRING: \"0x1::string::String\",\n  ARRAY: \"vector<u8>\",\n};\n\n/**\n * The keys of the PropertyTypeMap, representing different property types.\n * @group Implementation\n */\nexport type PropertyType = keyof typeof PropertyTypeMap;\n\n/**\n * Accepted property value types for user input, including boolean, number, bigint, string, AccountAddress, and Uint8Array.\n * To pass in an Array, use Uint8Array type\n * for example `new MoveVector([new MoveString(\"hello\"), new MoveString(\"world\")]).bcsToBytes()`\n * @group Implementation\n */\nexport type PropertyValue = boolean | number | bigint | string | AccountAddress | Uint8Array;\n\n// The default digital asset type to use if non provided\nconst defaultDigitalAssetType = \"0x4::token::Token\";\n\n// FETCH QUERIES\n\n/**\n * Retrieves data for a specific digital asset using its address.\n *\n * @param args - The arguments for fetching digital asset data.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.digitalAssetAddress - The address of the digital asset to retrieve data for.\n * @returns The data of the specified digital asset.\n * @group Implementation\n */\nexport async function getDigitalAssetData(args: {\n  aptosConfig: AptosConfig;\n  digitalAssetAddress: AccountAddressInput;\n}): Promise<GetTokenDataResponse> {\n  const { aptosConfig, digitalAssetAddress } = args;\n\n  const whereCondition: { token_data_id: { _eq: string } } = {\n    token_data_id: { _eq: AccountAddress.from(digitalAssetAddress).toStringLong() },\n  };\n\n  const graphqlQuery = {\n    query: GetTokenData,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetTokenDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getDigitalAssetData\",\n  });\n\n  return data.current_token_datas_v2[0];\n}\n\n/**\n * Retrieves the current ownership details of a specified digital asset.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.digitalAssetAddress - The address of the digital asset to query ownership for.\n * @returns The current ownership details of the specified digital asset.\n * @group Implementation\n */\nexport async function getCurrentDigitalAssetOwnership(args: {\n  aptosConfig: AptosConfig;\n  digitalAssetAddress: AccountAddressInput;\n}): Promise<GetCurrentTokenOwnershipResponse> {\n  const { aptosConfig, digitalAssetAddress } = args;\n\n  const whereCondition: CurrentTokenOwnershipsV2BoolExp = {\n    token_data_id: { _eq: AccountAddress.from(digitalAssetAddress).toStringLong() },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentTokenOwnershipQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentDigitalAssetOwnership\",\n  });\n\n  return data.current_token_ownerships_v2[0];\n}\n\n/**\n * Retrieves the digital assets owned by a specified account address.\n *\n * @param args - The arguments for retrieving owned digital assets.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.ownerAddress - The address of the account whose owned digital assets are being queried.\n * @param args.options - Optional pagination and ordering parameters for the query.\n * @param args.options.offset - The number of records to skip for pagination.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria for ordering the results.\n *\n * @returns An array of digital assets currently owned by the specified account.\n * @group Implementation\n */\nexport async function getOwnedDigitalAssets(args: {\n  aptosConfig: AptosConfig;\n  ownerAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;\n}): Promise<GetOwnedTokensResponse> {\n  const { aptosConfig, ownerAddress, options } = args;\n\n  const whereCondition: CurrentTokenOwnershipsV2BoolExp = {\n    owner_address: { _eq: AccountAddress.from(ownerAddress).toStringLong() },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentTokenOwnershipQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getOwnedDigitalAssets\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\n/**\n * Retrieves the activity associated with a specific digital asset.\n * This function allows you to track the token activities for a given digital asset address.\n *\n * @param args - The arguments for retrieving digital asset activity.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.digitalAssetAddress - The address of the digital asset to query.\n * @param args.options - Optional parameters for pagination and ordering.\n * @param args.options.offset - The number of records to skip before starting to collect the result set.\n * @param args.options.limit - The maximum number of records to return.\n * @param args.options.orderBy - The criteria to order the results by.\n * @returns A promise that resolves to an array of token activities for the specified digital asset.\n * @group Implementation\n */\nexport async function getDigitalAssetActivity(args: {\n  aptosConfig: AptosConfig;\n  digitalAssetAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;\n}): Promise<GetTokenActivityResponse> {\n  const { aptosConfig, digitalAssetAddress, options } = args;\n\n  const whereCondition: TokenActivitiesV2BoolExp = {\n    token_data_id: { _eq: AccountAddress.from(digitalAssetAddress).toStringLong() },\n  };\n\n  const graphqlQuery = {\n    query: GetTokenActivity,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetTokenActivityQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getDigitalAssetActivity\",\n  });\n\n  return data.token_activities_v2;\n}\n\n/**\n * Options for creating a collection, allowing customization of various attributes such as supply limits, mutability of metadata,\n * and royalty settings.\n *\n * @param maxSupply - Maximum number of tokens that can be minted in the collection.\n * @param mutableDescription - Indicates if the collection description can be changed after creation.\n * @param mutableRoyalty - Indicates if the royalty settings can be modified after creation.\n * @param mutableURI - Indicates if the collection URI can be updated.\n * @param mutableTokenDescription - Indicates if individual token descriptions can be modified.\n * @param mutableTokenName - Indicates if individual token names can be changed.\n * @param mutableTokenProperties - Indicates if individual token properties can be altered.\n * @param mutableTokenURI - Indicates if individual token URIs can be updated.\n * @param tokensBurnableByCreator - Indicates if the creator can burn tokens from the collection.\n * @param tokensFreezableByCreator - Indicates if the creator can freeze tokens in the collection.\n * @param royaltyNumerator - The numerator for calculating royalties.\n * @param royaltyDenominator - The denominator for calculating royalties.\n * @group Implementation\n */\nexport interface CreateCollectionOptions {\n  maxSupply?: AnyNumber;\n  mutableDescription?: boolean;\n  mutableRoyalty?: boolean;\n  mutableURI?: boolean;\n  mutableTokenDescription?: boolean;\n  mutableTokenName?: boolean;\n  mutableTokenProperties?: boolean;\n  mutableTokenURI?: boolean;\n  tokensBurnableByCreator?: boolean;\n  tokensFreezableByCreator?: boolean;\n  royaltyNumerator?: number;\n  royaltyDenominator?: number;\n}\n\nconst createCollectionAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagU64(),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagBool(),\n    new TypeTagU64(),\n    new TypeTagU64(),\n  ],\n};\n\n/**\n * Creates a new collection transaction on the Aptos blockchain.\n * This function allows you to define the properties of the collection, including its name, description, and URI.\n *\n * @param args - The parameters for creating the collection transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that will create the collection.\n * @param args.description - A description of the collection.\n * @param args.name - The name of the collection.\n * @param args.uri - The URI associated with the collection.\n * @param args.options - Optional parameters for generating the transaction.\n * @param args.maxSupply - The maximum supply of tokens in the collection (optional).\n * @param args.mutableDescription - Indicates if the collection description can be changed (optional, defaults to true).\n * @param args.mutableRoyalty - Indicates if the royalty settings can be changed (optional, defaults to true).\n * @param args.mutableURI - Indicates if the URI can be changed (optional, defaults to true).\n * @param args.mutableTokenDescription - Indicates if the token description can be changed (optional, defaults to true).\n * @param args.mutableTokenName - Indicates if the token name can be changed (optional, defaults to true).\n * @param args.mutableTokenProperties - Indicates if the token properties can be changed (optional, defaults to true).\n * @param args.mutableTokenURI - Indicates if the token URI can be changed (optional, defaults to true).\n * @param args.tokensBurnableByCreator - Indicates if tokens can be burned by the creator (optional, defaults to true).\n * @param args.tokensFreezableByCreator - Indicates if tokens can be frozen by the creator (optional, defaults to true).\n * @param args.royaltyNumerator - The numerator for calculating royalties (optional, defaults to 0).\n * @param args.royaltyDenominator - The denominator for calculating royalties (optional, defaults to 1).\n * @group Implementation\n */\nexport async function createCollectionTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n    creator: Account;\n    description: string;\n    name: string;\n    uri: string;\n    options?: InputGenerateTransactionOptions;\n  } & CreateCollectionOptions,\n): Promise<SimpleTransaction> {\n  const { aptosConfig, options, creator } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::create_collection\",\n      functionArguments: [\n        // Do not change the order\n        new MoveString(args.description),\n        new U64(args.maxSupply ?? MAX_U64_BIG_INT),\n        new MoveString(args.name),\n        new MoveString(args.uri),\n        new Bool(args.mutableDescription ?? true),\n        new Bool(args.mutableRoyalty ?? true),\n        new Bool(args.mutableURI ?? true),\n        new Bool(args.mutableTokenDescription ?? true),\n        new Bool(args.mutableTokenName ?? true),\n        new Bool(args.mutableTokenProperties ?? true),\n        new Bool(args.mutableTokenURI ?? true),\n        new Bool(args.tokensBurnableByCreator ?? true),\n        new Bool(args.tokensFreezableByCreator ?? true),\n        new U64(args.royaltyNumerator ?? 0),\n        new U64(args.royaltyDenominator ?? 1),\n      ],\n      abi: createCollectionAbi,\n    },\n    options,\n  });\n}\n\n/**\n * Retrieves data for the current collections based on specified options.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for filtering and pagination.\n * @param args.options.tokenStandard - The token standard to filter the collections (default is \"v2\").\n * @param args.options.offset - The offset for pagination.\n * @param args.options.limit - The limit for pagination.\n * @param args.options.where - The conditions to filter the collections.\n * @returns The data of the current collections.\n * @group Implementation\n */\nexport async function getCollectionData(args: {\n  aptosConfig: AptosConfig;\n  options?: TokenStandardArg & PaginationArgs & WhereArg<CurrentCollectionsV2BoolExp>;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, options } = args;\n\n  const whereCondition: any = options?.where;\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  const graphqlQuery = {\n    query: GetCollectionData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n    },\n  };\n  const data = await queryIndexer<GetCollectionDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCollectionData\",\n  });\n\n  return data.current_collections_v2[0];\n}\n\n/**\n * Retrieves collection data based on the creator's address and the collection name.\n *\n * @param args - The arguments for retrieving the collection data.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.creatorAddress - The address of the creator whose collection data is being retrieved.\n * @param args.collectionName - The name of the collection to fetch data for.\n * @param args.options - Optional parameters for filtering the results, including token standard and pagination options.\n * @param args.options.tokenStandard - The token standard to filter the results by (optional).\n * @param args.options.pagination - Pagination options for the results (optional).\n * @group Implementation\n */\nexport async function getCollectionDataByCreatorAddressAndCollectionName(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: AccountAddressInput;\n  collectionName: string;\n  options?: TokenStandardArg & PaginationArgs;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, creatorAddress, collectionName, options } = args;\n  const address = AccountAddress.from(creatorAddress);\n\n  const whereCondition: any = {\n    collection_name: { _eq: collectionName },\n    creator_address: { _eq: address.toStringLong() },\n  };\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return getCollectionData({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves collection data associated with a specific creator's address.\n * This function allows you to filter the collections based on the creator's address and optional token standards.\n *\n * @param args - The arguments for retrieving collection data.\n * @param args.aptosConfig - The configuration for the Aptos network.\n * @param args.creatorAddress - The address of the creator whose collection data is being retrieved.\n * @param args.options - Optional parameters for filtering the results.\n * @param args.options.tokenStandard - The token standard to filter the collections by.\n * @param args.options.pagination - Pagination options for the results.\n * @group Implementation\n */\nexport async function getCollectionDataByCreatorAddress(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, creatorAddress, options } = args;\n  const address = AccountAddress.from(creatorAddress);\n\n  const whereCondition: any = {\n    creator_address: { _eq: address.toStringLong() },\n  };\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return getCollectionData({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves data for a specific collection using its unique identifier.\n * This function allows you to filter the collection data based on the token standard and pagination options.\n *\n * @param args - The arguments for retrieving collection data.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.collectionId - The unique identifier for the collection.\n * @param args.options - Optional parameters for filtering by token standard and pagination.\n * @param args.options.tokenStandard - The standard of the token to filter the collection data.\n * @param args.options.page - The page number for pagination.\n * @param args.options.limit - The number of items per page for pagination.\n * @group Implementation\n */\nexport async function getCollectionDataByCollectionId(args: {\n  aptosConfig: AptosConfig;\n  collectionId: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs;\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, collectionId, options } = args;\n  const address = AccountAddress.from(collectionId);\n\n  const whereCondition: any = {\n    collection_id: { _eq: address.toStringLong() },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return getCollectionData({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves the collection ID based on the creator's address and the collection name.\n * This function helps in identifying a specific collection within the Aptos ecosystem.\n *\n * @param args - The parameters for retrieving the collection ID.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creatorAddress - The address of the creator of the collection.\n * @param args.collectionName - The name of the collection to look up.\n * @param args.options - Optional parameters for additional filtering.\n * @param args.options.tokenStandard - The token standard to filter the collection (default is \"v2\").\n * @returns The ID of the specified collection.\n * @group Implementation\n */\nexport async function getCollectionId(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: AccountAddressInput;\n  collectionName: string;\n  options?: TokenStandardArg;\n}): Promise<string> {\n  const { creatorAddress, collectionName, options, aptosConfig } = args;\n  const address = AccountAddress.from(creatorAddress);\n\n  const whereCondition: any = {\n    collection_name: { _eq: collectionName },\n    creator_address: { _eq: address.toStringLong() },\n  };\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  return (await getCollectionData({ aptosConfig, options: { where: whereCondition } })).collection_id;\n}\n\n// TRANSACTIONS\n\nconst mintDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(TypeTagVector.u8()),\n  ],\n};\n\n/**\n * Creates a transaction to mint a digital asset on the Aptos blockchain.\n * This function allows you to specify various attributes of the asset, including its collection, description, name, and URI.\n *\n * @param args - The arguments for minting the digital asset.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that will create the digital asset.\n * @param args.collection - The name of the collection to which the asset belongs.\n * @param args.description - A brief description of the digital asset.\n * @param args.name - The name of the digital asset.\n * @param args.uri - The URI pointing to the asset's metadata.\n * @param [args.propertyKeys] - Optional array of property keys associated with the asset.\n * @param [args.propertyTypes] - Optional array of property types corresponding to the asset's properties.\n * @param [args.propertyValues] - Optional array of property values for the asset's properties.\n * @param [args.options] - Optional transaction generation options.\n * @group Implementation\n */\nexport async function mintDigitalAssetTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  collection: string;\n  description: string;\n  name: string;\n  uri: string;\n  propertyKeys?: Array<string>;\n  propertyTypes?: Array<PropertyType>;\n  propertyValues?: Array<PropertyValue>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    options,\n    creator,\n    collection,\n    description,\n    name,\n    uri,\n    propertyKeys,\n    propertyTypes,\n    propertyValues,\n  } = args;\n  const convertedPropertyType = propertyTypes?.map((type) => PropertyTypeMap[type]);\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::mint\",\n      functionArguments: [\n        new MoveString(collection),\n        new MoveString(description),\n        new MoveString(name),\n        new MoveString(uri),\n        MoveVector.MoveString(propertyKeys ?? []),\n        MoveVector.MoveString(convertedPropertyType ?? []),\n\n        /**\n         * Retrieves the raw values of specified properties from an array of property values based on their types.\n         *\n         * @param propertyValues - An array of property values from which to extract the raw data.\n         * @param propertyTypes - An array of strings representing the types of properties to retrieve.\n         * @returns An array of Uint8Array containing the raw values for the specified property types.\n         * @group Implementation\n         */\n        getPropertyValueRaw(propertyValues ?? [], convertedPropertyType ?? []),\n      ],\n      abi: mintDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst transferDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagAddress()],\n};\n\n/**\n * Initiates a transaction to transfer a digital asset from one account to another.\n * This function helps in executing the transfer of digital assets securely and efficiently.\n *\n * @param args - The arguments required to perform the transfer.\n * @param args.aptosConfig - Configuration settings for the Aptos client.\n * @param args.sender - The account initiating the transfer.\n * @param args.digitalAssetAddress - The address of the digital asset being transferred.\n * @param args.recipient - The address of the account receiving the digital asset.\n * @param args.digitalAssetType - (Optional) The type of the digital asset being transferred.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function transferDigitalAssetTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  digitalAssetAddress: AccountAddressInput;\n  recipient: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, digitalAssetAddress, recipient, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::object::transfer\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), AccountAddress.from(recipient)],\n      abi: transferDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst mintSoulBoundAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(new TypeTagStruct(stringStructTag())),\n    new TypeTagVector(TypeTagVector.u8()),\n    new TypeTagAddress(),\n  ],\n};\n\n/**\n * Creates a transaction to mint a soul-bound token.\n * This function allows you to specify the token's attributes and recipient, facilitating the creation of unique digital assets.\n *\n * @param args - The parameters required to mint the soul-bound token.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.account - The account initiating the minting transaction.\n * @param args.collection - The name of the collection to which the token belongs.\n * @param args.description - A description of the token being minted.\n * @param args.name - The name of the token.\n * @param args.uri - The URI pointing to the token's metadata.\n * @param args.recipient - The address of the account that will receive the minted token.\n * @param [args.propertyKeys] - Optional array of property keys associated with the token.\n * @param [args.propertyTypes] - Optional array of property types corresponding to the property keys.\n * @param [args.propertyValues] - Optional array of property values that match the property keys and types.\n * @param [args.options] - Optional transaction generation options.\n * @throws Error if the counts of property keys, property types, and property values do not match.\n * @group Implementation\n */\nexport async function mintSoulBoundTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: Account;\n  collection: string;\n  description: string;\n  name: string;\n  uri: string;\n  recipient: AccountAddressInput;\n  propertyKeys?: Array<string>;\n  propertyTypes?: Array<PropertyType>;\n  propertyValues?: Array<PropertyValue>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    account,\n    collection,\n    description,\n    name,\n    uri,\n    recipient,\n    propertyKeys,\n    propertyTypes,\n    propertyValues,\n    options,\n  } = args;\n  if (propertyKeys?.length !== propertyValues?.length) {\n    throw new Error(\"Property keys and property values counts do not match\");\n  }\n  if (propertyTypes?.length !== propertyValues?.length) {\n    throw new Error(\"Property types and property values counts do not match\");\n  }\n  const convertedPropertyType = propertyTypes?.map((type) => PropertyTypeMap[type]);\n  return generateTransaction({\n    aptosConfig,\n    sender: account.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::mint_soul_bound\",\n      functionArguments: [\n        collection,\n        description,\n        name,\n        uri,\n        MoveVector.MoveString(propertyKeys ?? []),\n        MoveVector.MoveString(convertedPropertyType ?? []),\n        getPropertyValueRaw(propertyValues ?? [], convertedPropertyType ?? []),\n        recipient,\n      ],\n      abi: mintSoulBoundAbi,\n    },\n    options,\n  });\n}\n\nconst burnDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0)))],\n};\n\n/**\n * Creates a transaction to burn a specified digital asset.\n * This function allows users to permanently remove a digital asset from their account.\n *\n * @param args - The arguments for the transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that is initiating the burn transaction.\n * @param args.digitalAssetAddress - The address of the digital asset to be burned.\n * @param args.digitalAssetType - Optional; the type of the digital asset being burned.\n * @param args.options - Optional; additional options for generating the transaction.\n * @group Implementation\n */\nexport async function burnDigitalAssetTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::burn\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress)],\n      abi: burnDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst freezeDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0)))],\n};\n\n/**\n * Creates a transaction to freeze the transfer of a digital asset.\n * This function helps you prevent the transfer of a specified digital asset by generating the appropriate transaction.\n *\n * @param args - The parameters for the transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.creator - The account that is creating the transaction.\n * @param args.digitalAssetAddress - The address of the digital asset to be frozen.\n * @param args.digitalAssetType - (Optional) The type of the digital asset as a Move struct ID.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function freezeDigitalAssetTransferTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::freeze_transfer\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [digitalAssetAddress],\n      abi: freezeDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst unfreezeDigitalAssetAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0)))],\n};\n\n/**\n * Unfreezes a digital asset transfer transaction, allowing the transfer of the specified digital asset.\n *\n * @param args - The arguments for unfreezing the digital asset transfer transaction.\n * @param args.aptosConfig - The Aptos configuration settings.\n * @param args.creator - The account that is initiating the unfreeze transaction.\n * @param args.digitalAssetAddress - The address of the digital asset to be unfrozen.\n * @param args.digitalAssetType - (Optional) The type of the digital asset being unfrozen.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function unfreezeDigitalAssetTransferTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::unfreeze_transfer\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [digitalAssetAddress],\n      abi: unfreezeDigitalAssetAbi,\n    },\n    options,\n  });\n}\n\nconst setDigitalAssetDescriptionAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Sets the description for a digital asset, allowing users to provide additional context or information about the asset.\n *\n * @param args - The arguments for setting the digital asset description.\n * @param args.aptosConfig - The Aptos configuration to use for the transaction.\n * @param args.creator - The account that is creating the transaction.\n * @param args.description - The new description for the digital asset.\n * @param args.digitalAssetAddress - The address of the digital asset whose description is being set.\n * @param args.digitalAssetType - (Optional) The type of the digital asset.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function setDigitalAssetDescriptionTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  description: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, description, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::set_description\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(description)],\n      abi: setDigitalAssetDescriptionAbi,\n    },\n    options,\n  });\n}\n\nconst setDigitalAssetNameAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Sets the name of a digital asset on the Aptos blockchain.\n * This function allows you to update the name of a specified digital asset, enabling better identification and categorization.\n *\n * @param args - The parameters for setting the digital asset name.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that is creating the transaction.\n * @param args.name - The new name to assign to the digital asset.\n * @param args.digitalAssetAddress - The address of the digital asset to update.\n * @param args.digitalAssetType - (Optional) The type of the digital asset, represented as a Move struct ID.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function setDigitalAssetNameTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  name: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, name, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::set_name\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(name)],\n      abi: setDigitalAssetNameAbi,\n    },\n    options,\n  });\n}\n\nconst setDigitalAssetURIAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Sets the URI for a digital asset, allowing you to update the metadata associated with it.\n *\n * @param args - The arguments for setting the digital asset URI.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.uri - The new URI to be set for the digital asset.\n * @param args.digitalAssetAddress - The address of the digital asset whose URI is being set.\n * @param args.digitalAssetType - The optional type of the digital asset; defaults to a predefined type if not provided.\n * @param args.options - Optional settings for generating the transaction.\n * @group Implementation\n */\nexport async function setDigitalAssetURITransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  uri: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, uri, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::set_uri\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(uri)],\n      abi: setDigitalAssetURIAbi,\n    },\n    options,\n  });\n}\n\nconst addDigitalAssetPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Creates a transaction to add a property to a digital asset.\n * This function helps in enhancing the metadata associated with a digital asset by allowing the addition of custom properties.\n *\n * @param args - The arguments for the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key for the property being added.\n * @param args.propertyType - The type of the property being added.\n * @param args.propertyValue - The value of the property being added.\n * @param args.digitalAssetAddress - The address of the digital asset to which the property is being added.\n * @param args.digitalAssetType - The optional type of the digital asset.\n * @param args.options - Optional transaction generation options.\n * @group Implementation\n */\nexport async function addDigitalAssetPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::add_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [\n        AccountAddress.from(digitalAssetAddress),\n        new MoveString(propertyKey),\n        new MoveString(PropertyTypeMap[propertyType]),\n        MoveVector.U8(getSinglePropertyValueRaw(propertyValue, PropertyTypeMap[propertyType])),\n      ],\n      abi: addDigitalAssetPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst removeDigitalAssetPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))), new TypeTagStruct(stringStructTag())],\n};\n\n/**\n * Removes a property from a digital asset on the Aptos blockchain.\n * This function helps in managing the attributes of digital assets by allowing the removal of specific properties.\n *\n * @param args - The arguments for the transaction.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key of the property to be removed.\n * @param args.digitalAssetAddress - The address of the digital asset from which the property will be removed.\n * @param args.digitalAssetType - The type of the digital asset (optional).\n * @param args.options - Additional options for generating the transaction (optional).\n * @group Implementation\n */\nexport async function removeDigitalAssetPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, creator, propertyKey, digitalAssetAddress, digitalAssetType, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::remove_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(propertyKey)],\n      abi: removeDigitalAssetPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst updateDigitalAssetPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagStruct(stringStructTag()),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * Updates a property of a digital asset by generating a transaction for the Aptos blockchain.\n * This function allows you to modify attributes of a digital asset, facilitating dynamic changes to its properties.\n *\n * @param args - The arguments for updating the digital asset property.\n * @param args.aptosConfig - The configuration settings for the Aptos blockchain.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key of the property to be updated.\n * @param args.propertyType - The type of the property being updated.\n * @param args.propertyValue - The new value for the property.\n * @param args.digitalAssetAddress - The address of the digital asset to update.\n * @param args.digitalAssetType - (Optional) The type of the digital asset.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function updateDigitalAssetPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::update_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType],\n      functionArguments: [\n        AccountAddress.from(digitalAssetAddress),\n        new MoveString(propertyKey),\n        new MoveString(PropertyTypeMap[propertyType]),\n\n        /**\n         * Retrieves the raw byte representation of a single property value based on its type.\n         *\n         * @param propertyValue - The value of the property to convert.\n         * @param propertyType - The type of the property, which determines how the value is processed.\n         * @returns The raw byte representation of the property value.\n         * @group Implementation\n         */\n        getSinglePropertyValueRaw(propertyValue, PropertyTypeMap[propertyType]),\n      ],\n      abi: updateDigitalAssetPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst addDigitalAssetTypedPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }, { constraints: [] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagGeneric(1),\n  ],\n};\n\n/**\n * Creates a transaction to add a typed property to a digital asset.\n * This function helps in customizing digital assets by associating them with specific properties.\n *\n * @param args - The arguments required to create the transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key for the property being added.\n * @param args.propertyType - The type of the property being added.\n * @param args.propertyValue - The value of the property being added.\n * @param args.digitalAssetAddress - The address of the digital asset to which the property is being added.\n * @param args.digitalAssetType - (Optional) The type of the digital asset.\n * @param args.options - (Optional) Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function addDigitalAssetTypedPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::add_typed_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType, PropertyTypeMap[propertyType]],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(propertyKey), propertyValue],\n      abi: addDigitalAssetTypedPropertyAbi,\n    },\n    options,\n  });\n}\n\nconst updateDigitalAssetTypedPropertyAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [MoveAbility.KEY] }, { constraints: [] }],\n  parameters: [\n    new TypeTagStruct(objectStructTag(new TypeTagGeneric(0))),\n    new TypeTagStruct(stringStructTag()),\n    new TypeTagGeneric(1),\n  ],\n};\n\n/**\n * Updates the typed property of a digital asset by generating a transaction for the Aptos blockchain.\n *\n * @param args - The arguments for updating the digital asset typed property.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.creator - The account that is creating the transaction.\n * @param args.propertyKey - The key of the property to be updated.\n * @param args.propertyType - The type of the property being updated.\n * @param args.propertyValue - The new value for the property.\n * @param args.digitalAssetAddress - The address of the digital asset to be updated.\n * @param args.digitalAssetType - Optional. The type of the digital asset, if not provided, defaults to the standard type.\n * @param args.options - Optional. Additional options for generating the transaction.\n * @group Implementation\n */\nexport async function updateDigitalAssetTypedPropertyTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  propertyKey: string;\n  propertyType: PropertyType;\n  propertyValue: PropertyValue;\n  digitalAssetAddress: AccountAddressInput;\n  digitalAssetType?: MoveStructId;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const {\n    aptosConfig,\n    creator,\n    propertyKey,\n    propertyType,\n    propertyValue,\n    digitalAssetAddress,\n    digitalAssetType,\n    options,\n  } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress,\n    data: {\n      function: \"0x4::aptos_token::update_typed_property\",\n      typeArguments: [digitalAssetType ?? defaultDigitalAssetType, PropertyTypeMap[propertyType]],\n      functionArguments: [AccountAddress.from(digitalAssetAddress), new MoveString(propertyKey), propertyValue],\n      abi: updateDigitalAssetTypedPropertyAbi,\n    },\n    options,\n  });\n}\n\nfunction getPropertyValueRaw(propertyValues: Array<PropertyValue>, propertyTypes: Array<string>): Array<Uint8Array> {\n  const results = new Array<Uint8Array>();\n  propertyTypes.forEach((typ, index) => {\n    results.push(getSinglePropertyValueRaw(propertyValues[index], typ));\n  });\n\n  return results;\n}\n\nfunction getSinglePropertyValueRaw(propertyValue: PropertyValue, propertyType: string): Uint8Array {\n  const typeTag = parseTypeTag(propertyType);\n  const res = checkOrConvertArgument(propertyValue, typeTag, 0, []);\n  return res.bcsToBytes();\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AnyNumber,\n  GetCollectionDataResponse,\n  GetCurrentTokenOwnershipResponse,\n  GetOwnedTokensResponse,\n  GetTokenActivityResponse,\n  GetTokenDataResponse,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n} from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { Account } from \"../account\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport {\n  addDigitalAssetPropertyTransaction,\n  addDigitalAssetTypedPropertyTransaction,\n  burnDigitalAssetTransaction,\n  CreateCollectionOptions,\n  createCollectionTransaction,\n  freezeDigitalAssetTransferTransaction,\n  getCollectionData,\n  getCollectionDataByCollectionId,\n  getCollectionDataByCreatorAddress,\n  getCollectionDataByCreatorAddressAndCollectionName,\n  getCollectionId,\n  getCurrentDigitalAssetOwnership,\n  getDigitalAssetActivity,\n  getDigitalAssetData,\n  getOwnedDigitalAssets,\n  mintDigitalAssetTransaction,\n  mintSoulBoundTransaction,\n  PropertyType,\n  PropertyValue,\n  removeDigitalAssetPropertyTransaction,\n  setDigitalAssetDescriptionTransaction,\n  setDigitalAssetNameTransaction,\n  setDigitalAssetURITransaction,\n  transferDigitalAssetTransaction,\n  unfreezeDigitalAssetTransferTransaction,\n  updateDigitalAssetPropertyTransaction,\n  updateDigitalAssetTypedPropertyTransaction,\n} from \"../internal/digitalAsset\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * A class to query all `DigitalAsset` related queries on Aptos.\n * @group DigitalAsset\n */\nexport class DigitalAsset {\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your desired network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries data of a specific collection by the collection creator address and the collection name.\n   * This function is deprecated; use `getCollectionDataByCreatorAddressAndCollectionName` instead.\n   *\n   * If a creator account has two collections with the same name in v1 and v2, you can pass an optional `tokenStandard` parameter\n   * to query a specific standard.\n   *\n   * @param args - The arguments for querying the collection data.\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.collectionName - The name of the collection.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional parameters for the query.\n   * @param args.options.tokenStandard - The token standard to query.\n   * @returns GetCollectionDataResponse - The response type containing the collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Querying collection data by creator address and collection name\n   *   const collection = await aptos.getCollectionData({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     collectionName: \"myCollection\", // specify your collection name\n   *   });\n   *\n   *   console.log(collection);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionData(args: {\n    creatorAddress: AccountAddressInput;\n    collectionName: string;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n\n    const { creatorAddress, collectionName, options } = args;\n    const address = AccountAddress.from(creatorAddress);\n\n    const whereCondition: any = {\n      collection_name: { _eq: collectionName },\n      creator_address: { _eq: address.toStringLong() },\n    };\n    if (options?.tokenStandard) {\n      whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n    }\n\n    return getCollectionData({ aptosConfig: this.config, options: { where: whereCondition } });\n  }\n\n  /**\n   * Queries data of a specific collection by the collection creator address and the collection name.\n   * If a creator account has multiple collections with the same name across different versions,\n   * specify the `tokenStandard` parameter to query a specific standard.\n   *\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.collectionName - The name of the collection.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - Optional token standard to query.\n   * @returns GetCollectionDataResponse - The response type containing collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching collection data by creator address and collection name\n   *   const collection = await aptos.getCollectionDataByCreatorAddressAndCollectionName({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     collectionName: \"myCollection\",\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *     options: { tokenStandard: \"v2\" } // optional, specify if needed\n   *   });\n   *\n   *   console.log(collection);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionDataByCreatorAddressAndCollectionName(args: {\n    creatorAddress: AccountAddressInput;\n    collectionName: string;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n\n    return getCollectionDataByCreatorAddressAndCollectionName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves data for a specific collection created by a given creator address.\n   * This function allows you to query collection data while optionally specifying a minimum ledger version and pagination options.\n   *\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - Optional token standard to query.\n   * @param args.options.pagination - Optional pagination arguments.\n   * @returns GetCollectionDataResponse - The response type containing collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve collection data by creator address\n   *   const collectionData = await aptos.getCollectionDataByCreatorAddress({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     minimumLedgerVersion: 1, // specify the minimum ledger version if needed\n   *     options: {\n   *       tokenStandard: \"v2\", // specify the token standard if needed\n   *       pagination: { limit: 10, offset: 0 } // specify pagination options if needed\n   *     }\n   *   });\n   *\n   *   console.log(collectionData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionDataByCreatorAddress(args: {\n    creatorAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n\n    return getCollectionDataByCreatorAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries data of a specific collection by the collection ID.\n   *\n   * @param args.collectionId - The ID of the collection, which is the same as the address of the collection object.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional parameters for token standard and pagination.\n   * @returns GetCollectionDataResponse - The response type containing the collection data.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching collection data by collection ID\n   *   const collection = await aptos.getCollectionDataByCollectionId({\n   *     collectionId: \"0x123\", // replace with a real collection ID\n   *   });\n   *\n   *   console.log(collection);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionDataByCollectionId(args: {\n    collectionId: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs;\n  }): Promise<GetCollectionDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getCollectionDataByCollectionId({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the ID of a specified collection.\n   * This ID corresponds to the collection's object address in V2, while V1 does not utilize objects and lacks an address.\n   *\n   * @param args.creatorAddress - The address of the collection's creator.\n   * @param args.collectionName - The name of the collection.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options.tokenStandard - The token standard to query.\n   * @returns The collection ID.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the collection ID for a specific creator and collection name\n   *   const collectionId = await aptos.getCollectionId({\n   *     creatorAddress: \"0x1\", // replace with a real creator address\n   *     collectionName: \"myCollection\"\n   *   });\n   *\n   *   console.log(\"Collection ID:\", collectionId);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCollectionId(args: {\n    creatorAddress: AccountAddressInput;\n    collectionName: string;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg;\n  }): Promise<string> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getCollectionId({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves digital asset data using the address of a digital asset.\n   *\n   * @param args - The parameters for the request.\n   * @param args.digitalAssetAddress - The address of the digital asset.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns GetTokenDataResponse containing relevant data for the digital asset.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching digital asset data for a specific address\n   *   const digitalAsset = await aptos.getDigitalAssetData({\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(digitalAsset);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getDigitalAssetData(args: {\n    digitalAssetAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetTokenDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getDigitalAssetData({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current ownership data of a specified digital asset using its address.\n   *\n   * @param args The parameters for the request.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   *\n   * @returns GetCurrentTokenOwnershipResponse containing relevant ownership data of the digital asset.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the current ownership of a digital asset\n   *   const digitalAssetOwner = await aptos.getCurrentDigitalAssetOwnership({\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(digitalAssetOwner);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getCurrentDigitalAssetOwnership(args: {\n    digitalAssetAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetCurrentTokenOwnershipResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getCurrentDigitalAssetOwnership({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the digital assets owned by a specified address.\n   *\n   * @param args.ownerAddress The address of the owner.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional pagination and ordering parameters for the response.\n   *\n   * @returns GetOwnedTokensResponse containing ownership data of the digital assets belonging to the ownerAddress.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the digital assets owned by the specified address\n   *   const digitalAssets = await aptos.getOwnedDigitalAssets({\n   *     ownerAddress: \"0x1\", // replace with a real account address\n   *   });\n   *\n   *   console.log(digitalAssets);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getOwnedDigitalAssets(args: {\n    ownerAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetOwnedTokensResponse[0]>;\n  }): Promise<GetOwnedTokensResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getOwnedDigitalAssets({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the activity data for a specified digital asset using its address.\n   *\n   * @param args - The parameters for the request.\n   * @param args.digitalAssetAddress - The address of the digital asset.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to sync up to before querying.\n   * @param args.options - Optional pagination and ordering parameters.\n   *\n   * @returns A promise that resolves to the activity data related to the digital asset.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the activity data for a digital asset\n   *   const digitalAssetActivity = await aptos.getDigitalAssetActivity({\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(digitalAssetActivity);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async getDigitalAssetActivity(args: {\n    digitalAssetAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;\n  }): Promise<GetTokenActivityResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getDigitalAssetActivity({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Creates a new collection within the specified account.\n   *\n   * @param args.creator - The account of the collection's creator.\n   * @param args.description - The description of the collection.\n   * @param args.name - The name of the collection.\n   * @param args.uri - The URI to additional info about the collection.\n   * @param args.options - Optional parameters for generating the transaction.\n   *\n   * The parameters below are optional:\n   * @param args.maxSupply - Controls the max supply of the digital assets. Defaults to MAX_U64_BIG_INT.\n   * @param args.mutableDescription - Controls mutability of the collection's description. Defaults to true.\n   * @param args.mutableRoyalty - Controls mutability of the collection's royalty. Defaults to true.\n   * @param args.mutableUri - Controls mutability of the collection's URI. Defaults to true.\n   * @param args.mutableTokenDescription - Controls mutability of the digital asset's description. Defaults to true.\n   * @param args.mutableTokenName - Controls mutability of the digital asset's name. Defaults to true.\n   * @param args.mutableTokenProperties - Controls mutability of digital asset's properties. Defaults to true.\n   * @param args.mutableTokenUri - Controls mutability of the digital asset's URI. Defaults to true.\n   * @param args.tokensBurnableByCreator - Controls whether digital assets can be burnable by the creator. Defaults to true.\n   * @param args.tokensFreezableByCreator - Controls whether digital assets can be frozen by the creator. Defaults to true.\n   * @param args.royaltyNumerator - The numerator of the royalty to be paid to the creator when a digital asset is transferred.\n   * Defaults to 0.\n   * @param args.royaltyDenominator - The denominator of the royalty to be paid to the creator when a digital asset is\n   * transferred. Defaults to 1.\n   *\n   * @returns A SimpleTransaction that when submitted will create the collection.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Creating a new collection transaction\n   *   const transaction = await aptos.createCollectionTransaction({\n   *     creator: Account.generate(), // Replace with a real account\n   *     description: \"A unique collection of digital assets.\",\n   *     name: \"My Digital Collection\",\n   *     uri: \"https://mycollection.com\",\n   *   });\n   *\n   *   console.log(\"Transaction created:\", transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async createCollectionTransaction(\n    args: {\n      creator: Account;\n      description: string;\n      name: string;\n      uri: string;\n      options?: InputGenerateTransactionOptions;\n    } & CreateCollectionOptions,\n  ): Promise<SimpleTransaction> {\n    return createCollectionTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Create a transaction to mint a digital asset into the creator's account within an existing collection.\n   * This function helps you generate a transaction that can be simulated or submitted to the blockchain for minting a digital asset.\n   *\n   * @param args.creator - The creator of the collection.\n   * @param args.collection - The name of the collection the digital asset belongs to.\n   * @param args.description - The description of the digital asset.\n   * @param args.name - The name of the digital asset.\n   * @param args.uri - The URI to additional info about the digital asset.\n   * @param args.propertyKeys - Optional array of property keys for the digital asset.\n   * @param args.propertyTypes - Optional array of property types for the digital asset.\n   * @param args.propertyValues - Optional array of property values for the digital asset.\n   * @param args.options - Optional transaction generation options.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Creating a transaction to mint a digital asset\n   *   const transaction = await aptos.mintDigitalAssetTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     collection: \"MyCollection\",\n   *     description: \"This is a digital asset.\",\n   *     name: \"MyDigitalAsset\",\n   *     uri: \"https://example.com/my-digital-asset\",\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async mintDigitalAssetTransaction(args: {\n    creator: Account;\n    collection: string;\n    description: string;\n    name: string;\n    uri: string;\n    propertyKeys?: Array<string>;\n    propertyTypes?: Array<PropertyType>;\n    propertyValues?: Array<PropertyValue>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return mintDigitalAssetTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Transfer ownership of a non-fungible digital asset.\n   * This function allows you to transfer a digital asset only if it is not frozen, meaning the ownership transfer is not disabled.\n   *\n   * @param args The arguments for transferring the digital asset.\n   * @param args.sender The sender account of the current digital asset owner.\n   * @param args.digitalAssetAddress The address of the digital asset being transferred.\n   * @param args.recipient The account address of the recipient.\n   * @param args.digitalAssetType Optional. The type of the digital asset, defaults to \"0x4::token::Token\".\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Transfer a digital asset\n   *   const transaction = await aptos.transferDigitalAssetTransaction({\n   *     sender: Account.generate(), // replace with a real sender account\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *     recipient: \"0x456\", // replace with a real recipient account address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async transferDigitalAssetTransaction(args: {\n    sender: Account;\n    digitalAssetAddress: AccountAddressInput;\n    recipient: AccountAddress;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferDigitalAssetTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Mint a soul bound digital asset into a recipient's account.\n   * This function allows you to create a unique digital asset that is bound to a specific account.\n   *\n   * @param args - The arguments for minting the soul bound transaction.\n   * @param args.account - The account that mints the digital asset.\n   * @param args.collection - The collection name that the digital asset belongs to.\n   * @param args.description - The digital asset description.\n   * @param args.name - The digital asset name.\n   * @param args.uri - The digital asset URL.\n   * @param args.recipient - The account address where the digital asset will be created.\n   * @param args.propertyKeys - The property keys for storing on-chain properties.\n   * @param args.propertyTypes - The type of property values.\n   * @param args.propertyValues - The property values to be stored on-chain.\n   * @param args.options - Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Mint a soul bound digital asset\n   *   const transaction = await aptos.mintSoulBoundTransaction({\n   *     account: Account.generate(), // Replace with a real account\n   *     collection: \"collectionName\",\n   *     description: \"collectionDescription\",\n   *     name: \"digitalAssetName\",\n   *     uri: \"digital-asset-uri.com\",\n   *     recipient: \"0x123\" // Replace with a real recipient account address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async mintSoulBoundTransaction(args: {\n    account: Account;\n    collection: string;\n    description: string;\n    name: string;\n    uri: string;\n    recipient: AccountAddressInput;\n    propertyKeys?: Array<string>;\n    propertyTypes?: Array<PropertyType>;\n    propertyValues?: Array<PropertyValue>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return mintSoulBoundTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Burn a digital asset by its creator, allowing for the removal of a specified digital asset from the blockchain.\n   *\n   * @param args The arguments for burning the digital asset.\n   * @param args.creator The creator account that is burning the digital asset.\n   * @param args.digitalAssetAddress The address of the digital asset to be burned.\n   * @param args.digitalAssetType Optional. The type of the digital asset being burned.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const creator = Account.generate(); // Replace with a real creator account\n   *   const transaction = await aptos.burnDigitalAssetTransaction({\n   *     creator: creator,\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async burnDigitalAssetTransaction(args: {\n    creator: Account;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return burnDigitalAssetTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Freeze the ability to transfer a specified digital asset.\n   * This function allows the creator to restrict the transfer capability of a digital asset.\n   *\n   * @param args The arguments for freezing the digital asset transfer.\n   * @param args.creator The creator account initiating the freeze.\n   * @param args.digitalAssetAddress The address of the digital asset to be frozen.\n   * @param args.digitalAssetType Optional. The type of the digital asset being frozen.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Freeze the digital asset transfer\n   *   const transaction = await aptos.freezeDigitalAssetTransaferTransaction({\n   *     creator: Account.generate(), // Replace with a real account if needed\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async freezeDigitalAssetTransaferTransaction(args: {\n    creator: Account;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return freezeDigitalAssetTransferTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Unfreeze the ability to transfer a digital asset.\n   * This function allows the specified creator account to unfreeze the transfer of a digital asset identified by its address.\n   *\n   * @param args The parameters for unfreezing the digital asset transfer.\n   * @param args.creator The creator account that is unfreezing the digital asset transfer.\n   * @param args.digitalAssetAddress The address of the digital asset to unfreeze.\n   * @param args.digitalAssetType Optional. The type of the digital asset being unfrozen.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Unfreeze the ability to transfer a digital asset\n   *   const transaction = await aptos.unfreezeDigitalAssetTransaferTransaction({\n   *     creator: Account.generate(), // replace with a real creator account\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  // TODO: Rename Transafer to Transfer\n  async unfreezeDigitalAssetTransaferTransaction(args: {\n    creator: Account;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return unfreezeDigitalAssetTransferTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Set the digital asset description to provide additional context or information about the asset.\n   *\n   * @param args The parameters for setting the digital asset description.\n   * @param args.creator The creator account responsible for the digital asset.\n   * @param args.description The digital asset description to be set.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Set the digital asset description\n   *   const transaction = await aptos.setDigitalAssetDescriptionTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     description: \"This is a digital asset description.\",\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async setDigitalAssetDescriptionTransaction(args: {\n    creator: Account;\n    description: string;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return setDigitalAssetDescriptionTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Set the digital asset name, allowing you to define a name for a specific digital asset on the blockchain.\n   *\n   * @param args The parameters for setting the digital asset name.\n   * @param args.creator The creator account responsible for the transaction.\n   * @param args.name The desired name for the digital asset.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.digitalAssetType Optional. The type of the digital asset, represented as a Move struct ID.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the blockchain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const creator = Account.generate(); // Generate a new account for the creator\n   *   const digitalAssetAddress = \"0x123\"; // replace with a real digital asset address\n   *\n   *   // Set the digital asset name\n   *   const transaction = await aptos.setDigitalAssetNameTransaction({\n   *     creator: creator,\n   *     name: \"digitalAssetName\",\n   *     digitalAssetAddress: digitalAssetAddress,\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async setDigitalAssetNameTransaction(args: {\n    creator: Account;\n    name: string;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return setDigitalAssetNameTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Set the URI for a digital asset, allowing you to associate a unique identifier with the asset.\n   *\n   * @param args The parameters for the transaction.\n   * @param args.creator The creator account initiating the transaction.\n   * @param args.uri The digital asset URI to be set.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Set the URI for a digital asset\n   *   const transaction = await aptos.setDigitalAssetURITransaction({\n   *     creator: Account.generate(), // Replace with a real creator account\n   *     uri: \"digital-asset-uri.com\",\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async setDigitalAssetURITransaction(args: {\n    creator: Account;\n    uri: string;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return setDigitalAssetURITransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Add a digital asset property to the blockchain.\n   * This function allows you to specify a new property for a digital asset, including its key, type, and value.\n   *\n   * @param args - The arguments for adding a digital asset property.\n   * @param args.creator - The account that mints the digital asset.\n   * @param args.propertyKey - The property key for storing on-chain properties.\n   * @param args.propertyType - The type of property value.\n   * @param args.propertyValue - The property value to be stored on-chain.\n   * @param args.digitalAssetAddress - The digital asset address.\n   * @param args.digitalAssetType - (Optional) The type of the digital asset.\n   * @param args.options - (Optional) Options for generating the transaction.\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Add a digital asset property\n   *   const transaction = await aptos.addDigitalAssetPropertyTransaction({\n   *     creator: Account.generate(), // Replace with a real account\n   *     propertyKey: \"newKey\",\n   *     propertyType: \"BOOLEAN\",\n   *     propertyValue: true,\n   *     digitalAssetAddress: \"0x123\", // Replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async addDigitalAssetPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return addDigitalAssetPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Remove a digital asset property from the blockchain.\n   * This function allows you to delete an existing property associated with a digital asset.\n   *\n   * @param args The parameters required to remove the digital asset property.\n   * @param args.creator The account that mints the digital asset.\n   * @param args.propertyKey The property key for storing on-chain properties.\n   * @param args.propertyType The type of property value.\n   * @param args.propertyValue The property value to be stored on-chain.\n   * @param args.digitalAssetAddress The digital asset address.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Remove a digital asset property\n   *   const transaction = await aptos.removeDigitalAssetPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"newKey\",\n   *     propertyType: \"BOOLEAN\",\n   *     propertyValue: true,\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async removeDigitalAssetPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return removeDigitalAssetPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Update a digital asset property on-chain.\n   *\n   * @param args The parameters for updating the digital asset property.\n   * @param args.creator The account that mints the digital asset.\n   * @param args.digitalAssetAddress The address of the digital asset.\n   * @param args.propertyKey The property key for storing on-chain properties.\n   * @param args.propertyType The type of property value.\n   * @param args.propertyValue The property value to be stored on-chain.\n   * @param args.digitalAssetType Optional. The type of the digital asset.\n   * @param args.options Optional. Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Update a digital asset property\n   *   const transaction = await aptos.updateDigitalAssetPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"newKey\",\n   *     propertyType: \"BOOLEAN\",\n   *     propertyValue: false,\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async updateDigitalAssetPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return updateDigitalAssetPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Add a typed digital asset property to the blockchain.\n   * This function allows you to define and store a specific property for a digital asset, enabling better categorization and\n   * management of digital assets.\n   *\n   * @param args - The parameters for adding the typed property.\n   * @param args.creator - The account that mints the digital asset.\n   * @param args.propertyKey - The property key for storing on-chain properties.\n   * @param args.propertyType - The type of property value.\n   * @param args.propertyValue - The property value to be stored on-chain.\n   * @param args.digitalAssetAddress - The digital asset address.\n   * @param args.digitalAssetType - The optional type of the digital asset.\n   * @param args.options - Optional transaction generation options.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Adding a typed digital asset property\n   *   const transaction = await aptos.addDigitalAssetTypedPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"typedKey\",\n   *     propertyType: \"STRING\",\n   *     propertyValue: \"hello\",\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async addDigitalAssetTypedPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return addDigitalAssetTypedPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Update a typed digital asset property on-chain.\n   * This function allows you to modify the properties of a digital asset, enabling dynamic updates to its attributes.\n   *\n   * @param args - The arguments for updating the digital asset property.\n   * @param args.creator - The account that mints the digital asset.\n   * @param args.propertyKey - The property key for storing on-chain properties.\n   * @param args.propertyType - The type of property value.\n   * @param args.propertyValue - The property value to be stored on-chain.\n   * @param args.digitalAssetAddress - The digital asset address.\n   * @param args.digitalAssetType - (Optional) The type of the digital asset.\n   * @param args.options - (Optional) Additional options for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Update a typed digital asset property\n   *   const transaction = await aptos.updateDigitalAssetTypedPropertyTransaction({\n   *     creator: Account.generate(), // replace with a real account\n   *     propertyKey: \"typedKey\",\n   *     propertyType: \"U8\",\n   *     propertyValue: 2,\n   *     digitalAssetAddress: \"0x123\", // replace with a real digital asset address\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group DigitalAsset\n   */\n  async updateDigitalAssetTypedPropertyTransaction(args: {\n    creator: Account;\n    propertyKey: string;\n    propertyType: PropertyType;\n    propertyValue: PropertyValue;\n    digitalAssetAddress: AccountAddressInput;\n    digitalAssetType?: MoveStructId;\n    options?: InputGenerateTransactionOptions;\n  }) {\n    return updateDigitalAssetTypedPropertyTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/event}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * event namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { AnyNumber, GetEventsResponse, PaginationArgs, MoveStructId, OrderByArg, WhereArg } from \"../types\";\nimport { GetEventsQuery } from \"../types/generated/operations\";\nimport { GetEvents } from \"../types/generated/queries\";\nimport { EventsBoolExp, InputMaybe } from \"../types/generated/types\";\nimport { queryIndexer } from \"./general\";\n\nconst MAX_EVENT_TYPE_LENGTH = 300;\nconst checkEventTypeLength = (eventType?: InputMaybe<string>) => {\n  if (eventType && eventType.length > MAX_EVENT_TYPE_LENGTH) {\n    throw new Error(`Event type length exceeds the maximum length of ${MAX_EVENT_TYPE_LENGTH}`);\n  }\n};\n\n/**\n * Retrieves events associated with a specific module event type.\n * This function allows you to filter events based on the event type and pagination options.\n *\n * @param args - The arguments for retrieving module events.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.eventType - The MoveStructId representing the type of event to retrieve.\n * @param [args.options] - Optional pagination and ordering parameters for the event retrieval.\n * @group Implementation\n */\nexport async function getModuleEventsByEventType(args: {\n  aptosConfig: AptosConfig;\n  eventType: MoveStructId;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n}): Promise<GetEventsResponse> {\n  const { aptosConfig, eventType, options } = args;\n\n  const whereCondition: EventsBoolExp = {\n    _or: [\n      // EventHandle events\n      { account_address: { _eq: eventType.split(\"::\")[0] } },\n      // Module events\n      {\n        account_address: { _eq: \"0x0000000000000000000000000000000000000000000000000000000000000000\" },\n        sequence_number: { _eq: 0 },\n        creation_number: { _eq: 0 },\n      },\n    ],\n    indexed_type: { _eq: eventType },\n  };\n\n  return getEvents({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieve events associated with a specific account and creation number.\n *\n * @param args - The parameters for retrieving account events.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.accountAddress - The address of the account for which events are being retrieved.\n * @param args.creationNumber - The creation number to filter events.\n * @param args.options - Optional pagination and ordering parameters for the event retrieval.\n * @group Implementation\n */\nexport async function getAccountEventsByCreationNumber(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  creationNumber: AnyNumber;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n}): Promise<GetEventsResponse> {\n  const { accountAddress, aptosConfig, creationNumber, options } = args;\n  const address = AccountAddress.from(accountAddress);\n\n  const whereCondition: EventsBoolExp = {\n    account_address: { _eq: address.toStringLong() },\n    creation_number: { _eq: creationNumber },\n  };\n\n  return getEvents({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves events associated with a specific account and event type.\n *\n * @param args - The parameters for retrieving account events.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.accountAddress - The address of the account for which to retrieve events.\n * @param args.eventType - The type of event to filter by.\n * @param args.options - Optional pagination and ordering parameters for the event retrieval.\n * @group Implementation\n */\nexport async function getAccountEventsByEventType(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  eventType: MoveStructId;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n}): Promise<GetEventsResponse> {\n  const { accountAddress, aptosConfig, eventType, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: EventsBoolExp = {\n    account_address: { _eq: address },\n    indexed_type: { _eq: eventType },\n  };\n\n  return getEvents({ aptosConfig, options: { ...options, where: whereCondition } });\n}\n\n/**\n * Retrieves a list of events based on specified filtering and pagination options.\n *\n * @param args - The arguments for retrieving events.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.offset] - The number of records to skip before starting to collect the result set.\n * @param [args.options.limit] - The maximum number of records to return.\n * @param [args.options.orderBy] - Defines the order in which to return the events.\n * @param [args.options.where] - Conditions to filter the events.\n * @param [args.options.where.indexed_type] - Filters events by the indexed type.\n * @group Implementation\n */\nexport async function getEvents(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & OrderByArg<GetEventsResponse[0]> & WhereArg<EventsBoolExp>;\n}): Promise<GetEventsResponse> {\n  // eslint-disable-next-line no-console\n  console.warn(\n    // eslint-disable-next-line max-len\n    `[Aptos SDK] Events queries will be deprecated by the end of July 2025. Follow the details in https://aptoslabs.notion.site/Indexer-Feature-Updates-Events-v1-table-deprecation-and-end-of-support-July-1st-1ec8b846eb7280ffa042c0d3d7f45633?source=copy_link to migrate your events queries.`,\n  );\n  const { aptosConfig, options } = args;\n\n  /**\n   * Checks the length of event types based on the provided filtering options.\n   *\n   * @param options - The options for querying event types.\n   * @param options.where - The conditions to filter the event types.\n   * @param options.where.indexed_type - The indexed type to filter by.\n   * @param options.where.indexed_type._eq - The specific value to match for the indexed type.\n   * @param options.offset - The number of items to skip before starting to collect the result set.\n   * @param options.limit - The maximum number of items to return.\n   * @param options.orderBy - The criteria to sort the results.\n   * @group Implementation\n   */\n  // eslint-disable-next-line no-underscore-dangle\n  checkEventTypeLength(options?.where?.indexed_type?._eq);\n\n  const graphqlQuery = {\n    query: GetEvents,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetEventsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getEvents\",\n  });\n\n  return data.events;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  getAccountEventsByCreationNumber,\n  getAccountEventsByEventType,\n  getModuleEventsByEventType,\n  getEvents,\n} from \"../internal/event\";\nimport { AnyNumber, GetEventsResponse, MoveStructId, OrderByArg, PaginationArgs, WhereArg } from \"../types\";\nimport { EventsBoolExp } from \"../types/generated/types\";\nimport { AccountAddressInput } from \"../core\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\n\n/**\n * A class to query all `Event` Aptos related queries.\n * @group Event\n */\nexport class Event {\n  /**\n   * Initializes a new instance of the Aptos client with the provided configuration.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., Testnet, Mainnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet to use for funding accounts.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with Testnet configuration\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your own network if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Retrieve module events based on a specified event type.\n   * This function allows you to query for events that are associated with a particular module event type in the Aptos blockchain.\n   *\n   * @param args - The arguments for retrieving module events.\n   * @param args.eventType - The event type to filter the results.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional pagination and ordering parameters for the event results.\n   *\n   * @returns Promise<GetEventsResponse> - A promise that resolves to the retrieved events.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve module events for a specific event type\n   *   const events = await aptos.getModuleEventsByEventType({\n   *     eventType: \"0x1::transaction_fee::FeeStatement\", // specify the event type\n   *     minimumLedgerVersion: 1, // optional: specify minimum ledger version if needed\n   *   });\n   *\n   *   console.log(events); // log the retrieved events\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getModuleEventsByEventType(args: {\n    eventType: MoveStructId;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getModuleEventsByEventType({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve events associated with a specific account address and creation number.\n   *\n   * @param args - The parameters for retrieving account events.\n   * @param args.accountAddress - The account address to query events for.\n   * @param args.creationNumber - The event creation number to filter the events.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to sync up to before querying.\n   *\n   * @returns Promise<GetEventsResponse>\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get events for the account at creation number 0\n   *   const events = await aptos.getAccountEventsByCreationNumber({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     creationNumber: 0,\n   *   });\n   *\n   *   console.log(events);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getAccountEventsByCreationNumber(args: {\n    accountAddress: AccountAddressInput;\n    creationNumber: AnyNumber;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getAccountEventsByCreationNumber({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve events associated with a specific account address and event type.\n   *\n   * @param args.accountAddress - The account address to query events for.\n   * @param args.eventType - The type of event to filter by.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @param args.options - Optional pagination and ordering parameters for the event query.\n   *\n   * @returns Promise<GetEventsResponse>\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get events for a specific account and event type\n   *   const events = await aptos.getAccountEventsByEventType({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     eventType: \"0x1::transaction_fee::FeeStatement\", // replace with a real event type\n   *     minimumLedgerVersion: 1, // optional, specify if needed\n   *   });\n   *\n   *   console.log(events);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getAccountEventsByEventType(args: {\n    accountAddress: AccountAddressInput;\n    eventType: MoveStructId;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetEventsResponse[0]>;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getAccountEventsByEventType({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve all events from the Aptos blockchain.\n   * An optional `where` clause can be provided to filter the results based on specific criteria.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional pagination and filtering options.\n   * @param args.options.where Optional condition to filter events.\n   * @param args.options.offset Optional pagination offset.\n   * @param args.options.limit Optional maximum number of events to return.\n   * @param args.options.orderBy Optional ordering of the results.\n   *\n   * @returns GetEventsQuery response type containing the events.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve all events\n   *   const events = await aptos.getEvents();\n   *\n   *   // Retrieve events with filtering by account address\n   *   const whereCondition = {\n   *     account_address: { _eq: \"0x123\" }, // replace with a real account address\n   *   };\n   *   const filteredEvents = await aptos.getEvents({\n   *     options: { where: whereCondition },\n   *   });\n   *\n   *   console.log(events);\n   *   console.log(filteredEvents);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Event\n   */\n  async getEvents(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetEventsResponse[0]> & WhereArg<EventsBoolExp>;\n  }): Promise<GetEventsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.EVENTS_PROCESSOR,\n    });\n    return getEvents({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/faucet}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * faucet namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosFaucet } from \"../client\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { TransactionResponseType, UserTransactionResponse, WaitForTransactionOptions } from \"../types\";\nimport { DEFAULT_TXN_TIMEOUT_SEC } from \"../utils/const\";\nimport { waitForTransaction } from \"./transaction\";\n\n/**\n * Funds an account with a specified amount of tokens from the Aptos faucet.\n * This function is useful for quickly providing a new or existing account with tokens to facilitate transactions.\n *\n * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n * the minting page at https://aptos.dev/network/faucet.\n *\n * @param args - The arguments for funding the account.\n * @param args.aptosConfig - The configuration settings for connecting to the Aptos network.\n * @param args.accountAddress - The address of the account to be funded.\n * @param args.amount - The amount of tokens to fund the account with.\n * @param args.options - Optional parameters for the transaction.\n * @param args.options.timeoutSecs - The maximum time to wait for the transaction to complete, in seconds.\n * @param args.options.checkSuccess - A flag indicating whether to check if the transaction was successful.\n *\n * @throws Error if the transaction does not return a user transaction type.\n * @group Implementation\n */\nexport async function fundAccount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: AccountAddressInput;\n  amount: number;\n  options?: WaitForTransactionOptions;\n}): Promise<UserTransactionResponse> {\n  const { aptosConfig, accountAddress, amount, options } = args;\n  const timeout = options?.timeoutSecs || DEFAULT_TXN_TIMEOUT_SEC;\n  const { data } = await postAptosFaucet<any, { txn_hashes: Array<string> }>({\n    aptosConfig,\n    path: \"fund\",\n    body: {\n      address: AccountAddress.from(accountAddress).toString(),\n      amount,\n    },\n    originMethod: \"fundAccount\",\n  });\n\n  const txnHash = data.txn_hashes[0];\n\n  const res = await waitForTransaction({\n    aptosConfig,\n    transactionHash: txnHash,\n    options: {\n      timeoutSecs: timeout,\n      checkSuccess: options?.checkSuccess,\n    },\n  });\n\n  // Response is always User transaction for a user submitted transaction\n  if (res.type === TransactionResponseType.User) {\n    return res;\n  }\n\n  throw new Error(`Unexpected transaction received for fund account: ${res.type}`);\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fundAccount } from \"../internal/faucet\";\nimport { UserTransactionResponse, WaitForTransactionOptions } from \"../types\";\nimport { AccountAddressInput } from \"../core\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexer } from \"../internal/transaction\";\nimport { ProcessorType } from \"../utils\";\n\n/**\n * A class to query all `Faucet` related queries on Aptos.\n * @group Faucet\n */\nexport class Faucet {\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   *\n   * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n   * the minting page at https://aptos.dev/network/faucet.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.DEVNET }); // specify your own network if needed\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Faucet\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * This function creates an account if it does not exist and mints the specified amount of coins into that account.\n   *\n   * Note that only devnet has a publicly accessible faucet. For testnet, you must use\n   * the minting page at https://aptos.dev/network/faucet.\n   *\n   * @param args - The arguments for funding the account.\n   * @param args.accountAddress - The address of the account to fund.\n   * @param args.amount - The amount of tokens to fund the account with.\n   * @param args.options - Configuration options for waiting for the transaction.\n   * @returns Transaction hash of the transaction that funded the account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.DEVNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fund an account with a specified amount of tokens\n   *   const transaction = await aptos.fundAccount({\n   *     accountAddress: \"0x1\", // replace with your account address\n   *     amount: 100,\n   *   });\n   *\n   *   console.log(\"Transaction hash:\", transaction.hash);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Faucet\n   */\n  async fundAccount(args: {\n    accountAddress: AccountAddressInput;\n    amount: number;\n    options?: WaitForTransactionOptions;\n  }): Promise<UserTransactionResponse> {\n    const fundTxn = await fundAccount({ aptosConfig: this.config, ...args });\n\n    // If the user explicitly says to NOT wait by setting waitForIndexer to false, then we skip this.\n    // But, by default we want to wait for the indexer.\n    if (args.options?.waitForIndexer === undefined || args.options?.waitForIndexer) {\n      await waitForIndexer({\n        aptosConfig: this.config,\n        minimumLedgerVersion: BigInt(fundTxn.version),\n        processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n      });\n    }\n\n    return fundTxn;\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/fungible_asset}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * fungible_asset namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  AnyNumber,\n  GetCurrentFungibleAssetBalancesResponse,\n  GetFungibleAssetActivitiesResponse,\n  GetFungibleAssetMetadataResponse,\n  PaginationArgs,\n  WhereArg,\n} from \"../types\";\nimport { queryIndexer } from \"./general\";\nimport {\n  GetCurrentFungibleAssetBalances,\n  GetFungibleAssetActivities,\n  GetFungibleAssetMetadata,\n} from \"../types/generated/queries\";\nimport {\n  GetCurrentFungibleAssetBalancesQuery,\n  GetFungibleAssetActivitiesQuery,\n  GetFungibleAssetMetadataQuery,\n} from \"../types/generated/operations\";\nimport {\n  CurrentFungibleAssetBalancesBoolExp,\n  FungibleAssetActivitiesBoolExp,\n  FungibleAssetMetadataBoolExp,\n} from \"../types/generated/types\";\nimport { AccountAddressInput } from \"../core\";\nimport { Account } from \"../account\";\nimport {\n  EntryFunctionABI,\n  InputGenerateTransactionOptions,\n  parseTypeTag,\n  TypeTagAddress,\n  TypeTagU64,\n} from \"../transactions\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * Retrieves metadata for fungible assets based on specified criteria.\n * This function allows you to filter and paginate through fungible asset metadata.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for Aptos.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.limit] - The maximum number of results to return.\n * @param [args.options.offset] - The number of results to skip before starting to collect the result set.\n * @param [args.options.where] - Conditions to filter the results.\n * @group Implementation\n */\nexport async function getFungibleAssetMetadata(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<FungibleAssetMetadataBoolExp>;\n}): Promise<GetFungibleAssetMetadataResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetFungibleAssetMetadata,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.limit,\n      offset: options?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetFungibleAssetMetadataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetMetadata\",\n  });\n\n  return data.fungible_asset_metadata;\n}\n\n/**\n * Retrieves the activities associated with fungible assets.\n * This function allows you to filter and paginate through the activities based on specified conditions.\n *\n * @param args - The arguments for retrieving fungible asset activities.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.limit] - The maximum number of activities to retrieve.\n * @param [args.options.offset] - The number of activities to skip before starting to collect the result set.\n * @param [args.options.where] - Conditions to filter the activities.\n * @returns A promise that resolves to an array of fungible asset activities.\n * @group Implementation\n */\nexport async function getFungibleAssetActivities(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<FungibleAssetActivitiesBoolExp>;\n}): Promise<GetFungibleAssetActivitiesResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetFungibleAssetActivities,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.limit,\n      offset: options?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetFungibleAssetActivitiesQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetActivities\",\n  });\n\n  return data.fungible_asset_activities;\n}\n\n/**\n * Retrieves the current balances of fungible assets for a specified configuration.\n *\n * @param args - The arguments for retrieving fungible asset balances.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.options - Optional parameters for pagination and filtering.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the results.\n * @param args.options.where - Conditions to filter the results based on specific criteria.\n * @returns The current balances of fungible assets.\n * @group Implementation\n */\nexport async function getCurrentFungibleAssetBalances(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetCurrentFungibleAssetBalancesResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetCurrentFungibleAssetBalances,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.limit,\n      offset: options?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentFungibleAssetBalancesQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentFungibleAssetBalances\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\nconst faTransferAbi: EntryFunctionABI = {\n  typeParameters: [{ constraints: [] }],\n  parameters: [parseTypeTag(\"0x1::object::Object\"), new TypeTagAddress(), new TypeTagU64()],\n};\n\n/**\n * Transfers a specified amount of a fungible asset from the sender to the recipient.\n * This function helps facilitate the transfer of digital assets between accounts on the Aptos blockchain.\n *\n * @param args - The parameters for the transfer operation.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.sender - The account initiating the transfer.\n * @param args.fungibleAssetMetadataAddress - The address of the fungible asset's metadata.\n * @param args.recipient - The address of the account receiving the asset.\n * @param args.amount - The amount of the fungible asset to transfer.\n * @param args.options - Optional settings for generating the transaction.\n * @group Implementation\n */\nexport async function transferFungibleAsset(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  fungibleAssetMetadataAddress: AccountAddressInput;\n  recipient: AccountAddressInput;\n  amount: AnyNumber;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, fungibleAssetMetadataAddress, recipient, amount, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::primary_fungible_store::transfer\",\n      typeArguments: [\"0x1::fungible_asset::Metadata\"],\n      functionArguments: [fungibleAssetMetadataAddress, recipient, amount],\n      abi: faTransferAbi,\n    },\n    options,\n  });\n}\n\n/**\n * Transfers a specified amount of a fungible asset from any (primary or secondary) fungible store to any (primary or secondary) fungible store.\n * This function helps facilitate the transfer of digital assets between fungible stores on the Aptos blockchain.\n *\n * @param args - The parameters for the transfer operation.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.sender - The account initiating the transfer.\n * @param args.fromStore - The address of the fungible store initiating the transfer.\n * @param args.toStore - The address of the fungible store receiving the asset.\n * @param args.amount - The amount of the fungible asset to transfer. Must be a positive number.\n * @param args.options - Optional settings for generating the transaction.\n * @returns A SimpleTransaction that can be submitted to the blockchain.\n * @throws Error if the transaction generation fails or if the input parameters are invalid.\n * @group Implementation\n */\nexport async function transferFungibleAssetBetweenStores(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  fromStore: AccountAddressInput;\n  toStore: AccountAddressInput;\n  amount: AnyNumber;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, fromStore, toStore, amount, options } = args;\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::dispatchable_fungible_asset::transfer\",\n      typeArguments: [\"0x1::fungible_asset::FungibleStore\"],\n      functionArguments: [fromStore, toStore, amount],\n      abi: faTransferAbi,\n    },\n    options,\n  });\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AnyNumber,\n  GetCurrentFungibleAssetBalancesResponse,\n  GetFungibleAssetActivitiesResponse,\n  GetFungibleAssetMetadataResponse,\n  PaginationArgs,\n  WhereArg,\n} from \"../types\";\nimport {\n  getCurrentFungibleAssetBalances,\n  getFungibleAssetActivities,\n  getFungibleAssetMetadata,\n  transferFungibleAsset,\n  transferFungibleAssetBetweenStores,\n} from \"../internal/fungibleAsset\";\nimport {\n  CurrentFungibleAssetBalancesBoolExp,\n  FungibleAssetActivitiesBoolExp,\n  FungibleAssetMetadataBoolExp,\n} from \"../types/generated/types\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { InputGenerateTransactionOptions } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * A class for querying and managing fungible asset-related operations on the Aptos blockchain.\n * @group FungibleAsset\n */\nexport class FungibleAsset {\n  /**\n   * Initializes a new instance of the Aptos class with the provided configuration.\n   * This allows you to interact with the Aptos blockchain using the specified network settings.\n   *\n   * @param config - The configuration settings for connecting to the Aptos network.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your own network if needed\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries all fungible asset metadata.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional configuration for pagination and filtering.\n   *\n   * @returns A list of fungible asset metadata.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching fungible asset metadata\n   *   const fungibleAssets = await aptos.getFungibleAssetMetadata();\n   *   console.log(fungibleAssets);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetMetadata(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<FungibleAssetMetadataBoolExp>;\n  }): Promise<GetFungibleAssetMetadataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getFungibleAssetMetadata({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the fungible asset metadata for a specific asset type.\n   * This function helps retrieve detailed information about a fungible asset based on its type.\n   *\n   * @param args - The parameters for the query.\n   * @param args.assetType - The asset type of the fungible asset, e.g., \"0x1::aptos_coin::AptosCoin\" for Aptos Coin.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   *\n   * @returns A fungible asset metadata item.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve fungible asset metadata by asset type\n   *   const fungibleAsset = await aptos.getFungibleAssetMetadataByAssetType({\n   *     assetType: \"0x1::aptos_coin::AptosCoin\" // replace with your asset type\n   *   });\n   *\n   *   console.log(fungibleAsset);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetMetadataByAssetType(args: {\n    assetType: string;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetFungibleAssetMetadataResponse[0]> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          asset_type: { _eq: args.assetType },\n        },\n      },\n    });\n\n    return data[0];\n  }\n\n  /**\n   * Retrieves fungible asset metadata based on the creator address.\n   *\n   * This function allows you to query metadata for a specific fungible asset created by a given address.\n   *\n   * @param args - The parameters for the query.\n   * @param args.creatorAddress - The creator address of the fungible asset.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   *\n   * @returns A fungible asset metadata item.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve fungible asset metadata by creator address\n   *   const fungibleAsset = await aptos.getFungibleAssetMetadataByCreatorAddress({\n   *     creatorAddress: \"0x123\", // replace with a real creator address\n   *   });\n   *\n   *   console.log(fungibleAsset);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetMetadataByCreatorAddress(args: {\n    creatorAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetFungibleAssetMetadataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          creator_address: { _eq: AccountAddress.from(args.creatorAddress).toStringLong() },\n        },\n      },\n    });\n\n    return data;\n  }\n\n  /**\n   * Queries all fungible asset activities and returns a list of their metadata.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying.\n   * @param args.options Optional configuration for pagination and filtering.\n   * @returns A list of fungible asset metadata.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching fungible asset activities\n   *   const fungibleAssetActivities = await aptos.getFungibleAssetActivities();\n   *   console.log(fungibleAssetActivities);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getFungibleAssetActivities(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<FungibleAssetActivitiesBoolExp>;\n  }): Promise<GetFungibleAssetActivitiesResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getFungibleAssetActivities({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries all fungible asset balances.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying.\n   * @param args.options Optional configuration for pagination and filtering.\n   *\n   * @returns A list of fungible asset metadata.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching current fungible asset balances\n   *   const fungibleAssetBalances = await aptos.getCurrentFungibleAssetBalances();\n   *\n   *   console.log(fungibleAssetBalances);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async getCurrentFungibleAssetBalances(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetCurrentFungibleAssetBalancesResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getCurrentFungibleAssetBalances({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Transfer a specified amount of fungible asset from the sender's primary store to the recipient's primary store.\n   * This method allows you to transfer any fungible asset, including fungible tokens.\n   *\n   * @param args - The arguments for the transfer operation.\n   * @param args.sender - The sender account.\n   * @param args.fungibleAssetMetadataAddress - The fungible asset account address. For example, if you're transferring USDT,\n   * this would be the USDT address.\n   * @param args.recipient - The recipient account address.\n   * @param args.amount - The number of assets to transfer.\n   * @param args.options - Optional parameters for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Transfer fungible asset from sender to recipient\n   *   const transaction = await aptos.transferFungibleAsset({\n   *     sender: Account.generate(), // replace with a real sender account\n   *     fungibleAssetMetadataAddress: \"0x123\", // replace with a real fungible asset address\n   *     recipient: \"0x456\", // replace with a real recipient account\n   *     amount: 5\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async transferFungibleAsset(args: {\n    sender: Account;\n    fungibleAssetMetadataAddress: AccountAddressInput;\n    recipient: AccountAddressInput;\n    amount: AnyNumber;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferFungibleAsset({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Transfer a specified amount of fungible asset from the sender's any (primary or secondary) fungible store to any (primary or secondary) fungible store.\n   * This method allows you to transfer any fungible asset, including fungible tokens.\n   *\n   * @param args - The arguments for the transfer operation.\n   * @param args.sender - The sender account initiating the transfer.\n   * @param args.fromStore - The fungible store address initiating the transfer.\n   * @param args.toStore - The fungible store address receiving the asset.\n   * @param args.amount - The number of assets to transfer. Must be a positive number.\n   * @param args.options - Optional parameters for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @throws Error if:\n   * - The sender account is invalid\n   * - The store addresses are invalid\n   * - The amount is negative or zero\n   * - The transaction fails to generate\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function transferAssets() {\n   *   // Transfer 100 units of the asset from senderStore to recipientStore\n   *   const transaction = await aptos.transferFungibleAssetBetweenStores({\n   *     sender: Account.generate(), // replace with a real sender account\n   *     fromStore: \"0x123\", // replace with a real fungible store address\n   *     toStore: \"0x456\", // replace with a real fungible store address\n   *     amount: 100\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   *\n   * transferAssets().catch(console.error);\n   * ```\n   * @group FungibleAsset\n   */\n  async transferFungibleAssetBetweenStores(args: {\n    sender: Account;\n    fromStore: AccountAddressInput;\n    toStore: AccountAddressInput;\n    amount: AnyNumber;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return transferFungibleAssetBetweenStores({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getChainTopUserTransactions,\n  getIndexerLastSuccessVersion,\n  getLedgerInfo,\n  getProcessorStatus,\n  queryIndexer,\n} from \"../internal/general\";\nimport { getBlockByHeight, getBlockByVersion } from \"../internal/transaction\";\nimport { view, viewJson } from \"../internal/view\";\nimport {\n  AnyNumber,\n  Block,\n  GetChainTopUserTransactionsResponse,\n  GetProcessorStatusResponse,\n  GraphqlQuery,\n  LedgerInfo,\n  LedgerVersionArg,\n  MoveValue,\n} from \"../types\";\nimport { ProcessorType } from \"../utils/const\";\nimport { InputViewFunctionData, InputViewFunctionJsonData } from \"../transactions\";\n\n/**\n * A class to query various Aptos-related information and perform operations on the Aptos blockchain.\n * @group General\n */\nexport class General {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows users to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // specify the network\n   *         nodeUrl: \"https://testnet.aptos.dev\" // specify the node URL\n   *     });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries for the Aptos ledger information.\n   *\n   * @returns The Aptos Ledger Info, which includes details such as chain ID, epoch, and ledger version.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the ledger information\n   *   const ledgerInfo = await aptos.getLedgerInfo();\n   *\n   *   console.log(ledgerInfo);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getLedgerInfo(): Promise<LedgerInfo> {\n    return getLedgerInfo({ aptosConfig: this.config });\n  }\n\n  /**\n   * Retrieves the chain ID of the Aptos blockchain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching the chain ID\n   *   const chainId = await aptos.getChainId();\n   *   console.log(\"Chain ID:\", chainId);\n   * }\n   * runExample().catch(console.error);\n   *\n   * @returns The chain ID of the Aptos blockchain.\n   * ```\n   * @group General\n   */\n  async getChainId(): Promise<number> {\n    const result = await this.getLedgerInfo();\n    return result.chain_id;\n  }\n\n  /**\n   * Retrieves block information by the specified ledger version.\n   *\n   * @param args - The arguments for retrieving the block.\n   * @param args.ledgerVersion - The ledger version to lookup block information for.\n   * @param args.options - Optional parameters for the request.\n   * @param args.options.withTransactions - If set to true, include all transactions in the block.\n   *\n   * @returns Block information with optional transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve block information for a specific ledger version\n   *   const block = await aptos.getBlockByVersion({ ledgerVersion: 5 });\n   *   console.log(block);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getBlockByVersion(args: {\n    ledgerVersion: AnyNumber;\n    options?: { withTransactions?: boolean };\n  }): Promise<Block> {\n    return getBlockByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieve a block by its height, allowing for the inclusion of transactions if specified.\n   *\n   * @param args - The parameters for the block retrieval.\n   * @param args.blockHeight - The block height to look up, starting at 0.\n   * @param args.options - Optional settings for the retrieval.\n   * @param args.options.withTransactions - If set to true, includes all transactions in the block.\n   *\n   * @returns The block with optional transactions included.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the block at height 5, including transactions\n   *   const block = await aptos.getBlockByHeight({ blockHeight: 5, options: { withTransactions: true } });\n   *   console.log(block);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getBlockByHeight(args: { blockHeight: AnyNumber; options?: { withTransactions?: boolean } }): Promise<Block> {\n    return getBlockByHeight({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a Move view function\n   * @param args.payload Payload for the view function\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @example\n   * const data = await aptos.view({\n   *  payload: {\n   *   function: \"0x1::coin::balance\",\n   *   typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *   functionArguments: [accountAddress],\n   *  }\n   * })\n   *\n   * @returns an array of Move values\n   * @group General\n   */\n  async view<T extends Array<MoveValue>>(args: {\n    payload: InputViewFunctionData;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return view<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a Move view function with JSON, this provides compatability with the old `aptos` package\n   * @param args.payload Payload for the view function\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @example\n   * const data = await aptos.view({\n   *  payload: {\n   *   function: \"0x1::coin::balance\",\n   *   typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *   functionArguments: [accountAddress.toString()],\n   *  }\n   * })\n   *\n   * @returns an array of Move values\n   * @group General\n   */\n  async viewJson<T extends Array<MoveValue>>(args: {\n    payload: InputViewFunctionJsonData;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return viewJson<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the top user transactions based on the specified limit.\n   *\n   * @param args - The arguments for querying top user transactions.\n   * @param args.limit - The number of transactions to return.\n   * @returns GetChainTopUserTransactionsResponse\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch the top user transactions with a limit of 5\n   *   const topUserTransactions = await aptos.getChainTopUserTransactions({ limit: 5 });\n   *\n   *   console.log(topUserTransactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getChainTopUserTransactions(args: { limit: number }): Promise<GetChainTopUserTransactionsResponse> {\n    return getChainTopUserTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Retrieves data from the Aptos Indexer using a GraphQL query.\n   * This function allows you to execute complex queries to fetch specific data from the Aptos blockchain.\n   *\n   * @param args.query.query - A GraphQL query string.\n   * @param args.query.variables - The variables for the query (optional).\n   *\n   * @return The provided T type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Querying the Aptos Indexer for ledger information\n   *   const topUserTransactions = await aptos.queryIndexer({\n   *     query: { query: `query MyQuery {\n   *       ledger_infos {\n   *         chain_id\n   *       }\n   *     }`}\n   *   });\n   *\n   *   console.log(topUserTransactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async queryIndexer<T extends {}>(args: { query: GraphqlQuery }): Promise<T> {\n    return queryIndexer<T>({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for the last successful indexer version, providing insight into the ledger version the indexer is updated to, which\n   * may lag behind the full nodes.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the last successful indexer version\n   *   const version = await aptos.getIndexerLastSuccessVersion();\n   *   console.log(`Last successful indexer version: ${version}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getIndexerLastSuccessVersion(): Promise<bigint> {\n    return getIndexerLastSuccessVersion({ aptosConfig: this.config });\n  }\n\n  /**\n   * Query the processor status for a specific processor type.\n   *\n   * @param processorType The processor type to query.\n   * @returns The status of the specified processor type.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the processor status for the account transactions processor\n   *   const status = await aptos.getProcessorStatus(\"account_transactions_processor\");\n   *   console.log(status);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group General\n   */\n  async getProcessorStatus(processorType: ProcessorType): Promise<GetProcessorStatusResponse[0]> {\n    return getProcessorStatus({ aptosConfig: this.config, processorType });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/name}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * name namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { GetANSNameResponse, MoveAddressType, OrderByArg, PaginationArgs, WhereArg } from \"../types\";\nimport { GetNamesQuery } from \"../types/generated/operations\";\nimport { GetNames } from \"../types/generated/queries\";\nimport { CurrentAptosNamesBoolExp } from \"../types/generated/types\";\nimport { Network } from \"../utils/apiEndpoints\";\nimport { queryIndexer } from \"./general\";\nimport { view } from \"./view\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\nexport const VALIDATION_RULES_DESCRIPTION = [\n  \"A name must be between 3 and 63 characters long,\",\n  \"and can only contain lowercase a-z, 0-9, and hyphens.\",\n  \"A name may not start or end with a hyphen.\",\n].join(\" \");\n\n/**\n * Validate if a given fragment is a valid ANS segment.\n * This function checks the length and character constraints of the fragment to ensure it meets the ANS standards.\n *\n * @param fragment - A fragment of a name, either the domain or subdomain.\n * @returns A boolean indicating if the fragment is a valid fragment.\n * @group Implementation\n */\nexport function isValidANSSegment(fragment: string): boolean {\n  if (!fragment) return false;\n  if (fragment.length < 3) return false;\n  if (fragment.length > 63) return false;\n  // only lowercase a-z and 0-9 are allowed, along with -. a domain may not start or end with a hyphen\n  if (!/^[a-z\\d][a-z\\d-]{1,61}[a-z\\d]$/.test(fragment)) return false;\n  return true;\n}\n\n/**\n * Checks if an ANS name is valid or not.\n *\n * @param name - A string of the domain name, which can include or exclude the .apt suffix.\n * @group Implementation\n */\nexport function isValidANSName(name: string): { domainName: string; subdomainName?: string } {\n  const [first, second, ...rest] = name.replace(/\\.apt$/, \"\").split(\".\");\n\n  if (rest.length > 0) {\n    throw new Error(`${name} is invalid. A name can only have two parts, a domain and a subdomain separated by a \".\"`);\n  }\n\n  if (!isValidANSSegment(first)) {\n    throw new Error(`${first} is not valid. ${VALIDATION_RULES_DESCRIPTION}`);\n  }\n\n  if (second && !isValidANSSegment(second)) {\n    throw new Error(`${second} is not valid. ${VALIDATION_RULES_DESCRIPTION}`);\n  }\n\n  return {\n    domainName: second || first,\n    subdomainName: second ? first : undefined,\n  };\n}\n\n/**\n * Policy for determining how subdomains expire in relation to their parent domain.\n * @group Implementation\n */\nexport enum SubdomainExpirationPolicy {\n  Independent = 0,\n  FollowsDomain = 1,\n}\n\n/**\n * Determine if a given ANS name is considered active based on its expiration dates.\n * Domains are active if their expiration date is in the future, while subdomains may\n * follow their parent's expiration policy (1) or expire independently (0).\n * If the subdomain is expiring independently, it can expire before their parent, but not after.\n *\n * @param name - An ANS name returned from one of the functions of the SDK.\n * @returns A boolean indicating whether the contract considers the name active or not.\n * @group Implementation\n */\nexport function isActiveANSName(name: GetANSNameResponse[0]): boolean {\n  if (!name) return false;\n\n  const isTLDExpired = new Date(name.domain_expiration_timestamp).getTime() < Date.now();\n  const isExpired = new Date(name.expiration_timestamp).getTime() < Date.now();\n\n  // If we are a subdomain, if our parent is expired we are always expired\n  if (name.subdomain && isTLDExpired) return false;\n\n  // If we are a subdomain and our expiration policy is to follow the domain, we\n  // are active (since we know our parent is not expired by this point)\n  if (name.subdomain && name.subdomain_expiration_policy === SubdomainExpirationPolicy.FollowsDomain) return true;\n\n  // At this point, we are either a TLD or a subdomain with an independent\n  // expiration policy, we are active as long as we the expiration timestamp\n  return !isExpired;\n}\n\nexport const LOCAL_ANS_ACCOUNT_PK =\n  process.env.ANS_TEST_ACCOUNT_PRIVATE_KEY ??\n  \"ed25519-priv-0x37368b46ce665362562c6d1d4ec01a08c8644c488690df5a17e13ba163e20221\";\nexport const LOCAL_ANS_ACCOUNT_ADDRESS =\n  process.env.ANS_TEST_ACCOUNT_ADDRESS ?? \"0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82\";\n\nconst NetworkToAnsContract: Record<Network, string | null> = {\n  [Network.TESTNET]: \"0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c\",\n  [Network.MAINNET]: \"0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c\",\n  [Network.LOCAL]: LOCAL_ANS_ACCOUNT_ADDRESS,\n  [Network.CUSTOM]: null,\n  [Network.DEVNET]: null,\n};\n\n/**\n * Retrieves the address of the ANS contract based on the specified Aptos network configuration.\n *\n * @param aptosConfig - The configuration object for the Aptos network.\n * @param aptosConfig.network - The network for which to retrieve the ANS contract address.\n *\n * @throws Throws an error if the ANS contract is not deployed to the specified network.\n * @group Implementation\n */\nfunction getRouterAddress(aptosConfig: AptosConfig): string {\n  const address = NetworkToAnsContract[aptosConfig.network];\n  if (!address) throw new Error(`The ANS contract is not deployed to ${aptosConfig.network}`);\n  return address;\n}\n\nconst unwrapOption = <T>(option: any): T | undefined => {\n  if (!!option && typeof option === \"object\" && \"vec\" in option && Array.isArray(option.vec)) {\n    return option.vec[0];\n  }\n\n  return undefined;\n};\n\n/**\n * Retrieve the owner address of a specified domain or subdomain.\n *\n * @param args - The arguments for retrieving the owner address.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.name - The name of the domain or subdomain to query.\n * @returns The account address of the owner, or undefined if not found.\n * @group Implementation\n */\nexport async function getOwnerAddress(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<AccountAddress | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_owner_addr`,\n      functionArguments: [domainName, subdomainName],\n    },\n  });\n\n  const owner = unwrapOption<MoveAddressType>(res[0]);\n\n  return owner ? AccountAddress.from(owner) : undefined;\n}\n\n/**\n * Parameters for registering a name in the Aptos network.\n *\n * @param aptosConfig - Configuration settings for the Aptos network.\n * @param sender - The account initiating the name registration.\n * @param name - The name to be registered.\n * @param expiration - The expiration policy for the name registration.\n * @group Implementation\n */\nexport interface RegisterNameParameters {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  expiration:\n    | { policy: \"domain\"; years?: 1 }\n    | { policy: \"subdomain:follow-domain\" }\n    | { policy: \"subdomain:independent\"; expirationDate: number };\n  transferable?: boolean;\n  toAddress?: AccountAddressInput;\n  targetAddress?: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}\n\n/**\n * Registers a domain or subdomain with the specified parameters. This function ensures that the provided names and expiration\n * policies are valid before proceeding with the registration process.\n *\n * @param args - The parameters required for registering a name.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.expiration - The expiration details for the registration.\n * @param args.name - The name to be registered, which can be a domain or subdomain.\n * @param args.sender - The account details of the sender initiating the registration.\n * @param args.targetAddress - The target address for the registration.\n * @param args.toAddress - The address to which the registration is associated.\n * @param args.options - Additional options for the registration process.\n * @param args.transferable - Indicates whether the registered name is transferable.\n *\n * @throws Error if the provided expiration policy is invalid for subdomains.\n * @throws Error if the domain does not exist.\n * @throws Error if the subdomain expiration time exceeds the domain expiration time.\n *\n * @returns A transaction object representing the registration process.\n * @group Implementation\n */\nexport async function registerName(args: RegisterNameParameters): Promise<SimpleTransaction> {\n  const { aptosConfig, expiration, name, sender, targetAddress, toAddress, options, transferable } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const hasSubdomainPolicy =\n    expiration.policy === \"subdomain:independent\" || expiration.policy === \"subdomain:follow-domain\";\n\n  if (subdomainName && !hasSubdomainPolicy) {\n    throw new Error(\n      \"Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'\",\n    );\n  }\n\n  if (hasSubdomainPolicy && !subdomainName) {\n    throw new Error(`Policy is set to ${expiration.policy} but no subdomain was provided`);\n  }\n\n  if (expiration.policy === \"domain\") {\n    const years = expiration.years ?? 1;\n    if (years !== 1) {\n      throw new Error(\"For now, names can only be registered for 1 year at a time\");\n    }\n\n    const secondsInYear = 31536000;\n    const registrationDuration = years * secondsInYear;\n\n    const transaction = await generateTransaction({\n      aptosConfig,\n      sender: sender.accountAddress.toString(),\n      data: {\n        function: `${routerAddress}::router::register_domain`,\n        functionArguments: [domainName, registrationDuration, targetAddress, toAddress],\n      },\n      options,\n    });\n\n    return transaction;\n  }\n\n  // We are a subdomain\n  if (!subdomainName) {\n    throw new Error(`${expiration.policy} requires a subdomain to be provided.`);\n  }\n\n  const tldExpiration = await getExpiration({ aptosConfig, name: domainName });\n  if (!tldExpiration) {\n    throw new Error(\"The domain does not exist\");\n  }\n\n  const expirationDateInMillisecondsSinceEpoch =\n    expiration.policy === \"subdomain:independent\" ? expiration.expirationDate : tldExpiration;\n\n  if (expirationDateInMillisecondsSinceEpoch > tldExpiration) {\n    throw new Error(\"The subdomain expiration time cannot be greater than the domain expiration time\");\n  }\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::register_subdomain`,\n      functionArguments: [\n        domainName,\n        subdomainName,\n        Math.round(expirationDateInMillisecondsSinceEpoch / 1000),\n        expiration.policy === \"subdomain:follow-domain\" ? 1 : 0,\n        !!transferable,\n        targetAddress,\n        toAddress,\n      ],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * Retrieves the expiration time of a specified domain or subdomain in epoch milliseconds.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.name - The name of the domain or subdomain to check.\n * @returns The expiration time in epoch milliseconds, or undefined if an error occurs.\n * @group Implementation\n */\nexport async function getExpiration(args: { aptosConfig: AptosConfig; name: string }): Promise<number | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  try {\n    const res = await view({\n      aptosConfig,\n      payload: {\n        function: `${routerAddress}::router::get_expiration`,\n        functionArguments: [domainName, subdomainName],\n      },\n    });\n\n    // Normalize expiration time from epoch seconds to epoch milliseconds\n    return Number(res[0]) * 1000;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * Retrieves the primary name associated with a given account address.\n * This function helps in obtaining the complete domain name by combining the subdomain and domain names.\n *\n * @param args - The arguments for retrieving the primary name.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.address - The account address for which to retrieve the primary name.\n * @returns The primary name as a string, or undefined if no domain name exists.\n * @group Implementation\n */\nexport async function getPrimaryName(args: {\n  aptosConfig: AptosConfig;\n  address: AccountAddressInput;\n}): Promise<string | undefined> {\n  const { aptosConfig, address } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_primary_name`,\n      functionArguments: [AccountAddress.from(address).toString()],\n    },\n  });\n\n  const domainName = unwrapOption<MoveAddressType>(res[1]);\n  const subdomainName = unwrapOption<MoveAddressType>(res[0]);\n\n  if (!domainName) return undefined;\n\n  return [subdomainName, domainName].filter(Boolean).join(\".\");\n}\n\n/**\n * Sets the primary name for the specified account, allowing for the association of a domain or subdomain with the account.\n * If no name is provided, it clears the existing primary name.\n *\n * @param args - The arguments for setting the primary name.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.sender - The account that is sending the transaction.\n * @param args.name - The name to set as the primary name. If omitted, the function will clear the primary name.\n * @param args.options - Optional transaction generation options.\n * @returns A transaction object representing the operation.\n * @group Implementation\n */\nexport async function setPrimaryName(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name?: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  if (!name) {\n    const transaction = await generateTransaction({\n      aptosConfig,\n      sender: sender.accountAddress.toString(),\n      data: {\n        function: `${routerAddress}::router::clear_primary_name`,\n        functionArguments: [],\n      },\n      options,\n    });\n\n    return transaction;\n  }\n\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::set_primary_name`,\n      functionArguments: [domainName, subdomainName],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * Retrieves the target address associated with a given domain name and subdomain name.\n *\n * @param args - The arguments for retrieving the target address.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.name - The name of the domain, which may include a subdomain.\n * @returns The target address as an AccountAddress, or undefined if not found.\n * @group Implementation\n */\nexport async function getTargetAddress(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<AccountAddress | undefined> {\n  const { aptosConfig, name } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const res = await view({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::router::get_target_addr`,\n      functionArguments: [domainName, subdomainName],\n    },\n  });\n\n  const target = unwrapOption<MoveAddressType>(res[0]);\n  return target ? AccountAddress.from(target) : undefined;\n}\n\n/**\n * Sets the target address for a specified domain and subdomain in the Aptos network.\n * This function helps to associate a given address with a domain name, allowing for easier access and management of resources.\n *\n * @param args - The arguments for setting the target address.\n * @param args.aptosConfig - The configuration settings for the Aptos network.\n * @param args.sender - The account that is sending the transaction.\n * @param args.name - The name of the domain or subdomain to be set.\n * @param args.address - The address to be associated with the domain or subdomain.\n * @param args.options - Optional parameters for generating the transaction.\n *\n * @returns A transaction object representing the set target address operation.\n * @group Implementation\n */\nexport async function setTargetAddress(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  address: AccountAddressInput;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, address, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::set_target_addr`,\n      functionArguments: [domainName, subdomainName, address],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * Retrieves the active Aptos name associated with the specified domain and subdomain.\n *\n * @param args - The parameters for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.name - The name to look up, which includes the domain and optional subdomain.\n * @returns The active Aptos name if it exists; otherwise, returns undefined.\n * @group Implementation\n */\nexport async function getName(args: {\n  aptosConfig: AptosConfig;\n  name: string;\n}): Promise<GetANSNameResponse[0] | undefined> {\n  const { aptosConfig, name } = args;\n  const { domainName, subdomainName = \"\" } = isValidANSName(name);\n\n  const where: CurrentAptosNamesBoolExp = {\n    domain: { _eq: domainName },\n    subdomain: { _eq: subdomainName },\n  };\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    query: {\n      query: GetNames,\n      variables: {\n        where_condition: where,\n        limit: 1,\n      },\n    },\n    originMethod: \"getName\",\n  });\n\n  // Convert the expiration_timestamp from an ISO string to milliseconds since epoch\n  let res = data.current_aptos_names[0];\n  if (res) {\n    res = sanitizeANSName(res);\n  }\n\n  return isActiveANSName(res) ? res : undefined;\n}\n\n/**\n * Options for querying names, including pagination, ordering, and filtering criteria.\n *\n * @param options - Pagination and filtering options for the query.\n * @group Implementation\n */\ninterface QueryNamesOptions {\n  options?: PaginationArgs & OrderByArg<GetANSNameResponse[0]> & WhereArg<CurrentAptosNamesBoolExp>;\n}\n\n/**\n * Arguments for retrieving account names based on the specified account address.\n *\n * @param accountAddress - The address of the account for which names are to be retrieved.\n * @group Implementation\n */\nexport interface GetAccountNamesArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\n/**\n * Retrieves the current Aptos names associated with a specific account address.\n *\n * @param args - The arguments for retrieving account names.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for querying account names.\n * @param args.options.limit - The maximum number of names to retrieve.\n * @param args.options.offset - The number of names to skip before starting to collect the result set.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.accountAddress - The address of the account for which to retrieve names.\n *\n * @returns An array of sanitized Aptos names associated with the specified account address.\n * @group Implementation\n */\nexport async function getAccountNames(\n  args: { aptosConfig: AptosConfig } & GetAccountNamesArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountNames\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\n/**\n * Arguments for retrieving the domains associated with a specific account.\n *\n * @param accountAddress - The address of the account for which to fetch domains.\n * @group Implementation\n */\nexport interface GetAccountDomainsArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\n/**\n * Retrieves the list of top-level domains owned by a specified account.\n *\n * @param args - The arguments for retrieving account domains.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.options - Optional parameters for the query.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the result set.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.options.where.owner_address - The address of the account whose domains are being queried.\n * @param args.options.where.expiration_timestamp - The minimum expiration timestamp for the domains.\n * @param args.options.where.subdomain - The specific subdomain to filter by.\n *\n * @returns An array of sanitized domain names owned by the specified account.\n * @group Implementation\n */\nexport async function getAccountDomains(\n  args: { aptosConfig: AptosConfig } & GetAccountDomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountDomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n          subdomain: { _eq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\n/**\n * Arguments for retrieving subdomains associated with a specific account.\n *\n * @param accountAddress - The address of the account for which to fetch subdomains.\n * @group Implementation\n */\nexport interface GetAccountSubdomainsArgs extends QueryNamesOptions {\n  accountAddress: AccountAddressInput;\n}\n\n/**\n * Retrieves a list of subdomains owned by a specified account address.\n * This function helps you identify all subdomains associated with a given account.\n *\n * @param args - The arguments for retrieving account subdomains.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.options - Optional parameters for the query.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the result set.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.options.where.owner_address - The address of the account to filter by.\n * @param args.options.where.expiration_timestamp - The expiration timestamp to filter by.\n * @param args.options.where.subdomain - The subdomain condition to filter by.\n * @param args.accountAddress - The address of the account whose subdomains are being queried.\n * @group Implementation\n */\nexport async function getAccountSubdomains(\n  args: { aptosConfig: AptosConfig } & GetAccountSubdomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, accountAddress } = args;\n\n  const expirationDate = await getANSExpirationDate({ aptosConfig });\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getAccountSubdomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          owner_address: { _eq: accountAddress.toString() },\n          expiration_timestamp: { _gte: expirationDate },\n          subdomain: { _neq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName);\n}\n\n/**\n * Arguments for retrieving subdomains associated with a specific domain.\n *\n * @param domain - The domain for which to fetch subdomains.\n * @group Implementation\n */\nexport interface GetDomainSubdomainsArgs extends QueryNamesOptions {\n  domain: string;\n}\n\n/**\n * Retrieve the active subdomains associated with a specified domain.\n *\n * @param args - The arguments for retrieving subdomains.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.options - Optional parameters for the query.\n * @param args.options.limit - The maximum number of results to return.\n * @param args.options.offset - The number of results to skip before starting to collect the results.\n * @param args.options.orderBy - The field by which to order the results.\n * @param args.options.where - Additional conditions to filter the results.\n * @param args.domain - The domain for which to retrieve subdomains.\n *\n * @returns An array of active subdomain names.\n * @group Implementation\n */\nexport async function getDomainSubdomains(\n  args: { aptosConfig: AptosConfig } & GetDomainSubdomainsArgs,\n): Promise<GetANSNameResponse> {\n  const { aptosConfig, options, domain } = args;\n\n  const data = await queryIndexer<GetNamesQuery>({\n    aptosConfig,\n    originMethod: \"getDomainSubdomains\",\n    query: {\n      query: GetNames,\n      variables: {\n        limit: options?.limit,\n        offset: options?.offset,\n        order_by: options?.orderBy,\n        where_condition: {\n          ...(args.options?.where ?? {}),\n          domain: { _eq: domain },\n          subdomain: { _neq: \"\" },\n        },\n      },\n    },\n  });\n\n  return data.current_aptos_names.map(sanitizeANSName).filter(isActiveANSName);\n}\n\n/**\n * This function returns the expiration date in which a name is fully expired as\n * defined by the contract.  The grace period allows for names to be past\n * expiration for a certain amount of time before they are released to the\n * public. The names will not function as normal, but the owner can renew\n * without others taking ownership of the name. At the time of writing, the\n * contract specified 30 days.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - An AptosConfig object containing the configuration settings.\n * @returns The expiration date in ISO 8601 format.\n * @group Implementation\n */\nasync function getANSExpirationDate(args: { aptosConfig: AptosConfig }): Promise<string> {\n  const { aptosConfig } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n\n  const [gracePeriodInSeconds] = await view<[number]>({\n    aptosConfig,\n    payload: {\n      function: `${routerAddress}::config::reregistration_grace_sec`,\n      functionArguments: [],\n    },\n  });\n\n  const gracePeriodInDays = gracePeriodInSeconds / 60 / 60 / 24;\n  const now = () => new Date();\n  return new Date(now().setDate(now().getDate() - gracePeriodInDays)).toISOString();\n}\n\n/**\n * Renews a domain for a specified duration. This function allows you to extend the registration of a domain for one year.\n *\n * @param args - The parameters required to renew the domain.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.sender - The account that is sending the renewal transaction.\n * @param args.name - The name of the domain to renew.\n * @param args.years - The number of years to renew the domain for. Currently, only 1 year renewals are supported. (optional, default is 1)\n * @param args.options - Additional options for generating the transaction. (optional)\n * @throws Error if the name contains a subdomain or if the years parameter is not equal to 1.\n * @group Implementation\n */\nexport async function renewDomain(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  name: string;\n  years?: 1;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, name, years = 1, options } = args;\n  const routerAddress = getRouterAddress(aptosConfig);\n  const renewalDuration = years * 31536000;\n  const { domainName, subdomainName } = isValidANSName(name);\n\n  if (subdomainName) {\n    throw new Error(\"Subdomains cannot be renewed\");\n  }\n\n  if (years !== 1) {\n    throw new Error(\"Currently, only 1 year renewals are supported\");\n  }\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: `${routerAddress}::router::renew_domain`,\n      functionArguments: [domainName, renewalDuration],\n    },\n    options,\n  });\n\n  return transaction;\n}\n\n/**\n * The indexer returns ISO strings for expiration, however the contract works in\n * epoch milliseconds. This function converts the ISO string to epoch\n * milliseconds. In the future, if other properties need sanitization, this can\n * be extended.\n *\n * @param name - The ANS name response to sanitize.\n * @param name.expiration_timestamp - The expiration timestamp in ISO string format.\n * @group Implementation\n */\nfunction sanitizeANSName(name: GetANSNameResponse[0]): GetANSNameResponse[0] {\n  return {\n    ...name,\n    expiration_timestamp: new Date(name.expiration_timestamp).getTime(),\n  };\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport {\n  RegisterNameParameters,\n  getExpiration,\n  getOwnerAddress,\n  registerName,\n  getPrimaryName,\n  setPrimaryName,\n  getTargetAddress,\n  setTargetAddress,\n  renewDomain,\n  getName,\n  getAccountDomains,\n  GetAccountDomainsArgs,\n  GetAccountSubdomainsArgs,\n  getAccountSubdomains,\n  getAccountNames,\n  GetAccountNamesArgs,\n  getDomainSubdomains,\n  GetDomainSubdomainsArgs,\n} from \"../internal/ans\";\nimport { GetANSNameResponse } from \"../types\";\nimport { InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\n/**\n * A class to handle all `ANS` operations.\n * @group ANS\n */\nexport class ANS {\n  /**\n   * Initializes a new instance of the Aptos class with the provided configuration.\n   * This allows you to interact with the Aptos blockchain using the specified network settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., mainnet, testnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet to use for funding accounts.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for connecting to the Aptos testnet\n   *     const config = new AptosConfig({ network: Network.TESTNET });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Retrieve the owner address of a specified domain name or subdomain name from the contract.\n   *\n   * @param args - The arguments for retrieving the owner address.\n   * @param args.name - A string representing the name of the domain or subdomain to retrieve the owner address for.\n   *\n   * @returns AccountAddress if the name is owned, undefined otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the owner address of \"test.aptos\"\n   *   const owner = await aptos.getOwnerAddress({ name: \"test.aptos\" });\n   *   console.log(owner); // Logs the owner address or undefined if not owned\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getOwnerAddress(args: { name: string }): Promise<AccountAddress | undefined> {\n    return getOwnerAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve the expiration time of a domain name or subdomain name from the contract.\n   *\n   * @param args - The arguments for retrieving the expiration.\n   * @param args.name - A string of the name to retrieve.\n   *\n   * @returns number as a unix timestamp in milliseconds.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the expiration time for the domain \"test.aptos\"\n   *   const exp = await aptos.getExpiration({ name: \"test.aptos\" });\n   *\n   *   // Log the expiration date\n   *   console.log(new Date(exp)); // Outputs the expiration date\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getExpiration(args: { name: string }): Promise<number | undefined> {\n    return getExpiration({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve the target address of a domain or subdomain name, which indicates the address the name points to for use on-chain.\n   * Note that the target address can point to addresses that do not own the name.\n   *\n   * @param args - The arguments for retrieving the target address.\n   * @param args.name - A string representing the name, which can be a primary name, a subdomain, or a combination (e.g.,\n   * \"primary\", \"primary.apt\", \"secondary.primary\", \"secondary.primary.apt\").\n   *\n   * @returns AccountAddress if the name has a target, undefined otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the target address for the specified domain name\n   *   const targetAddr = await aptos.getTargetAddress({ name: \"test.aptos\" });\n   *\n   *   console.log(targetAddr); // Logs the target address, e.g., 0x123...\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getTargetAddress(args: { name: string }): Promise<AccountAddress | undefined> {\n    return getTargetAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sets the target address of a domain or subdomain name, pointing it to a specified address for use on-chain.\n   * The target address can be different from the owner of the name.\n   *\n   * @param args - The arguments for setting the target address.\n   * @param args.sender - The account initiating the transaction.\n   * @param args.name - A string representing the domain or subdomain name (e.g., \"test.aptos\").\n   * @param args.address - The AccountAddressInput of the address to set the domain or subdomain to.\n   * @param args.options - Optional settings for generating the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Setting the target address for a domain name\n   *   const sender = Account.generate(); // replace with a real account\n   *   const address = \"0x1\"; // replace with a real account address\n   *\n   *   await aptos.setTargetAddress({\n   *     sender: sender,\n   *     name: \"test.aptos\",\n   *     address: address,\n   *   });\n   *\n   *   const targetAddress = await aptos.getTargetAddress({ name: \"test.aptos\" });\n   *   console.log(targetAddress); // Should log the address set for \"test.aptos\"\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async setTargetAddress(args: {\n    sender: Account;\n    name: string;\n    address: AccountAddressInput;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return setTargetAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieve the primary name for an account. An account can have multiple names, but only one primary name, which may not exist.\n   *\n   * @param args - The arguments for retrieving the primary name.\n   * @param args.address - An AccountAddressInput (address) of the account.\n   *\n   * @returns A string if the account has a primary name, undefined otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the primary name for the specified account address\n   *   const name = await aptos.getPrimaryName({ address: \"0x1\" }); // replace with a real account address\n   *   console.log(name);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getPrimaryName(args: { address: AccountAddressInput }): Promise<string | undefined> {\n    return getPrimaryName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sets the primary name for the sender account, allowing them to designate a single primary name among potentially multiple\n   * names. An account may not have a primary name.\n   *\n   * @param args - The arguments for setting the primary name.\n   * @param args.sender - The sender account.\n   * @param args.name - A string representing the name to set as primary (e.g., \"test.aptos\").\n   * @param args.options - Optional transaction options.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Set the primary name for the sender account\n   *   const sender = Account.generate(); // replace with a real account\n   *   await aptos.setPrimaryName({ sender, name: \"test.aptos\" });\n   *\n   *   const primaryName = await aptos.getPrimaryName({ address: sender.accountAddress });\n   *   console.log(\"Primary Name:\", primaryName); // Should log: \"Primary Name: test.aptos\"\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async setPrimaryName(args: {\n    sender: Account;\n    name?: string;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return setPrimaryName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Registers a new name.\n   *\n   * This function allows you to register a domain or subdomain name with specific expiration policies and options.\n   *\n   * @param args.sender - The sender account.\n   * @param args.name - A string of the name to register. This can be inclusive or exclusive of the .apt suffix. Examples include:\n   * \"test\", \"test.apt\", \"test.aptos.apt\", etc.\n   * @param args.expiration  - An object with the expiration policy of the name.\n   * @param args.expiration.policy - 'domain' | 'subdomain:follow-domain' | 'subdomain:independent'.\n   * - domain: Years is required and the name will expire after the given number of years.\n   * - subdomain:follow-domain: The name will expire at the same time as the domain name.\n   * - subdomain:independent: The name will expire at the given date.\n   * @param args.expiration.expirationDate - An epoch number in milliseconds of the date when the subdomain will expire. Only\n   * applicable when the policy is set to 'subdomain:independent'.\n   * @param args.transferable  - Determines if the subdomain being minted is soul-bound. Applicable only to subdomains.\n   * @param args.targetAddress optional - The address the domain name will resolve to. If not provided, the sender's address will\n   * be used.\n   * @param args.toAddress optional - The address to send the domain name to. If not provided, the transaction will be sent to the\n   * router.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Registering a subdomain name assuming def.apt is already registered and belongs to the sender alice.\n   *   const txn = await aptos.registerName({\n   *     sender: \"0x1\", // replace with a real sender account\n   *     name: \"test.aptos.apt\",\n   *     expiration: {\n   *       policy: \"subdomain:independent\",\n   *       expirationDate: Date.now() + 30 * 24 * 60 * 60 * 1000, // expires in 30 days\n   *     },\n   *   });\n   *\n   *   console.log(\"Transaction:\", txn);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async registerName(args: Omit<RegisterNameParameters, \"aptosConfig\">): Promise<SimpleTransaction> {\n    return registerName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Renews a domain name for one year.\n   * If a domain name was minted with V1 of the contract, it will automatically be upgraded to V2 via this transaction.\n   *\n   * @param args - The arguments for renewing the domain.\n   * @param args.sender - The sender account, which must be the domain owner.\n   * @param args.name - A string representing the domain to renew. Subdomains cannot be renewed.\n   * @param args.years - The number of years to renew the name. Currently, only one year is permitted.\n   * @param args.options - Optional transaction options.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Renew the domain \"test\" for one year\n   *   const transaction = await aptos.renewDomain({\n   *     sender: Account.generate(), // replace with a real account\n   *     name: \"test\"\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async renewDomain(args: {\n    sender: Account;\n    name: string;\n    years?: 1;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return renewDomain({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches a single name from the indexer based on the provided name argument.\n   *\n   * @param args - The arguments for retrieving the name.\n   * @param args.name - A string of the name to retrieve, e.g. \"test.aptos.apt\" or \"test.apt\" or \"test\".\n   *                    Can be inclusive or exclusive of the .apt suffix and can be a subdomain.\n   *\n   * @returns A promise of an ANSName or undefined if the name is not active.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Fetching a name from the indexer\n   *     const name = await aptos.getName({ name: \"test.aptos\" }); // replace with a real name\n   *     console.log(name);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getName(args: { name: string }): Promise<GetANSNameResponse[0] | undefined> {\n    return getName({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all names for an account, including both top-level domains and subdomains.\n   *\n   * @param args - The arguments for fetching account names.\n   * @param args.accountAddress - An AccountAddressInput of the address to retrieve names for.\n   * @param args.options - Optional parameters for fetching names.\n   * @param args.options.offset - Optional, the offset to start from when fetching names.\n   * @param args.options.limit - Optional, a number of the names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise of an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch account names for a specific address\n   *   const accountNames = await aptos.getAccountNames({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify how many names to fetch\n   *       orderBy: \"name\", // specify the order by which to sort the names\n   *     },\n   *   });\n   *\n   *   console.log(accountNames);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getAccountNames(args: GetAccountNamesArgs): Promise<GetANSNameResponse> {\n    return getAccountNames({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all top-level domain names for a specified account.\n   *\n   * @param args - The arguments for retrieving account domains.\n   * @param args.accountAddress - An AccountAddressInput of the address to retrieve domain names for.\n   * @param args.options.offset - Optional, the offset to start from when fetching names.\n   * @param args.options.limit - Optional, a number of the names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise of an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching all top-level domain names for a specific account\n   *   const domains = await aptos.getAccountDomains({\n   *     accountAddress: \"0x1\", // replace with a real account address\n   *     options: {\n   *       limit: 10, // specify the number of names to fetch\n   *       offset: 0, // specify the offset for pagination\n   *       orderBy: \"created_at\", // specify the order by which to sort the names\n   *       where: {\n   *         // additional filters can be specified here\n   *       },\n   *     },\n   *   });\n   *\n   *   console.log(domains);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getAccountDomains(args: GetAccountDomainsArgs): Promise<GetANSNameResponse> {\n    return getAccountDomains({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all subdomain names for a specified account.\n   *\n   * @param args - The arguments for retrieving subdomains.\n   * @param args.accountAddress - The address to retrieve subdomain names for.\n   * @param args.options - Optional parameters for fetching subdomains.\n   * @param args.options.offset - The offset to start from when fetching names.\n   * @param args.options.limit - The number of names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise of an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     // Fetching subdomain names for a specific account\n   *     const subdomains = await aptos.getAccountSubdomains({\n   *         accountAddress: \"0x1\", // replace with a real account address\n   *         options: {\n   *             limit: 10, // specify the number of subdomains to fetch\n   *             offset: 0, // specify the offset for pagination\n   *             orderBy: \"name\", // specify the order by which to sort the names\n   *         },\n   *     });\n   *\n   *     console.log(subdomains);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getAccountSubdomains(args: GetAccountSubdomainsArgs): Promise<GetANSNameResponse> {\n    return getAccountSubdomains({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches all subdomain names for a given domain, excluding the domain itself.\n   *\n   * @param args - The arguments for fetching subdomains.\n   * @param args.domain - A string of the domain name, e.g., \"test.apt\" or \"test\" (without the suffix of .apt).\n   * @param args.options - Optional parameters for fetching subdomains.\n   * @param args.options.offset - Optional, the offset to start from when fetching names.\n   * @param args.options.limit - Optional, the number of names to fetch per request.\n   * @param args.options.orderBy - The order to sort the names by.\n   * @param args.options.where - Additional filters to apply to the query.\n   *\n   * @returns A promise that resolves to an array of ANSName.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching subdomains for a specific domain\n   *   const subdomains = await aptos.getDomainSubdomains({\n   *     domain: \"test\", // replace with your domain\n   *     options: {\n   *       limit: 10, // specify the number of subdomains to fetch\n   *       offset: 0, // specify the starting point for fetching\n   *       orderBy: \"name\", // specify the order by which to sort the results\n   *     },\n   *   });\n   *\n   *   console.log(subdomains);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group ANS\n   */\n  async getDomainSubdomains(args: GetDomainSubdomainsArgs): Promise<GetANSNameResponse> {\n    return getDomainSubdomains({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/staking}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * staking namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput } from \"../core\";\nimport { GetDelegatedStakingActivitiesResponse, GetNumberOfDelegatorsResponse, OrderByArg } from \"../types\";\nimport { GetDelegatedStakingActivitiesQuery, GetNumberOfDelegatorsQuery } from \"../types/generated/operations\";\nimport { GetDelegatedStakingActivities, GetNumberOfDelegators } from \"../types/generated/queries\";\nimport { queryIndexer } from \"./general\";\n\n/**\n * Retrieves the number of active delegators for a specified pool address.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.poolAddress - The address of the pool for which to retrieve the number of delegators.\n * @returns The number of active delegators for the specified pool address.\n * @group Implementation\n */\nexport async function getNumberOfDelegators(args: {\n  aptosConfig: AptosConfig;\n  poolAddress: AccountAddressInput;\n}): Promise<number> {\n  const { aptosConfig, poolAddress } = args;\n  const address = AccountAddress.from(poolAddress).toStringLong();\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: { where_condition: { pool_address: { _eq: address } } },\n  };\n  const data = await queryIndexer<GetNumberOfDelegatorsQuery>({ aptosConfig, query });\n\n  // commonjs (aka cjs) doesn't handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.num_active_delegator_per_pool[0] ? data.num_active_delegator_per_pool[0].num_active_delegator : 0;\n}\n\n/**\n * Retrieves the number of active delegators for all pools.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration for the Aptos client.\n * @param [args.options] - Optional parameters for ordering the results.\n * @param args.options.orderBy - Specifies the order in which to return the results.\n * @returns The number of active delegators per pool.\n * @group Implementation\n */\nexport async function getNumberOfDelegatorsForAllPools(args: {\n  aptosConfig: AptosConfig;\n  options?: OrderByArg<GetNumberOfDelegatorsResponse[0]>;\n}): Promise<GetNumberOfDelegatorsResponse> {\n  const { aptosConfig, options } = args;\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: { order_by: options?.orderBy },\n  };\n  const data = await queryIndexer<GetNumberOfDelegatorsQuery>({\n    aptosConfig,\n    query,\n  });\n  return data.num_active_delegator_per_pool;\n}\n\n/**\n * Retrieves the delegated staking activities for a specified delegator and pool.\n *\n * @param args - The parameters for the query.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.delegatorAddress - The address of the delegator whose activities are being queried.\n * @param args.poolAddress - The address of the pool associated with the delegated staking activities.\n * @returns The delegated staking activities for the specified delegator and pool.\n * @group Implementation\n */\nexport async function getDelegatedStakingActivities(args: {\n  aptosConfig: AptosConfig;\n  delegatorAddress: AccountAddressInput;\n  poolAddress: AccountAddressInput;\n}): Promise<GetDelegatedStakingActivitiesResponse> {\n  const { aptosConfig, delegatorAddress, poolAddress } = args;\n  const query = {\n    query: GetDelegatedStakingActivities,\n    variables: {\n      delegatorAddress: AccountAddress.from(delegatorAddress).toStringLong(),\n      poolAddress: AccountAddress.from(poolAddress).toStringLong(),\n    },\n  };\n  const data = await queryIndexer<GetDelegatedStakingActivitiesQuery>({ aptosConfig, query });\n  return data.delegated_staking_activities;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  getDelegatedStakingActivities,\n  getNumberOfDelegators,\n  getNumberOfDelegatorsForAllPools,\n} from \"../internal/staking\";\nimport { AnyNumber, GetDelegatedStakingActivitiesResponse, GetNumberOfDelegatorsResponse, OrderByArg } from \"../types\";\nimport { AccountAddressInput } from \"../core\";\nimport { ProcessorType } from \"../utils/const\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\n\n/**\n * A class to query all `Staking` related queries on Aptos.\n * @group Staking\n */\nexport class Staking {\n  /**\n   * Creates an instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Queries the current number of delegators in a specified pool. Throws an error if the pool is not found.\n   *\n   * @param args - The parameters for the query.\n   * @param args.poolAddress - The address of the pool to query.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The number of delegators for the given pool.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get the number of delegators for a specific pool\n   *   const delegators = await aptos.getNumberOfDelegators({ poolAddress: \"0x1\" }); // replace with a real pool address\n   *   console.log(`Number of delegators: ${delegators}`);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  async getNumberOfDelegators(args: {\n    poolAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.STAKE_PROCESSOR,\n    });\n    return getNumberOfDelegators({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Retrieves the current number of delegators across all pools.\n   *\n   * @param args Optional parameters for the query.\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to before querying.\n   * @param args.options Optional ordering options for the response.\n   * @returns GetNumberOfDelegatorsForAllPoolsResponse response type containing the number of delegators per pool.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Retrieve the number of delegators for all pools\n   *   const delegators = await aptos.getNumberOfDelegatorsForAllPools();\n   *   console.log(delegators);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  async getNumberOfDelegatorsForAllPools(args?: {\n    minimumLedgerVersion?: AnyNumber;\n    options?: OrderByArg<GetNumberOfDelegatorsResponse[0]>;\n  }): Promise<GetNumberOfDelegatorsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.STAKE_PROCESSOR,\n    });\n    return getNumberOfDelegatorsForAllPools({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries delegated staking activities for a specific delegator and pool.\n   *\n   * @param args - The arguments for querying delegated staking activities.\n   * @param args.delegatorAddress - The address of the delegator.\n   * @param args.poolAddress - The address of the staking pool.\n   * @param args.minimumLedgerVersion - Optional ledger version to sync up to before querying.\n   * @returns The response containing delegated staking activities.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Get delegated staking activities for a specific delegator and pool\n   *   const activities = await aptos.getDelegatedStakingActivities({\n   *     delegatorAddress: \"0x1\", // replace with a real delegator address\n   *     poolAddress: \"0x2\", // replace with a real pool address\n   *     minimumLedgerVersion: 1, // specify your own if needed\n   *   });\n   *\n   *   console.log(activities);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Staking\n   */\n  async getDelegatedStakingActivities(args: {\n    delegatorAddress: AccountAddressInput;\n    poolAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<GetDelegatedStakingActivitiesResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args?.minimumLedgerVersion,\n      processorType: ProcessorType.STAKE_PROCESSOR,\n    });\n    return getDelegatedStakingActivities({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddressInput } from \"../../core\";\nimport { generateTransaction } from \"../../internal/transactionSubmission\";\nimport {\n  InputGenerateTransactionPayloadData,\n  InputGenerateTransactionOptions,\n  InputGenerateOrderlessTransactionOptions,\n} from \"../../transactions\";\nimport { MultiAgentTransaction } from \"../../transactions/instances/multiAgentTransaction\";\nimport { SimpleTransaction } from \"../../transactions/instances/simpleTransaction\";\nimport { AptosConfig } from \"../aptosConfig\";\n\n/**\n * A class to handle all `Build` transaction operations.\n * @group Implementation\n */\nexport class Build {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.account - The account details for authentication.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // specify the network\n   *         nodeUrl: \"https://testnet.aptos.dev\", // specify the node URL\n   *     });\n   *\n   *     // Initialize the Aptos client\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Build a simple transaction.\n   *\n   * This function allows you to create a transaction with specified sender and data.\n   *\n   * @param args.sender - The sender account address.\n   * @param args.data - The transaction data.\n   * @param args.options - Optional transaction configurations.\n   * @param args.withFeePayer - Whether there is a fee payer for the transaction.\n   *\n   * @returns SimpleTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Build a simple transaction\n   *   const transaction = await aptos.transaction.simple({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [\"0x2\", 100], // replace with a real destination account address\n   *     },\n   *     options: {\n   *       gasUnitPrice: 100, // specify your own gas unit price if needed\n   *       maxGasAmount: 1000, // specify your own max gas amount if needed\n   *     },\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  async simple(args: {\n    sender: AccountAddressInput;\n    data: InputGenerateTransactionPayloadData;\n    options?: InputGenerateTransactionOptions;\n    withFeePayer?: boolean;\n  }): Promise<SimpleTransaction> {\n    return generateTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Build a multi-agent transaction that allows multiple signers to authorize a transaction.\n   *\n   * @param args - The parameters for creating the multi-agent transaction.\n   * @param args.sender - The sender account address.\n   * @param args.data - The transaction data.\n   * @param args.secondarySignerAddresses - An array of the secondary signers' account addresses.\n   * @param args.options - Optional transaction configurations.\n   * @param args.withFeePayer - Whether there is a fee payer for the transaction.\n   *\n   * @returns MultiAgentTransaction\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Build a multi-agent transaction\n   *   const transaction = await aptos.multiAgent({\n   *     sender: \"0x1\", // replace with a real sender account address\n   *     data: {\n   *       // Transaction data structure\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [\"0x2\", 100], // replace with a real destination account address and amount\n   *     },\n   *     secondarySignerAddresses: [\"0x3\", \"0x4\"], // replace with real secondary signer addresses\n   *     options: {\n   *       // Optional transaction configurations\n   *       maxGasAmount: \"1000\",\n   *       gasUnitPrice: \"1\",\n   *     },\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  async multiAgent(args: {\n    sender: AccountAddressInput;\n    data: InputGenerateTransactionPayloadData;\n    secondarySignerAddresses: AccountAddressInput[];\n    options?: InputGenerateTransactionOptions;\n    withFeePayer?: boolean;\n  }): Promise<MultiAgentTransaction> {\n    return generateTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PublicKey } from \"../../core\";\nimport { simulateTransaction } from \"../../internal/transactionSubmission\";\nimport { AnyRawTransaction, InputSimulateTransactionOptions } from \"../../transactions\";\nimport { UserTransactionResponse } from \"../../types\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { ValidateFeePayerDataOnSimulation } from \"./helpers\";\n\n/**\n * A class to handle all `Simulate` transaction operations.\n * @group Implementation\n */\nexport class Simulate {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your desired network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Simulates a transaction based on the provided parameters and returns the result.\n   * This function helps you understand the outcome of a transaction before executing it on the blockchain.\n   *\n   * @param args - The parameters for simulating the transaction.\n   * @param args.signerPublicKey - The public key of the signer for the transaction (optional).\n   * @param args.transaction - The raw transaction data to simulate.\n   * @param args.feePayerPublicKey - The public key of the fee payer (optional).\n   * @param args.options - Additional options for simulating the transaction (optional).\n   *\n   * @example\n   * ```typescript\n   * import {\n   *     Account,\n   *     Aptos,\n   *     AptosConfig,\n   *     Network,\n   * } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function example() {\n   *     let sender = Account.generate();\n   *     let receiver = Account.generate();\n   *\n   *     // 0. Set up the client and test accounts\n   *     const config = new AptosConfig({ network: Network.DEVNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     await aptos.fundAccount({\n   *         accountAddress: sender.accountAddress,\n   *         amount: 100_000_000,\n   *     });\n   *\n   *     // 1. Build the transaction to preview the impact of it\n   *     const transaction = await aptos.transaction.build.simple({\n   *         sender: sender.accountAddress,\n   *         data: {\n   *             // All transactions on Aptos are implemented via smart contracts.\n   *             function: \"0x1::aptos_account::transfer\",\n   *             functionArguments: [receiver.accountAddress, 100],\n   *         },\n   *     });\n   *\n   *     // 2. Simulate to see what would happen if we execute this transaction\n   *     const [userTransactionResponse] = await aptos.transaction.simulate.simple({\n   *         signerPublicKey: sender.publicKey,\n   *         transaction,\n   *     });\n   *     console.log(userTransactionResponse);\n   *\n   *     // If the fee looks ok, continue to signing!\n   *     // ...\n   * }\n   *\n   * example();\n   * ```\n   * @group Implementation\n   */\n  @ValidateFeePayerDataOnSimulation\n  async simple(args: {\n    signerPublicKey?: PublicKey;\n    transaction: AnyRawTransaction;\n    feePayerPublicKey?: PublicKey;\n    options?: InputSimulateTransactionOptions;\n  }): Promise<Array<UserTransactionResponse>> {\n    return simulateTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Simulates a multi-agent transaction by generating a signed transaction and posting it to the Aptos full node.\n   * This function helps in understanding the outcome of a transaction involving multiple signers before it is executed.\n   *\n   * @param args - The parameters for simulating the transaction.\n   * @param args.signerPublicKey - The public key of the primary signer (optional).\n   * @param args.transaction - The raw transaction to be simulated.\n   * @param args.secondarySignersPublicKeys - An array of public keys for secondary signers (optional).\n   *        Each element of the array can be optional, allowing the corresponding key check to be skipped.\n   * @param args.feePayerPublicKey - The public key of the fee payer (optional).\n   * @param args.options - Options for simulating the transaction (optional).\n   *\n   * @example\n   * ```typescript\n   * import {\n   *     Account,\n   *     Aptos,\n   *     AptosConfig,\n   *     Network,\n   * } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function example() {\n   *     let sender1 = Account.generate();\n   *     let sender2 = Account.generate();\n   *     let receiver = Account.generate();\n   *\n   *     // 0. Set up the client and test accounts\n   *     const config = new AptosConfig({ network: Network.DEVNET });\n   *     const aptos = new Aptos(config);\n   *\n   *     await aptos.fundAccount({\n   *         accountAddress: sender.accountAddress,\n   *         amount: 100_000_000,\n   *     });\n   *\n   *     // 1. Build\n   *     console.log(\"\\n=== 1. Building the transaction ===\\n\");\n   *     const transaction = await aptos.transaction.build.multiAgent({\n   *     sender: sender1.accountAddress,\n   *     secondarySignerAddresses: [sender2.accountAddress],\n   *     data: {\n   *        // REPLACE WITH YOUR MULTI-AGENT FUNCTION HERE\n   *        function:\n   *          \"<REPLACE WITH YOUR MULTI AGENT MOVE ENTRY FUNCTION> (Syntax {address}::{module}::{function})\",\n   *          functionArguments: [],\n   *        },\n   *      });\n   *      console.log(\"Transaction:\", transaction);\n   *\n   *      // 2. Simulate (Optional)\n   *      console.log(\"\\n === 2. Simulating Response (Optional) === \\n\");\n   *      const [userTransactionResponse] = await aptos.transaction.simulate.multiAgent(\n   *        {\n   *          signerPublicKey: sender1.publicKey,\n   *          secondarySignersPublicKeys: [sender2.publicKey],\n   *          transaction,\n   *        },\n   *      );\n   *      console.log(userTransactionResponse);\n   *\n   *      // If the fee looks ok, continue to signing!\n   *      // ...\n   * }\n   *\n   * example();\n   * ```\n   * @group Implementation\n   */\n  @ValidateFeePayerDataOnSimulation\n  async multiAgent(args: {\n    signerPublicKey?: PublicKey;\n    transaction: AnyRawTransaction;\n    secondarySignersPublicKeys?: Array<PublicKey | undefined>;\n    feePayerPublicKey?: PublicKey;\n    options?: InputSimulateTransactionOptions;\n  }): Promise<Array<UserTransactionResponse>> {\n    return simulateTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { submitTransaction } from \"../../internal/transactionSubmission\";\nimport { AccountAuthenticator, AnyRawTransaction, InputTransactionPluginData } from \"../../transactions\";\nimport { PendingTransactionResponse } from \"../../types\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { validateFeePayerDataOnSubmission } from \"./helpers\";\n\n/**\n * A class to handle all `Submit` transaction operations.\n * @group Implementation\n */\nexport class Submit {\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet for obtaining test tokens.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // Use the TESTNET for testing\n   *         nodeUrl: \"https://testnet.aptos.dev\", // Specify the node URL\n   *         faucetUrl: \"https://faucet.testnet.aptos.dev\" // Specify the faucet URL\n   *     });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Submits a transaction to the Aptos blockchain using the provided transaction details and authenticators.\n   * This function allows you to execute transactions securely by specifying the sender and optional fee payer authenticators.\n   *\n   * @param args - The arguments for submitting the transaction.\n   * @param args.transaction - The raw transaction data to be submitted.\n   * @param args.senderAuthenticator - The authenticator for the sender's account.\n   * @param [args.feePayerAuthenticator] - The optional authenticator for the fee payer's account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new sender account\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [Account.generate().accountAddress, 100], // Replace with a real destination account\n   *     },\n   *   });\n   *\n   *   // Submit the transaction\n   *   const response = await aptos.simple({\n   *     transaction,\n   *     senderAuthenticator: sender.getAuthenticator(), // Use the sender's authenticator\n   *   });\n   *\n   *   console.log(\"Transaction submitted:\", response);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  async simple(\n    args: {\n      transaction: AnyRawTransaction;\n      senderAuthenticator: AccountAuthenticator;\n      feePayerAuthenticator?: AccountAuthenticator;\n    } & InputTransactionPluginData,\n  ): Promise<PendingTransactionResponse> {\n    validateFeePayerDataOnSubmission(this.config, args);\n    return submitTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Submits a multi-agent transaction to the Aptos network, allowing multiple signers to authorize the transaction.\n   * This function is useful for scenarios where a transaction requires approval from multiple accounts.\n   *\n   * @param args - The parameters for the multi-agent transaction.\n   * @param args.transaction - The raw transaction to be submitted.\n   * @param args.senderAuthenticator - The authenticator for the sender account.\n   * @param args.additionalSignersAuthenticators - An array of authenticators for additional signers.\n   * @param [args.feePayerAuthenticator] - An optional authenticator for the fee payer account.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new sender account\n   *   const additionalSigner1 = Account.generate(); // Generate an additional signer account\n   *   const additionalSigner2 = Account.generate(); // Generate another additional signer account\n   *\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [additionalSigner1.accountAddress, 100],\n   *     },\n   *   });\n   *\n   *   const response = await aptos.multiAgent({\n   *     transaction,\n   *     senderAuthenticator: sender.getAuthenticator(), // Use the sender's authenticator\n   *     additionalSignersAuthenticators: [\n   *       additionalSigner1.getAuthenticator(), // Use the first additional signer's authenticator\n   *       additionalSigner2.getAuthenticator(), // Use the second additional signer's authenticator\n   *     ],\n   *   });\n   *\n   *   console.log(response); // Log the response from the transaction submission\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  async multiAgent(\n    args: {\n      transaction: AnyRawTransaction;\n      senderAuthenticator: AccountAuthenticator;\n      additionalSignersAuthenticators: Array<AccountAuthenticator>;\n      feePayerAuthenticator?: AccountAuthenticator;\n    } & InputTransactionPluginData,\n  ): Promise<PendingTransactionResponse> {\n    validateFeePayerDataOnSubmission(this.config, args);\n    return submitTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n", "import EventEmitter from \"eventemitter3\";\nimport { TransactionWorkerEvents, TransactionWorker, TransactionWorkerEventsEnum } from \"../../transactions/management\";\nimport { InputGenerateTransactionPayloadData, InputGenerateTransactionOptions } from \"../../transactions\";\nimport { AptosConfig } from \"../aptosConfig\";\nimport { Account } from \"../../account\";\n\nexport class TransactionManagement extends EventEmitter<TransactionWorkerEvents> {\n  account!: Account;\n\n  transactionWorker!: TransactionWorker;\n\n  readonly config: AptosConfig;\n\n  /**\n   * Initializes a new instance of the Aptos client with the provided configuration settings.\n   * This allows you to interact with the Aptos blockchain using the specified network and options.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., TESTNET, MAINNET).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.account - Optional account settings for authentication.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // specify the network to use\n   *         nodeUrl: \"https://testnet.aptos.dev\" // replace with your node URL\n   *     });\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  constructor(config: AptosConfig) {\n    super();\n    this.config = config;\n  }\n\n  /**\n   * Initializes the transaction worker using the provided sender account and begins listening for events.\n   * This function is essential for setting up the transaction processing environment.\n   *\n   * @param args - The arguments for starting the transaction worker.\n   * @param args.sender - The sender account to sign and submit the transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const sender = Account.generate(); // Generate a new account for sending transactions\n   *\n   *     // Start the transaction worker with the sender account\n   *     aptos.start({ sender });\n   *\n   *     console.log(\"Transaction worker started with sender:\", sender.accountAddress);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  private start(args: { sender: Account }): void {\n    const { sender } = args;\n    this.account = sender;\n    this.transactionWorker = new TransactionWorker(this.config, sender);\n\n    this.transactionWorker.start();\n    this.registerToEvents();\n  }\n\n  /**\n   * Pushes transaction data to the transaction worker for processing.\n   *\n   * @param args.data An array of transaction payloads to be processed.\n   * @param args.options Optional. Transaction generation configurations (excluding accountSequenceNumber).\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Prepare transaction payloads\n   *   const payloads = [\n   *      {}, // Build your first transaction payload\n   *      {}, // Build your second transaction payload\n   *   ];\n   *\n   *   // Push transaction data to the worker\n   *   aptos.push({\n   *     data: payloads,\n   *     {}, // Specify options as needed\n   *   });\n   *\n   *   console.log(\"Transaction data pushed successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  private push(args: {\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): void {\n    const { data, options } = args;\n\n    for (const d of data) {\n      this.transactionWorker.push(d, options);\n    }\n  }\n\n  /**\n   * Starts listening to transaction worker events, allowing the application to respond to transaction status changes.\n   * This function enables the application to handle events such as transaction sent, execution success, or failure.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Register to listen for transaction events\n   *   aptos.registerToEvents();\n   *\n   *   // You can send a transaction here to see the events in action\n   *   const sender = Account.generate(); // replace with a real account\n   *   const destination = Account.generate(); // replace with a real account\n   *\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [destination.accountAddress, 100],\n   *     },\n   *   });\n   *\n   *   await aptos.transaction.send(transaction);\n   *\n   *   console.log(\"Transaction sent and events registered.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Implementation\n   */\n  private registerToEvents() {\n    // TODO - Should we ask events to listen to this as an input?\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionSent, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionSent, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionSendFailed, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionSendFailed, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionExecuted, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionExecuted, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.TransactionExecutionFailed, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.TransactionExecutionFailed, data);\n    });\n    this.transactionWorker.on(TransactionWorkerEventsEnum.ExecutionFinish, async (data) => {\n      this.emit(TransactionWorkerEventsEnum.ExecutionFinish, data);\n    });\n  }\n\n  /**\n   * Send batch transactions for a single account.\n   *\n   * This function uses a transaction worker that receives payloads to be processed\n   * and submitted to chain.\n   * Note that this process is best for submitting multiple transactions that\n   * don't rely on each other, i.e. batch funds, batch token mints, etc.\n   *\n   * If any worker failure, the functions throws an error.\n   *\n   * @param args.sender The sender account to sign and submit the transaction\n   * @param args.data An array of transaction payloads\n   * @param args.options optional. Transaction generation configurations (excluding accountSequenceNumber)\n   *\n   * @return void. Throws if any error\n   * @group Implementation\n   */\n  forSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): void {\n    try {\n      const { sender, data, options } = args;\n      this.start({ sender });\n\n      this.push({ data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n}\n", "/**\n * A wrapper that handles and manages an account sequence number.\n *\n * Submit up to `maximumInFlight` transactions per account in parallel with a timeout of `sleepTime`\n * If local assumes `maximumInFlight` are in flight, determine the actual committed state from the network\n * If there are less than `maximumInFlight` due to some being committed, adjust the window\n * If `maximumInFlight` are in flight, wait `sleepTime` seconds before re-evaluating\n * If ever waiting more than `maxWaitTime` restart the sequence number to the current on-chain state\n *\n * Assumptions:\n * Accounts are expected to be managed by a single AccountSequenceNumber and not used otherwise.\n * They are initialized to the current on-chain state, so if there are already transactions in\n * flight, they may take some time to reset.\n * Accounts are automatically initialized if not explicitly\n *\n * Notes:\n * This is co-routine safe, that is many async tasks can be reading from this concurrently.\n * The state of an account cannot be used across multiple AccountSequenceNumber services.\n * The synchronize method will create a barrier that prevents additional nextSequenceNumber\n * calls until it is complete.\n * This only manages the distribution of sequence numbers it does not help handle transaction\n * failures.\n * If a transaction fails, you should call synchronize and wait for timeouts.\n * @group Implementation\n * @category Transactions\n */\n\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { Account } from \"../../account\";\nimport { getInfo } from \"../../internal/account\";\nimport { nowInSeconds, sleep } from \"../../utils/helpers\";\n\n/**\n * Represents an account's sequence number management for transaction handling on the Aptos blockchain.\n * This class provides methods to retrieve the next available sequence number, synchronize with the on-chain sequence number,\n * and manage local sequence numbers while ensuring thread safety.\n *\n * @param aptosConfig - The configuration settings for Aptos.\n * @param account - The account associated with the sequence number.\n * @param maxWaitTime - The maximum time to wait for a transaction to commit.\n * @param maximumInFlight - The maximum number of transactions that can be in flight at once.\n * @param sleepTime - The time to wait before retrying to get the sequence number.\n * @group Implementation\n * @category Transactions\n */\nexport class AccountSequenceNumber {\n  readonly aptosConfig: AptosConfig;\n\n  readonly account: Account;\n\n  // sequence number on chain\n  // TODO: Change to Uncommitted\n  lastUncommintedNumber: bigint | null = null;\n\n  // local sequence number\n  currentNumber: bigint | null = null;\n\n  /**\n   * We want to guarantee that we preserve ordering of workers to requests.\n   *\n   * `lock` is used to try to prevent multiple coroutines from accessing a shared resource at the same time,\n   * which can result in race conditions and data inconsistency.\n   * This code actually doesn't do it though, since we aren't giving out a slot, it is still somewhat a race condition.\n   *\n   * The ideal solution is likely that each thread grabs the next number from an incremental integer.\n   * When they complete, they increment that number and that entity is able to enter the `lock`.\n   * That would guarantee ordering.\n   * @group Implementation\n   * @category Transactions\n   */\n  lock = false;\n\n  maxWaitTime: number;\n\n  maximumInFlight: number;\n\n  sleepTime: number;\n\n  /**\n   * Creates an instance of the class with the specified configuration and account details.\n   * This constructor initializes the necessary parameters for managing Aptos transactions.\n   *\n   * @param aptosConfig - The configuration settings for Aptos.\n   * @param account - The account associated with the Aptos transactions.\n   * @param maxWaitTime - The maximum time to wait for a transaction to be processed, in milliseconds.\n   * @param maximumInFlight - The maximum number of transactions that can be in flight at the same time.\n   * @param sleepTime - The time to sleep between transaction checks, in milliseconds.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    aptosConfig: AptosConfig,\n    account: Account,\n    maxWaitTime: number,\n    maximumInFlight: number,\n    sleepTime: number,\n  ) {\n    this.aptosConfig = aptosConfig;\n    this.account = account;\n    this.maxWaitTime = maxWaitTime;\n    this.maximumInFlight = maximumInFlight;\n    this.sleepTime = sleepTime;\n  }\n\n  /**\n   * Returns the next available sequence number for this account.\n   * This function ensures that the sequence number is updated and synchronized, handling potential delays in transaction commits.\n   *\n   * @returns {BigInt} The next available sequence number.\n   * @group Implementation\n   * @category Transactions\n   */\n  async nextSequenceNumber(): Promise<bigint | null> {\n    /* eslint-disable no-await-in-loop */\n    while (this.lock) {\n      await sleep(this.sleepTime);\n    }\n\n    this.lock = true;\n    let nextNumber = BigInt(0);\n    try {\n      if (this.lastUncommintedNumber === null || this.currentNumber === null) {\n        await this.initialize();\n      }\n\n      if (this.currentNumber! - this.lastUncommintedNumber! >= this.maximumInFlight) {\n        await this.update();\n\n        const startTime = nowInSeconds();\n        while (this.currentNumber! - this.lastUncommintedNumber! >= this.maximumInFlight) {\n          await sleep(this.sleepTime);\n          if (nowInSeconds() - startTime > this.maxWaitTime) {\n            /* eslint-disable no-console */\n            console.warn(\n              `Waited over 30 seconds for a transaction to commit, re-syncing ${this.account.accountAddress.toString()}`,\n            );\n            await this.initialize();\n          } else {\n            await this.update();\n          }\n        }\n      }\n      nextNumber = this.currentNumber!;\n      this.currentNumber! += BigInt(1);\n    } catch (e) {\n      console.error(\"error in getting next sequence number for this account\", e);\n    } finally {\n      this.lock = false;\n    }\n    return nextNumber;\n  }\n\n  /**\n   * Initializes this account with the sequence number on chain.\n   *\n   * @returns {Promise<void>} A promise that resolves when the account has been initialized.\n   *\n   * @throws {Error} Throws an error if the account information cannot be retrieved.\n   * @group Implementation\n   * @category Transactions\n   */\n  async initialize(): Promise<void> {\n    const { sequence_number: sequenceNumber } = await getInfo({\n      aptosConfig: this.aptosConfig,\n      accountAddress: this.account.accountAddress,\n    });\n    this.currentNumber = BigInt(sequenceNumber);\n    this.lastUncommintedNumber = BigInt(sequenceNumber);\n  }\n\n  /**\n   * Updates this account's sequence number with the one on-chain.\n   *\n   * @returns The on-chain sequence number for this account.\n   * @group Implementation\n   * @category Transactions\n   */\n  async update(): Promise<bigint> {\n    const { sequence_number: sequenceNumber } = await getInfo({\n      aptosConfig: this.aptosConfig,\n      accountAddress: this.account.accountAddress,\n    });\n    this.lastUncommintedNumber = BigInt(sequenceNumber);\n    return this.lastUncommintedNumber;\n  }\n\n  /**\n   * Synchronizes the local sequence number with the sequence number on-chain for the specified account.\n   * This function polls the network until all submitted transactions have either been committed or until the maximum wait time has elapsed.\n   *\n   * @throws {Error} Throws an error if there is an issue synchronizing the account sequence number with the one on-chain.\n   * @group Implementation\n   * @category Transactions\n   */\n  async synchronize(): Promise<void> {\n    if (this.lastUncommintedNumber === this.currentNumber) return;\n\n    /* eslint-disable no-await-in-loop */\n    while (this.lock) {\n      await sleep(this.sleepTime);\n    }\n\n    this.lock = true;\n\n    try {\n      await this.update();\n      const startTime = nowInSeconds();\n      while (this.lastUncommintedNumber !== this.currentNumber) {\n        if (nowInSeconds() - startTime > this.maxWaitTime) {\n          /* eslint-disable no-console */\n          console.warn(\n            `Waited over 30 seconds for a transaction to commit, re-syncing ${this.account.accountAddress.toString()}`,\n          );\n          await this.initialize();\n        } else {\n          await sleep(this.sleepTime);\n          await this.update();\n        }\n      }\n    } catch (e) {\n      console.error(\"error in synchronizing this account sequence number with the one on chain\", e);\n    } finally {\n      this.lock = false;\n    }\n  }\n}\n", "/* eslint-disable no-await-in-loop */\n\nimport EventEmitter from \"eventemitter3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { Account } from \"../../account\";\nimport { waitForTransaction } from \"../../internal/transaction\";\nimport { generateTransaction, signAndSubmitTransaction } from \"../../internal/transactionSubmission\";\nimport { PendingTransactionResponse, TransactionResponse } from \"../../types\";\nimport { InputGenerateTransactionOptions, InputGenerateTransactionPayloadData } from \"../types\";\nimport { AccountSequenceNumber } from \"./accountSequenceNumber\";\nimport { AsyncQueue, AsyncQueueCancelledError } from \"./asyncQueue\";\nimport { SimpleTransaction } from \"../instances/simpleTransaction\";\n\n/**\n * @group Implementation\n * @category Transactions\n */\nexport const promiseFulfilledStatus = \"fulfilled\";\n\n/**\n * Events emitted by the transaction worker during its operation, allowing the dapp to respond to various transaction states.\n * @group Implementation\n * @category Transactions\n */\nexport enum TransactionWorkerEventsEnum {\n  // fired after a transaction gets sent to the chain\n  TransactionSent = \"transactionSent\",\n  // fired if there is an error sending the transaction to the chain\n  TransactionSendFailed = \"transactionSendFailed\",\n  // fired when a single transaction has executed successfully\n  TransactionExecuted = \"transactionExecuted\",\n  // fired if a single transaction fails in execution\n  TransactionExecutionFailed = \"transactionExecutionFailed\",\n  // fired when the worker has finished its job / when the queue has been emptied\n  ExecutionFinish = \"executionFinish\",\n}\n\n/**\n * Defines the events emitted by the transaction worker during various stages of transaction processing. *\n * @group Implementation\n * @category Transactions\n */\nexport interface TransactionWorkerEvents {\n  transactionSent: (data: SuccessEventData) => void;\n  transactionSendFailed: (data: FailureEventData) => void;\n  transactionExecuted: (data: SuccessEventData) => void;\n  transactionExecutionFailed: (data: FailureEventData) => void;\n  executionFinish: (data: ExecutionFinishEventData) => void;\n}\n\n/**\n * The payload for when the worker has finished its job.\n * @group Implementation\n * @category Transactions\n */\nexport type ExecutionFinishEventData = {\n  message: string;\n};\n\n/**\n * The payload for a success event.\n * @group Implementation\n * @category Transactions\n */\nexport type SuccessEventData = {\n  message: string;\n  transactionHash: string;\n};\n\n/**\n * The payload for a failure event.\n * @group Implementation\n * @category Transactions\n */\nexport type FailureEventData = {\n  message: string;\n  error: string;\n};\n\n/**\n * TransactionWorker provides a simple framework for receiving payloads to be processed.\n *\n * Once one `start()` the process and pushes a new transaction, the worker acquires\n * the current account's next sequence number (by using the AccountSequenceNumber class),\n * generates a signed transaction and pushes an async submission process into the `outstandingTransactions` queue.\n * At the same time, the worker processes transactions by reading the `outstandingTransactions` queue\n * and submits the next transaction to chain, it\n * 1) waits for resolution of the submission process or get pre-execution validation error\n * and 2) waits for the resolution of the execution process or get an execution error.\n * The worker fires events for any submission and/or execution success and/or failure.\n * @group Implementation\n * @category Transactions\n */\nexport class TransactionWorker extends EventEmitter<TransactionWorkerEvents> {\n  readonly aptosConfig: AptosConfig;\n\n  readonly account: Account;\n\n  // current account sequence number\n  // TODO: Rename Sequnce -> Sequence\n  readonly accountSequnceNumber: AccountSequenceNumber;\n\n  readonly taskQueue: AsyncQueue<() => Promise<void>> = new AsyncQueue<() => Promise<void>>();\n\n  // process has started\n  started: boolean;\n\n  /**\n   * transactions payloads waiting to be generated and signed\n   *\n   * TODO support entry function payload from ABI builder\n   * @group Implementation\n   * @category Transactions\n   */\n  transactionsQueue = new AsyncQueue<\n    [InputGenerateTransactionPayloadData, InputGenerateTransactionOptions | undefined]\n  >();\n\n  /**\n   * signed transactions waiting to be submitted\n   * @group Implementation\n   * @category Transactions\n   */\n  outstandingTransactions = new AsyncQueue<[Promise<PendingTransactionResponse>, bigint]>();\n\n  /**\n   * transactions that have been submitted to chain\n   * @group Implementation\n   * @category Transactions\n   */\n  sentTransactions: Array<[string, bigint, any]> = [];\n\n  /**\n   * transactions that have been committed to chain\n   * @group Implementation\n   * @category Transactions\n   */\n  executedTransactions: Array<[string, bigint, any]> = [];\n\n  /**\n   * Initializes a new instance of the class, providing a framework for receiving payloads to be processed.\n   *\n   * @param aptosConfig - A configuration object for Aptos.\n   * @param account - The account that will be used for sending transactions.\n   * @param maxWaitTime - The maximum wait time to wait before re-syncing the sequence number to the current on-chain state,\n   * default is 30 seconds.\n   * @param maximumInFlight - The maximum number of transactions that can be submitted per account, default is 100.\n   * @param sleepTime - The time to wait in seconds before re-evaluating if the maximum number of transactions are in flight,\n   * default is 10 seconds.\n   * @group Implementation\n   * @category Transactions\n   */\n  constructor(\n    aptosConfig: AptosConfig,\n    account: Account,\n    maxWaitTime: number = 30,\n    maximumInFlight: number = 100,\n    sleepTime: number = 10,\n  ) {\n    super();\n    this.aptosConfig = aptosConfig;\n    this.account = account;\n    this.started = false;\n    this.accountSequnceNumber = new AccountSequenceNumber(\n      aptosConfig,\n      account,\n      maxWaitTime,\n      maximumInFlight,\n      sleepTime,\n    );\n  }\n\n  /**\n   * Submits the next transaction for the account by generating it with the current sequence number\n   * and adding it to the outstanding transaction queue for processing.\n   * This function continues to submit transactions until there are no more to process.\n   *\n   * @throws {Error} Throws an error if the transaction submission fails.\n   * @group Implementation\n   * @category Transactions\n   */\n  async submitNextTransaction() {\n    try {\n      /* eslint-disable no-constant-condition */\n      while (true) {\n        const sequenceNumber = await this.accountSequnceNumber.nextSequenceNumber();\n        if (sequenceNumber === null) return;\n        const transaction = await this.generateNextTransaction(this.account, sequenceNumber);\n        if (!transaction) return;\n        const pendingTransaction = signAndSubmitTransaction({\n          aptosConfig: this.aptosConfig,\n          transaction,\n          signer: this.account,\n        });\n        await this.outstandingTransactions.enqueue([pendingTransaction, sequenceNumber]);\n      }\n    } catch (error: any) {\n      if (error instanceof AsyncQueueCancelledError) {\n        return;\n      }\n      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${error}`);\n    }\n  }\n\n  /**\n   * Reads the outstanding transaction queue and submits the transactions to the chain.\n   * This function processes each transaction, checking their status and emitting events based on whether they were successfully\n   * sent or failed.\n   *\n   * @throws {Error} Throws an error if the process execution fails.\n   * @event TransactionWorkerEventsEnum.TransactionSent - Emitted when a transaction has been successfully committed to the chain.\n   * @event TransactionWorkerEventsEnum.TransactionSendFailed - Emitted when a transaction fails to commit, along with the error\n   * reason.\n   * @event TransactionWorkerEventsEnum.ExecutionFinish - Emitted when the execution of transactions is complete.\n   * @group Implementation\n   * @category Transactions\n   */\n  async processTransactions() {\n    try {\n      /* eslint-disable no-constant-condition */\n      while (true) {\n        const awaitingTransactions = [];\n        const sequenceNumbers = [];\n        let [pendingTransaction, sequenceNumber] = await this.outstandingTransactions.dequeue();\n\n        awaitingTransactions.push(pendingTransaction);\n        sequenceNumbers.push(sequenceNumber);\n\n        while (!this.outstandingTransactions.isEmpty()) {\n          [pendingTransaction, sequenceNumber] = await this.outstandingTransactions.dequeue();\n\n          awaitingTransactions.push(pendingTransaction);\n          sequenceNumbers.push(sequenceNumber);\n        }\n        // send awaiting transactions to chain\n        const sentTransactions = await Promise.allSettled(awaitingTransactions);\n        for (let i = 0; i < sentTransactions.length && i < sequenceNumbers.length; i += 1) {\n          // check sent transaction status\n          const sentTransaction = sentTransactions[i];\n          sequenceNumber = sequenceNumbers[i];\n          if (sentTransaction.status === promiseFulfilledStatus) {\n            // transaction sent to chain\n            this.sentTransactions.push([sentTransaction.value.hash, sequenceNumber, null]);\n            // check sent transaction execution\n            this.emit(TransactionWorkerEventsEnum.TransactionSent, {\n              message: `transaction hash ${sentTransaction.value.hash} has been committed to chain`,\n              transactionHash: sentTransaction.value.hash,\n            });\n            await this.checkTransaction(sentTransaction, sequenceNumber);\n          } else {\n            // send transaction failed\n            this.sentTransactions.push([sentTransaction.status, sequenceNumber, sentTransaction.reason]);\n            this.emit(TransactionWorkerEventsEnum.TransactionSendFailed, {\n              message: `failed to commit transaction ${this.sentTransactions.length} with error ${sentTransaction.reason}`,\n              error: sentTransaction.reason,\n            });\n          }\n        }\n        this.emit(TransactionWorkerEventsEnum.ExecutionFinish, {\n          message: `execute ${sentTransactions.length} transactions finished`,\n        });\n      }\n    } catch (error: any) {\n      if (error instanceof AsyncQueueCancelledError) {\n        return;\n      }\n      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${error}`);\n    }\n  }\n\n  /**\n   * Once a transaction has been sent to the chain, this function checks for its execution status.\n   * @param sentTransaction - The transaction that was sent to the chain and is now waiting to be executed.\n   * @param sequenceNumber - The account's sequence number that was sent with the transaction.\n   * @group Implementation\n   * @category Transactions\n   */\n  async checkTransaction(sentTransaction: PromiseFulfilledResult<PendingTransactionResponse>, sequenceNumber: bigint) {\n    try {\n      const waitFor: Array<Promise<TransactionResponse>> = [];\n      waitFor.push(waitForTransaction({ aptosConfig: this.aptosConfig, transactionHash: sentTransaction.value.hash }));\n      const sentTransactions = await Promise.allSettled(waitFor);\n\n      for (let i = 0; i < sentTransactions.length; i += 1) {\n        const executedTransaction = sentTransactions[i];\n        if (executedTransaction.status === promiseFulfilledStatus) {\n          // transaction executed to chain\n          this.executedTransactions.push([executedTransaction.value.hash, sequenceNumber, null]);\n          this.emit(TransactionWorkerEventsEnum.TransactionExecuted, {\n            message: `transaction hash ${executedTransaction.value.hash} has been executed on chain`,\n            transactionHash: sentTransaction.value.hash,\n          });\n        } else {\n          // transaction execution failed\n          this.executedTransactions.push([executedTransaction.status, sequenceNumber, executedTransaction.reason]);\n          this.emit(TransactionWorkerEventsEnum.TransactionExecutionFailed, {\n            message: `failed to execute transaction ${this.executedTransactions.length} with error ${executedTransaction.reason}`,\n            error: executedTransaction.reason,\n          });\n        }\n      }\n    } catch (error: any) {\n      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${error}`);\n    }\n  }\n\n  /**\n   * Pushes a transaction to the transactions queue for processing.\n   *\n   * @param transactionData - The transaction payload containing necessary details.\n   * @param transactionData.abi - For all entry function payloads, the ABI to skip remote ABI lookups.\n   * @param options - Optional parameters for transaction configuration.\n   * @param options.maxGasAmount - Maximum gas amount for the transaction.\n   * @param options.gasUnitPrice - Gas unit price for the transaction.\n   * @param options.expireTimestamp - Expiration timestamp on the transaction.\n   * @param options.accountSequenceNumber - The sequence number for the transaction.\n   * @group Implementation\n   * @category Transactions\n   */\n  async push(\n    transactionData: InputGenerateTransactionPayloadData,\n    options?: InputGenerateTransactionOptions,\n  ): Promise<void> {\n    this.transactionsQueue.enqueue([transactionData, options]);\n  }\n\n  /**\n   * Generates a signed transaction that can be submitted to the chain.\n   *\n   * @param account - An Aptos account used as the sender of the transaction.\n   * @param sequenceNumber - A sequence number the transaction will be generated with.\n   * @returns A signed transaction object or undefined if the transaction queue is empty.\n   * @group Implementation\n   * @category Transactions\n   */\n  async generateNextTransaction(account: Account, sequenceNumber: bigint): Promise<SimpleTransaction | undefined> {\n    if (this.transactionsQueue.isEmpty()) return undefined;\n    const [transactionData, options] = await this.transactionsQueue.dequeue();\n    return generateTransaction({\n      aptosConfig: this.aptosConfig,\n      sender: account.accountAddress,\n      data: transactionData,\n      options: { ...options, accountSequenceNumber: sequenceNumber, replayProtectionNonce: undefined },\n    });\n  }\n\n  /**\n   * Starts transaction submission and processing by executing tasks from the queue until it is cancelled.\n   *\n   * @throws {Error} Throws an error if unable to start transaction batching.\n   * @group Implementation\n   * @category Transactions\n   */\n  async run() {\n    try {\n      while (!this.taskQueue.isCancelled()) {\n        const task = await this.taskQueue.dequeue();\n        await task();\n      }\n    } catch (error: any) {\n      throw new Error(`Unable to start transaction batching: ${error}`);\n    }\n  }\n\n  /**\n   * Starts the transaction management process.\n   *\n   * @throws {Error} Throws an error if the worker has already started.\n   * @group Implementation\n   * @category Transactions\n   */\n  start() {\n    if (this.started) {\n      throw new Error(\"worker has already started\");\n    }\n    this.started = true;\n    this.taskQueue.enqueue(() => this.submitNextTransaction());\n    this.taskQueue.enqueue(() => this.processTransactions());\n    this.run();\n  }\n\n  /**\n   * Stops the transaction management process.\n   *\n   * @throws {Error} Throws an error if the worker has already stopped.\n   * @group Implementation\n   * @category Transactions\n   */\n  stop() {\n    if (this.taskQueue.isCancelled()) {\n      throw new Error(\"worker has already stopped\");\n    }\n    this.started = false;\n    this.taskQueue.cancel();\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getGasPriceEstimation,\n  getTransactionByHash,\n  getTransactionByVersion,\n  getTransactions,\n  isTransactionPending,\n  waitForTransaction,\n} from \"../internal/transaction\";\nimport {\n  AnyNumber,\n  CommittedTransactionResponse,\n  GasEstimation,\n  HexInput,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TransactionResponse,\n  WaitForTransactionOptions,\n} from \"../types\";\nimport {\n  FeePayerOrFeePayerAuthenticatorOrNeither,\n  getSigningMessage,\n  publicPackageTransaction,\n  signAndSubmitAsFeePayer,\n  signAndSubmitTransaction,\n  signAsFeePayer,\n  signTransaction,\n} from \"../internal/transactionSubmission\";\nimport {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadData,\n  InputTransactionPluginData,\n} from \"../transactions\";\nimport { AccountAddressInput, AuthenticationKey, Ed25519PrivateKey } from \"../core\";\nimport { Account } from \"../account\";\nimport { Build } from \"./transactionSubmission/build\";\nimport { Simulate } from \"./transactionSubmission/simulate\";\nimport { Submit } from \"./transactionSubmission/submit\";\nimport { TransactionManagement } from \"./transactionSubmission/management\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { rotateAuthKey } from \"../internal/account\";\n\n/**\n * Represents a transaction in the Aptos blockchain,\n * providing methods to build, simulate, submit, and manage transactions.\n * This class encapsulates functionalities for querying transaction details,\n * estimating gas prices, signing transactions, and handling transaction states.\n *\n * This class is used as part of the Aptos object, so should be called like so:\n * @example\n * ```typescript\n * import { Account, Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * const APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\n * const COIN_STORE = `0x1::coin::CoinStore<${APTOS_COIN}>`;\n * const ALICE_INITIAL_BALANCE = 100_000_000;\n * const TRANSFER_AMOUNT = 100;\n *\n * async function example() {\n *   console.log(\n *     \"This example will create two accounts (Alice and Bob), fund them, and transfer between them.\",\n *   );\n *\n *   // Set up the client\n *   const config = new AptosConfig({ network: Network.DEVNET });\n *   const aptos = new Aptos(config);\n *\n *   // Generate two account credentials\n *   // Each account has a private key, a public key, and an address\n *   const alice = Account.generate();\n *   const bob = Account.generate();\n *\n *   console.log(\"=== Addresses ===\\n\");\n *   console.log(`Alice's address is: ${alice.accountAddress}`);\n *   console.log(`Bob's address is: ${bob.accountAddress}`);\n *\n *   // Fund the accounts using a faucet\n *   console.log(\"\\n=== Funding accounts ===\\n\");\n *\n *   await aptos.fundAccount({\n *     accountAddress: alice.accountAddress,\n *     amount: ALICE_INITIAL_BALANCE,\n *   });\n *\n *   // Send a transaction from Alice's account to Bob's account\n *   const txn = await aptos.transaction.build.simple({\n *     sender: alice.accountAddress,\n *     data: {\n *       // All transactions on Aptos are implemented via smart contracts.\n *       function: \"0x1::aptos_account::transfer\",\n *       functionArguments: [bob.accountAddress, 100],\n *     },\n *   });\n *\n *   console.log(\"\\n=== Transfer transaction ===\\n\");\n *   // Both signs and submits\n *   const committedTxn = await aptos.signAndSubmitTransaction({\n *     signer: alice,\n *     transaction: txn,\n *  });\n *   // Waits for Aptos to verify and execute the transaction\n *   const executedTransaction = await aptos.waitForTransaction({\n *     transactionHash: committedTxn.hash,\n *   });\n *   console.log(\"Transaction hash:\", executedTransaction.hash);\n *\n *  console.log(\"\\n=== Balances after transfer ===\\n\");\n *  const newAliceAccountBalance = await aptos.getAccountResource({\n *    accountAddress: alice.accountAddress,\n *    resourceType: COIN_STORE,\n *  });\n *  const newAliceBalance = Number(newAliceAccountBalance.coin.value);\n *  console.log(`Alice's balance is: ${newAliceBalance}`);\n *\n *  const newBobAccountBalance = await aptos.getAccountResource({\n *    accountAddress: bob.accountAddress,\n *    resourceType: COIN_STORE,\n *  });\n *  const newBobBalance = Number(newBobAccountBalance.coin.value);\n *  console.log(`Bob's balance is: ${newBobBalance}`);\n * }\n *\n * example();\n * ```\n * @group Transaction\n */\nexport class Transaction {\n  readonly config: AptosConfig;\n\n  readonly build: Build;\n\n  readonly simulate: Simulate;\n\n  readonly submit: Submit;\n\n  readonly batch: TransactionManagement;\n\n  /**\n   * Creates an instance of the Aptos client with the specified configuration.\n   * This allows you to interact with the Aptos blockchain using the provided settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., Testnet, Mainnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client instance\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify the network\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client created successfully:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  constructor(config: AptosConfig) {\n    this.config = config;\n    this.build = new Build(this.config);\n    this.simulate = new Simulate(this.config);\n    this.submit = new Submit(this.config);\n    this.batch = new TransactionManagement(this.config);\n  }\n\n  /**\n   * Queries on-chain transactions, excluding pending transactions.\n   * Use this function to retrieve historical transactions from the blockchain.\n   *\n   * @param args Optional parameters for pagination.\n   * @param args.options Optional pagination options.\n   * @param args.options.offset The number of the transaction to start with.\n   * @param args.options.limit The number of results to return.\n   *\n   * @returns An array of on-chain transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch transactions with pagination\n   *   const transactions = await aptos.getTransactions({\n   *     options: {\n   *       offset: 0, // Start from the first transaction\n   *       limit: 10, // Limit to 10 results\n   *     },\n   *   });\n   *\n   *   console.log(transactions);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactions(args?: { options?: PaginationArgs }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by version. This function will not return pending transactions.\n   *\n   * @param args - The arguments for querying the transaction.\n   * @param args.ledgerVersion - Transaction version is an unsigned 64-bit number.\n   * @returns On-chain transaction. Only on-chain transactions have versions, so this\n   * function cannot be used to query pending transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching a transaction by its version\n   *   const transaction = await aptos.getTransactionByVersion({ ledgerVersion: 1 }); // replace 1 with a real version\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactionByVersion(args: { ledgerVersion: AnyNumber }): Promise<TransactionResponse> {\n    return getTransactionByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transactions by their transaction hash, returning both pending and committed transactions.\n   *\n   * @param args - The arguments for querying the transaction.\n   * @param args.transactionHash - The transaction hash should be a hex-encoded bytes string with a 0x prefix.\n   * @returns The transaction from the mempool (pending) or the on-chain (committed) transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetch a transaction by its hash\n   *   const transaction = await aptos.getTransactionByHash({ transactionHash: \"0x123\" }); // replace with a real transaction hash\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getTransactionByHash(args: { transactionHash: HexInput }): Promise<TransactionResponse> {\n    return getTransactionByHash({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Defines if the specified transaction is currently in a pending state.\n   * This function helps you determine the status of a transaction using its hash.\n   *\n   * @param args - The arguments for the function.\n   * @param args.transactionHash - A hash of the transaction in hexadecimal format.\n   * @returns `true` if the transaction is in a pending state and `false` otherwise.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Check if the transaction is pending using its hash\n   *   const isPendingTransaction = await aptos.isPendingTransaction({ transactionHash: \"0x123\" }); // replace with a real transaction hash\n   *   console.log(\"Is the transaction pending?\", isPendingTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async isPendingTransaction(args: { transactionHash: HexInput }): Promise<boolean> {\n    return isTransactionPending({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Waits for a transaction to move past the pending state and provides the transaction response.\n   * There are 4 cases.\n   * 1. Transaction is successfully processed and committed to the chain.\n   *    - The function will resolve with the transaction response from the API.\n   * 2. Transaction is rejected for some reason, and is therefore not committed to the blockchain.\n   *    - The function will throw an AptosApiError with an HTTP status code indicating some problem with the request.\n   * 3. Transaction is committed but execution failed, meaning no changes were\n   *    written to the blockchain state.\n   *    - If `checkSuccess` is true, the function will throw a FailedTransactionError\n   *      If `checkSuccess` is false, the function will resolve with the transaction response where the `success` field is false.\n   * 4. Transaction does not move past the pending state within `args.options.timeoutSecs` seconds.\n   *    - The function will throw a WaitForTransactionError\n   *\n   * @param args.transactionHash - The hash of a transaction previously submitted to the blockchain.\n   * @param args.options - Optional parameters for waiting behavior.\n   * @param args.options.timeoutSecs - Timeout in seconds. Defaults to 20 seconds.\n   * @param args.options.checkSuccess - A boolean which controls whether the function will error if the transaction failed.\n   * Defaults to true.\n   * @returns The transaction on-chain response.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Wait for a transaction to complete using its hash\n   *   const transactionHash = \"0x123\"; // replace with a real transaction hash\n   *   const transactionResponse = await aptos.waitForTransaction({\n   *     transactionHash,\n   *     options: {\n   *       timeoutSecs: 30, // specify your own timeout if needed\n   *       checkSuccess: true,\n   *     },\n   *   });\n   *\n   *   console.log(transactionResponse);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async waitForTransaction(args: {\n    transactionHash: HexInput;\n    options?: WaitForTransactionOptions;\n  }): Promise<CommittedTransactionResponse> {\n    return waitForTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Estimates the gas unit price required to process a transaction on the Aptos blockchain in a timely manner.\n   * This helps users to understand the cost associated with their transactions.\n   * {@link https://api.mainnet.aptoslabs.com/v1/spec#/operations/estimate_gas_price}\n   *\n   * @returns An object containing the estimated gas price.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET }); // Specify your network\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Getting the gas price estimation\n   *   const gasPriceEstimation = await aptos.getGasPriceEstimation();\n   *\n   *   console.log(\"Estimated Gas Price:\", gasPriceEstimation);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async getGasPriceEstimation(): Promise<GasEstimation> {\n    return getGasPriceEstimation({\n      aptosConfig: this.config,\n    });\n  }\n\n  /**\n   * Returns a signing message for a transaction, allowing a user to sign it using their preferred method before submission to the network.\n   *\n   * @param args - The arguments for obtaining the signing message.\n   * @param args.transaction - A raw transaction for signing elsewhere.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *     const transaction = await aptos.transaction.build.simple({\n   *         sender: \"0x1\", // replace with a real sender address\n   *         data: {\n   *             function: \"0x1::aptos_account::transfer\",\n   *             functionArguments: [\"0x2\", 100], // replace with a real destination address\n   *         },\n   *     });\n   *\n   *     const message = await aptos.getSigningMessage({ transaction });\n   *     console.log(message);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n    return getSigningMessage(args);\n  }\n\n  /**\n   * Generates a transaction to publish a Move package to the blockchain.\n   * This function helps you create a transaction that can be simulated or submitted to the chain for publishing a package.\n   *\n   * To get the `metadataBytes` and `byteCode`, can compile using Aptos CLI with command\n   * `aptos move compile --save-metadata ...`,\n   *\n   * {@link https://aptos.dev/tutorials/your-first-dapp/#step-4-publish-a-move-module}\n   *\n   * @param args The arguments for publishing the package.\n   * @param args.account The publisher account.\n   * @param args.metadataBytes The package metadata bytes.\n   * @param args.moduleBytecode An array of the bytecode of each module in the package in compiler output order.\n   * @param args.options Optional settings for generating the transaction.\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to the chain.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Replace with a real account address\n   *   const account = \"0x1\";\n   *   const metadataBytes = \"0x...\"; // replace with real metadata bytes\n   *   const byteCode = \"0x...\"; // replace with real module bytecode\n   *\n   *   const transaction = await aptos.publishPackageTransaction({\n   *     account,\n   *     metadataBytes,\n   *     moduleBytecode: [byteCode],\n   *   });\n   *\n   *   console.log(transaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async publishPackageTransaction(args: {\n    account: AccountAddressInput;\n    metadataBytes: HexInput;\n    moduleBytecode: Array<HexInput>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return publicPackageTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Rotates the authentication key for a given account.  Once an account is rotated, only the new private key\n   * or keyless signing scheme can be used to sign transactions for the account.\n   *\n   * @param args - The arguments for rotating the authentication key.\n   * @param args.fromAccount - The account from which the authentication key will be rotated.\n   * @param args.toAccount - (Optional) The target account to rotate to. Required if not using toNewPrivateKey or toAuthKey.\n   * @param args.toNewPrivateKey - (Optional) The new private key to rotate to. Required if not using toAccount or toAuthKey.\n   * @param args.toAuthKey - (Optional) The new authentication key to rotate to. Can only be used with dangerouslySkipVerification=true.\n   * @param args.dangerouslySkipVerification - (Optional) If true, skips verification steps after rotation. Required when using toAuthKey.\n   *\n   * @remarks\n   * This function supports three modes of rotation:\n   * 1. Using a target Account object (toAccount)\n   * 2. Using a new private key (toNewPrivateKey)\n   * 3. Using a raw authentication key (toAuthKey) - requires dangerouslySkipVerification=true\n   *\n   * When not using dangerouslySkipVerification, the function performs additional safety checks and account setup.\n   *\n   * If the new key is a multi key, skipping verification is dangerous because verification will publish the public key onchain and\n   * prevent users from being locked out of the account from loss of knowledge of one of the public keys.\n   *\n   * @returns PendingTransactionResponse\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account, PrivateKey } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Rotate the authentication key for an account\n   *   const response = await aptos.rotateAuthKey({\n   *     // replace with a real account\n   *     fromAccount: Account.generate(),\n   *     // replace with a real private key\n   *     toNewPrivateKey: new PrivateKey(\"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\"),\n   *   });\n   *\n   *   console.log(response);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async rotateAuthKey(\n    args: {\n      fromAccount: Account;\n      options?: InputGenerateTransactionOptions;\n    } & (\n      | { toAccount: Account; dangerouslySkipVerification?: never }\n      | { toNewPrivateKey: Ed25519PrivateKey; dangerouslySkipVerification?: never }\n      | { toAuthKey: AuthenticationKey; dangerouslySkipVerification: true }\n    ),\n  ): Promise<PendingTransactionResponse> {\n    return rotateAuthKey({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sign a transaction that can later be submitted to the chain.\n   * This function is essential for ensuring the authenticity of the transaction by using the provided account's signing capabilities.\n   *\n   * @param args - The arguments for signing the transaction.\n   * @param args.signer - The account that will sign the transaction.\n   * @param args.transaction - A raw transaction to sign.\n   *\n   * @returns AccountAuthenticator - The authenticator for the signed transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for signing\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [ \"0x1\", 100 ], // replace with a real account address and amount\n   *     },\n   *   });\n   *\n   *   const signedTransaction = await aptos.transaction.sign({\n   *     signer: sender,\n   *     transaction,\n   *   }); // Sign the transaction\n   *\n   *   console.log(\"Signed Transaction:\", signedTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  sign(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signTransaction({\n      ...args,\n    });\n  }\n\n  /**\n   * Sign a transaction as a fee payer that can later be submitted to the chain.\n   * This function ensures that the transaction is marked with the fee payer's address, allowing it to be processed correctly.\n   *\n   * @param args - The arguments for signing the transaction.\n   * @param args.signer - The fee payer signer account.\n   * @param args.transaction - A raw transaction to sign on. This transaction must include a `feePayerAddress` property.\n   *\n   * @returns AccountAuthenticator - The authenticator for the signed transaction.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for the fee payer\n   *   const transaction = await aptos.transaction.build.simple({\n   *     // All transactions on Aptos are implemented via smart contracts.\n   *     function: \"0x1::aptos_account::transfer\",\n   *     functionArguments: [sender.accountAddress, 100],\n   *     feePayerAddress: sender.accountAddress, // Set the fee payer address\n   *   });\n   *\n   *   const signedTransaction = await aptos.transaction.signAsFeePayer({\n   *     signer: sender,\n   *     transaction,\n   *   });\n   *\n   *   console.log(\"Signed transaction as fee payer:\", signedTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  // eslint-disable-next-line class-methods-use-this\n  signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signAsFeePayer({\n      ...args,\n    });\n  }\n\n  // TRANSACTION SUBMISSION //\n\n  /**\n   * @deprecated Prefer to use `aptos.transaction.batch.forSingleAccount()`\n   *\n   * Batch transactions for a single account by submitting multiple transaction payloads.\n   * This function is useful for efficiently processing and submitting transactions that do not depend on each other, such as\n   * batch funding or batch token minting.\n   *\n   * @param args - The arguments for batching transactions.\n   * @param args.sender - The sender account to sign and submit the transactions.\n   * @param args.data - An array of transaction payloads to be processed.\n   * @param args.options - Optional. Transaction generation configurations (excluding accountSequenceNumber).\n   *\n   * @throws Error if any worker failure occurs during submission.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, Account } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   * const sender = Account.generate(); // Generate a new account for sending transactions\n   *\n   * async function runExample() {\n   *   const transactions = [\n   *     { }, // Build your first transaction payload\n   *     { }, // Build your second transaction payload\n   *   ];\n   *\n   *   // Batch transactions for the single account\n   *   await aptos.batchTransactionsForSingleAccount({\n   *     sender,\n   *     data: transactions,\n   *   });\n   *\n   *   console.log(\"Batch transactions submitted successfully.\");\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Transaction\n   */\n  async batchTransactionsForSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): Promise<void> {\n    try {\n      const { sender, data, options } = args;\n      this.batch.forSingleAccount({ sender, data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n\n  /**\n   * Sign and submit a single signer transaction to the blockchain.\n   * This function allows you to execute a transaction after signing it with the specified account.\n   *\n   * @param args The arguments for signing and submitting the transaction.\n   * @param args.signer The signer account to sign the transaction.\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const sender = Account.generate(); // Generate a new account for sending the transaction\n   *   const transaction = await aptos.transaction.build.simple({\n   *     sender: sender.accountAddress,\n   *     data: {\n   *       function: \"0x1::aptos_account::transfer\",\n   *       functionArguments: [ \"0x1\", 100 ], // replace with a real account address\n   *     },\n   *   });\n   *\n   *   // Sign and submit the transaction\n   *   const pendingTransaction = await aptos.signAndSubmitTransaction({\n   *     signer: sender,\n   *     transaction,\n   *   });\n   *\n   *   console.log(pendingTransaction);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @return PendingTransactionResponse\n   * @group Transaction\n   */\n  async signAndSubmitTransaction(\n    args: FeePayerOrFeePayerAuthenticatorOrNeither & {\n      signer: Account;\n      transaction: AnyRawTransaction;\n    } & InputTransactionPluginData,\n  ): Promise<PendingTransactionResponse> {\n    return signAndSubmitTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Sign and submit a single signer transaction as the fee payer to chain given an authenticator by the sender of the transaction.\n   *\n   * @param args.feePayer The fee payer account to sign the transaction\n   * @param args.senderAuthenticator The AccountAuthenticator signed by the sender of the transaction\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n   *\n   * @example\n   * const transaction = await aptos.transaction.build.simple({sender: alice.accountAddress, feePayer: true ...})\n   * const senderAuthenticator = alice.signTransactionWithAuthenticator(transaction)\n   * const pendingTransaction = await aptos.signAndSubmitAsFeePayer({\n   *  senderAuthenticator,\n   *  feePayer: bob,\n   *  transaction,\n   * })\n   *\n   * @return PendingTransactionResponse\n   * @group Transaction\n   */\n  async signAndSubmitAsFeePayer(\n    args: {\n      feePayer: Account;\n      senderAuthenticator: AccountAuthenticator;\n      transaction: AnyRawTransaction;\n    } & InputTransactionPluginData,\n  ): Promise<PendingTransactionResponse> {\n    return signAndSubmitAsFeePayer({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/keyless}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * keyless namespace and without having a dependency cycle error.\n * @group Implementation\n */\nimport { jwtDecode, JwtPayload } from \"jwt-decode\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosPepperService, postAptosProvingService } from \"../client\";\nimport {\n  AccountAddressInput,\n  EphemeralSignature,\n  Groth16Zkp,\n  Hex,\n  KeylessPublicKey,\n  MoveJWK,\n  ZeroKnowledgeSig,\n  ZkProof,\n  getKeylessConfig,\n} from \"../core\";\nimport { HexInput, ZkpVariant } from \"../types\";\nimport { Account, EphemeralKeyPair, KeylessAccount, ProofFetchCallback } from \"../account\";\nimport { PepperFetchRequest, PepperFetchResponse, ProverRequest, ProverResponse } from \"../types/keyless\";\nimport { lookupOriginalAccountAddress } from \"./account\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { FederatedKeylessAccount } from \"../account/FederatedKeylessAccount\";\nimport { MoveVector } from \"../bcs\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { InputGenerateTransactionOptions, SimpleTransaction } from \"../transactions\";\nimport { KeylessError, KeylessErrorType } from \"../errors\";\nimport { FIREBASE_AUTH_ISS_PATTERN } from \"../utils/const\";\n\n/**\n * Retrieves a pepper value based on the provided configuration and authentication details.\n *\n * @param args - The arguments required to fetch the pepper.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for the operation.\n * @param args.uidKey - An optional unique identifier key (defaults to \"sub\").\n * @param args.derivationPath - An optional derivation path for the key.\n * @returns A Uint8Array containing the fetched pepper value.\n * @group Implementation\n */\nexport async function getPepper(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  uidKey?: string;\n  derivationPath?: string;\n}): Promise<Uint8Array> {\n  const { aptosConfig, jwt, ephemeralKeyPair, uidKey = \"sub\", derivationPath } = args;\n\n  const body = {\n    jwt_b64: jwt,\n    epk: ephemeralKeyPair.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n    exp_date_secs: ephemeralKeyPair.expiryDateSecs,\n    epk_blinder: Hex.fromHexInput(ephemeralKeyPair.blinder).toStringWithoutPrefix(),\n    uid_key: uidKey,\n    derivation_path: derivationPath,\n  };\n  const { data } = await postAptosPepperService<PepperFetchRequest, PepperFetchResponse>({\n    aptosConfig,\n    path: \"fetch\",\n    body,\n    originMethod: \"getPepper\",\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return Hex.fromHexInput(data.pepper).toUint8Array();\n}\n\n/**\n * Generates a zero-knowledge proof based on the provided parameters.\n * This function is essential for creating a signed proof that can be used in various cryptographic operations.\n *\n * @param args - The parameters required to generate the proof.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for generating the proof.\n * @param args.pepper - An optional hex input used to enhance security (default is generated if not provided).\n * @param args.uidKey - An optional string that specifies the unique identifier key (defaults to \"sub\").\n * @throws Error if the pepper length is not valid or if the ephemeral key pair's lifespan exceeds the maximum allowed.\n * @group Implementation\n */\nexport async function getProof(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  pepper?: HexInput;\n  uidKey?: string;\n  maxExpHorizonSecs?: number;\n}): Promise<ZeroKnowledgeSig> {\n  const {\n    aptosConfig,\n    jwt,\n    ephemeralKeyPair,\n    pepper = await getPepper(args),\n    uidKey = \"sub\",\n    maxExpHorizonSecs = (await getKeylessConfig({ aptosConfig })).maxExpHorizonSecs,\n  } = args;\n  if (Hex.fromHexInput(pepper).toUint8Array().length !== KeylessAccount.PEPPER_LENGTH) {\n    throw new Error(`Pepper needs to be ${KeylessAccount.PEPPER_LENGTH} bytes`);\n  }\n  const decodedJwt = jwtDecode<JwtPayload>(jwt);\n  if (typeof decodedJwt.iat !== \"number\") {\n    throw new Error(\"iat was not found\");\n  }\n  if (maxExpHorizonSecs < ephemeralKeyPair.expiryDateSecs - decodedJwt.iat) {\n    throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${maxExpHorizonSecs}`);\n  }\n  const json = {\n    jwt_b64: jwt,\n    epk: ephemeralKeyPair.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n    epk_blinder: Hex.fromHexInput(ephemeralKeyPair.blinder).toStringWithoutPrefix(),\n    exp_date_secs: ephemeralKeyPair.expiryDateSecs,\n    exp_horizon_secs: maxExpHorizonSecs,\n    pepper: Hex.fromHexInput(pepper).toStringWithoutPrefix(),\n    uid_key: uidKey,\n  };\n\n  const { data } = await postAptosProvingService<ProverRequest, ProverResponse>({\n    aptosConfig,\n    path: \"prove\",\n    body: json,\n    originMethod: \"getProof\",\n    overrides: { WITH_CREDENTIALS: false },\n  });\n\n  const proofPoints = data.proof;\n  const groth16Zkp = new Groth16Zkp({\n    a: proofPoints.a,\n    b: proofPoints.b,\n    c: proofPoints.c,\n  });\n\n  const signedProof = new ZeroKnowledgeSig({\n    proof: new ZkProof(groth16Zkp, ZkpVariant.Groth16),\n    trainingWheelsSignature: EphemeralSignature.fromHex(data.training_wheels_signature),\n    expHorizonSecs: maxExpHorizonSecs,\n  });\n  return signedProof;\n}\n\n/**\n * Derives a keyless account by fetching the necessary proof and looking up the original account address.\n * This function helps in creating a keyless account that can be used without managing private keys directly.\n *\n * @param args - The arguments required to derive the keyless account.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for cryptographic operations.\n * @param args.uidKey - An optional unique identifier key for the user.\n * @param args.pepper - An optional hexadecimal input used for additional security.\n * @param args.proofFetchCallback - An optional callback function to handle the proof fetch outcome.\n * @returns A keyless account object.\n * @group Implementation\n */\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<FederatedKeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress?: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount | FederatedKeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress?: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount | FederatedKeylessAccount> {\n  const { aptosConfig, jwt, jwkAddress, uidKey, proofFetchCallback, pepper = await getPepper(args) } = args;\n  const { verificationKey, maxExpHorizonSecs } = await getKeylessConfig({ aptosConfig });\n\n  const proofPromise = getProof({ ...args, pepper, maxExpHorizonSecs });\n  // If a callback is provided, pass in the proof as a promise to KeylessAccount.create.  This will make the proof be fetched in the\n  // background and the callback will handle the outcome of the fetch.  This allows the developer to not have to block on the proof fetch\n  // allowing for faster rendering of UX.\n  //\n  // If no callback is provided, the just await the proof fetch and continue synchronously.\n  const proof = proofFetchCallback ? proofPromise : await proofPromise;\n\n  // Look up the original address to handle key rotations and then instantiate the account.\n  if (jwkAddress !== undefined) {\n    const publicKey = FederatedKeylessPublicKey.fromJwtAndPepper({ jwt, pepper, jwkAddress, uidKey });\n    const address = await lookupOriginalAccountAddress({\n      aptosConfig,\n      authenticationKey: publicKey.authKey().derivedAddress(),\n    });\n\n    return FederatedKeylessAccount.create({\n      ...args,\n      address,\n      proof,\n      pepper,\n      proofFetchCallback,\n      jwkAddress,\n      verificationKey,\n    });\n  }\n\n  const publicKey = KeylessPublicKey.fromJwtAndPepper({ jwt, pepper, uidKey });\n  const address = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: publicKey.authKey().derivedAddress(),\n  });\n  return KeylessAccount.create({ ...args, address, proof, pepper, proofFetchCallback, verificationKey });\n}\n\nexport interface JWKS {\n  keys: MoveJWK[];\n}\n\nexport async function updateFederatedKeylessJwkSetTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  iss: string;\n  jwksUrl?: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, iss, options } = args;\n\n  let { jwksUrl } = args;\n\n  if (jwksUrl === undefined) {\n    if (FIREBASE_AUTH_ISS_PATTERN.test(iss)) {\n      jwksUrl = \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\";\n    } else {\n      jwksUrl = iss.endsWith(\"/\") ? `${iss}.well-known/jwks.json` : `${iss}/.well-known/jwks.json`;\n    }\n  }\n\n  let response: Response;\n\n  try {\n    response = await fetch(jwksUrl);\n    if (!response.ok) {\n      throw new Error(`${response.status} ${response.statusText}`);\n    }\n  } catch (error) {\n    let errorMessage: string;\n    if (error instanceof Error) {\n      errorMessage = `${error.message}`;\n    } else {\n      errorMessage = `error unknown - ${error}`;\n    }\n    throw KeylessError.fromErrorType({\n      type: KeylessErrorType.JWK_FETCH_FAILED_FEDERATED,\n      details: `Failed to fetch JWKS at ${jwksUrl}: ${errorMessage}`,\n    });\n  }\n\n  const jwks: JWKS = await response.json();\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::jwks::update_federated_jwk_set\",\n      functionArguments: [\n        iss,\n        MoveVector.MoveString(jwks.keys.map((key) => key.kid)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.alg)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.e)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.n)),\n      ],\n    },\n    options,\n  });\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account, EphemeralKeyPair, KeylessAccount, ProofFetchCallback } from \"../account\";\nimport { FederatedKeylessAccount } from \"../account/FederatedKeylessAccount\";\nimport { AccountAddressInput, ZeroKnowledgeSig } from \"../core\";\nimport {\n  deriveKeylessAccount,\n  getPepper,\n  getProof,\n  updateFederatedKeylessJwkSetTransaction,\n} from \"../internal/keyless\";\nimport { InputGenerateTransactionOptions, SimpleTransaction } from \"../transactions\";\nimport { HexInput } from \"../types\";\nimport { AptosConfig } from \"./aptosConfig\";\n\n/**\n * A class to query all `Keyless` related queries on Aptos.\n *\n * More documentation on how to integrate Keyless Accounts see the below\n * [Aptos Keyless Integration Guide](https://aptos.dev/guides/keyless-accounts/#aptos-keyless-integration-guide).\n * @group Keyless\n */\nexport class Keyless {\n  /**\n   * Initializes a new instance of the Aptos class with the provided configuration.\n   * This allows you to interact with the Aptos blockchain using the specified network settings.\n   *\n   * @param config - The configuration settings for connecting to the Aptos network.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new configuration for the Aptos client\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your desired network\n   *\n   *     // Initialize the Aptos client with the configuration\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Fetches the pepper from the Aptos pepper service API.\n   *\n   * @param args - The arguments for fetching the pepper.\n   * @param args.jwt - JWT token.\n   * @param args.ephemeralKeyPair - The EphemeralKeyPair used to generate the nonce in the JWT token.\n   * @param args.derivationPath - A derivation path used for creating multiple accounts per user via the BIP-44 standard. Defaults\n   * to \"m/44'/637'/0'/0'/0\".\n   * @returns The pepper which is a Uint8Array of length 31.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const ephemeralKeyPair = new EphemeralKeyPair(); // create a new ephemeral key pair\n   *   const jwt = \"your_jwt_token\"; // replace with a real JWT token\n   *\n   *   // Fetching the pepper using the provided JWT and ephemeral key pair\n   *   const pepper = await aptos.getPepper({\n   *     jwt,\n   *     ephemeralKeyPair,\n   *     // derivationPath: \"m/44'/637'/0'/0'/0\" // specify your own if needed\n   *   });\n   *\n   *   console.log(\"Fetched pepper:\", pepper);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  async getPepper(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    derivationPath?: string;\n  }): Promise<Uint8Array> {\n    return getPepper({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Fetches a proof from the Aptos prover service API.\n   *\n   * @param args - The arguments for fetching the proof.\n   * @param args.jwt - JWT token.\n   * @param args.ephemeralKeyPair - The EphemeralKeyPair used to generate the nonce in the JWT token.\n   * @param args.pepper - The pepper used for the account. If not provided, it will be fetched from the Aptos pepper service.\n   * @param args.uidKey - A key in the JWT token to use to set the uidVal in the IdCommitment.\n   *\n   * @returns The proof which is represented by a ZeroKnowledgeSig.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, EphemeralKeyPair, getPepper } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const jwt = \"your_jwt_token\"; // replace with a real JWT token\n   *   const ephemeralKeyPair = new EphemeralKeyPair(); // create a new ephemeral key pair\n   *\n   *   // Fetch the proof using the getProof function\n   *   const proof = await aptos.getProof({\n   *     jwt,\n   *     ephemeralKeyPair,\n   *     pepper: await getPepper({}), // fetch the pepper if not provided\n   *     uidKey: \"sub\", // specify the uid key\n   *   });\n   *\n   *   console.log(\"Fetched proof:\", proof);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  async getProof(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper?: HexInput;\n    uidKey?: string;\n  }): Promise<ZeroKnowledgeSig> {\n    return getProof({ aptosConfig: this.config, ...args });\n  }\n\n  async deriveKeylessAccount(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    uidKey?: string;\n    pepper?: HexInput;\n    proofFetchCallback?: ProofFetchCallback;\n  }): Promise<KeylessAccount>;\n\n  async deriveKeylessAccount(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n    pepper?: HexInput;\n    proofFetchCallback?: ProofFetchCallback;\n  }): Promise<FederatedKeylessAccount>;\n\n  /**\n   * Derives a Keyless Account from the provided JWT token and corresponding EphemeralKeyPair. This function computes the proof\n   * via the proving service and can fetch the pepper from the pepper service if not explicitly provided.\n   *\n   * @param args - The arguments required to derive the Keyless Account.\n   * @param args.jwt - The JWT token used for deriving the account.\n   * @param args.ephemeralKeyPair - The EphemeralKeyPair used to generate the nonce in the JWT token.\n   * @param args.jwkAddress - The address the where the JWKs used to verify signatures are found.  Setting the value derives a\n   * FederatedKeylessAccount.\n   * @param args.uidKey - An optional key in the JWT token to set the uidVal in the IdCommitment.\n   * @param args.pepper - An optional pepper value.\n   * @param args.proofFetchCallback - An optional callback function for fetching the proof in the background, allowing for a more\n   * responsive user experience.\n   *\n   * @returns A KeylessAccount that can be used to sign transactions.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network, deriveKeylessAccount } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   const jwt = \"your_jwt_token\"; // replace with a real JWT token\n   *   const ephemeralKeyPair = new EphemeralKeyPair(); // create a new ephemeral key pair\n   *\n   *   // Deriving the Keyless Account\n   *   const keylessAccount = await deriveKeylessAccount({\n   *     jwt,\n   *     ephemeralKeyPair,\n   *     uidKey: \"your_uid_key\", // optional\n   *     pepper: \"your_pepper\", // optional\n   *   });\n   *\n   *   console.log(\"Keyless Account derived:\", keylessAccount);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Keyless\n   */\n  async deriveKeylessAccount(args: {\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    jwkAddress?: AccountAddressInput;\n    uidKey?: string;\n    pepper?: HexInput;\n    proofFetchCallback?: ProofFetchCallback;\n  }): Promise<KeylessAccount | FederatedKeylessAccount> {\n    return deriveKeylessAccount({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * This installs a set of FederatedJWKs at an address for a given iss.\n   *\n   * It will fetch the JSON Web Keyset (JWK) set from the well-known endpoint and update the FederatedJWKs at the sender's address\n   * to reflect it.\n   *\n   * @param args.sender The account that will install the JWKs\n   * @param args.iss the iss claim of the federated OIDC provider.\n   * @param args.jwksUrl the URL to find the corresponding JWKs. For supported IDP providers this parameter in not necessary.\n   *\n   * @returns The pending transaction that results from submission.\n   * @group Keyless\n   */\n  async updateFederatedKeylessJwkSetTransaction(args: {\n    sender: Account;\n    iss: string;\n    jwksUrl?: string;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return updateFederatedKeylessJwkSetTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n", "import { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddressInput, AccountAddress } from \"../core\";\nimport { PaginationArgs, OrderByArg, GetObjectDataQueryResponse, WhereArg } from \"../types\";\nimport { GetObjectDataQuery } from \"../types/generated/operations\";\nimport { GetObjectData } from \"../types/generated/queries\";\nimport { CurrentObjectsBoolExp } from \"../types/generated/types\";\nimport { queryIndexer } from \"./general\";\n\n/**\n * Retrieves the current objects based on specified filtering and pagination options.\n *\n * @param args - The arguments for retrieving object data.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param [args.options] - Optional parameters for pagination and filtering.\n * @param [args.options.offset] - The number of items to skip before starting to collect the result set.\n * @param [args.options.limit] - The maximum number of items to return.\n * @param [args.options.orderBy] - The criteria for ordering the results.\n * @param [args.options.where] - The conditions to filter the results.\n * @returns The current objects that match the specified criteria.\n * @group Implementation\n */\nexport async function getObjectData(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]> & WhereArg<CurrentObjectsBoolExp>;\n}): Promise<GetObjectDataQueryResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetObjectData,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetObjectDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getObjectData\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * Retrieves the object data associated with a specific object address.\n * This function allows you to access detailed information about an object in the Aptos blockchain.\n *\n * @param args - The arguments for retrieving object data.\n * @param args.aptosConfig - The configuration for connecting to the Aptos blockchain.\n * @param args.objectAddress - The address of the object whose data is being retrieved.\n * @param args.options - Optional parameters for pagination and ordering of the results.\n * @group Implementation\n */\nexport async function getObjectDataByObjectAddress(args: {\n  aptosConfig: AptosConfig;\n  objectAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n}): Promise<GetObjectDataQueryResponse[0]> {\n  const { aptosConfig, objectAddress, options } = args;\n  const address = AccountAddress.from(objectAddress).toStringLong();\n\n  const whereCondition: { object_address: { _eq: string } } = {\n    object_address: { _eq: address },\n  };\n  return (await getObjectData({ aptosConfig, options: { ...options, where: whereCondition } }))[0];\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AnyNumber, GetObjectDataQueryResponse, OrderByArg, PaginationArgs } from \"../types\";\nimport { AccountAddressInput } from \"../core\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { ProcessorType } from \"../utils\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { getObjectDataByObjectAddress } from \"../internal/object\";\n\n/**\n * A class to query all `Object` related queries on Aptos.\n * @group Object\n */\nexport class AptosObject {\n  /**\n   * Creates an instance of the Aptos client with the provided configuration.\n   * This allows interaction with the Aptos blockchain using the specified settings.\n   *\n   * @param config - The configuration settings for the Aptos client.\n   * @param config.network - The network to connect to (e.g., mainnet, testnet).\n   * @param config.nodeUrl - The URL of the Aptos node to connect to.\n   * @param config.faucetUrl - The URL of the faucet for funding accounts (optional).\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a configuration for the Aptos client\n   *     const config = new AptosConfig({\n   *         network: Network.TESTNET, // Specify the desired network\n   *         nodeUrl: \"https://testnet.aptos.dev\", // Replace with your node URL\n   *     });\n   *\n   *     // Create an instance of the Aptos client\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client created successfully\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Object\n   */\n  constructor(readonly config: AptosConfig) {}\n\n  /**\n   * Fetches the object data based on the specified object address.\n   *\n   * @param args.objectAddress - The object address to retrieve data for.\n   * @param args.minimumLedgerVersion - Optional minimum ledger version to wait for.\n   * @param args.options - Optional configuration options for pagination and ordering.\n   *\n   * @returns The object data corresponding to the provided address.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * const config = new AptosConfig({ network: Network.TESTNET });\n   * const aptos = new Aptos(config);\n   *\n   * async function runExample() {\n   *   // Fetching object data by object address\n   *   const objectData = await aptos.getObjectDataByObjectAddress({\n   *     objectAddress: \"0x1\", // replace with a real object address\n   *   });\n   *\n   *   console.log(objectData);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Object\n   */\n  async getObjectDataByObjectAddress(args: {\n    objectAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetObjectDataQueryResponse[0]>;\n  }): Promise<GetObjectDataQueryResponse[0]> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.OBJECT_PROCESSOR,\n    });\n    return getObjectDataByObjectAddress({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"./account\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { Coin } from \"./coin\";\nimport { DigitalAsset } from \"./digitalAsset\";\nimport { Event } from \"./event\";\nimport { Faucet } from \"./faucet\";\nimport { FungibleAsset } from \"./fungibleAsset\";\nimport { General } from \"./general\";\nimport { ANS } from \"./ans\";\nimport { Staking } from \"./staking\";\nimport { Transaction } from \"./transaction\";\nimport { Table } from \"./table\";\nimport { Keyless } from \"./keyless\";\nimport { AptosObject } from \"./object\";\nimport { AccountAbstraction } from \"./account/abstraction\";\n\n/**\n * The main entry point for interacting with the Aptos APIs,\n * providing access to various functionalities organized into\n * distinct namespaces.\n *\n * To utilize the SDK, instantiate a new Aptos object to gain\n * access to the complete range of SDK features.\n *\n * @example\n * ```typescript\n * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n *\n * async function runExample() {\n *     // Create a configuration for connecting to the Aptos testnet\n *     const config = new AptosConfig({ network: Network.TESTNET });\n *\n *     // Initialize the Aptos client with the configuration\n *     const aptos = new Aptos(config);\n *\n *     console.log(\"Aptos client initialized:\", aptos);\n * }\n * runExample().catch(console.error);\n * ```\n * @group Client\n */\nexport class Aptos {\n  readonly config: AptosConfig;\n\n  readonly account: Account;\n\n  readonly ans: ANS;\n\n  readonly coin: Coin;\n\n  readonly digitalAsset: DigitalAsset;\n\n  readonly event: Event;\n\n  readonly faucet: Faucet;\n\n  readonly fungibleAsset: FungibleAsset;\n\n  readonly general: General;\n\n  readonly staking: Staking;\n\n  readonly transaction: Transaction;\n\n  readonly table: Table;\n\n  readonly keyless: Keyless;\n\n  readonly object: AptosObject;\n\n  /**\n   * Initializes a new instance of the Aptos client with the provided configuration settings.\n   * This allows you to interact with various Aptos functionalities such as accounts, transactions, and events.\n   *\n   * @param settings - Configuration settings for the Aptos client.\n   *\n   * @example\n   * ```typescript\n   * import { Aptos, AptosConfig, Network } from \"@aptos-labs/ts-sdk\";\n   *\n   * async function runExample() {\n   *     // Create a new Aptos client with default settings\n   *     const config = new AptosConfig({ network: Network.TESTNET }); // Specify your own settings if needed\n   *     const aptos = new Aptos(config);\n   *\n   *     console.log(\"Aptos client initialized:\", aptos);\n   * }\n   * runExample().catch(console.error);\n   * ```\n   * @group Client\n   */\n  constructor(config?: AptosConfig) {\n    this.config = config ?? new AptosConfig();\n    this.account = new Account(this.config);\n    this.abstraction = new AccountAbstraction(this.config);\n    this.ans = new ANS(this.config);\n    this.coin = new Coin(this.config);\n    this.digitalAsset = new DigitalAsset(this.config);\n    this.event = new Event(this.config);\n    this.faucet = new Faucet(this.config);\n    this.fungibleAsset = new FungibleAsset(this.config);\n    this.general = new General(this.config);\n    this.staking = new Staking(this.config);\n    this.transaction = new Transaction(this.config);\n    this.table = new Table(this.config);\n    this.keyless = new Keyless(this.config);\n    this.object = new AptosObject(this.config);\n  }\n\n  setIgnoreTransactionSubmitter(ignore: boolean) {\n    this.config.setIgnoreTransactionSubmitter(ignore);\n  }\n}\n\n// extends Aptos interface so all the methods and properties\n// from the other classes will be recognized by typescript.\nexport interface Aptos\n  extends Account,\n    ANS,\n    Coin,\n    DigitalAsset,\n    Event,\n    Faucet,\n    FungibleAsset,\n    General,\n    Keyless,\n    Staking,\n    Table,\n    AptosObject,\n    Omit<Transaction, \"build\" | \"simulate\" | \"submit\" | \"batch\"> {}\n\n/**\nIn TypeScript, we can’t inherit or extend from more than one class,\nMixins helps us to get around that by creating a partial classes\nthat we can combine to form a single class that contains all the methods and properties from the partial classes.\n{@link https://www.typescriptlang.org/docs/handbook/mixins.html#alternative-pattern}\n\nHere, we combine any subclass and the Aptos class.\n * @group Client\n*/\nfunction applyMixin(targetClass: any, baseClass: any, baseClassProp: string) {\n  // Mixin instance methods\n  Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);\n    if (!propertyDescriptor) return;\n    // eslint-disable-next-line func-names\n    propertyDescriptor.value = function (...args: any) {\n      return (this as any)[baseClassProp][propertyName](...args);\n    };\n    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);\n  });\n}\n\napplyMixin(Aptos, Account, \"account\");\napplyMixin(Aptos, AccountAbstraction, \"abstraction\");\napplyMixin(Aptos, ANS, \"ans\");\napplyMixin(Aptos, Coin, \"coin\");\napplyMixin(Aptos, DigitalAsset, \"digitalAsset\");\napplyMixin(Aptos, Event, \"event\");\napplyMixin(Aptos, Faucet, \"faucet\");\napplyMixin(Aptos, FungibleAsset, \"fungibleAsset\");\napplyMixin(Aptos, General, \"general\");\napplyMixin(Aptos, Staking, \"staking\");\napplyMixin(Aptos, Transaction, \"transaction\");\napplyMixin(Aptos, Table, \"table\");\napplyMixin(Aptos, Keyless, \"keyless\");\napplyMixin(Aptos, AptosObject, \"object\");\n", "/**\n * The variant for the AbstractionAuthData enum.\n */\nexport enum AbstractionAuthDataVariant {\n  V1 = 0,\n  DerivableV1 = 1,\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  Wallet,\n  WalletWithFeatures,\n  WalletsEventsListeners,\n  getWallets\n} from '@wallet-standard/core'\n\nimport { MinimallyRequiredFeatures } from './features'\nimport { AptosWallet } from './wallet'\n\n// These features are absolutely required for wallets to function in the Aptos ecosystem.\n// Eventually, as wallets have more consistent support of features, we may want to extend this list.\nconst REQUIRED_FEATURES: (keyof MinimallyRequiredFeatures)[] = [\n  'aptos:account',\n  'aptos:connect',\n  'aptos:disconnect',\n  'aptos:network',\n  'aptos:onAccountChange',\n  'aptos:onNetworkChange',\n  'aptos:signMessage',\n  'aptos:signTransaction'\n]\n\nexport function isWalletWithRequiredFeatureSet<AdditionalFeatures extends Wallet['features']>(\n  wallet: Wallet,\n  additionalFeatures: (keyof AdditionalFeatures)[] = []\n): wallet is WalletWithFeatures<MinimallyRequiredFeatures & AdditionalFeatures> {\n  return [...REQUIRED_FEATURES, ...additionalFeatures].every(\n    (feature) => feature in wallet.features\n  )\n}\n\n/**\n * Helper function to get only Aptos wallets\n * @returns Aptos compatible wallets and `on` event to listen to wallets register event\n */\nexport function getAptosWallets(): {\n  aptosWallets: AptosWallet[]\n  on: <E extends keyof WalletsEventsListeners>(\n    event: E,\n    listener: WalletsEventsListeners[E]\n  ) => () => void\n} {\n  const { get, on } = getWallets()\n\n  const wallets = get()\n\n  const aptosWallets: Wallet[] = []\n\n  wallets.map((wallet: Wallet) => {\n    const isAptos = isWalletWithRequiredFeatureSet(wallet)\n\n    if (isAptos) {\n      aptosWallets.push(wallet)\n    }\n  })\n\n  return { aptosWallets: aptosWallets as AptosWallet[], on }\n}\n", "export enum AptosWalletErrorCode {\n  Unauthorized = 4100,\n  Unsupported = 4200,\n  InternalError = -30001\n}\n\nexport const AptosWalletErrors = Object.freeze({\n  [AptosWalletErrorCode.Unauthorized]: {\n    status: 'Unauthorized',\n    message: 'The requested method and/or account has not been authorized by the user.'\n  },\n  [AptosWalletErrorCode.InternalError]: {\n    status: 'Internal error',\n    message: 'Something went wrong within the wallet.'\n  },\n  [AptosWalletErrorCode.Unsupported]: {\n    status: 'Unsupported',\n    message: 'The requested feature is not supported.'\n  }\n})\n\nexport class AptosWalletError extends Error {\n  readonly code: number\n  readonly status: string\n\n  constructor(code: number, message?: string) {\n    super(\n      message ??\n        AptosWalletErrors[code as keyof typeof AptosWalletErrors]?.message ??\n        'Unknown error occurred'\n    )\n    this.code = code\n    this.status =\n      AptosWalletErrors[code as keyof typeof AptosWalletErrors]?.status ?? 'Unknown error'\n    this.name = 'AptosWalletError'\n    Object.setPrototypeOf(this, AptosWalletError.prototype)\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Network } from '@aptos-labs/ts-sdk'\n\nexport type TransactionHash = `0x${string}`\n\nexport interface NetworkInfo {\n  name: Network // Name of the network.\n  chainId: number // Chain ID of the network.\n  url?: string // RPC URL of the network.\n}\n\nexport enum UserResponseStatus {\n  APPROVED = 'Approved',\n  REJECTED = 'Rejected'\n}\n\nexport interface UserApproval<TResponseArgs> {\n  status: UserResponseStatus.APPROVED\n  args: TResponseArgs\n}\n\nexport interface UserRejection {\n  status: UserResponseStatus.REJECTED\n}\n\nexport type UserResponse<TResponseArgs> = UserApproval<TResponseArgs> | UserRejection\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { InputGenerateTransactionPayloadData } from '@aptos-labs/ts-sdk'\nimport { UserResponse } from '../misc'\n\n/** Version of the feature. */\nexport type AptosSignAndSubmitTransactionVersion = '1.1.0'\n/** Name of the feature. */\nexport const AptosSignAndSubmitTransactionNamespace = 'aptos:signAndSubmitTransaction'\n/**\n * A Wallet Standard feature for signing a transaction, and returning the\n * hash of the transaction.\n */\nexport type AptosSignAndSubmitTransactionFeature = {\n  /** Namespace for the feature. */\n  [AptosSignAndSubmitTransactionNamespace]: {\n    /** Version of the feature API. */\n    version: AptosSignAndSubmitTransactionVersion\n    signAndSubmitTransaction: AptosSignAndSubmitTransactionMethod\n  }\n}\n\nexport type AptosSignAndSubmitTransactionMethod = (\n  transaction: AptosSignAndSubmitTransactionInput\n) => Promise<UserResponse<AptosSignAndSubmitTransactionOutput>>\n\nexport interface AptosSignAndSubmitTransactionInput {\n  gasUnitPrice?: number;  // defaults to estimated gas unit price\n  maxGasAmount?: number;  // defaults to estimated max gas amount\n  payload: InputGenerateTransactionPayloadData;\n}\n\nexport interface AptosSignAndSubmitTransactionOutput {\n  hash: string;\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Signature } from '@aptos-labs/ts-sdk'\nimport { UserResponse } from '../misc'\nimport { AccountInfo } from '../AccountInfo'\n\n/**\n * AIP: [Sign in with Aptos](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-116.md)\n */\n\n/** Version of the feature. */\nexport type AptosSignInVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosSignInNamespace = 'aptos:signIn'\n\nexport type AptosSignInFeature = {\n  /** Namespace for the feature. */\n  [AptosSignInNamespace]: {\n    /** Version of the feature API. */\n    version: AptosSignInVersion\n    signIn: AptosSignInMethod\n  }\n}\n\nexport type AptosSignInMethod = (\n  input: AptosSignInInput\n) => Promise<UserResponse<AptosSignInOutput>>\n\n/**\n * Input fields to the `signIn` signing request to the wallet.\n */\nexport type AptosSignInInput = {\n  /**\n   * [`dnsauthority`](https://www.rfc-editor.org/rfc/rfc4501.html) that is requesting the signing.\n   *\n   * @example 'example.com'\n   */\n  domain: string\n  /**\n   * Randomized token to prevent signature replay attacks.\n   */\n  nonce: string\n  /**\n   * Blockchain address performing the signing.\n   *\n   * @example '0x10d7cf502f8571b5b6e402221cafb142547103da9c2847ffcf708f065a78b8d1'\n   */\n  address?: string\n  /**\n   * [URI](https://www.rfc-editor.org/rfc/rfc3986) referring to the resource that is the subject of the signing i.e. the subject of the claim.\n   *\n   * @example 'https://example.com'\n   */\n  uri?: string\n  /**\n   * Current version of the message.\n   *\n   * @example '1'\n   */\n  version?: string\n  /**\n   * Human-readable ASCII assertion that the user will sign. It MUST NOT contain `\\n`.\n   */\n  statement?: string\n  /**\n   * Identifier for the network where the address above lives (e.g., for Aptos mainnet, the identifier would be `aptos:mainnet`)\n   *\n   * @example 'aptos:mainnet'\n   */\n  chainId?: string\n  /**\n   * ISO 8601 [`date-time`](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) that indicates the issuance time of the message.\n   *\n   * @example '2025-05-23T12:00:00Z'\n   */\n  issuedAt?: string\n  /**\n   * ISO 8601 [`date-time`](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) that indicates when the signed authentication message is no longer valid.\n   *\n   * @example '2025-05-23T12:00:00Z'\n   */\n  expirationTime?: string\n  /**\n   * ISO 8601 [`date-time`](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) that indicates when the signed authentication message starts being valid.\n   *\n   * @example '2025-05-23T12:00:00Z'\n   */\n  notBefore?: string\n  /**\n   * System-specific identifier used to uniquely refer to the authentication request.\n   */\n  requestId?: string\n  /**\n   * List of information or references to information the user wishes to have resolved as part of the authentication by the relying party.\n   *\n   * @example ['https://example.com/resource']\n   */\n  resources?: string[]\n}\n\n/**\n * Fields that are bound by the wallet if not provided in the `AptosSignInInput`.\n */\nexport type AptosSignInBoundFields = {\n  /**\n   * @see AptosSignInInput.domain\n   */\n  domain: string\n  /**\n   * @see AptosSignInInput.address\n   */\n  address: string\n  /**\n   * @see AptosSignInInput.uri\n   */\n  uri: string\n  /**\n   * @see AptosSignInInput.version\n   */\n  version: string\n  /**\n   * @see AptosSignInInput.chainId\n   */\n  chainId: string\n}\n\n/**\n * Output fields from the `signIn` signing request to the wallet.\n */\nexport type AptosSignInOutput = {\n  /**\n   * Account information of the user.\n   */\n  account: AccountInfo\n  /**\n   * Input fields to the `signIn` signing request to the wallet. The wallet will ensure that any bound fields not included in the `AptosSignInInput` are included in the output.\n   */\n  input: AptosSignInInput & AptosSignInBoundFields\n  /**\n   * Signature of the SIWA Signing Message constructed from the `input` fields.\n   */\n  signature: Signature\n  /**\n   * The type of signing scheme used to sign the message.\n   *\n   * @example 'ed25519' | 'multi_ed25519' | 'single_key' | 'multi_key'\n   */\n  type: string\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Signature } from '@aptos-labs/ts-sdk'\nimport { UserResponse } from '../misc'\n\n/** Version of the feature. */\nexport type AptosSignMessageVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosSignMessageNamespace = 'aptos:signMessage'\n\nexport type AptosSignMessageFeature = {\n  /** Namespace for the feature. */\n  [AptosSignMessageNamespace]: {\n    /** Version of the feature API. */\n    version: AptosSignMessageVersion\n    signMessage: AptosSignMessageMethod\n  }\n}\n\nexport type AptosSignMessageMethod = (\n  input: AptosSignMessageInput\n) => Promise<UserResponse<AptosSignMessageOutput>>\n\nexport type AptosSignMessageInput = {\n  address?: boolean\n  application?: boolean\n  chainId?: boolean\n  message: string\n  nonce: string\n}\n\nexport type AptosSignMessageOutput = {\n  address?: string\n  application?: string\n  chainId?: number\n  fullMessage: string\n  message: string\n  nonce: string\n  prefix: 'APTOS'\n  signature: Signature\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionPayloadData,\n  Network,\n  PublicKey,\n  TransactionPayload\n} from '@aptos-labs/ts-sdk'\nimport { UserResponse } from '../misc'\n\n// region Feature definition\n\n/** Name of the feature. */\nexport const AptosSignTransactionNamespace = 'aptos:signTransaction'\n\nexport type AptosSignTransactionFeatureV1_0 = {\n  [AptosSignTransactionNamespace]: {\n    version: '1.0.0',\n    signTransaction: AptosSignTransactionMethod\n  }\n}\n\nexport type AptosSignTransactionFeatureV1_1 = {\n  [AptosSignTransactionNamespace]: {\n    version: '1.1'\n    signTransaction: AptosSignTransactionMethod & AptosSignTransactionMethodV1_1\n  }\n}\n\n/**\n * A Wallet Standard feature for signing an Aptos transaction, and returning the\n * account authenticator.\n */\nexport type AptosSignTransactionFeature =\n  AptosSignTransactionFeatureV1_0 | AptosSignTransactionFeatureV1_1;\n\n// endregion\n\n// region V1.0\n\nexport type AptosSignTransactionOutput = AccountAuthenticator;\n\nexport type AptosSignTransactionMethod = (\n  transaction: AnyRawTransaction,\n  asFeePayer?: boolean\n) => Promise<UserResponse<AptosSignTransactionOutput>>\n\n// endregion\n\n// region V1.1\n\nexport interface AccountInput {\n  address: AccountAddress;\n  publicKey?: PublicKey;\n}\n\nexport interface AptosSignTransactionInputV1_1 {\n  expirationSecondsFromNow?: number; // defaults to 30 seconds (depends on wallet)\n  expirationTimestamp?: number;\n  feePayer?: AccountInput; // defaults to no fee payer\n  gasUnitPrice?: number; // defaults to estimated gas unit price\n  maxGasAmount?: number; // defaults to simulation result with fuzz factor\n  network?: Network; // defaults to active network\n  payload: TransactionPayload | InputGenerateTransactionPayloadData;\n  secondarySigners?: AccountInput[]; // defaults to no secondary signers\n  sender?: AccountInput; // defaulting to active account (if applicable)\n  sequenceNumber?: number | bigint; // defaulting to sender's sequence number\n  signerAddress?: AccountAddress;\n}\n\nexport interface AptosSignTransactionOutputV1_1 {\n  authenticator: AccountAuthenticator;\n  rawTransaction: AnyRawTransaction;\n}\n\nexport type AptosSignTransactionMethodV1_1 = (\n  input: AptosSignTransactionInputV1_1\n) => Promise<UserResponse<AptosSignTransactionOutputV1_1>>;\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountInfo } from '../AccountInfo'\nimport { NetworkInfo, UserResponse } from '../misc'\n\n/** Version of the feature. */\nexport type AptosConnectVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosConnectNamespace = 'aptos:connect'\n\nexport type AptosConnectFeature = {\n  /** Namespace for the feature. */\n  [AptosConnectNamespace]: {\n    /** Version of the feature API. */\n    version: AptosConnectVersion\n    connect: AptosConnectMethod\n  }\n}\n\nexport type AptosConnectMethod = (\n  ...args: AptosConnectInput\n) => Promise<UserResponse<AptosConnectOutput>>\n\nexport type AptosConnectInput = [silent?: boolean, networkInfo?: NetworkInfo]\n\nexport type AptosConnectOutput = AccountInfo\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/** Version of the feature. */\nexport type AptosDisconnectVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosDisconnectNamespace = 'aptos:disconnect'\n\nexport type AptosDisconnectFeature = {\n  /** Namespace for the feature. */\n  [AptosDisconnectNamespace]: {\n    /** Version of the feature API. */\n    version: AptosDisconnectVersion\n    disconnect: AptosDisconnectMethod\n  }\n}\n\nexport type AptosDisconnectMethod = () => Promise<void>\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountInfo } from '../AccountInfo'\n\n/** Version of the feature. */\nexport type AptosGetAccountVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosGetAccountNamespace = 'aptos:account'\n\nexport type AptosGetAccountFeature = {\n  /** Namespace for the feature. */\n  [AptosGetAccountNamespace]: {\n    /** Version of the feature API. */\n    version: AptosGetAccountVersion\n    account: AptosGetAccountMethod\n  }\n}\n\nexport type AptosGetAccountMethod = () => Promise<AptoGetsAccountOutput>\n\nexport type AptoGetsAccountOutput = AccountInfo\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { NetworkInfo } from '../misc'\n\n/** Version of the feature. */\nexport type AptosGetNetworkVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosGetNetworkNamespace = 'aptos:network'\n\nexport type AptosGetNetworkFeature = {\n  /** Namespace for the feature. */\n  [AptosGetNetworkNamespace]: {\n    /** Version of the feature API. */\n    version: AptosGetNetworkVersion\n    network: AptosGetNetworkMethod\n  }\n}\n\nexport type AptosGetNetworkMethod = () => Promise<AptosGetNetworkOutput>\n\nexport type AptosGetNetworkOutput = NetworkInfo\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountInfo } from '../AccountInfo'\n\n/** Version of the feature. */\nexport type AptosOnAccountChangeVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosOnAccountChangeNamespace = 'aptos:onAccountChange'\n\nexport type AptosOnAccountChangeFeature = {\n  /** Namespace for the feature. */\n  [AptosOnAccountChangeNamespace]: {\n    /** Version of the feature API. */\n    version: AptosOnAccountChangeVersion\n    onAccountChange: AptosOnAccountChangeMethod\n  }\n}\n\nexport type AptosOnAccountChangeMethod = (input: AptosOnAccountChangeInput) => Promise<void>\n\nexport type AptosOnAccountChangeInput = (newAccount: AccountInfo) => void\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { NetworkInfo } from '../misc'\n\n/** Version of the feature. */\nexport type AptosOnNetworkChangeVersion = '1.0.0'\n/** Name of the feature. */\nexport const AptosOnNetworkChangeNamespace = 'aptos:onNetworkChange'\n\nexport type AptosOnNetworkChangeFeature = {\n  /** Namespace for the feature. */\n  [AptosOnNetworkChangeNamespace]: {\n    /** Version of the feature API. */\n    version: AptosOnNetworkChangeVersion\n    onNetworkChange: AptosOnNetworkChangeMethod\n  }\n}\n\nexport type AptosOnNetworkChangeMethod = (input: AptosOnNetworkChangeInput) => Promise<void>\n\nexport type AptosOnNetworkChangeInput = (newNetwork: NetworkInfo) => void\n", "import {\n  AccountAddress, AccountAddressInput, AnyPublicKey,\n  Deserializer,\n  Ed25519PublicKey,\n  MultiEd25519PublicKey, MultiKey,\n  PublicKey,\n  Serializable,\n  Serializer, SigningScheme\n} from '@aptos-labs/ts-sdk'\n\nexport interface AccountInfoInput {\n  address: AccountAddressInput\n  publicKey: PublicKey\n  ansName?: string\n}\n\nexport class AccountInfo extends Serializable {\n  readonly address: AccountAddress\n  readonly publicKey: PublicKey\n  readonly ansName?: string\n\n  constructor({ address, publicKey, ansName }: AccountInfoInput) {\n    super()\n    this.address = AccountAddress.from(address)\n    this.publicKey = publicKey\n    this.ansName = ansName\n  }\n\n  serialize(serializer: Serializer) {\n    this.address.serialize(serializer)\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.Ed25519)\n    } else if (this.publicKey instanceof MultiEd25519PublicKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.MultiEd25519)\n    } else if (this.publicKey instanceof AnyPublicKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.SingleKey)\n    } else if (this.publicKey instanceof MultiKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.MultiKey)\n    } else {\n      throw new Error('Unsupported public key')\n    }\n    this.publicKey.serialize(serializer)\n    serializer.serializeStr(this.ansName ?? '')\n  }\n\n  static deserialize(deserializer: Deserializer) {\n    const address = AccountAddress.deserialize(deserializer)\n    const variant = deserializer.deserializeUleb128AsU32()\n    let publicKey: PublicKey\n    switch (variant) {\n      case SigningScheme.Ed25519:\n        publicKey = Ed25519PublicKey.deserialize(deserializer)\n        break\n      case SigningScheme.MultiEd25519:\n        publicKey = MultiEd25519PublicKey.deserialize(deserializer)\n        break\n      case SigningScheme.SingleKey:\n        publicKey = AnyPublicKey.deserialize(deserializer)\n        break\n      case SigningScheme.MultiKey:\n        publicKey = MultiKey.deserialize(deserializer)\n        break\n      default:\n        throw new Error(`Unknown variant index for WrappedPublicKey: ${variant}`)\n    }\n    const ansName = deserializer.deserializeStr() || undefined\n    return new AccountInfo({ address, publicKey, ansName })\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nexport type ChainsId = `${string}:${string}` // e.g. 'aptos:devnet'\n/** APTOS Devnet */\nexport const APTOS_DEVNET_CHAIN = 'aptos:devnet'\n\n/** APTOS Testnet */\nexport const APTOS_TESTNET_CHAIN = 'aptos:testnet'\n\n/** APTOS Localnet */\nexport const APTOS_LOCALNET_CHAIN = 'aptos:localnet'\n\n/** APTOS Mainnet */\nexport const APTOS_MAINNET_CHAIN = 'aptos:mainnet'\n\nexport const APTOS_CHAINS = [\n  APTOS_DEVNET_CHAIN,\n  APTOS_TESTNET_CHAIN,\n  APTOS_LOCALNET_CHAIN,\n  APTOS_MAINNET_CHAIN\n] as const\n\nexport type AptosChain =\n  | typeof APTOS_DEVNET_CHAIN\n  | typeof APTOS_TESTNET_CHAIN\n  | typeof APTOS_LOCALNET_CHAIN\n  | typeof APTOS_MAINNET_CHAIN\n", "export enum AptosWalletErrorCode {\n  Unauthorized = 4100,\n  Unsupported = 4200,\n  InternalError = -30001\n}\n\nexport const AptosWalletErrors = Object.freeze({\n  [AptosWalletErrorCode.Unauthorized]: {\n    status: 'Unauthorized',\n    message: 'The requested method and/or account has not been authorized by the user.'\n  },\n  [AptosWalletErrorCode.InternalError]: {\n    status: 'Internal error',\n    message: 'Something went wrong within the wallet.'\n  },\n  [AptosWalletErrorCode.Unsupported]: {\n    status: 'Unsupported',\n    message: 'The requested feature is not supported.'\n  }\n})\n\nexport class AptosWalletError extends Error {\n  readonly code: number\n  readonly status: string\n\n  constructor(code: number, message?: string) {\n    super(\n      message ??\n        AptosWalletErrors[code as keyof typeof AptosWalletErrors]?.message ??\n        'Unknown error occurred'\n    )\n    this.code = code\n    this.status =\n      AptosWalletErrors[code as keyof typeof AptosWalletErrors]?.status ?? 'Unknown error'\n    this.name = 'AptosWalletError'\n    Object.setPrototypeOf(this, AptosWalletError.prototype)\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Network } from '@aptos-labs/ts-sdk'\n\nexport type TransactionHash = `0x${string}`\n\nexport interface NetworkInfo {\n  name: Network // Name of the network.\n  chainId: number // Chain ID of the network.\n  url?: string // RPC URL of the network.\n}\n\nexport enum UserResponseStatus {\n  APPROVED = 'Approved',\n  REJECTED = 'Rejected'\n}\n\nexport interface UserApproval<TResponseArgs> {\n  status: UserResponseStatus.APPROVED\n  args: TResponseArgs\n}\n\nexport interface UserRejection {\n  status: UserResponseStatus.REJECTED\n}\n\nexport type UserResponse<TResponseArgs> = UserApproval<TResponseArgs> | UserRejection\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519Signature, PublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport nacl from 'tweetnacl';\nimport ed2curve from 'ed2curve';\nimport { DecryptionError } from './errors';\nimport {\n  concatUint8array,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n  X25519SecretKey,\n} from './utils';\n\n// This callback takes in a message bytes, and signs it.\n// THIS DOES NOT PERFORM DOMAIN SEPARATION: IT IS ASSUMED OUR LIBRARY ALREADY DID IT.\n// This is to support hardware wallets.\nexport type SignCallback = (message: Uint8Array) => Promise<Signature>;\n\nexport type SignaturePurpose = 'TRANSPORT_KEYPAIR' | 'ACCOUNT_INFO' | 'SECURED_ENVELOPE';\n\nexport const SIGNATURE_PREFIX = 'APTOS::IDENTITY_CONNECT';\n\nexport type EncryptionResult = {\n  nonce: Uint8Array;\n  secured: Uint8Array;\n};\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\n/**\n * Converts an Ed25519 public key to an X25519 public key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519PublicKey The Ed25519 public key to convert\n * @param errorKeyName The name of the key to use in error messages\n */\nexport function convertEd25519PublicKeyToX25519PublicKey(\n  ed25519PublicKey: Ed25519PublicKey,\n  errorKeyName: string,\n): X25519PublicKey {\n  const x25519PublicKey = ed2curve.convertPublicKey(ed25519PublicKey.key.slice(0, 32));\n  if (!x25519PublicKey) throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);\n  return toKey(x25519PublicKey, KeyTypes.X25519PublicKey);\n}\n\n/**\n * Converts an Ed25519 secret key to an X25519 secret key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519SecretKey The Ed25519 secret key to convert\n */\nexport function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey: Ed25519SecretKey): X25519SecretKey {\n  const x25519SecretKey = ed2curve.convertSecretKey(ed25519SecretKey.key.slice(0, 32));\n  return toKey(x25519SecretKey, KeyTypes.X25519SecretKey);\n}\nexport function serializeEncryptionResult(enc: EncryptionResult): SerializedEncryptionResult {\n  return {\n    nonceB64: encodeBase64(enc.nonce),\n    securedB64: encodeBase64(enc.secured),\n  };\n}\n\nexport function deserializeEncryptionResult(enc: SerializedEncryptionResult): EncryptionResult {\n  return {\n    nonce: decodeBase64(enc.nonceB64),\n    secured: decodeBase64(enc.securedB64),\n  };\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResult<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObject<T>(senderX25519PublicKey, receiverEd25519SecretKey, des.secured, des.nonce);\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResultDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObjectDirect<T>(senderX25519PublicKey, receiverX25519SecretKey, des.secured, des.nonce);\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessage(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Encrypt the message with the receiver's public key and sender's secret key\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessageDirect(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Generate a random nonce\n  const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n  // Convert the message to a Uint8Array\n  const messageUint8 = new TextEncoder().encode(message);\n\n  const secured = nacl.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));\n\n  return { nonce, secured };\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObject<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: T,\n): EncryptionResult {\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObjectDirect<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: T,\n): EncryptionResult {\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessage(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  // Decrypt the message with the receiver's secret key and sender's public key\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessageDirect(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  let decryptedUint8;\n  try {\n    decryptedUint8 = nacl.box.open(\n      securedMessage,\n      nonce,\n      senderX25519PublicKey.key.slice(0, 32),\n      receiverX25519SecretKey.key.slice(0, 32),\n    );\n  } catch (e: any) {\n    throw new DecryptionError(`Could not decrypt message: ${e.message}`);\n  }\n  if (!decryptedUint8) throw new DecryptionError('Could not decrypt message');\n\n  // Convert the decrypted Uint8Array back to a string\n  return new TextDecoder().decode(decryptedUint8);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObject<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptObjectDirect<T>(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObjectDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n  return JSON.parse(decryptedStr) as T;\n}\n\n/**\n * Hashes a message with a purpose-specific prefix using SHA-3 256-bit algorithm.\n * The purpose prefix is constructed as `'APTOS::IDENTITY_CONNECT' + '::' + purpose + '::'`\n * This is to prevent hash collisions with other services, uses, and purposes\n * @param message The message to hash as a Uint8Array.\n * @param purpose The purpose of the signature.\n * @returns Uint8Array The hashed message as a Uint8Array\n */\nexport function messageHash(message: Uint8Array, purpose: SignaturePurpose) {\n  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));\n  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));\n}\n\nexport function signWithEd25519SecretKey(\n  message: Uint8Array,\n  signingEd25519SecretKey: Ed25519SecretKey,\n  purpose: SignaturePurpose,\n) {\n  return nacl.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);\n}\n\n// This assumes that domain separation has already happened: this emulates the behavior of a hardware device\nexport function makeEd25519SecretKeySignCallbackNoDomainSeparation(\n  signingEd25519SecretKey: Ed25519SecretKey,\n): SignCallback {\n  return async (message: Uint8Array) => new Ed25519Signature(nacl.sign.detached(message, signingEd25519SecretKey.key));\n}\n\nexport function verifySignature(\n  message: Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });\n}\n\nexport function hashAndVerifySignature(\n  message: string | Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  const messageUint8 = message instanceof Uint8Array ? message : new TextEncoder().encode(message);\n  const messageUint8Hash = sha3_256(messageUint8);\n  return verifySignature(messageUint8Hash, signature, signingPublicKey, purpose);\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class EncryptionEnvelopeError extends Error {}\n\nexport class EnvelopeMessageMismatchError extends EncryptionEnvelopeError {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = 'EnvelopeMessageMismatchError';\n    Object.setPrototypeOf(this, EnvelopeMessageMismatchError.prototype);\n  }\n}\n\nexport class DecryptionError extends EncryptionEnvelopeError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecryptionError';\n    Object.setPrototypeOf(this, DecryptionError.prototype);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\n\nexport enum KeyTypes {\n  'Ed25519PublicKey' = 'Ed25519PublicKey',\n  'Ed25519SecretKey' = 'Ed25519SecretKey',\n  'X25519PublicKey' = 'X25519PublicKey',\n  'X25519SecretKey' = 'X25519SecretKey',\n}\n\nexport interface IKey<Type extends KeyTypes> {\n  key: Uint8Array;\n  type: Type;\n}\n\nexport type X25519PublicKey = IKey<KeyTypes.X25519PublicKey>;\nexport type X25519SecretKey = IKey<KeyTypes.X25519SecretKey>;\nexport type X25519KeyPair = {\n  publicKey: X25519PublicKey;\n  secretKey: X25519SecretKey;\n};\n\nexport type Ed25519PublicKey = IKey<KeyTypes.Ed25519PublicKey>;\nexport type Ed25519SecretKey = IKey<KeyTypes.Ed25519SecretKey>;\nexport type Ed25519KeyPair = {\n  publicKey: Ed25519PublicKey;\n  secretKey: Ed25519SecretKey;\n};\n\nexport type RawKeyPair = {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n};\n\nexport function createX25519KeyPair(): X25519KeyPair {\n  return keypairToX25519(nacl.box.keyPair());\n}\n\nexport function createEd25519KeyPair(): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair());\n}\n\nexport function toKey<Type extends KeyTypes = KeyTypes>(\n  rawKey: Uint8Array,\n  type: Type,\n): Type extends KeyTypes.Ed25519PublicKey\n  ? Ed25519PublicKey\n  : Type extends KeyTypes.Ed25519SecretKey\n    ? Ed25519SecretKey\n    : Type extends KeyTypes.X25519PublicKey\n      ? X25519PublicKey\n      : Type extends KeyTypes.X25519SecretKey\n        ? X25519SecretKey\n        : never {\n  return {\n    key: rawKey,\n    type,\n  } as any;\n}\n\nexport function keypairToEd25519(keyPair: RawKeyPair): Ed25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.Ed25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.Ed25519SecretKey),\n  };\n}\n\nexport function keypairToX25519(keyPair: RawKeyPair): X25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.X25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.X25519SecretKey),\n  };\n}\n\nexport function aptosAccountToEd25519Keypair(account: { signingKey: nacl.SignKeyPair }) {\n  return ed25519KeypairFromSecret(account.signingKey.secretKey);\n}\n\nexport function ed25519KeypairFromSecret(ed25519SecretKeyBytes: Uint8Array): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair.fromSeed(ed25519SecretKeyBytes.slice(0, 32)));\n}\n\nexport function decodeBase64(base64Str: string): Uint8Array {\n  if (globalThis.Buffer) {\n    return new Uint8Array(Buffer.from(base64Str, 'base64'));\n  }\n  return Uint8Array.from(atob(base64Str), (m) => m.codePointAt(0)!);\n}\n\nexport function encodeBase64(bytes: Uint8Array): string {\n  if (globalThis.Buffer) {\n    return Buffer.from(bytes).toString('base64');\n  }\n  return btoa(Array.from(bytes, (x) => String.fromCodePoint(x)).join(''));\n}\n\nexport function concatUint8array(arrayOne: Uint8Array, arrayTwo: Uint8Array): Uint8Array {\n  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n  mergedArray.set(arrayOne);\n  mergedArray.set(arrayTwo, arrayOne.length);\n  return mergedArray;\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519PublicKey as AptosEd25519PublicKey, Ed25519Signature, Hex } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport {\n  createX25519KeyPair,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  X25519KeyPair,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n} from './utils';\nimport { EnvelopeMessageMismatchError } from './errors';\nimport {\n  SerializedEncryptionResult,\n  SignCallback,\n  decryptObject,\n  encryptObject,\n  serializeEncryptionResult,\n  deserializeEncryptionResult,\n  verifySignature,\n  signWithEd25519SecretKey,\n} from './encrDecr';\n\n/**\n * When sending messages back and forth, there are some things that Identity Connect must know to function and provide\n * security for users, and dApps and wallets need to know that any messages sent to one another were sent (and\n * received) by the expected parties.\n *\n * To allow for secure communication between parties, we are introducing the\n * *SecuredEnvelope*. This envelope provides a secure channel for parties to encrypt private messages, *and*\n * authenticate one another, while allowing IC to route requests and block invalid messages.\n *\n * The envelope can be thought of as a wrapper around the JSON payload of a POST/PUT request T, and has two parts:\n * `messagePrivate`: This contains some of the parameters of `T`, which will be signed by the sender and encrypted\n *                   with the recipient's public key.\n * `publicMessage`: This field is sent unencrypted, but signed so that the IC endpoint can do basic validation before\n *                  processing. The parameters in `publicMessage` are DISJOINT from `messagePrivate`, and are invalid\n *                  otherwise: there are no keys in `messagePrivate` that also appear in `publicMessage`. It must\n *                  contain a ``_metadata`` field with security features like the timestamp, public keys, sequence\n *                  number, etc.\n *\n * Both IC and dApps can verify, on chain, that the senders’ keys match their address and that they are speaking\n * with who they expect. Encryption is done with an X25519 key derived from the ED25519 PublicKey of the wallet\n * account that is connecting (this allows for seamless cross-device account access), and an ephemeral X25519 KeyPair,\n * of which the SecretKey is thrown away after encryption. Decryption uses the X25519 key derived from the receiver\n * ED25519 SecretKey.\n *\n * Account private keys Ska (and their counterpart X25519 keys) are only used to decrypt and sign:\n * THEY ARE NEVER USED TO ENCRYPT!\n *\n * Operations follow the Cryptographic Doom Principle:\n *   Always verify the signature of the message before any other cryptographic operations\n * https://moxie.org/2011/12/13/the-cryptographic-doom-principle.html\n *\n *\n * To send a `SecuredEnvelope` over the wire, it must first be turned into a `SecuredEnvelopeTransport` - this\n * involves:\n * 1. Encrypting and serializing the `privateMessage` field to an `encryptedPrivateMessage`field.\n *     a. Generate ephemeral X25519 sender keypair `xPkse/xSkse`. The `xPkse` becomes the `senderX25519PublicKeyB64` in\n *      the `EnvelopeMetadata`.\n *     b. Convert the `receiverEd25519PublicKey` to a `receiverX25519PublicKey` - `xPkr`\n *     c. Generate a random `nonce` for the `[nacl.box](http://nacl.box)` encryption\n *     d. Encrypt the `privateMessage` using `[nacl.box](http://nacl.box)` with the `xSkse` and `xPkr`\n *     e. Package this encrypted data, and the `nonce`, into a `SerializedEncryptionResult`\n * 2. JSON serializing the `publicMessage` field into a `serializedPublicMessage`. We don’t care about canonical\n *    serialization/ordering as the sender signs over this serialized string.\n * 3.  Now that we have the private `encryptedPrivateMessage` and public `serializedPublicMessage` we can generate the\n *    `messageSignature`:\n *     a. Hash the `SHA3-256(encryptedPublicMessage)` to get `publicMessageHash`\n *     b. Hash the `SHA3-256(encryptedPrivateMessage)` to get `privateMessageHash`\n *     c. Hash `SHA3-256(publicMessageHash | privateMessageHash)` to get `combinedMessageHash`\n *     d. Get the `domainSeparatedMessageHash` by hashing the `combinedMessageHash` with a domain separator:\n *        `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | combinedMessageHash)`\n *     e. To obtain the final `messageSignature`, we sign the `domainSeparatedMessageHash` with the Ed25519 private\n *        key of the sender, and hex encode it.\n * 4. This creates the final `SecuredEnvelopeTransport` object, ready to be JSON serialized and sent in an HTTP\n *    request\n */\n\nexport const REQUIRED_FIELDS: (keyof EnvelopeMetadata)[] = [\n  'receiverEd25519PublicKeyB64',\n  'senderEd25519PublicKeyB64',\n  'senderX25519PublicKeyB64',\n  'sequence',\n  'timestampMillis',\n].sort() as (keyof EnvelopeMetadata)[];\n\n// The publicMessage._metadata field looks like this:\nexport type EnvelopeMetadata = {\n  // The receiver's public key, base64\n  receiverEd25519PublicKeyB64: string;\n  // The sender public key, base64\n  senderEd25519PublicKeyB64: string;\n  // The senders X25519 public key, base64\n  senderX25519PublicKeyB64: string;\n  // The sequence of the sender.\n  // This number only goes up, to prevent relay attacks\n  // This exists per pairing\n  // dApps, wallets, accounts, etc are expected to keep track of them\n  // IC will reject out-of-order sequence numbers\n  sequence: number;\n  // The timestamp this message was sent at\n  // IC will reject if it's in the future or older than 5 minutes\n  timestampMillis: number;\n};\n\nexport interface IEnvelopeMetadata extends Message {\n  _metadata: EnvelopeMetadata;\n}\n\n// A message- whether the `Public` or `Private` component- is a JSON object.\n// As such, we know that the keys are strings, and the values are any JSON-serializable type ('unknown')\nexport type Message = Record<string, unknown>;\n\nexport type SecuredEnvelope<Public extends Message> = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\nexport type DecryptedEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n> = {\n  messageSignature: string;\n  privateMessage: Private;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type DeserializedTransportEnvelope<Public extends Message> = SecuredEnvelopeTransport & SecuredEnvelope<Public>;\n\nexport type SignCallbackOrEd25519SecretKey = SignCallback | Ed25519SecretKey;\n\nexport function ensurePrivatePublicFieldsDisjoint<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(privateMessage: Private, publicMessage: Public) {\n  // gets all fields in privateMessage that are also in publicMessage\n  const intersection = Object.keys(privateMessage).filter((x) => Object.keys(publicMessage).includes(x));\n  if (intersection.length > 0) {\n    const field = intersection[0];\n    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);\n  }\n}\n\nexport function ensureMetadataFields(message: EnvelopeMetadata) {\n  // ensure ONLY the fields in REQUIRED_FIELDS are present in message. Sort asc.\n  const messageKeys = Object.keys(message).sort();\n  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key as any));\n  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key as any));\n  if (extraFields.length > 0 || missingFields.length > 0) {\n    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(', ')})` : '';\n    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(', ')})` : '';\n    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;\n    throw new EnvelopeMessageMismatchError(\n      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,\n      '_metadata',\n    );\n  }\n}\n\nexport function deserializeTransportEnvelope<Public extends Message>(\n  transportEnvelope: SecuredEnvelopeTransport,\n): DeserializedTransportEnvelope<Public> {\n  const publicMessage = JSON.parse(transportEnvelope.serializedPublicMessage) as Public & IEnvelopeMetadata;\n  return {\n    ...transportEnvelope,\n    publicMessage,\n  };\n}\n\n// This signs with the senders ed25519 private key,\n// but encrypts with an ephemeral X25519 keyPair + the receivers x25519 public key (converted from their ed25519 key)\n// This is so that the private key IS ONLY EVER USED FOR DECRYPTION, NEVER FOR ENCRYPTION\nexport function encryptAndSignEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  publicMessage: Public,\n  privateMessage: Private,\n): SecuredEnvelopeTransport {\n  const senderEphemeralX25519KeyPair = createX25519KeyPair();\n  const metadata = constructMetadata(\n    senderEd25519PublicKey,\n    receiverEd25519PublicKey,\n    sequence,\n    senderEphemeralX25519KeyPair.publicKey,\n  );\n\n  ensureMetadataFields(metadata);\n  ensurePrivatePublicFieldsDisjoint<Public, Private>(privateMessage, publicMessage);\n\n  return dangerouslyEncryptAndSignEnvelopeUnvalidated(\n    senderEd25519SecretKey,\n    receiverEd25519PublicKey,\n    metadata,\n    privateMessage,\n    publicMessage,\n    senderEphemeralX25519KeyPair,\n  );\n}\n\nexport function constructMetadata(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  senderEphemeralX25519PublicKey: X25519PublicKey,\n): EnvelopeMetadata {\n  // This is used for SIGNING ONLY!\n  return {\n    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),\n    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),\n    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),\n    sequence,\n    timestampMillis: Date.now(),\n  };\n}\n\nexport function dangerouslyEncryptAndSignEnvelopeUnvalidated<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  metadata: EnvelopeMetadata,\n  privateMessage: Private,\n  publicMessage: Public,\n  senderEphemeralX25519KeyPair: X25519KeyPair,\n): SecuredEnvelopeTransport {\n  const encryptionResult = encryptObject(\n    senderEphemeralX25519KeyPair.secretKey,\n    receiverEd25519PublicKey,\n    privateMessage,\n  );\n  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);\n  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);\n  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });\n  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);\n  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);\n  return {\n    encryptedPrivateMessage,\n    messageSignature,\n    serializedPublicMessage,\n  };\n}\n\nfunction combineHashedEnvelopeMessageBytes(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n): Uint8Array {\n  const publicMessageBytesHash = sha3_256(publicMessageBytes);\n  const privateMessageBytesHash = sha3_256(privateMessageBytes);\n  // Concatenate the two hashes\n  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);\n  combinedHash.set(publicMessageBytesHash);\n  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);\n  // Hash and return\n  return sha3_256(combinedHash);\n}\n\nfunction signEnvelope(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  senderEd25519SecretKey: Ed25519SecretKey,\n) {\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, 'SECURED_ENVELOPE');\n  return Hex.fromHexInput(signatureBytes).toString();\n}\n\nexport function verifyEnvelopeSignature(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  messageSignatureInput: string,\n  senderEd25519PublicKey: Ed25519PublicKey,\n) {\n  const messageSignature = new Ed25519Signature(Hex.fromHexInput(messageSignatureInput).toUint8Array());\n  const senderPublicKey = new AptosEd25519PublicKey(senderEd25519PublicKey.key);\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, 'SECURED_ENVELOPE');\n  if (!messageVerified) {\n    throw new EnvelopeMessageMismatchError('Could not verify SecuredEnvelope signature', 'messageSignature');\n  }\n}\n\nexport function decryptEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  message: SecuredEnvelopeTransport,\n): DecryptedEnvelope<Public, Private> {\n  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;\n  const publicMessage = JSON.parse(serializedPublicMessage) as Public & IEnvelopeMetadata;\n\n  // Ensure the private/public message signature matches the expected signature\n  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);\n  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);\n  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);\n\n  // Ensure the public key matches the expected public key\n  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);\n  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;\n  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {\n    throw new EnvelopeMessageMismatchError(\n      'senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey',\n      'senderPublicKey',\n    );\n  }\n\n  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);\n  const senderX25519PublicKey = toKey(senderX25519PublicKeyBytes, KeyTypes.X25519PublicKey);\n  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);\n  const privateMessage = decryptObject<Private>(\n    senderX25519PublicKey,\n    receiverEd25519SecretKey,\n    encryptionResult.secured,\n    encryptionResult.nonce,\n  );\n\n  ensureMetadataFields(publicMessage._metadata);\n  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);\n\n  return {\n    messageSignature,\n    privateMessage,\n    publicMessage,\n  };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  base64ToBytes,\n  bytesToBase64,\n  deserializePublicKey,\n  deserializeSignature,\n  serializePublicKey,\n  serializeSignature,\n} from '@aptos-connect/wallet-api';\nimport {\n  AccountPublicKey,\n  Deserializer,\n  Ed25519PublicKey as AptosEd25519PublicKey,\n  Ed25519Signature,\n  Hex,\n  PublicKey,\n  Serializer,\n  Signature,\n} from '@aptos-labs/ts-sdk';\nimport { decodeBase64 } from './utils';\n\nexport function serializePublicKeyB64(publicKey: PublicKey) {\n  const serializer = new Serializer();\n  serializePublicKey(serializer, publicKey);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializePublicKeyB64(publicKeyB64: string) {\n  const serializedPublicKey = base64ToBytes(publicKeyB64);\n  const deserializer = new Deserializer(serializedPublicKey);\n  return deserializePublicKey(deserializer) as AccountPublicKey;\n}\n\nexport function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  return new AptosEd25519PublicKey(decodeBase64(ed25519PublicKeyB64));\n}\n\nexport function serializeSignatureB64(signature: Signature) {\n  const serializer = new Serializer();\n  serializeSignature(serializer, signature);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializeSignatureB64(signatureB64: string) {\n  const serializedSignature = base64ToBytes(signatureB64);\n  const deserializer = new Deserializer(serializedSignature);\n  return deserializeSignature(deserializer);\n}\n\nexport function deserializeEd25519SignatureB64(ed25519SignatureB64: string) {\n  const signatureBytes = Hex.fromHexInput(ed25519SignatureB64).toUint8Array();\n  return new Ed25519Signature(signatureBytes);\n}\n\nexport function publicKeyB64FromEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  const publicKey = deserializeEd25519PublicKeyB64(ed25519PublicKeyB64);\n  return serializePublicKeyB64(publicKey);\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n// Adding or removing an account? This will be idempotent, but racy\nimport { Account, AccountPublicKey, PublicKey as AptosPublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport { messageHash, signWithEd25519SecretKey } from './encrDecr';\nimport { serializePublicKeyB64, serializeSignatureB64 } from './serialization';\nimport { Ed25519KeyPair, ed25519KeypairFromSecret, Ed25519PublicKey, Ed25519SecretKey, encodeBase64 } from './utils';\n\n// ADD/REMOVE is used for account connections\nexport enum AccountConnectionAction {\n  ADD = 'add',\n  REMOVE = 'remove',\n}\n\n/**\n * When a wallet wants to create a pairing, or add/remove an account from a wallet connection, it must prove that it\n * has the secret key for a given account. To do so it uses an `AccountConnectInfo` object.\n *  1. Once the `AccountConnectInfo` is assembled, it’s JSON serialized to get a `accountInfoSerialized` string.\n *  2. We then domain separate and hash the `accountInfoSerialized` to get the `accountInfoHash`:\n *    `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | SHA3-256(accountInfoSerialized))`\n *  3. To obtain the `signature`, we sign the `accountInfoHash` with the Ed25519 private key of the sender, and hex\n *     encode it.\n *  4. These are assembled into an `AccountConnectInfoSerialized`, ready to be sent in an HTTP request.\n */\n\nexport type BaseAccountConnectInfo = {\n  // The account address\n  accountAddress: string;\n  // either 'add' or 'remove'\n  action: AccountConnectionAction;\n  // A unique identifier for this connection: it is either the walletId or the pairingId\n  // Prevents replay attacks across wallets\n  intentId: string;\n  // Prevents replay attacks across time- these are only valid for 5 minutes\n  timestampMillis: number;\n  // The public key for the encrypted e2e channel, base64\n  transportEd25519PublicKeyB64: string;\n};\n\nexport type Ed25519AccountConnectInfo = BaseAccountConnectInfo & {\n  // The account ed25519 public key, base64\n  ed25519PublicKeyB64: string;\n  publicKeyB64?: undefined;\n};\n\nexport type AnyAccountConnectInfo = BaseAccountConnectInfo & {\n  ed25519PublicKeyB64?: undefined;\n  // The account public key, bcs-serialized and base64-encoded\n  publicKeyB64: string;\n};\n\n// Ensuring compatibility with previous wallet-sdk versions\nexport type AccountConnectInfo = Ed25519AccountConnectInfo | AnyAccountConnectInfo;\n\nexport type Ed25519AccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature: string;\n  signatureB64?: undefined;\n};\n\nexport type AnyAccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature?: undefined;\n  signatureB64: string;\n};\n\nexport type AccountConnectInfoSerialized = Ed25519AccountConnectInfoSerialized | AnyAccountConnectInfoSerialized;\n\nexport type SyncSignCallback = (message: Uint8Array) => Signature;\nexport type AsyncSignCallback = (message: Uint8Array) => Promise<Signature>;\nexport type AnySignCallback = SyncSignCallback | AsyncSignCallback;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKey: Ed25519SecretKey,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: SyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport async function deriveAccountTransportEd25519Keypair(\n  signCallback: AsyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair | Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKeyOrSignCallback: Ed25519SecretKey | AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n) {\n  const publicKeyBytes = publicKey instanceof AptosPublicKey ? publicKey.toUint8Array() : publicKey.key;\n  if (ed25519SecretKeyOrSignCallback instanceof Function) {\n    const seedGeneratorBytes = messageHash(publicKeyBytes, 'TRANSPORT_KEYPAIR');\n    const signature = ed25519SecretKeyOrSignCallback(seedGeneratorBytes);\n    if (signature instanceof Promise) {\n      return signature.then((value) => ed25519KeypairFromSecret(value.toUint8Array()));\n    }\n    return ed25519KeypairFromSecret(signature.toUint8Array());\n  }\n\n  const seedBytes = signWithEd25519SecretKey(publicKeyBytes, ed25519SecretKeyOrSignCallback, 'TRANSPORT_KEYPAIR');\n  return ed25519KeypairFromSecret(seedBytes);\n}\n\nexport type CreateSerializedAccountInfoArgs<TSignCallback extends AnySignCallback> = [\n  signCallback: TSignCallback,\n  publicKey: AccountPublicKey,\n  transportEd25519PublicKey: Ed25519PublicKey,\n  action: AccountConnectionAction,\n  intentId: string,\n  accountAddress?: string,\n];\n\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<SyncSignCallback>\n): AccountConnectInfoSerialized;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AsyncSignCallback>\n): Promise<AccountConnectInfoSerialized>;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized>;\n\nexport function createSerializedAccountInfo(\n  ...[\n    signCallback,\n    publicKey,\n    transportEd25519PublicKey,\n    action,\n    intentId,\n    accountAddress,\n  ]: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized> {\n  // TODO: WRITE TESTS FOR THIS!\n\n  // Either the passed in Pk, or the Pk derived from the Sk\n  const authKey = publicKey.authKey();\n\n  // Either the passed in account address, or the one derived from the authKey: (either Pk, or derived from Sk)\n  const finalAccountAddress = accountAddress || authKey.derivedAddress().toString();\n  const publicKeyB64 = serializePublicKeyB64(publicKey);\n\n  const accountInfo: AccountConnectInfo = {\n    accountAddress: finalAccountAddress,\n    action,\n    intentId,\n    publicKeyB64,\n    timestampMillis: Date.now(),\n    transportEd25519PublicKeyB64: encodeBase64(transportEd25519PublicKey.key),\n  };\n  const accountInfoSerialized = JSON.stringify(accountInfo);\n  const accountInfoBytes = new TextEncoder().encode(accountInfoSerialized);\n  const accountInfoHash = sha3_256(accountInfoBytes);\n\n  const signature = signCallback(messageHash(accountInfoHash, 'ACCOUNT_INFO'));\n  if (signature instanceof Promise) {\n    return signature.then((value) => ({\n      accountInfoSerialized,\n      signatureB64: serializeSignatureB64(value),\n    }));\n  }\n  return {\n    accountInfoSerialized,\n    signatureB64: serializeSignatureB64(signature),\n  };\n}\n\nexport async function aptosAccountToSerializedInfo(\n  account: Account,\n  intentId: string,\n): Promise<AccountConnectInfoSerialized> {\n  const signCallback = async (data: Uint8Array) => account.sign(data);\n  const transportKey = await deriveAccountTransportEd25519Keypair(signCallback, account.publicKey);\n  return createSerializedAccountInfo(\n    signCallback,\n    account.publicKey,\n    transportKey.publicKey,\n    AccountConnectionAction.ADD,\n    intentId,\n  );\n}\n", "import {\n  AccountAddress, AccountAddressInput, AnyPublicKey,\n  Deserializer,\n  Ed25519PublicKey,\n  MultiEd25519PublicKey, MultiKey,\n  PublicKey,\n  Serializable,\n  Serializer, SigningScheme\n} from '@aptos-labs/ts-sdk'\n\nexport interface AccountInfoInput {\n  address: AccountAddressInput\n  publicKey: PublicKey\n  ansName?: string\n}\n\nexport class AccountInfo extends Serializable {\n  readonly address: AccountAddress\n  readonly publicKey: PublicKey\n  readonly ansName?: string\n\n  constructor({ address, publicKey, ansName }: AccountInfoInput) {\n    super()\n    this.address = AccountAddress.from(address)\n    this.publicKey = publicKey\n    this.ansName = ansName\n  }\n\n  serialize(serializer: Serializer) {\n    this.address.serialize(serializer)\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.Ed25519)\n    } else if (this.publicKey instanceof MultiEd25519PublicKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.MultiEd25519)\n    } else if (this.publicKey instanceof AnyPublicKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.SingleKey)\n    } else if (this.publicKey instanceof MultiKey) {\n      serializer.serializeU32AsUleb128(SigningScheme.MultiKey)\n    } else {\n      throw new Error('Unsupported public key')\n    }\n    this.publicKey.serialize(serializer)\n    serializer.serializeStr(this.ansName ?? '')\n  }\n\n  static deserialize(deserializer: Deserializer) {\n    const address = AccountAddress.deserialize(deserializer)\n    const variant = deserializer.deserializeUleb128AsU32()\n    let publicKey: PublicKey\n    switch (variant) {\n      case SigningScheme.Ed25519:\n        publicKey = Ed25519PublicKey.deserialize(deserializer)\n        break\n      case SigningScheme.MultiEd25519:\n        publicKey = MultiEd25519PublicKey.deserialize(deserializer)\n        break\n      case SigningScheme.SingleKey:\n        publicKey = AnyPublicKey.deserialize(deserializer)\n        break\n      case SigningScheme.MultiKey:\n        publicKey = MultiKey.deserialize(deserializer)\n        break\n      default:\n        throw new Error(`Unknown variant index for WrappedPublicKey: ${variant}`)\n    }\n    const ansName = deserializer.deserializeStr() || undefined\n    return new AccountInfo({ address, publicKey, ansName })\n  }\n}\n", "export enum AptosWalletErrorCode {\n  Unauthorized = 4100,\n  Unsupported = 4200,\n  InternalError = -30001\n}\n\nexport const AptosWalletErrors = Object.freeze({\n  [AptosWalletErrorCode.Unauthorized]: {\n    status: 'Unauthorized',\n    message: 'The requested method and/or account has not been authorized by the user.'\n  },\n  [AptosWalletErrorCode.InternalError]: {\n    status: 'Internal error',\n    message: 'Something went wrong within the wallet.'\n  },\n  [AptosWalletErrorCode.Unsupported]: {\n    status: 'Unsupported',\n    message: 'The requested feature is not supported.'\n  }\n})\n\nexport class AptosWalletError extends Error {\n  readonly code: number\n  readonly status: string\n\n  constructor(code: number, message?: string) {\n    super(\n      message ??\n        AptosWalletErrors[code as keyof typeof AptosWalletErrors]?.message ??\n        'Unknown error occurred'\n    )\n    this.code = code\n    this.status =\n      AptosWalletErrors[code as keyof typeof AptosWalletErrors]?.status ?? 'Unknown error'\n    this.name = 'AptosWalletError'\n    Object.setPrototypeOf(this, AptosWalletError.prototype)\n  }\n}\n", "// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Network } from '@aptos-labs/ts-sdk'\n\nexport type TransactionHash = `0x${string}`\n\nexport interface NetworkInfo {\n  name: Network // Name of the network.\n  chainId: number // Chain ID of the network.\n  url?: string // RPC URL of the network.\n}\n\nexport enum UserResponseStatus {\n  APPROVED = 'Approved',\n  REJECTED = 'Rejected'\n}\n\nexport interface UserApproval<TResponseArgs> {\n  status: UserResponseStatus.APPROVED\n  args: TResponseArgs\n}\n\nexport interface UserRejection {\n  status: UserResponseStatus.REJECTED\n}\n\nexport type UserResponse<TResponseArgs> = UserApproval<TResponseArgs> | UserRejection\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport function base64ToBytes(base64: string) {\n  const binaryString = atob(base64);\n  return Uint8Array.from(binaryString, (m) => m.charCodeAt(0));\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  const binaryString = String.fromCharCode(...bytes);\n  return btoa(binaryString);\n}\n\nexport function base64urlToBytes(base64: string) {\n  return base64ToBytes(base64.replace(/-/g, '+').replace(/_/g, '/'));\n}\n\nexport function bytesToBase64url(bytes: Uint8Array) {\n  return bytesToBase64(bytes).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Network, NetworkToChainId, Serializer } from '@aptos-labs/ts-sdk';\n\nexport type SerializeFn<T> = (serializer: Serializer, value: T) => void;\nexport type DeserializeFn<T> = (deserializer: Deserializer) => T;\n\nexport function chainIdToNetwork(chainId: number): Network {\n  switch (chainId) {\n    case NetworkToChainId.mainnet:\n      return Network.MAINNET;\n    case NetworkToChainId.testnet:\n      return Network.TESTNET;\n    default:\n      // TODO: fetch Devnet's chain id and compare, otherwise throw error\n      return Network.DEVNET;\n  }\n}\n\nexport function isSupportedNetwork(network: string): network is Network {\n  return [Network.MAINNET, Network.TESTNET, Network.DEVNET].includes(network as Network);\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Ed25519PrivateKey, Network, Serializer } from '@aptos-labs/ts-sdk';\nimport { DappInfo } from '../../shared';\nimport {\n  deserializeWalletRequestWithArgs,\n  SerializedWalletRequest,\n  serializeWalletRequestWithArgs,\n  WalletRequest,\n} from '../../WalletRequest';\nimport { isSupportedNetwork } from '../../helpers';\n\nexport interface ClaimOptions {\n  asset?: string;\n  network: Network;\n  secretKey: Ed25519PrivateKey;\n}\n\nexport interface ConnectRequest extends WalletRequest<ConnectRequest.RequestName, ConnectRequest.SupportedVersions> {\n  args: ConnectRequest.Args;\n}\n\nexport namespace ConnectRequest {\n  export const name = 'connect' as const;\n  export type RequestName = typeof name;\n\n  export const supportedVersions = [1, 2, 3, 4] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n  export const currentVersion = 4 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  // region Args\n\n  export type Args = {\n    claimOptions?: ClaimOptions;\n    dappEd25519PublicKeyB64?: string;\n    dappId?: string;\n    // Whether to display paired accounts under the specified wallet first\n    preferredWalletName?: string;\n  };\n\n  export function serializeArgs(serializer: Serializer, value: Args) {\n    serializer.serializeOptionStr(value.dappId);\n    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);\n    serializer.serializeOptionStr(value.preferredWalletName);\n\n    serializer.serializeBool(value.claimOptions !== undefined);\n    if (value.claimOptions) {\n      serializer.serialize(value.claimOptions.secretKey);\n      serializer.serializeStr(value.claimOptions.network);\n      serializer.serializeOptionStr(value.claimOptions.asset);\n      if (!isSupportedNetwork(value.claimOptions.network)) {\n        throw new Error(`Unsupported network '${value.claimOptions.network}'`);\n      }\n    }\n  }\n\n  export function deserializeArgs(deserializer: Deserializer, version: SupportedVersions): Args {\n    if (version === 1) {\n      return {};\n    }\n\n    const dappId = deserializer.deserializeOption('string');\n    const dappEd25519PublicKeyB64 = deserializer.deserializeOption('string');\n    const preferredWalletName = version >= 3 ? deserializer.deserializeOption('string') : undefined;\n\n    const hasClaimOptions = version >= 4 ? deserializer.deserializeBool() : false;\n    let claimOptions: ClaimOptions | undefined;\n    if (hasClaimOptions) {\n      const secretKey = deserializer.deserialize(Ed25519PrivateKey);\n      const network = deserializer.deserializeStr();\n      const asset = deserializer.deserializeOption('string');\n\n      if (!isSupportedNetwork(network)) {\n        throw new Error(`Unsupported network '${network}'`);\n      }\n\n      claimOptions = { asset, network, secretKey };\n    }\n\n    return { claimOptions, dappEd25519PublicKeyB64, dappId, preferredWalletName };\n  }\n\n  // endregion\n\n  export function serialize(\n    dappInfo: DappInfo,\n    args: ConnectRequest.Args = {},\n  ): SerializedWalletRequest<RequestName, CurrentVersion> {\n    return serializeWalletRequestWithArgs({ args, dappInfo, name, version: currentVersion }, serializeArgs);\n  }\n\n  export function deserialize(request: SerializedWalletRequest<RequestName, SupportedVersions>): ConnectRequest {\n    return deserializeWalletRequestWithArgs(request, (d) => deserializeArgs(d, request.version));\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, SupportedVersions> {\n    return request.name === name && supportedVersions.includes(request.version as SupportedVersions);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { DappInfo, deserializeDappInfo, serializeDappInfo } from './shared';\nimport { DeserializeFn, SerializeFn } from './helpers';\n\nexport interface WalletRequest<RequestName extends string, Version extends number> {\n  dappInfo: DappInfo;\n  name: RequestName;\n  version: Version;\n}\n\nexport interface WalletRequestWithArgs<RequestName extends string, Version extends number, TArgs>\n  extends WalletRequest<RequestName, Version> {\n  args: TArgs;\n}\n\nexport interface SerializedWalletRequest<RequestName extends string = string, Version extends number = number> {\n  data: Uint8Array;\n  name: RequestName;\n  version: Version;\n}\n\nexport function serializeWalletRequest<RequestName extends string, Version extends number>({\n  dappInfo,\n  name,\n  version,\n}: WalletRequest<RequestName, Version>): SerializedWalletRequest<RequestName, Version> {\n  const serializer = new Serializer();\n  serializeDappInfo(serializer, dappInfo);\n  const data = serializer.toUint8Array();\n  return { data, name, version };\n}\n\nexport function deserializeWalletRequest<RequestName extends string, Version extends number>({\n  data,\n  name,\n  version,\n}: SerializedWalletRequest<RequestName, Version>): WalletRequest<RequestName, Version> {\n  const deserializer = new Deserializer(data);\n  const dappInfo = deserializeDappInfo(deserializer);\n  return { dappInfo, name, version };\n}\n\nexport function serializeWalletRequestWithArgs<RequestName extends string, Version extends number, TArgs>(\n  { args, dappInfo, name, version }: WalletRequestWithArgs<RequestName, Version, TArgs>,\n  serializeArgsFn: SerializeFn<TArgs>,\n): SerializedWalletRequest<RequestName, Version> {\n  const serializer = new Serializer();\n  serializeDappInfo(serializer, dappInfo);\n  serializeArgsFn(serializer, args);\n  const data = serializer.toUint8Array();\n  return { data, name, version };\n}\n\nexport function deserializeWalletRequestWithArgs<RequestName extends string, Version extends number, TArgs>(\n  { data, name, version }: SerializedWalletRequest<RequestName, Version>,\n  deserializeArgsFn: DeserializeFn<TArgs>,\n): WalletRequestWithArgs<RequestName, Version, TArgs> {\n  const deserializer = new Deserializer(data);\n  const dappInfo = deserializeDappInfo(deserializer);\n  const args = deserializeArgsFn(deserializer);\n  return { args, dappInfo, name, version };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddress, AccountAuthenticator, Deserializer, Serializer } from '@aptos-labs/ts-sdk';\n\nexport interface AccountAuthenticatorInput {\n  address: AccountAddress;\n  authenticator: AccountAuthenticator;\n}\n\nexport function serializeAccountAuthenticatorInput(serializer: Serializer, value: AccountAuthenticatorInput) {\n  serializer.serialize(value.address);\n  serializer.serialize(value.authenticator);\n}\n\nexport function deserializeAccountAuthenticatorInput(deserializer: Deserializer): AccountAuthenticatorInput {\n  const address = deserializer.deserialize(AccountAddress);\n  const authenticator = deserializer.deserialize(AccountAuthenticator);\n  return { address, authenticator };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddress, Deserializer, PublicKey, Serializer } from '@aptos-labs/ts-sdk';\nimport { deserializePublicKey, serializePublicKey } from './PublicKey';\n\nexport interface AccountInfo {\n  address: AccountAddress;\n  name?: string;\n  publicKey: PublicKey;\n}\n\nexport function serializeAccountInfo(serializer: Serializer, value: AccountInfo) {\n  serializer.serialize(value.address);\n  serializePublicKey(serializer, value.publicKey);\n  serializer.serializeStr(value.name ?? '');\n}\n\nexport function deserializeAccountInfo(deserializer: Deserializer): AccountInfo {\n  const address = deserializer.deserialize(AccountAddress);\n  const publicKey = deserializePublicKey(deserializer);\n  const name = deserializer.deserializeStr();\n  return {\n    address,\n    publicKey,\n    ...(name.length > 0 ? { name } : undefined),\n  };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AnyPublicKey,\n  Deserializer,\n  Ed25519PublicKey,\n  MultiEd25519PublicKey,\n  MultiKey,\n  PublicKey,\n  Serializer,\n  SigningScheme,\n} from '@aptos-labs/ts-sdk';\n\nexport function serializePublicKey(serializer: Serializer, value: PublicKey) {\n  if (value instanceof Ed25519PublicKey) {\n    serializer.serializeU32AsUleb128(SigningScheme.Ed25519);\n  } else if (value instanceof MultiEd25519PublicKey) {\n    serializer.serializeU32AsUleb128(SigningScheme.MultiEd25519);\n  } else if (value instanceof AnyPublicKey) {\n    serializer.serializeU32AsUleb128(SigningScheme.SingleKey);\n  } else if (value instanceof MultiKey) {\n    serializer.serializeU32AsUleb128(SigningScheme.MultiKey);\n  } else {\n    throw new Error('Unexpected public key type');\n  }\n  serializer.serialize(value);\n}\n\nexport function deserializePublicKey(deserializer: Deserializer): PublicKey {\n  const signingScheme = deserializer.deserializeUleb128AsU32();\n  switch (signingScheme) {\n    case SigningScheme.Ed25519:\n      return deserializer.deserialize(Ed25519PublicKey);\n    case SigningScheme.MultiEd25519:\n      return deserializer.deserialize(MultiEd25519PublicKey);\n    case SigningScheme.SingleKey:\n      return deserializer.deserialize(AnyPublicKey);\n    case SigningScheme.MultiKey:\n      return deserializer.deserialize(MultiKey);\n    default:\n      throw new Error(`Unknown signing scheme: ${signingScheme}`);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddress, Deserializer, PublicKey, Serializer } from '@aptos-labs/ts-sdk';\nimport { deserializePublicKey, serializePublicKey } from './PublicKey';\n\nexport interface AccountInput {\n  address: AccountAddress;\n  publicKey?: PublicKey;\n}\n\nexport function serializeAccountInput(serializer: Serializer, value: AccountInput) {\n  serializer.serialize(value.address);\n  serializer.serializeBool(value.publicKey !== undefined);\n  if (value.publicKey) {\n    serializePublicKey(serializer, value.publicKey);\n  }\n}\n\nexport function deserializeAccountInput(deserializer: Deserializer): AccountInput {\n  const address = deserializer.deserialize(AccountAddress);\n  const hasPublicKey = deserializer.deserializeBool();\n  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : undefined;\n  return { address, publicKey };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\n\nexport interface DappInfo {\n  domain: string;\n  imageURI?: string;\n  name: string;\n}\n\nexport function serializeDappInfo(serializer: Serializer, value: DappInfo) {\n  serializer.serializeStr(value.domain);\n  serializer.serializeStr(value.name);\n  serializer.serializeBool(value.imageURI !== undefined);\n  if (value.imageURI !== undefined) {\n    serializer.serializeStr(value.imageURI);\n  }\n}\n\nexport function deserializeDappInfo(deserializer: Deserializer): DappInfo {\n  const domain = deserializer.deserializeStr();\n  const name = deserializer.deserializeStr();\n  const hasImageUri = deserializer.deserializeBool();\n  const imageURI = hasImageUri ? deserializer.deserializeStr() : undefined;\n  return { domain, imageURI, name };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  Deserializer,\n  EntryFunctionArgumentTypes,\n  FixedBytes,\n  Serializer,\n  SimpleEntryFunctionArgumentTypes,\n} from '@aptos-labs/ts-sdk';\n\nexport type EntryFunctionArgument = EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes;\n\n/* eslint-disable @typescript-eslint/no-shadow */\nexport enum EntryFunctionArgumentVariant {\n  Undefined,\n  Array,\n  String,\n  Uint8Array,\n  AccountAddress,\n  FixedBytes,\n}\n\n/* eslint-enable @typescript-eslint/no-shadow */\n\nexport function serializeEntryFunctionArgument(serializer: Serializer, argument: EntryFunctionArgument) {\n  // undefined | null -> undefined\n  if (argument === undefined || argument === null) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.Undefined);\n    return;\n  }\n\n  // Array -> Array\n  if (Array.isArray(argument)) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.Array);\n    serializer.serializeU32AsUleb128(argument.length);\n    for (const subArgument of argument) {\n      serializeEntryFunctionArgument(serializer, subArgument);\n    }\n    return;\n  }\n\n  // boolean | number | bigint | string -> string\n  if (\n    typeof argument === 'string' ||\n    typeof argument === 'number' ||\n    typeof argument === 'boolean' ||\n    typeof argument === 'bigint'\n  ) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.String);\n    serializer.serializeStr(argument.toString());\n    return;\n  }\n\n  // Uint8Array -> Uint8Array\n  if (argument instanceof Uint8Array) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.Uint8Array);\n    serializer.serializeBytes(argument);\n    return;\n  }\n\n  // ArrayBuffer -> Uint8Array\n  if (argument instanceof ArrayBuffer) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.Uint8Array);\n    serializer.serializeBytes(new Uint8Array(argument));\n    return;\n  }\n\n  // MoveVector -> Array\n  if ('values' in argument) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.Array);\n    serializer.serializeU32AsUleb128(argument.values.length);\n    for (const subArgument of argument.values) {\n      serializeEntryFunctionArgument(serializer, subArgument);\n    }\n    return;\n  }\n\n  // AccountAddress -> AccountAddress\n  if ('data' in argument) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.AccountAddress);\n    serializer.serialize(argument);\n    return;\n  }\n\n  // Empty MoveOption -> undefined\n  if (argument.value === undefined) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.Undefined);\n    serializer.serialize(argument);\n    return;\n  }\n\n  // FixedBytes -> FixedBytes\n  if (argument.value instanceof Uint8Array) {\n    serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.FixedBytes);\n    serializer.serializeBytes(argument.value);\n    return;\n  }\n\n  // Bool | U8 | U16 | U32 | U64 | U128 | U256 | MoveString -> string\n  serializer.serializeU32AsUleb128(EntryFunctionArgumentVariant.String);\n  serializer.serializeStr(argument.value.toString());\n}\n\nexport function deserializeEntryFunctionArgument(deserializer: Deserializer): EntryFunctionArgument {\n  const variant = deserializer.deserializeUleb128AsU32() as EntryFunctionArgumentVariant;\n\n  switch (variant) {\n    // undefined | null | empty MoveOption\n    case EntryFunctionArgumentVariant.Undefined: {\n      return undefined;\n    }\n    // Array | MoveVector\n    case EntryFunctionArgumentVariant.Array: {\n      const length = deserializer.deserializeUleb128AsU32();\n      const args: (EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes)[] = [];\n      for (let i = 0; i < length; i += 1) {\n        const argument = deserializeEntryFunctionArgument(deserializer);\n        args.push(argument);\n      }\n      return args;\n    }\n    // Uint8Array | ArrayBuffer | FixedBytes\n    case EntryFunctionArgumentVariant.Uint8Array: {\n      return deserializer.deserializeBytes();\n    }\n    // AccountAddress\n    case EntryFunctionArgumentVariant.AccountAddress: {\n      return deserializer.deserialize(AccountAddress);\n    }\n    // Bool | U8 | U16 | U32 | U64 | U128 | U256 | MoveString\n    case EntryFunctionArgumentVariant.String: {\n      return deserializer.deserializeStr();\n    }\n    // FixedBytes (custom serialization)\n    case EntryFunctionArgumentVariant.FixedBytes: {\n      const bytes = deserializer.deserializeBytes();\n      return new FixedBytes(bytes);\n    }\n    default: {\n      throw new Error('Unexpected variant');\n    }\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AnySignature,\n  Deserializer,\n  Ed25519Signature,\n  MultiEd25519Signature,\n  // This type got renamed in the zeta branch, commenting out until it's synced with main\n  // MultiSignature,\n  Serializer,\n  Signature,\n  SigningScheme,\n} from '@aptos-labs/ts-sdk';\n\nexport function serializeSignature(serializer: Serializer, value: Signature) {\n  if (value instanceof Ed25519Signature) {\n    serializer.serializeU32AsUleb128(SigningScheme.Ed25519);\n  } else if (value instanceof MultiEd25519Signature) {\n    serializer.serializeU32AsUleb128(SigningScheme.MultiEd25519);\n  } else if (value instanceof AnySignature) {\n    serializer.serializeU32AsUleb128(SigningScheme.SingleKey);\n    // } else if (value instanceof MultiSignature) {\n    //   serializer.serializeU32AsUleb128(SigningScheme.MultiKey);\n  } else {\n    throw new Error('Unexpected signature type');\n  }\n  serializer.serialize(value);\n}\n\nexport function deserializeSignature(deserializer: Deserializer) {\n  const signingScheme = deserializer.deserializeUleb128AsU32();\n  switch (signingScheme) {\n    case SigningScheme.Ed25519:\n      return deserializer.deserialize(Ed25519Signature);\n    case SigningScheme.MultiEd25519:\n      return deserializer.deserialize(MultiEd25519Signature);\n    case SigningScheme.SingleKey:\n      return deserializer.deserialize(AnySignature);\n    // case SigningScheme.MultiKey:\n    //   return deserializer.deserialize(MultiSignature);\n    default:\n      throw new Error(`Unknown signing scheme: ${signingScheme}`);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  deserializeFromScriptArgument,\n  Deserializer,\n  Hex,\n  InputGenerateTransactionPayloadData,\n  MoveFunctionId,\n  parseTypeTag,\n  ScriptFunctionArgumentTypes,\n  Serializer,\n  TypeArgument,\n  TypeTag,\n} from '@aptos-labs/ts-sdk';\nimport {\n  deserializeEntryFunctionArgument,\n  EntryFunctionArgument,\n  serializeEntryFunctionArgument,\n} from './EntryFunctionArgument';\n\nexport enum TransactionPayloadInputVariant {\n  EntryFunction,\n  Script,\n  Multisig,\n}\n\n// region Utils\n\nfunction serializeTypeArguments(serializer: Serializer, typeArguments: TypeArgument[]) {\n  serializer.serializeU32AsUleb128(typeArguments.length);\n  for (const typeArgument of typeArguments) {\n    const typeTag =\n      typeof typeArgument === 'string' ? parseTypeTag(typeArgument, { allowGenerics: true }) : typeArgument;\n    serializer.serialize(typeTag);\n  }\n}\n\nfunction deserializeTypeArguments(deserializer: Deserializer) {\n  const typeArguments: TypeTag[] = [];\n  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();\n  for (let i = 0; i < typeArgumentsLength; i += 1) {\n    const typeTag = deserializer.deserialize(TypeTag);\n    typeArguments.push(typeTag);\n  }\n  return typeArguments;\n}\n\nfunction serializeEntryFunctionArguments(serializer: Serializer, functionArguments: EntryFunctionArgument[]) {\n  serializer.serializeU32AsUleb128(functionArguments.length);\n  for (const functionArgument of functionArguments) {\n    serializeEntryFunctionArgument(serializer, functionArgument);\n  }\n}\n\nfunction deserializeEntryFunctionArguments(deserializer: Deserializer) {\n  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();\n  const functionArguments: EntryFunctionArgument[] = [];\n  for (let i = 0; i < functionArgumentsLength; i += 1) {\n    const functionArgument = deserializeEntryFunctionArgument(deserializer);\n    functionArguments.push(functionArgument);\n  }\n  return functionArguments;\n}\n\n// endregion\n\nexport function serializeTransactionPayloadInput(serializer: Serializer, value: InputGenerateTransactionPayloadData) {\n  if ('multisigAddress' in value) {\n    serializer.serializeU32AsUleb128(TransactionPayloadInputVariant.Multisig);\n    serializer.serializeStr(value.function);\n    serializeEntryFunctionArguments(serializer, value.functionArguments);\n    serializeTypeArguments(serializer, value.typeArguments ?? []);\n    const multisigAddress = AccountAddress.from(value.multisigAddress);\n    serializer.serialize(multisigAddress);\n  } else if ('function' in value) {\n    serializer.serializeU32AsUleb128(TransactionPayloadInputVariant.EntryFunction);\n    serializer.serializeStr(value.function);\n    serializeEntryFunctionArguments(serializer, value.functionArguments);\n    serializeTypeArguments(serializer, value.typeArguments ?? []);\n    // TODO: possibly serialize ABI?\n  } else {\n    serializer.serializeU32AsUleb128(TransactionPayloadInputVariant.Script);\n    const bytecode = Hex.fromHexInput(value.bytecode);\n    serializer.serializeBytes(bytecode.toUint8Array());\n    serializer.serializeU32AsUleb128(value.functionArguments.length);\n    for (const argument of value.functionArguments) {\n      argument.serializeForScriptFunction(serializer);\n    }\n    serializeTypeArguments(serializer, value.typeArguments ?? []);\n  }\n}\n\nexport function deserializeTransactionPayloadInput(deserializer: Deserializer): InputGenerateTransactionPayloadData {\n  const variant = deserializer.deserializeUleb128AsU32();\n  switch (variant) {\n    case TransactionPayloadInputVariant.Multisig: {\n      const functionId = deserializer.deserializeStr() as MoveFunctionId;\n      const functionArguments = deserializeEntryFunctionArguments(deserializer);\n      const typeArguments = deserializeTypeArguments(deserializer);\n      const multisigAddress = deserializer.deserialize(AccountAddress);\n      return {\n        function: functionId,\n        functionArguments,\n        multisigAddress,\n        typeArguments,\n      };\n    }\n    case TransactionPayloadInputVariant.EntryFunction: {\n      const functionId = deserializer.deserializeStr() as MoveFunctionId;\n      const functionArguments = deserializeEntryFunctionArguments(deserializer);\n      const typeArguments = deserializeTypeArguments(deserializer);\n      return {\n        function: functionId,\n        functionArguments,\n        typeArguments,\n      };\n    }\n    case TransactionPayloadInputVariant.Script: {\n      const bytecode = deserializer.deserializeBytes();\n      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();\n      const functionArguments: ScriptFunctionArgumentTypes[] = [];\n      for (let i = 0; i < functionArgumentsLength; i += 1) {\n        const argument = deserializeFromScriptArgument(deserializer);\n        functionArguments.push(argument as ScriptFunctionArgumentTypes);\n      }\n      const typeArguments = deserializeTypeArguments(deserializer);\n      return {\n        bytecode,\n        functionArguments,\n        typeArguments,\n      };\n    }\n    default: {\n      throw new Error('Unexpected variant');\n    }\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { DeserializeFn, SerializeFn } from './helpers';\n\nexport interface UserApproval<TApprovalArgs> {\n  args: TApprovalArgs;\n  status: 'approved';\n}\n\nexport interface UserDismissal {\n  status: 'dismissed';\n}\n\nexport type UserResponse<TApprovalArgs> = UserApproval<TApprovalArgs> | UserDismissal;\n\nexport function makeUserApproval<TApprovalArgs>(args: TApprovalArgs): UserApproval<TApprovalArgs> {\n  return { args, status: 'approved' };\n}\n\nexport function makeUserResponseSerializeFn<TArgs>(\n  serializeArgs: SerializeFn<TArgs>,\n): SerializeFn<UserResponse<TArgs>> {\n  return (serializer: Serializer, value: UserResponse<TArgs>) => {\n    serializer.serializeBool(value.status === 'approved');\n    if (value.status === 'approved') {\n      serializeArgs(serializer, value.args);\n    }\n  };\n}\n\nexport function makeUserResponseDeserializeFn<TArgs>(\n  deserializeArgs: DeserializeFn<TArgs>,\n): DeserializeFn<UserResponse<TArgs>> {\n  return (deserializer: Deserializer) => {\n    const isApproved = deserializer.deserializeBool();\n    return isApproved ? { args: deserializeArgs(deserializer), status: 'approved' } : { status: 'dismissed' };\n  };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { DeserializeFn, SerializeFn } from './helpers';\n\nexport interface WalletResponseWithArgs<TResponseArgs> {\n  args: TResponseArgs;\n}\n\nexport interface SerializedWalletResponse {\n  data: Uint8Array;\n}\n\nexport function serializeWalletResponse<TArgs>(args: TArgs, serializeFn: SerializeFn<TArgs>): SerializedWalletResponse {\n  const serializer = new Serializer();\n  serializeFn(serializer, args);\n  const data = serializer.toUint8Array();\n  return { data };\n}\n\nexport function deserializeWalletResponse<TArgs>(\n  { data }: SerializedWalletResponse,\n  deserializeFn: DeserializeFn<TArgs>,\n): WalletResponseWithArgs<TArgs> {\n  const deserializer = new Deserializer(data);\n  const args = deserializeFn(deserializer);\n  return { args };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { FinalizedPairingData, SerializedDate } from '@identity-connect/api';\nimport { type AccountInfo, deserializeAccountInfo, serializeAccountInfo } from '../../shared';\nimport { makeUserResponseDeserializeFn, makeUserResponseSerializeFn, UserResponse } from '../../UserResponse';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface ConnectResponse extends WalletResponseWithArgs<ConnectResponse.Args> {}\n\nexport namespace ConnectResponse {\n  export const supportedVersions = [1, 2] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n  export const currentVersion = 2 as const;\n\n  // region ApprovalArgs\n\n  export interface ApprovalArgs {\n    account: AccountInfo;\n    pairing?: SerializedDate<FinalizedPairingData>;\n  }\n\n  function serializeApprovalArgsV1(serializer: Serializer, value: ApprovalArgs) {\n    serializeAccountInfo(serializer, value.account);\n  }\n\n  function serializeApprovalArgs(serializer: Serializer, value: ApprovalArgs) {\n    serializeAccountInfo(serializer, value.account);\n    serializer.serializeOptionStr(value.pairing !== undefined ? JSON.stringify(value.pairing) : undefined);\n  }\n\n  function deserializeApprovalArgs(deserializer: Deserializer): ApprovalArgs {\n    const account = deserializeAccountInfo(deserializer);\n    const serializedPairing = deserializer.deserializeOption('string');\n    const pairing = serializedPairing !== undefined ? JSON.parse(serializedPairing) : undefined;\n    return { account, pairing };\n  }\n\n  // endregion\n\n  // region ResponseArgs\n\n  export type Args = UserResponse<ApprovalArgs>;\n\n  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);\n  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);\n  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);\n\n  // endregion\n\n  type _Response = ConnectResponse;\n\n  export function serialize(args: Args, version: SupportedVersions = currentVersion): SerializedWalletResponse {\n    return serializeWalletResponse(args, version === 1 ? serializeArgsV1 : serializeArgs);\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { DappInfo } from '../../shared';\nimport {\n  deserializeWalletRequest,\n  SerializedWalletRequest,\n  serializeWalletRequest,\n  WalletRequest,\n} from '../../WalletRequest';\n\nexport interface DisconnectRequest\n  extends WalletRequest<DisconnectRequest.RequestName, DisconnectRequest.CurrentVersion> {}\n\nexport namespace DisconnectRequest {\n  export const name = 'disconnect' as const;\n  export type RequestName = typeof name;\n\n  export const currentVersion = 1 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  export function serialize(dappInfo: DappInfo): SerializedWalletRequest<RequestName, CurrentVersion> {\n    return serializeWalletRequest({ dappInfo, name, version: currentVersion });\n  }\n\n  export function deserialize(request: SerializedWalletRequest<RequestName, CurrentVersion>): DisconnectRequest {\n    return deserializeWalletRequest(request);\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, CurrentVersion> {\n    return request.name === name && request.version === currentVersion;\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface DisconnectResponse extends WalletResponseWithArgs<DisconnectResponse.Args> {}\n\nexport namespace DisconnectResponse {\n  export type Args = {};\n  type _Response = DisconnectResponse;\n\n  export function serialize(args: Args): SerializedWalletResponse {\n    return serializeWalletResponse(args, () => {});\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, () => ({}));\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { AptosSignInInput } from '@aptos-labs/wallet-standard';\n\nexport function serializeAptosSignInInput(serializer: Serializer, value: AptosSignInInput) {\n  serializer.serializeStr(JSON.stringify(value));\n}\n\nexport function deserializeAptosSignInInput(deserializer: Deserializer): AptosSignInInput {\n  return JSON.parse(deserializer.deserializeStr());\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Network, Serializer } from '@aptos-labs/ts-sdk';\nimport { AptosSignInInput } from '@aptos-labs/wallet-standard';\nimport { DappInfo } from '../../shared';\nimport {\n  deserializeWalletRequestWithArgs,\n  SerializedWalletRequest,\n  serializeWalletRequestWithArgs,\n  WalletRequest,\n} from '../../WalletRequest';\nimport { deserializeAptosSignInInput, serializeAptosSignInInput } from '../../shared/AptosSignInInput';\nimport { isSupportedNetwork } from '../../helpers';\n\nexport interface SignInRequest extends WalletRequest<SignInRequest.RequestName, SignInRequest.SupportedVersions> {\n  args: SignInRequest.Args;\n}\n\nexport namespace SignInRequest {\n  export const name = 'signIn' as const;\n  export type RequestName = typeof name;\n\n  export const supportedVersions = [1, 2] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n\n  export const currentVersion = 2 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  // region Args\n\n  export type Args = AptosSignInInput & {\n    network: Network;\n  };\n\n  export function serializeArgs(serializer: Serializer, value: Args) {\n    if (value.network !== undefined && !isSupportedNetwork(value.network)) {\n      throw new Error(`Unsupported network '${value.network}' in SignInRequest.serializeArgs`);\n    }\n\n    serializeAptosSignInInput(serializer, value);\n    serializer.serializeStr(value.network);\n  }\n\n  export function deserializeArgs(deserializer: Deserializer, _: SupportedVersions): Args {\n    return { ...deserializeAptosSignInInput(deserializer), network: deserializer.deserializeStr() as Network };\n  }\n\n  // endregion\n\n  export function serialize(\n    dappInfo: DappInfo,\n    args: SignInRequest.Args,\n  ): SerializedWalletRequest<RequestName, CurrentVersion> {\n    return serializeWalletRequestWithArgs({ args, dappInfo, name, version: currentVersion }, serializeArgs);\n  }\n\n  export function deserialize(request: SerializedWalletRequest<RequestName, SupportedVersions>): SignInRequest {\n    return deserializeWalletRequestWithArgs(request, (d) => deserializeArgs(d, request.version));\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, SupportedVersions> {\n    return request.name === name && supportedVersions.includes(request.version as SupportedVersions);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { AccountInfo, AptosSignInOutput } from '@aptos-labs/wallet-standard';\nimport { deserializeSignature, serializeSignature } from './Signature';\nimport { serializeAccountInfo, deserializeAccountInfo } from './AccountInfo';\n\nexport function serializeAptosSignInOutputV1(\n  serializer: Serializer,\n  value: AptosSignInOutput & { plainText: string; signingMessage: Uint8Array },\n) {\n  serializeAccountInfo(serializer, value.account);\n  serializer.serializeStr(JSON.stringify(value.input));\n  serializer.serializeStr(value.plainText);\n  serializeSignature(serializer, value.signature);\n  serializer.serializeBytes(value.signingMessage);\n  serializer.serializeStr(value.type);\n}\n\nexport function deserializeAptosSignInOutputV1(\n  deserializer: Deserializer,\n): AptosSignInOutput & { plainText: string; signingMessage: Uint8Array } {\n  return {\n    account: new AccountInfo(deserializeAccountInfo(deserializer)),\n    input: JSON.parse(deserializer.deserializeStr()),\n    plainText: deserializer.deserializeStr(),\n    signature: deserializeSignature(deserializer),\n    signingMessage: deserializer.deserializeBytes(),\n    type: deserializer.deserializeStr(),\n  };\n}\n\nexport function serializeAptosSignInOutput(serializer: Serializer, value: AptosSignInOutput) {\n  serializeAccountInfo(serializer, value.account);\n  serializer.serializeStr(JSON.stringify(value.input));\n  serializeSignature(serializer, value.signature);\n  serializer.serializeStr(value.type);\n}\n\nexport function deserializeAptosSignInOutput(deserializer: Deserializer): AptosSignInOutput {\n  return {\n    account: new AccountInfo(deserializeAccountInfo(deserializer)),\n    input: JSON.parse(deserializer.deserializeStr()),\n    signature: deserializeSignature(deserializer),\n    type: deserializer.deserializeStr(),\n  };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { AptosSignInOutput } from '@aptos-labs/wallet-standard';\nimport { makeUserResponseDeserializeFn, makeUserResponseSerializeFn, UserResponse } from '../../UserResponse';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\nimport {\n  deserializeAptosSignInOutput,\n  deserializeAptosSignInOutputV1,\n  serializeAptosSignInOutput,\n  serializeAptosSignInOutputV1,\n} from '../../shared/AptosSignInOutput';\n\nexport interface SignInResponse extends WalletResponseWithArgs<SignInResponse.Args> {}\n\nexport namespace SignInResponse {\n  export const supportedVersions = [1, 2] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n\n  export const currentVersion = 2 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  // region ApprovalArgs\n\n  export interface ApprovalArgsV1 extends AptosSignInOutput {\n    plainText: string;\n    signingMessage: Uint8Array;\n  }\n\n  export interface ApprovalArgs extends AptosSignInOutput {}\n\n  function serializeApprovalArgsV1(serializer: Serializer, value: ApprovalArgsV1) {\n    serializeAptosSignInOutputV1(serializer, value);\n  }\n\n  function deserializeApprovalArgsV1(deserializer: Deserializer): ApprovalArgsV1 {\n    return deserializeAptosSignInOutputV1(deserializer);\n  }\n\n  function serializeApprovalArgs(serializer: Serializer, value: ApprovalArgs) {\n    serializeAptosSignInOutput(serializer, value);\n  }\n\n  function deserializeApprovalArgs(deserializer: Deserializer): ApprovalArgs {\n    return deserializeAptosSignInOutput(deserializer);\n  }\n\n  // endregion\n\n  // region ResponseArgs\n\n  export type Args = UserResponse<ApprovalArgs>;\n\n  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);\n  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);\n\n  const deserializeArgsV1 = makeUserResponseDeserializeFn(deserializeApprovalArgsV1);\n  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);\n\n  // endregion\n\n  type _Response = SignInResponse;\n\n  export function serialize(args: Args, version: SupportedVersions = currentVersion): SerializedWalletResponse {\n    return serializeWalletResponse(args as any, version === 1 ? serializeArgsV1 : serializeArgs);\n  }\n\n  export function deserialize(\n    serializedResponse: SerializedWalletResponse,\n    version: SupportedVersions = currentVersion,\n  ): _Response {\n    return deserializeWalletResponse(serializedResponse, version === 1 ? deserializeArgsV1 : deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { DappInfo } from '../../shared';\nimport {\n  deserializeWalletRequest,\n  SerializedWalletRequest,\n  serializeWalletRequest,\n  WalletRequest,\n} from '../../WalletRequest';\n\nexport interface GetConnectedAccountsRequest\n  extends WalletRequest<GetConnectedAccountsRequest.RequestName, GetConnectedAccountsRequest.CurrentVersion> {}\n\nexport namespace GetConnectedAccountsRequest {\n  export const name = 'getConnectedAccounts' as const;\n  export type RequestName = typeof name;\n\n  export const currentVersion = 1 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  export function serialize(dappInfo: DappInfo): SerializedWalletRequest<RequestName, CurrentVersion> {\n    return serializeWalletRequest({ dappInfo, name, version: currentVersion });\n  }\n\n  export function deserialize(\n    request: SerializedWalletRequest<RequestName, CurrentVersion>,\n  ): GetConnectedAccountsRequest {\n    return deserializeWalletRequest(request);\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, CurrentVersion> {\n    return request.name === name && request.version === currentVersion;\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { type AccountInfo, deserializeAccountInfo, serializeAccountInfo } from '../../shared';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface GetConnectedAccountsResponse extends WalletResponseWithArgs<GetConnectedAccountsResponse.Args> {}\n\nexport namespace GetConnectedAccountsResponse {\n  // region Args\n\n  export type Args = AccountInfo[];\n\n  function serializeArgs(serializer: Serializer, args: Args) {\n    serializer.serializeU32AsUleb128(args.length);\n    for (const account of args) {\n      serializeAccountInfo(serializer, account);\n    }\n  }\n\n  function deserializeArgs(deserializer: Deserializer): Args {\n    const length = deserializer.deserializeUleb128AsU32();\n\n    const accounts: AccountInfo[] = [];\n    for (let i = 0; i < length; i += 1) {\n      accounts.push(deserializeAccountInfo(deserializer));\n    }\n\n    return accounts;\n  }\n\n  // endregion\n\n  type _Response = GetConnectedAccountsResponse;\n\n  export function serialize(args: Args): SerializedWalletResponse {\n    return serializeWalletResponse(args, serializeArgs);\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { DappInfo } from '../../shared';\nimport {\n  deserializeWalletRequest,\n  SerializedWalletRequest,\n  serializeWalletRequest,\n  WalletRequest,\n} from '../../WalletRequest';\n\nexport interface IsConnectedRequest\n  extends WalletRequest<IsConnectedRequest.RequestName, IsConnectedRequest.CurrentVersion> {}\n\nexport namespace IsConnectedRequest {\n  export const name = 'isConnected' as const;\n  export type RequestName = typeof name;\n\n  export const currentVersion = 1 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  export function serialize(dappInfo: DappInfo): SerializedWalletRequest<RequestName, CurrentVersion> {\n    return serializeWalletRequest({ dappInfo, name, version: currentVersion });\n  }\n\n  export function deserialize(request: SerializedWalletRequest<RequestName, CurrentVersion>): IsConnectedRequest {\n    return deserializeWalletRequest(request);\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, CurrentVersion> {\n    return request.name === name && request.version === currentVersion;\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface IsConnectedResponse extends WalletResponseWithArgs<IsConnectedResponse.Args> {}\n\nexport namespace IsConnectedResponse {\n  // region Args\n\n  export type Args = boolean;\n\n  function serializeArgs(serializer: Serializer, value: Args) {\n    serializer.serializeBool(value);\n  }\n\n  function deserializeArgs(deserializer: Deserializer): Args {\n    return deserializer.deserializeBool();\n  }\n\n  // endregion\n\n  type _Response = IsConnectedResponse;\n\n  export function serialize(args: Args): SerializedWalletResponse {\n    return serializeWalletResponse(args, serializeArgs);\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  Deserializer,\n  InputGenerateTransactionPayloadData,\n  Network,\n  Serializer,\n  TransactionPayload,\n} from '@aptos-labs/ts-sdk';\nimport { isSupportedNetwork } from '../../helpers';\nimport {\n  AccountAuthenticatorInput,\n  DappInfo,\n  deserializeAccountAuthenticatorInput,\n  deserializeTransactionPayloadInput,\n  serializeAccountAuthenticatorInput,\n  serializeTransactionPayloadInput,\n} from '../../shared';\nimport {\n  deserializeWalletRequestWithArgs,\n  SerializedWalletRequest,\n  serializeWalletRequestWithArgs,\n  WalletRequest,\n} from '../../WalletRequest';\n\nexport interface SignAndSubmitTransactionRequest\n  extends WalletRequest<\n    SignAndSubmitTransactionRequest.RequestName,\n    SignAndSubmitTransactionRequest.SupportedVersions\n  > {\n  args: SignAndSubmitTransactionRequest.Args;\n}\n\nexport namespace SignAndSubmitTransactionRequest {\n  export const name = 'signAndSubmitTransaction' as const;\n  export type RequestName = typeof name;\n\n  export const supportedVersions = [1, 2, 3] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n  export const currentVersion = 3 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  // region Args\n\n  export interface Args {\n    expirationTimestamp?: number;\n    feePayer?: AccountAuthenticatorInput;\n    gasUnitPrice?: number;\n    maxGasAmount?: number;\n    network?: Network;\n    payload: TransactionPayload | InputGenerateTransactionPayloadData;\n    signerAddress?: AccountAddress;\n  }\n\n  export function serializeArgs(serializer: Serializer, value: Args) {\n    if (value.network !== undefined && !isSupportedNetwork(value.network)) {\n      throw new Error(`Unsupported network '${value.network}'`);\n    }\n\n    serializer.serializeBool(value.signerAddress !== undefined);\n    if (value.signerAddress !== undefined) {\n      serializer.serialize(value.signerAddress);\n    }\n\n    serializer.serializeOptionStr(value.network);\n\n    if ('bcsToBytes' in value.payload) {\n      serializer.serializeBool(true);\n      serializer.serialize(value.payload);\n    } else {\n      serializer.serializeBool(false);\n      serializeTransactionPayloadInput(serializer, value.payload);\n    }\n\n    serializer.serializeU64(value.expirationTimestamp ?? 0);\n    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);\n    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);\n    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);\n    if (value.feePayer) {\n      serializeAccountAuthenticatorInput(serializer, value.feePayer);\n    }\n  }\n\n  export function deserializeArgs(deserializer: Deserializer, version: SupportedVersions): Args {\n    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();\n    const signerAddress = hasSignerAddress ? deserializer.deserialize(AccountAddress) : undefined;\n\n    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption('string');\n    if (network !== undefined && !isSupportedNetwork(network)) {\n      throw new Error(`Unsupported network '${network}'`);\n    }\n\n    const isPayloadBcsSerializable = version === 1 || deserializer.deserializeBool();\n    const payload = isPayloadBcsSerializable\n      ? deserializer.deserialize(TransactionPayload)\n      : deserializeTransactionPayloadInput(deserializer);\n    const expirationTimestamp = Number(deserializer.deserializeU64());\n    const gasUnitPrice = deserializer.deserializeUleb128AsU32();\n    const maxGasAmount = deserializer.deserializeUleb128AsU32();\n    const hasFeePayer = deserializer.deserializeUleb128AsU32();\n    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : undefined;\n\n    return {\n      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : undefined,\n      feePayer,\n      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : undefined,\n      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : undefined,\n      network,\n      payload,\n      signerAddress,\n    };\n  }\n\n  // endregion\n\n  // region Request\n\n  export function serialize(dappInfo: DappInfo, args: Args): SerializedWalletRequest<RequestName, CurrentVersion> {\n    const request = { args, dappInfo, name, version: currentVersion };\n    return serializeWalletRequestWithArgs(request, serializeArgs);\n  }\n\n  export function deserialize(\n    serializedRequest: SerializedWalletRequest<RequestName, SupportedVersions>,\n  ): SignAndSubmitTransactionRequest {\n    return deserializeWalletRequestWithArgs(serializedRequest, (deserializer) =>\n      deserializeArgs(deserializer, serializedRequest.version),\n    );\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, SupportedVersions> {\n    return request.name === name && supportedVersions.includes(request.version as SupportedVersions);\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { makeUserResponseDeserializeFn, makeUserResponseSerializeFn, UserResponse } from '../../UserResponse';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface SignAndSubmitTransactionResponse\n  extends WalletResponseWithArgs<SignAndSubmitTransactionResponse.Args> {}\n\nexport namespace SignAndSubmitTransactionResponse {\n  // region ApprovalArgs\n\n  export interface ApprovalArgs {\n    txnHash: string;\n  }\n\n  function serializeApprovalArgs(serializer: Serializer, value: ApprovalArgs) {\n    serializer.serializeStr(value.txnHash);\n  }\n\n  function deserializeApprovalArgs(deserializer: Deserializer): ApprovalArgs {\n    const txnHash = deserializer.deserializeStr();\n    return { txnHash };\n  }\n\n  // endregion\n\n  // region ResponseArgs\n\n  export type Args = UserResponse<ApprovalArgs>;\n\n  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);\n  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);\n\n  // endregion\n\n  type _Response = SignAndSubmitTransactionResponse;\n\n  export function serialize(args: Args): SerializedWalletResponse {\n    return serializeWalletResponse(args, serializeArgs);\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { AccountAddress, Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { DappInfo } from '../../shared';\nimport {\n  deserializeWalletRequestWithArgs,\n  SerializedWalletRequest,\n  serializeWalletRequestWithArgs,\n  WalletRequest,\n} from '../../WalletRequest';\n\nexport interface SignMessageRequest\n  extends WalletRequest<SignMessageRequest.RequestName, SignMessageRequest.SupportedVersions> {\n  args: SignMessageRequest.Args;\n}\n\nexport namespace SignMessageRequest {\n  export const name = 'signMessage' as const;\n  export type RequestName = typeof name;\n\n  export const supportedVersions = [1, 2] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n  export const currentVersion = 2 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  // region Args\n\n  export interface Args {\n    chainId: number;\n    message: Uint8Array;\n    nonce: Uint8Array;\n    signerAddress?: AccountAddress;\n  }\n\n  function serializeArgs(serializer: Serializer, value: Args) {\n    serializer.serializeBool(value.signerAddress !== undefined);\n    if (value.signerAddress !== undefined) {\n      serializer.serialize(value.signerAddress);\n    }\n    serializer.serializeU8(value.chainId);\n    serializer.serializeBytes(value.nonce);\n    serializer.serializeBytes(value.message);\n  }\n\n  function deserializeArgs(deserializer: Deserializer, version: SupportedVersions): Args {\n    const hasSignerAddress = version >= 2 && deserializer.deserializeBool();\n    const signerAddress = hasSignerAddress ? deserializer.deserialize(AccountAddress) : undefined;\n    const chainId = deserializer.deserializeU8();\n    const nonce = deserializer.deserializeBytes();\n    const message = deserializer.deserializeBytes();\n    return { chainId, message, nonce, signerAddress };\n  }\n\n  // endregion\n\n  // region Request\n\n  export function serialize(dappInfo: DappInfo, args: Args): SerializedWalletRequest<RequestName, CurrentVersion> {\n    const request = { args, dappInfo, name, version: currentVersion };\n    return serializeWalletRequestWithArgs(request, serializeArgs);\n  }\n\n  export function deserialize(\n    serializedRequest: SerializedWalletRequest<RequestName, SupportedVersions>,\n  ): SignMessageRequest {\n    return deserializeWalletRequestWithArgs(serializedRequest, (d) => deserializeArgs(d, serializedRequest.version));\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, SupportedVersions> {\n    return request.name === name && request.version === currentVersion;\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { Deserializer, Serializer, Signature } from '@aptos-labs/ts-sdk';\nimport { deserializeSignature, serializeSignature } from '../../shared';\nimport { makeUserResponseDeserializeFn, makeUserResponseSerializeFn, UserResponse } from '../../UserResponse';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface SignMessageResponse extends WalletResponseWithArgs<SignMessageResponse.Args> {}\n\nexport namespace SignMessageResponse {\n  // region ApprovalArgs\n\n  export interface ApprovalArgs {\n    // Should return message parts\n    fullMessage: string;\n    signature: Signature;\n  }\n\n  function serializeApprovalArgs(serializer: Serializer, value: ApprovalArgs) {\n    serializer.serializeStr(value.fullMessage);\n    serializeSignature(serializer, value.signature);\n  }\n\n  function deserializeApprovalArgs(deserializer: Deserializer): ApprovalArgs {\n    const fullMessage = deserializer.deserializeStr();\n    const signature = deserializeSignature(deserializer);\n    return { fullMessage, signature };\n  }\n\n  // endregion\n\n  // region ResponseArgs\n\n  export type Args = UserResponse<ApprovalArgs>;\n\n  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);\n  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);\n\n  // endregion\n\n  type _Response = SignMessageResponse;\n\n  export function serialize(args: Args): SerializedWalletResponse {\n    return serializeWalletResponse(args, serializeArgs);\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport {\n  AccountAddress,\n  Deserializer,\n  InputGenerateTransactionPayloadData,\n  Network,\n  PublicKey,\n  RawTransaction,\n  Serializer,\n  TransactionPayload,\n} from '@aptos-labs/ts-sdk';\nimport { chainIdToNetwork, isSupportedNetwork } from '../../helpers';\nimport {\n  AccountInput,\n  DappInfo,\n  deserializeAccountInput,\n  deserializeTransactionPayloadInput,\n  serializeAccountInput,\n  serializeTransactionPayloadInput,\n} from '../../shared';\nimport {\n  deserializeWalletRequestWithArgs,\n  SerializedWalletRequest,\n  serializeWalletRequestWithArgs,\n  WalletRequest,\n} from '../../WalletRequest';\n\nexport interface SignTransactionRequest\n  extends WalletRequest<SignTransactionRequest.RequestName, SignTransactionRequest.SupportedVersions> {\n  args: SignTransactionRequest.Args;\n}\n\nexport namespace SignTransactionRequest {\n  export const name = 'signTransaction' as const;\n  export type RequestName = typeof name;\n\n  export const supportedVersions = [1, 2, 3, 4] as const;\n  export type SupportedVersions = (typeof supportedVersions)[number];\n  export const currentVersion = 4 as const;\n  export type CurrentVersion = typeof currentVersion;\n\n  // region Args\n\n  export interface Args {\n    expirationSecondsFromNow?: number;\n    expirationTimestamp?: number;\n    feePayer?: AccountInput;\n    gasUnitPrice?: number;\n    maxGasAmount?: number;\n    network?: Network;\n    payload: TransactionPayload | InputGenerateTransactionPayloadData;\n    secondarySigners?: AccountInput[];\n    sender?: AccountInput;\n    sequenceNumber?: number | bigint;\n    signerAddress?: AccountAddress;\n  }\n\n  export interface ArgsWithTransaction {\n    feePayer?: AccountInput;\n    secondarySigners?: AccountInput[];\n    senderPublicKey?: PublicKey;\n    signerAddress?: AccountAddress;\n    transaction: RawTransaction;\n  }\n\n  export function normalizeArgs(args: ArgsWithTransaction): Args {\n    const { feePayer, secondarySigners, senderPublicKey, signerAddress, transaction } = args;\n\n    const sender: AccountInput = {\n      address: transaction.sender,\n      publicKey: senderPublicKey,\n    };\n\n    const network = chainIdToNetwork(args.transaction.chain_id.chainId);\n\n    return {\n      expirationTimestamp: Number(transaction.expiration_timestamp_secs),\n      feePayer,\n      gasUnitPrice: Number(transaction.gas_unit_price),\n      maxGasAmount: Number(transaction.max_gas_amount),\n      network,\n      payload: transaction.payload,\n      secondarySigners,\n      sender,\n      signerAddress,\n    };\n  }\n\n  function serializeArgs(serializer: Serializer, value: Args) {\n    if (value.network !== undefined && !isSupportedNetwork(value.network)) {\n      throw new Error(`Unsupported network '${value.network}'`);\n    }\n\n    serializer.serializeBool(value.signerAddress !== undefined);\n    if (value.signerAddress !== undefined) {\n      serializer.serialize(value.signerAddress);\n    }\n\n    serializer.serializeOptionStr(value.network);\n    serializer.serializeBool(value.sender !== undefined);\n    if (value.sender !== undefined) {\n      serializeAccountInput(serializer, value.sender);\n    }\n\n    if ('bcsToBytes' in value.payload) {\n      serializer.serializeBool(true);\n      serializer.serialize(value.payload);\n    } else {\n      serializer.serializeBool(false);\n      serializeTransactionPayloadInput(serializer, value.payload);\n    }\n\n    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);\n    serializer.serializeU64(value.expirationTimestamp ?? 0);\n    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);\n    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);\n\n    serializer.serializeBool(value.feePayer !== undefined);\n    if (value.feePayer !== undefined) {\n      serializeAccountInput(serializer, value.feePayer);\n    }\n\n    const secondarySigners = value.secondarySigners ?? [];\n    serializer.serializeU32AsUleb128(secondarySigners.length);\n    for (const signer of secondarySigners) {\n      serializeAccountInput(serializer, signer);\n    }\n  }\n\n  function deserializeArgs(deserializer: Deserializer, version: SupportedVersions): Args {\n    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();\n    const signerAddress = hasSignerAddress ? deserializer.deserialize(AccountAddress) : undefined;\n\n    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption('string');\n    if (network !== undefined && !isSupportedNetwork(network)) {\n      throw new Error(`Unsupported network '${network}'`);\n    }\n\n    const hasSender = deserializer.deserializeBool();\n    const sender = hasSender ? deserializeAccountInput(deserializer) : undefined;\n\n    const isPayloadBcsSerializable = version < 4 || deserializer.deserializeBool();\n    const payload = isPayloadBcsSerializable\n      ? deserializer.deserialize(TransactionPayload)\n      : deserializeTransactionPayloadInput(deserializer);\n\n    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();\n    const expirationTimestamp = Number(deserializer.deserializeU64());\n    const gasUnitPrice = deserializer.deserializeUleb128AsU32();\n    const maxGasAmount = deserializer.deserializeUleb128AsU32();\n    const hasFeePayer = deserializer.deserializeBool();\n    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : undefined;\n\n    const secondarySignersLength = deserializer.deserializeUleb128AsU32();\n    const secondarySigners: AccountInput[] = [];\n    for (let i = 0; i < secondarySignersLength; i += 1) {\n      secondarySigners.push(deserializeAccountInput(deserializer));\n    }\n\n    return {\n      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : undefined,\n      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : undefined,\n      feePayer,\n      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : undefined,\n      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : undefined,\n      network,\n      payload,\n      secondarySigners,\n      sender,\n      signerAddress,\n    };\n  }\n\n  // endregion\n\n  // region Request\n\n  export function serialize(dappInfo: DappInfo, args: Args): SerializedWalletRequest<RequestName, CurrentVersion> {\n    const request = { args, dappInfo, name, version: currentVersion };\n    return serializeWalletRequestWithArgs(request, serializeArgs);\n  }\n\n  export function deserialize(\n    serializedRequest: SerializedWalletRequest<RequestName, SupportedVersions>,\n  ): SignTransactionRequest {\n    return deserializeWalletRequestWithArgs(serializedRequest, (deserializer) =>\n      deserializeArgs(deserializer, serializedRequest.version),\n    );\n  }\n\n  export function isSerialized(\n    request: SerializedWalletRequest,\n  ): request is SerializedWalletRequest<RequestName, SupportedVersions> {\n    return request.name === name && supportedVersions.includes(request.version as SupportedVersions);\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-inner-declarations */\n\nimport { AccountAuthenticator, Deserializer, RawTransaction, Serializer } from '@aptos-labs/ts-sdk';\nimport { makeUserResponseDeserializeFn, makeUserResponseSerializeFn, UserResponse } from '../../UserResponse';\nimport {\n  deserializeWalletResponse,\n  SerializedWalletResponse,\n  serializeWalletResponse,\n  WalletResponseWithArgs,\n} from '../../WalletResponse';\n\nexport interface SignTransactionResponse extends WalletResponseWithArgs<SignTransactionResponse.Args> {}\n\nexport namespace SignTransactionResponse {\n  // region ApprovalArgs\n\n  export interface ApprovalArgs {\n    authenticator: AccountAuthenticator;\n    rawTransaction?: RawTransaction;\n  }\n\n  function serializeApprovalArgs(serializer: Serializer, value: ApprovalArgs) {\n    serializer.serialize(value.authenticator);\n    serializer.serializeBool(value.rawTransaction !== undefined);\n    if (value.rawTransaction !== undefined) {\n      serializer.serialize(value.rawTransaction);\n    }\n  }\n\n  function deserializeApprovalArgs(deserializer: Deserializer): ApprovalArgs {\n    const authenticator = deserializer.deserialize(AccountAuthenticator);\n    const hasRawTransaction = deserializer.deserializeBool();\n    const rawTransaction = hasRawTransaction ? deserializer.deserialize(RawTransaction) : undefined;\n\n    return {\n      authenticator,\n      rawTransaction,\n    };\n  }\n\n  // endregion\n\n  // region ResponseArgs\n\n  export type Args = UserResponse<ApprovalArgs>;\n\n  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);\n  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);\n\n  // endregion\n\n  type _Response = SignTransactionResponse;\n\n  export function serialize(args: Args): SerializedWalletResponse {\n    return serializeWalletResponse(args, serializeArgs);\n  }\n\n  export function deserialize(serializedResponse: SerializedWalletResponse): _Response {\n    return deserializeWalletResponse(serializedResponse, deserializeArgs);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport type TypedMessage<MessageType extends string = string> = { __messageType: MessageType };\nexport type TypedMessageConstructor<TMessage extends TypedMessage<MessageType>, MessageType extends string> = {\n  TYPE: MessageType;\n  new (...args: any[]): TMessage;\n};\n\nexport function isTypedMessage<TMessage extends TypedMessage<MessageType>, MessageType extends string>(\n  messageCls: TypedMessageConstructor<TMessage, MessageType>,\n  message: any,\n): message is TMessage {\n  return message?.__messageType === messageCls.TYPE;\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Serializer } from '@aptos-labs/ts-sdk';\nimport { base64ToBytes, bytesToBase64 } from '../base64';\nimport { SerializedWalletRequest } from '../WalletRequest';\nimport { SerializedWalletResponse } from '../WalletResponse';\nimport { TypedMessage } from './common';\n\nexport class PromptConnectionRequestMessage implements TypedMessage {\n  static readonly TYPE = 'PromptConnectionRequest';\n  readonly __messageType = PromptConnectionRequestMessage.TYPE;\n}\n\nexport class PromptConnectionResponseMessage implements TypedMessage {\n  static readonly TYPE = 'PromptConnectionResponse';\n  readonly __messageType = PromptConnectionResponseMessage.TYPE;\n\n  constructor(public serializedRequest: SerializedWalletRequest) {}\n}\n\nexport class PromptApprovalResponseMessage implements TypedMessage {\n  static readonly TYPE = 'PromptApprovalResponse';\n  readonly __messageType = PromptApprovalResponseMessage.TYPE;\n\n  constructor(public serializedValue: SerializedWalletResponse) {}\n}\n\nexport class PromptUnauthorizedErrorMessage implements TypedMessage {\n  static readonly TYPE = 'PromptUnauthorizedError';\n  readonly __messageType = PromptUnauthorizedErrorMessage.TYPE;\n}\n\nexport function urlEncodeWalletRequest(request: SerializedWalletRequest) {\n  const serializer = new Serializer();\n  serializer.serializeStr(request.name);\n  serializer.serializeBytes(request.data);\n  serializer.serializeStr(request.version.toString());\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function urlDecodeWalletRequest(encodedRequest: string): SerializedWalletRequest {\n  const deserializer = new Deserializer(base64ToBytes(encodedRequest));\n  const name = deserializer.deserializeStr();\n  const data = deserializer.deserializeBytes();\n\n  let version: number;\n  try {\n    version = Number(deserializer.deserializeStr());\n  } catch {\n    version = 1;\n  }\n  return { data, name, version };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  Ed25519PublicKey,\n  Ed25519Signature,\n  Serializer,\n} from '@aptos-labs/ts-sdk';\nimport { base64ToBytes, base64urlToBytes, bytesToBase64, bytesToBase64url } from './base64';\nimport { decodeWalletRequestBody, encodeWalletRequestBody, type WalletRequestBody } from './WalletRequestBody';\n\nexport interface UnsignedPopupWalletRequest {\n  accountAddress?: AccountAddressInput;\n  body: WalletRequestBody;\n  clientIdentityKey?: undefined;\n}\n\nexport interface BaseSignedPopupWalletRequest {\n  accountAddress?: AccountAddressInput;\n  clientIdentityKey: Ed25519PublicKey;\n  id: string;\n  // against ('AptosConnectWalletRequest', id, body, address, timestamp)\n  signature: Ed25519Signature;\n  timestamp: number;\n}\n\nexport interface DeferredSignedPopupWalletRequest extends BaseSignedPopupWalletRequest {\n  body?: undefined;\n}\n\nexport interface SignedPopupWalletRequest extends BaseSignedPopupWalletRequest {\n  body: WalletRequestBody;\n}\n\nexport type PopupWalletRequest =\n  | UnsignedPopupWalletRequest\n  | DeferredSignedPopupWalletRequest\n  | SignedPopupWalletRequest;\n\nexport function encodePopupWalletRequest(request: PopupWalletRequest): string {\n  const serialized = JSON.stringify(request, (key, value) => {\n    switch (key) {\n      case 'body':\n        return encodeWalletRequestBody(value);\n      case 'clientIdentityKey':\n        return bytesToBase64((value as Ed25519PublicKey).toUint8Array());\n      case 'signature':\n        return bytesToBase64((value as Ed25519Signature).toUint8Array());\n      default:\n        return value;\n    }\n  });\n  const utf8Encoded = new TextEncoder().encode(serialized);\n  return bytesToBase64url(utf8Encoded);\n}\n\nexport function decodePopupWalletRequest(encoded: string): PopupWalletRequest {\n  const utfEncoded = base64urlToBytes(encoded);\n  const serialized = new TextDecoder().decode(utfEncoded);\n  return JSON.parse(serialized, (key, value) => {\n    switch (key) {\n      case 'body':\n        return decodeWalletRequestBody(value);\n      case 'clientIdentityKey':\n        return new Ed25519PublicKey(base64ToBytes(value));\n      case 'signature':\n        return new Ed25519Signature(base64ToBytes(value));\n      default:\n        return value;\n    }\n  });\n}\n\nexport function makePopupWalletRequestChallenge({\n  accountAddress,\n  body,\n  id,\n  timestamp,\n}: Omit<SignedPopupWalletRequest, 'clientIdentityKey' | 'signature'>) {\n  const serializer = new Serializer();\n  serializer.serializeStr('SignedPopupWalletRequest');\n  serializer.serializeStr(id);\n  serializer.serializeU64(timestamp);\n  serializer.serializeBool(accountAddress !== undefined);\n  if (accountAddress !== undefined) {\n    serializer.serialize(AccountAddress.from(accountAddress));\n  }\n  serializer.serializeStr(body.name);\n  serializer.serializeU8(body.version);\n  serializer.serializeBytes(body.data);\n  return serializer.toUint8Array();\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { base64ToBytes, bytesToBase64 } from './base64';\n\nexport interface WalletRequestBody<RequestName extends string = string, Version extends number = number> {\n  data: Uint8Array;\n  name: RequestName;\n  version: Version;\n}\n\nexport function encodeWalletRequestBody({ data, ...rest }: WalletRequestBody): string {\n  const serialized = JSON.stringify({ data, ...rest }, (key, value) => (key === 'data' ? bytesToBase64(value) : value));\n  const utf8Encoded = new TextEncoder().encode(serialized);\n  return bytesToBase64(utf8Encoded);\n}\n\nexport function decodeWalletRequestBody(encoded: string): WalletRequestBody {\n  const utfEncoded = base64ToBytes(encoded);\n  const serialized = new TextDecoder().decode(utfEncoded);\n  return JSON.parse(serialized, (key, value) => (key === 'data' ? base64ToBytes(value) : value));\n}\n", "class u extends Error {\n  constructor(e, r, n) {\n    super(\n      typeof r == \"object\" ? r.message : r || e,\n      {\n        cause: typeof r == \"object\" ? r.cause : n\n      }\n    ), this.type = e, this.name = \"TypedError\", Object.setPrototypeOf(this, u.prototype);\n  }\n}\nfunction h(t) {\n  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction S(t) {\n  return t.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nconst w = \"ERR_INVALID_VALUE\", D = \"ERR_UNEXPECTED_VALUE\", W = \"ERR_UNEXPECTED_TYPE\", d = \"ERR_PARSE\";\nfunction A(t, e) {\n  const r = {};\n  for (const n in t) {\n    const o = t[n];\n    if (!o)\n      continue;\n    let a, c;\n    typeof o == \"function\" ? (a = n, c = o) : [a, c] = o;\n    try {\n      const s = c(e(a));\n      s !== void 0 && (r[n] = s);\n    } catch (s) {\n      throw new u(\n        d,\n        `Parser for \"${n}\" property failed${a === n ? \"\" : `. Source field: \"${a}\"`}`,\n        s\n      );\n    }\n  }\n  return r;\n}\nfunction P(t) {\n  let e = t;\n  if (typeof e == \"string\")\n    try {\n      e = JSON.parse(e);\n    } catch (r) {\n      throw new u(w, { cause: r });\n    }\n  if (typeof e != \"object\" || !e || Array.isArray(e))\n    throw new u(D);\n  return e;\n}\nfunction i(t, e) {\n  return (r) => {\n    const n = (o) => {\n      if (!(r && o === void 0))\n        try {\n          return e(o);\n        } catch (a) {\n          throw new u(d, {\n            message: `\"${t}\" transformer failed to parse the value`,\n            cause: a\n          });\n        }\n    };\n    return /* @__PURE__ */ Object.assign(\n      n,\n      {\n        isValid(o) {\n          try {\n            return n(o), !0;\n          } catch {\n            return !1;\n          }\n        }\n      }\n    );\n  };\n}\nfunction m(t, e) {\n  return i(e || \"object\", (r) => {\n    const n = P(r);\n    return A(t, (o) => n[o]);\n  });\n}\nfunction p(t) {\n  throw new u(W, `Unexpected value received: ${JSON.stringify(t)}`);\n}\nconst E = i(\"boolean\", (t) => {\n  if (typeof t == \"boolean\")\n    return t;\n  const e = String(t);\n  if (e === \"1\" || e === \"true\")\n    return !0;\n  if (e === \"0\" || e === \"false\")\n    return !1;\n  p(t);\n}), f = i(\"string\", (t) => {\n  if (typeof t == \"string\" || typeof t == \"number\")\n    return t.toString();\n  p(t);\n}), g = i(\"number\", (t) => {\n  if (typeof t == \"number\")\n    return t;\n  if (typeof t == \"string\") {\n    const e = Number(t);\n    if (!Number.isNaN(e))\n      return e;\n  }\n  p(t);\n}), U = i(\"date\", (t) => t instanceof Date ? t : new Date(g()(t) * 1e3));\nfunction R(t, e) {\n  return i(e || \"searchParams\", (r) => {\n    typeof r != \"string\" && !(r instanceof URLSearchParams) && p(r);\n    const n = typeof r == \"string\" ? new URLSearchParams(r) : r;\n    return A(t, (o) => {\n      const a = n.get(o);\n      return a === null ? void 0 : a;\n    });\n  });\n}\nfunction l(t) {\n  for (const e in t)\n    t[e] = [h(e), t[e]];\n  return t;\n}\nconst N = (t) => {\n  const e = g(), r = g(!0), n = f(), o = f(!0), a = E(!0), c = m(l({\n    addedToAttachmentMenu: a,\n    allowsWriteToPm: a,\n    firstName: n,\n    id: e,\n    isBot: a,\n    isPremium: a,\n    languageCode: o,\n    lastName: o,\n    photoUrl: o,\n    username: o\n  }), \"User\")(!0);\n  return R(\n    l({\n      authDate: U(),\n      canSendAfter: r,\n      chat: m(\n        l({\n          id: e,\n          type: n,\n          title: n,\n          photoUrl: o,\n          username: o\n        }),\n        \"Chat\"\n      )(!0),\n      chatInstance: o,\n      chatType: o,\n      hash: n,\n      queryId: o,\n      receiver: c,\n      startParam: o,\n      signature: n,\n      user: c\n    }),\n    \"initData\"\n  )(t);\n};\nfunction O(t) {\n  return /^#[\\da-f]{6}$/i.test(t);\n}\nfunction T(t) {\n  return /^#[\\da-f]{3}$/i.test(t);\n}\nfunction _(t) {\n  const e = t.replace(/\\s/g, \"\").toLowerCase();\n  if (O(e))\n    return e;\n  if (T(e)) {\n    let n = \"#\";\n    for (let o = 0; o < 3; o += 1)\n      n += e[1 + o].repeat(2);\n    return n;\n  }\n  const r = e.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || e.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${t}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((n, o) => {\n    const a = parseInt(o, 10).toString(16);\n    return n + (a.length === 1 ? \"0\" : \"\") + a;\n  }, \"#\");\n}\nconst C = i(\"rgb\", (t) => _(f()(t))), b = i(\n  \"themeParams\",\n  (t) => {\n    const e = C(!0);\n    return Object.entries(P(t)).reduce((r, [n, o]) => (r[S(n)] = e(o), r), {});\n  }\n);\n// @__NO_SIDE_EFFECTS__\nfunction y(t) {\n  return JSON.stringify(\n    Object.fromEntries(\n      Object.entries(t).map(([e, r]) => [h(e), r])\n    )\n  );\n}\nconst V = (t) => {\n  const e = f(), r = f(!0), n = E(!0);\n  return R({\n    botInline: [\"tgWebAppBotInline\", n],\n    defaultColors: [\"tgWebAppDefaultColors\", b(!0)],\n    fullscreen: [\"tgWebAppFullscreen\", n],\n    initData: [\"tgWebAppData\", N(!0)],\n    initDataRaw: [\"tgWebAppData\", r],\n    platform: [\"tgWebAppPlatform\", e],\n    showSettings: [\"tgWebAppShowSettings\", n],\n    startParam: [\"tgWebAppStartParam\", r],\n    themeParams: [\"tgWebAppThemeParams\", b()],\n    version: [\"tgWebAppVersion\", e]\n  }, \"launchParams\")(t);\n};\n// @__NO_SIDE_EFFECTS__\nfunction $(t) {\n  const {\n    initDataRaw: e,\n    startParam: r,\n    showSettings: n,\n    botInline: o,\n    fullscreen: a,\n    defaultColors: c\n  } = t, s = new URLSearchParams();\n  return s.set(\"tgWebAppPlatform\", t.platform), s.set(\"tgWebAppThemeParams\", /* @__PURE__ */ y(t.themeParams)), s.set(\"tgWebAppVersion\", t.version), e && s.set(\"tgWebAppData\", e), r && s.set(\"tgWebAppStartParam\", r), typeof n == \"boolean\" && s.set(\"tgWebAppShowSettings\", n ? \"1\" : \"0\"), typeof o == \"boolean\" && s.set(\"tgWebAppBotInline\", o ? \"1\" : \"0\"), typeof a == \"boolean\" && s.set(\"tgWebAppFullscreen\", a ? \"1\" : \"0\"), c && s.set(\"tgWebAppDefaultColors\", /* @__PURE__ */ y(c)), s.toString();\n}\nconst j = m({\n  eventType: f(),\n  eventData: (t) => t\n}, \"miniAppsMessage\");\nfunction L(t, e) {\n  return i(e || \"array\", (r) => {\n    let n;\n    if (Array.isArray(r))\n      n = r;\n    else if (typeof r == \"string\")\n      try {\n        const o = JSON.parse(r);\n        Array.isArray(o) && (n = o);\n      } catch {\n      }\n    return n || p(r), n.map(t);\n  });\n}\nconst I = i(\"fn\", (t) => {\n  if (typeof t == \"function\")\n    return t;\n  p(t);\n});\nfunction B(t) {\n  return !!t && typeof t == \"object\" && !Array.isArray(t);\n}\nexport {\n  w as ERR_INVALID_VALUE,\n  d as ERR_PARSE,\n  W as ERR_UNEXPECTED_TYPE,\n  D as ERR_UNEXPECTED_VALUE,\n  L as array,\n  E as boolean,\n  i as createTransformerGen,\n  U as date,\n  I as fn,\n  N as initData,\n  O as isRGB,\n  T as isRGBShort,\n  B as isRecord,\n  V as launchParams,\n  j as miniAppsMessage,\n  g as number,\n  m as object,\n  C as rgb,\n  R as searchParams,\n  $ as serializeLaunchParams,\n  y as serializeThemeParams,\n  f as string,\n  b as themeParams,\n  _ as toRGB,\n  P as toRecord\n};\n//# sourceMappingURL=index.js.map\n", "import { object, fn } from '@telegram-apps/transformers';\n\ninterface WithWebviewProxy {\n  TelegramWebviewProxy: {\n    postEvent: (...args: unknown[]) => unknown;\n  };\n}\n\nconst webViewProxy = object<WithWebviewProxy>({\n  TelegramWebviewProxy: object({ postEvent: fn() })(),\n});\n\n/**\n * Returns true in case, passed value contains path `TelegramWebviewProxy.postEvent` property and\n * `postEvent` is a function.\n * @param value - value to check.\n */\nexport function hasWebviewProxy<T>(value: T): value is T & WithWebviewProxy {\n  return webViewProxy().isValid(value);\n}\n", "/**\n * @see https://stackoverflow.com/a/326076\n * @returns True, if current environment is iframe.\n */\nexport function isIframe(): boolean {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\n", "var k = Object.defineProperty;\nvar I = (r, e, t) => e in r ? k(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;\nvar E = (r, e, t) => I(r, typeof e != \"symbol\" ? e + \"\" : e, t);\nclass d extends Error {\n  constructor(e, t, n) {\n    super(\n      typeof t == \"object\" ? t.message : t || e,\n      {\n        cause: typeof t == \"object\" ? t.cause : n\n      }\n    ), this.type = e, this.name = \"TypedError\", Object.setPrototypeOf(this, d.prototype);\n  }\n}\nfunction x(r, e, t) {\n  return r.addEventListener(e, t), () => r.removeEventListener(e, t);\n}\nfunction _(...r) {\n  const e = r.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((t) => {\n        t();\n      });\n    }\n  ];\n}\nfunction F(r, e) {\n  return r instanceof d && r.type === e;\n}\nfunction m(r) {\n  return (e) => F(e, r);\n}\nconst R = \"ERR_ABORTED\", $ = \"ERR_CANCELED\", S = \"ERR_TIMED_OUT\";\nfunction T(r) {\n  return new d(R, { cause: r });\n}\nconst U = m(S), V = m(R), B = m($);\nfunction C(r, e) {\n  return r.reject = e.reject, r;\n}\nclass i extends Promise {\n  constructor(t, n) {\n    let o, s;\n    typeof t == \"function\" ? (o = t, s = n) : s = t;\n    let u, c;\n    super((a, h) => {\n      s || (s = {});\n      const { abortSignal: l } = s;\n      if (l && l.aborted)\n        return h(T(l.reason));\n      const [y, A] = _(), b = (f) => (...L) => (A(), f(...L)), w = new AbortController(), { signal: D } = w;\n      c = b((f) => {\n        w.abort(f), h(f);\n      }), u = b(a), l && y(\n        x(l, \"abort\", () => {\n          c(T(l.reason));\n        })\n      );\n      const { timeout: g } = s;\n      if (g) {\n        const f = setTimeout(() => {\n          c(new d(S, `Timeout reached: ${g}ms`));\n        }, g);\n        y(() => {\n          clearTimeout(f);\n        });\n      }\n      o && o(u, c, D);\n    });\n    /**\n     * Rejects the promise.\n     */\n    E(this, \"reject\");\n    this.reject = c;\n  }\n  /**\n   * Creates a new BetterPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new i((o, s, u) => {\n      try {\n        const c = t(u);\n        return c instanceof Promise ? c.then(o, s) : o(c);\n      } catch (c) {\n        s(c);\n      }\n    }, n);\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new i((n) => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new i((n, o) => {\n      o(t);\n    });\n  }\n  /**\n   * Cancels the promise execution.\n   */\n  cancel() {\n    this.reject(new d($));\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return C(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return C(super.then(t, n), this);\n  }\n}\nfunction v(r, e) {\n  return r.resolve = e.resolve, r;\n}\nclass p extends i {\n  constructor(t, n) {\n    let o, s;\n    typeof t == \"function\" ? (o = t, s = n) : s = t;\n    let u;\n    super((c, a, h) => {\n      u = c, o && o(c, a, h);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    E(this, \"resolve\");\n    this.resolve = u;\n  }\n  /**\n   * Creates a new EnhancedPromise instance using executor, resolving promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static withFn(t, n) {\n    return new p(\n      (o, s, u) => i.withFn(t, { abortSignal: u }).then(o, s),\n      n\n    );\n  }\n  /**\n   * @see Promise.resolve\n   */\n  static resolve(t) {\n    return new p((n) => {\n      n(t);\n    });\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(t) {\n    return new p((n, o) => {\n      o(t);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(t) {\n    return this.then(void 0, t);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(t) {\n    return v(super.finally(t), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(t, n) {\n    return v(super.then(t, n), this);\n  }\n}\nfunction Z(r, e) {\n  return new i((t) => {\n    setTimeout(t, r);\n  }, { abortSignal: e });\n}\nfunction j(r) {\n  return `tapps/${r}`;\n}\nfunction J(r, e) {\n  sessionStorage.setItem(j(r), JSON.stringify(e));\n}\nfunction K(r) {\n  const e = sessionStorage.getItem(j(r));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction M(r) {\n  return r.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction z(r) {\n  return r.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction G(r) {\n  return r.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\n// @__NO_SIDE_EFFECTS__\nfunction q(r, e) {\n  e || (e = {});\n  const {\n    textColor: t,\n    bgColor: n,\n    shouldLog: o = !0\n  } = e;\n  function s(u, ...c) {\n    if (!o || typeof o == \"function\" && !o())\n      return;\n    const a = \"font-weight:bold;padding:0 5px;border-radius:5px\";\n    console[u](\n      `%c${Intl.DateTimeFormat(\"en-GB\", {\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\",\n        fractionalSecondDigits: 3,\n        timeZone: \"UTC\"\n      }).format(/* @__PURE__ */ new Date())}%c / %c${r}`,\n      `${a};background-color: lightblue;color:black`,\n      \"\",\n      `${a};${t ? `color:${t};` : \"\"}${n ? `background-color:${n}` : \"\"}`,\n      ...c\n    );\n  }\n  return [\n    function(...c) {\n      s(\"log\", ...c);\n    },\n    function(...c) {\n      s(\"error\", ...c);\n    }\n  ];\n}\nfunction H(r, e) {\n  document.documentElement.style.setProperty(r, e);\n}\nfunction P(r) {\n  document.documentElement.style.removeProperty(r);\n}\nexport {\n  i as CancelablePromise,\n  R as ERR_ABORTED,\n  $ as ERR_CANCELED,\n  S as ERR_TIMED_OUT,\n  p as EnhancedPromise,\n  d as TypedError,\n  x as addEventListener,\n  M as camelToKebab,\n  z as camelToSnake,\n  T as createAbortError,\n  _ as createCbCollector,\n  q as createLogger,\n  m as createTypedErrorPredicate,\n  P as deleteCssVar,\n  K as getStorageValue,\n  V as isAbortError,\n  B as isCanceledError,\n  F as isErrorOfType,\n  U as isTimeoutError,\n  H as setCssVar,\n  J as setStorageValue,\n  Z as sleep,\n  G as snakeToCamel\n};\n//# sourceMappingURL=index.js.map\n", "let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n", "import { signal } from '@telegram-apps/signals';\nimport { createLogger } from '@telegram-apps/toolkit';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nexport const $debug = signal(false);\n\nexport const [logInfo, logError] = createLogger('Bridge', {\n  bgColor: '#9147ff',\n  textColor: 'white',\n  shouldLog: $debug,\n});\n", "import {\n  boolean,\n  createTransformerGen,\n  number,\n  object,\n  string,\n  type TransformerGen,\n} from '@telegram-apps/transformers';\n\nimport type { EventName, EventPayload } from '@/events/types/events.js';\n\n/**\n * Transformers for problematic Mini Apps events.\n */\nexport const transformers: { [E in EventName]?: TransformerGen<EventPayload<E>> } = {\n  clipboard_text_received: object({\n    req_id: string(),\n    data: (value) => (value === null ? value : string(true)(value)),\n  }, 'clipboard_text_received'),\n  custom_method_invoked: object({\n    req_id: string(),\n    result: (value) => value,\n    error: string(true),\n  }, 'custom_method_invoked'),\n  popup_closed: createTransformerGen('popup_closed', value => {\n    return value\n      ? object({\n        button_id: (value) => (\n          value === null || value === undefined ? undefined : string()(value)\n        ),\n      })()(value)\n      : {};\n  }),\n  viewport_changed: object({\n    height: number(),\n    width: (value) => (\n      value === null || value === undefined\n        ? window.innerWidth\n        : number()(value)\n    ),\n    is_state_stable: boolean(),\n    is_expanded: boolean(),\n  }, 'viewport_changed'),\n};", "import { createCbCollector, addEventListener, type If, type IsNever } from '@telegram-apps/toolkit';\nimport { Signal, signal } from '@telegram-apps/signals';\nimport { miniAppsMessage, type MiniAppsMessage } from '@telegram-apps/transformers';\n\nimport { logError, logInfo } from '@/debug.js';\n\nimport { transformers } from '../transformers.js';\nimport type { EventPayload, EventName } from '../types/events.js';\n\nexport type LastEvent = {\n  [E in EventName]: [E, If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>]\n}[EventName];\n\n/**\n * Creates window event listeners, tracking Mini Apps events and calling passed handler with their\n * data.\n * @param onEvent - event callback.\n */\nfunction defineListeners(onEvent: (event: LastEvent) => void): () => void {\n  const w = window;\n  const [, cleanup] = createCbCollector(\n    // Add listener, which handles events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    addEventListener(w, 'message', (event) => {\n      // Ignore non-parent window messages.\n      if (event.source !== w.parent) {\n        return;\n      }\n\n      // Parse incoming event data.\n      let message: MiniAppsMessage;\n      try {\n        message = miniAppsMessage()(event.data);\n      } catch {\n        // We ignore incorrect messages as they could be generated by any other code.\n        return;\n      }\n\n      const { eventType, eventData } = message;\n      const createTransformer = transformers[eventType as keyof typeof transformers];\n\n      try {\n        const transformed = createTransformer\n          ? createTransformer()(eventData)\n          : eventData;\n        logInfo('Event received:', transformed\n          ? { eventType, eventData: transformed }\n          : { eventType });\n        onEvent([eventType, transformed] as LastEvent);\n      } catch (cause) {\n        logError(\n          [\n            `An error occurred processing the \"${eventType}\" event from the Telegram application.`,\n            'Please, file an issue here:',\n            'https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose',\n          ].join('\\n'),\n          message,\n          cause,\n        );\n      }\n    }),\n  );\n\n  return cleanup;\n}\n\n/**\n * Last received event.\n */\nexport const $lastEvent = signal<LastEvent>();\n\n/**\n * Side effects listening cleanup function. It will be eventually set when some code tried\n * to retrieve the last event.\n */\nexport const $lastEventCleanup = signal<() => void>();\n\n/**\n * Retrieve last received Mini Apps event ensuring that external listeners were defined.\n */\nexport function lastEventSignal(): Signal<LastEvent | undefined> {\n  if (!$lastEventCleanup()) {\n    $lastEventCleanup.set(defineListeners($lastEvent.set));\n  }\n  return $lastEvent;\n}\n\n", "import { type Signal, signal } from '@telegram-apps/signals';\n\nimport { lastEventSignal } from '@/events/listening/lastEvent.js';\nimport type { EventName } from '@/events/types/events.js';\nimport type { SignalPayload } from '@/events/listening/types.js';\n\ntype CachedSignal<E extends EventName> = Signal<SignalPayload<E>>;\ntype Cache = {\n  [E in EventName]?: CachedSignal<E>\n};\n\nexport const $eventSignalsCache = signal<Cache>({});\n\n/**\n * Returns a signal for specified event using cache.\n * @param event - event name.\n */\nexport function signalFor<E extends EventName>(event: E): CachedSignal<E> {\n  let cached = $eventSignalsCache()[event];\n  if (!cached) {\n    // This is the special symbol we use to notify signal, that nothing changed, and the current\n    // value should be preserved.\n    cached = signal(undefined, {\n      equals() {\n        // We may receive several undefined in a row. For example,\n        // in the main_button_pressed event.\n        return false;\n      },\n    }) as Cache[E];\n    lastEventSignal().sub(ev => {\n      if (ev && ev[0] === event) {\n        cached!.set(ev[1] as SignalPayload<E>);\n      }\n    });\n\n    $eventSignalsCache.set({ ...$eventSignalsCache(), [event]: cached });\n  }\n\n  return cached as CachedSignal<E>;\n}", "import type { RemoveListenerFn } from '@telegram-apps/signals';\n\nimport { signalFor } from '@/events/listening/signalFor.js';\nimport type { EventName } from '@/events/types/events.js';\nimport type { EventListener } from '@/events/listening/types.js';\n\n/**\n * Adds a new listener to the specified event.\n * @param event - event name.\n * @param listener - event listener.\n * @param once - should listener be called only once.\n * @returns Function to remove bound event listener.\n */\nexport function on<E extends EventName>(\n  event: E,\n  listener: EventListener<E>,\n  once?: boolean,\n): RemoveListenerFn {\n  return signalFor(event).sub(listener, once);\n}", "export const ERR_METHOD_UNSUPPORTED = 'ERR_METHOD_UNSUPPORTED';\nexport const ERR_RETRIEVE_LP_FAILED = 'ERR_RETRIEVE_LP_FAILED';\nexport const ERR_METHOD_PARAMETER_UNSUPPORTED = 'ERR_METHOD_PARAMETER_UNSUPPORTED';\nexport const ERR_UNKNOWN_ENV = 'ERR_UNKNOWN_ENV';\nexport const ERR_CUSTOM_METHOD_ERR_RESPONSE = 'ERR_INVOKE_CUSTOM_METHOD_RESPONSE';\n", "import { signal } from '@telegram-apps/signals';\n\n/**\n * Target origin used by the `postEvent` method.\n *\n * You don't need to override this value until you know what you are doing.\n * @default 'https://web.telegram.org'\n */\nexport const $targetOrigin = signal('https://web.telegram.org');\n", "import { fn, object } from '@telegram-apps/transformers';\nimport { TypedError } from '@telegram-apps/toolkit';\n\nimport { logInfo } from '@/debug.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { ERR_UNKNOWN_ENV } from '@/errors.js';\nimport { $targetOrigin } from '@/methods/$targetOrigin.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nexport type PostEventFn = typeof postEvent;\n\n/**\n * Calls Mini Apps methods requiring parameters.\n * @param method - method name.\n * @param params - options along with params.\n * @throws {TypedError} ERR_UNKNOWN_ENV\n */\nexport function postEvent<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): void;\n\n/**\n * Calls Mini Apps methods accepting no parameters at all.\n * @param method - method name.\n * @throws {TypedError} ERR_UNKNOWN_ENV\n */\nexport function postEvent(method: MethodNameWithoutParams): void;\n\n/**\n * Calls Mini Apps methods accepting optional parameters.\n * @param method - method name.\n * @param params - options along with params.\n * @throws {TypedError} ERR_UNKNOWN_ENV\n */\nexport function postEvent<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): void;\n\nexport function postEvent(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): void {\n  logInfo('Posting event:', eventData ? { eventType, eventData } : { eventType });\n\n  const w = window;\n\n  // Telegram for iOS and macOS.\n  if (hasWebviewProxy(w)) {\n    w.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    return;\n  }\n\n  const message = JSON.stringify({ eventType, eventData });\n\n  // Telegram Web.\n  if (isIframe()) {\n    return w.parent.postMessage(message, $targetOrigin());\n  }\n\n  // Telegram for Windows Phone or Android.\n  const { external } = w;\n  if (object({ notify: fn() })().isValid(external)) {\n    external.notify(message);\n    return;\n  }\n\n  // Otherwise current environment is unknown, and we are not able to send event.\n  throw new TypedError(ERR_UNKNOWN_ENV);\n}\n", "import {\n  CancelablePromise,\n  createCbCollector,\n  type If,\n  type IsNever,\n} from '@telegram-apps/toolkit';\n\nimport { on } from '@/events/listening/on.js';\nimport { postEvent } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\nimport type { EventName, EventPayload } from '@/events/types/events.js';\nimport type { ExecuteWithOptions } from '@/types.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type RequestCaptureFnEventsPayload<E extends EventName[]> = E extends (infer U extends EventName)[]\n  ? {\n    [K in U]: If<\n      IsNever<EventPayload<K>>,\n      { event: K },\n      { event: K; payload: EventPayload<K> }\n    >\n  }[U]\n  : never;\n\nexport type RequestCaptureEventsFn<E extends EventName[]> = (\n  payload: RequestCaptureFnEventsPayload<E>,\n) => boolean\n\nexport type RequestCaptureEventFn<E extends EventName> = If<\n  IsNever<EventPayload<E>>,\n  () => boolean,\n  (payload: EventPayload<E>) => boolean\n>;\n\nexport type RequestCaptureFn<E extends AnyEventName> = E extends EventName[]\n  ? RequestCaptureEventsFn<E>\n  : E extends EventName\n    ? RequestCaptureEventFn<E>\n    : never;\n\nexport interface RequestBasicOptions<E extends AnyEventName> extends ExecuteWithOptions {\n  /**\n   * Should return true if this event should be captured.\n   * The first compatible request will be captured if this property is omitted.\n   */\n  capture?: RequestCaptureFn<E>;\n}\n\nexport type RequestResult<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? If<IsNever<EventPayload<K>>, undefined, EventPayload<K>>\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport type RequestFn = typeof request;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods, requiring parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestBasicOptions<E> & { params: MethodParams<M> },\n): CancelablePromise<RequestResult<E>>;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods with optional parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestBasicOptions<E> & { params?: MethodParams<M> },\n): CancelablePromise<RequestResult<E>>;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods without parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestBasicOptions<E>,\n): CancelablePromise<RequestResult<E>>;\n\nexport function request<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestBasicOptions<E> & { params?: MethodParams<M> },\n): CancelablePromise<RequestResult<E>> {\n  options ||= {};\n  const { capture } = options;\n  const [addCleanup, cleanup] = createCbCollector();\n\n  return new CancelablePromise<RequestResult<E>>((resolve) => {\n    // We need to iterate over all tracked events and create their event listeners.\n    ((Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents])).forEach(event => {\n      // Each event listener waits for the event to occur.\n      // Then, if the capture function was passed, we should check if the event should be captured.\n      // If the function is omitted, we instantly capture the event.\n      addCleanup(\n        on(event, payload => {\n          if (!capture || (\n            Array.isArray(eventOrEvents)\n              ? (capture as RequestCaptureEventsFn<EventName[]>)({\n                event,\n                payload,\n              } as RequestCaptureFnEventsPayload<EventName[]>)\n              : (capture as RequestCaptureEventFn<EventName>)(payload)\n          )) {\n            resolve(payload as RequestResult<E>);\n          }\n        }),\n      );\n    });\n\n    (options.postEvent || postEvent)(method as any, (options as any).params);\n  }, options)\n    .finally(cleanup);\n}\n", "import { launchParams, type LaunchParams } from '@telegram-apps/transformers';\n\n/**\n * Parses value as launch parameters.\n * @param value - value to parse.\n */\nexport function parseLaunchParams(value: unknown): LaunchParams {\n  return launchParams()(value);\n}\n", "import type { LaunchParams } from '@telegram-apps/types';\n\nimport { parseLaunchParams } from './parseLaunchParams.js';\n\n/**\n * @param urlString - URL to extract launch parameters from.\n * @returns Launch parameters from the specified URL.\n * @throws Error if function was unable to extract launch parameters from the passed URL.\n */\nexport function retrieveFromUrl(urlString: string): LaunchParams {\n  return parseLaunchParams(\n    urlString\n      // Replace everything before this first hashtag or question sign.\n      .replace(/^[^?#]*[?#]/, '')\n      // Replace all hashtags and question signs to make it look like some search params.\n      .replace(/[?#]/g, '&'),\n  );\n}\n", "import type { LaunchParams } from '@telegram-apps/types';\n\nimport { retrieveFromUrl } from './retrieveFromUrl.js';\n\n/**\n * @returns Launch parameters from the current window location hash.\n * @throws Error if function was unable to extract launch parameters from the window location hash.\n */\nexport function retrieveFromLocation(): LaunchParams {\n  return retrieveFromUrl(window.location.href);\n}\n", "import type { LaunchParams } from '@telegram-apps/types';\n\nimport { retrieveFromUrl } from './retrieveFromUrl.js';\n\n/**\n * @returns Launch parameters based on the first navigation entry.\n * @throws Error if function was unable to extract launch parameters from the navigation entry.\n */\nexport function retrieveFromPerformance(): LaunchParams {\n  const navigationEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n  if (!navigationEntry) {\n    throw new Error('Unable to get first navigation entry.');\n  }\n\n  return retrieveFromUrl(navigationEntry.name);\n}\n", "import { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\nimport { serializeLaunchParams } from '@telegram-apps/transformers';\nimport type { LaunchParams } from '@telegram-apps/types';\n\nimport { parseLaunchParams } from './parseLaunchParams.js';\n\nconst STORAGE_KEY = 'launchParams';\n\n/**\n * @returns Launch parameters stored in the session storage.\n * @throws Error if function was unable to extract launch parameters from the window location hash.\n */\nexport function retrieveFromStorage(): LaunchParams {\n  return parseLaunchParams(getStorageValue(STORAGE_KEY) || '');\n}\n\n/**\n * Saves specified launch parameters in the session storage.\n * @param value - launch params to save.\n */\nexport function saveToStorage(value: LaunchParams): void {\n  setStorageValue('launchParams', serializeLaunchParams(value));\n}\n", "import type { LaunchParams } from '@telegram-apps/types';\nimport { TypedError } from '@telegram-apps/toolkit';\n\nimport { ERR_RETRIEVE_LP_FAILED } from '@/errors.js';\n\nimport { retrieveFromLocation } from './retrieveFromLocation.js';\nimport { retrieveFromPerformance } from './retrieveFromPerformance.js';\nimport { retrieveFromStorage, saveToStorage } from './storage.js';\n\nfunction unwrapError(e: unknown): string {\n  if (e instanceof Error) {\n    return e.message + (e.cause ? `\\n  ${unwrapError(e.cause)}` : '');\n  }\n  return JSON.stringify(e);\n}\n\n/**\n * @returns Launch parameters from any known source.\n * @throws {TypedError} ERR_RETRIEVE_LP_FAILED\n */\nexport function retrieveLaunchParams(): LaunchParams {\n  const errors: unknown[] = [];\n\n  for (const retrieve of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    retrieveFromLocation,\n    // Then, try using the lower level API - window.performance.\n    retrieveFromPerformance,\n    // Finally, try to extract launch parameters from the session storage.\n    retrieveFromStorage,\n  ]) {\n    try {\n      const lp = retrieve();\n      saveToStorage(lp);\n      return lp;\n    } catch (e) {\n      errors.push(e);\n    }\n  }\n\n  throw new TypedError(ERR_RETRIEVE_LP_FAILED, [\n    'Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?',\n    '📖 Refer to docs for more information:',\n    'https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment',\n    'Collected errors:',\n    ...errors.map(e => `— ${unwrapError(e)}`),\n  ].join('\\n'));\n}\n", "import { CancelablePromise, type AsyncOptions } from '@telegram-apps/toolkit';\n\nimport { request } from '@/utils/request.js';\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { retrieveLaunchParams } from '@/launch-params/retrieveLaunchParams.js';\n\n/**\n * Returns true if the current environment is Telegram Mini Apps.\n *\n * It uses the `retrieveLaunchParams` function to determine if the environment contains\n * launch parameters. In case it does, true will be returned.\n *\n * In case you need stricter checks, use async override of this function.\n */\nexport function isTMA(type: 'simple'): boolean;\n\n/**\n * Returns promise with true if the current environment is Telegram Mini Apps.\n *\n * First of all, it checks if the current environment contains traits specific to the\n * Mini Apps environment.\n * Then, it attempts to call a Mini Apps method and waits for a response to be received.\n *\n * In case you need less strict checks, use sync override of this function.\n */\nexport function isTMA(options?: AsyncOptions): CancelablePromise<boolean>\n\nexport function isTMA(optionsOrType?: AsyncOptions | 'simple'): boolean | CancelablePromise<boolean> {\n  if (optionsOrType === 'simple') {\n    try {\n      retrieveLaunchParams();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  return CancelablePromise.withFn(async () => {\n    if (hasWebviewProxy(window)) {\n      return true;\n    }\n    try {\n      await request('web_app_request_theme', 'theme_changed', { timeout: 100 });\n      return true;\n    } catch {\n      return false;\n    }\n  }, optionsOrType);\n}\n", "/**\n * Emits an event sent from the Telegram native application like it was sent in a default web\n * environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitMiniAppsEvent(eventType: string, eventData?: unknown): void {\n  window.dispatchEvent(new MessageEvent('message', {\n    data: JSON.stringify({ eventType, eventData }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent,\n  }));\n}", "import {\n  miniAppsMessage,\n  serializeThemeParams,\n  type ThemeParams,\n} from '@telegram-apps/transformers';\nimport type { LaunchParams } from '@telegram-apps/types';\n\nimport { parseLaunchParams } from '@/launch-params/parseLaunchParams.js';\nimport { saveToStorage } from '@/launch-params/storage.js';\nimport { logInfo } from '@/debug.js';\nimport { emitMiniAppsEvent } from '@/events/emitMiniAppsEvent.js';\nimport type { EventPayload } from '@/events/types/index.js';\n\n/**\n * Intercepts the window.parent.postMessage call and performs pre-defined actions. For example,\n * it may handle the request theme request and emit the theme_changed event.\n * @param tp - theme params.\n * @param data - postMessage data.\n */\nfunction imitatePostEvent(tp: ThemeParams, data: unknown): void {\n  if (typeof data !== 'string') {\n    return;\n  }\n  try {\n    const { eventType } = miniAppsMessage()(data);\n\n    if (eventType === 'web_app_request_theme') {\n      emitMiniAppsEvent('theme_changed', {\n        theme_params: JSON.parse(serializeThemeParams(tp)),\n      } satisfies EventPayload<'theme_changed'>);\n    }\n\n    if (eventType === 'web_app_request_viewport') {\n      emitMiniAppsEvent('viewport_changed', {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        is_state_stable: true,\n        is_expanded: true,\n      } satisfies EventPayload<'viewport_changed'>);\n    }\n  } catch {\n  }\n}\n\n/**\n * Mocks a Telegram application environment.\n * @param launchParamsRaw - launch parameters presented as a string or query parameters.\n */\nexport function mockTelegramEnv(launchParamsRaw: LaunchParams | string): void {\n  const lp = typeof launchParamsRaw === 'string'\n    ? parseLaunchParams(launchParamsRaw)\n    : launchParamsRaw;\n\n  // Save launch params in the storage, so retrieveLaunchParams will return them.\n  saveToStorage(lp);\n\n  // Define a special port, expected by the postEvent function.\n  const proxyPostEvent = (window as any).TelegramWebviewProxy?.postEvent;\n  (window as any).TelegramWebviewProxy = {\n    postEvent(eventType: string, eventData: string) {\n      imitatePostEvent(lp.themeParams, JSON.stringify({ eventType, eventData }));\n      proxyPostEvent?.(eventType, eventData);\n    },\n  };\n\n  logInfo('Environment was mocked by the mockTelegramEnv function');\n}", "import { emitMiniAppsEvent } from '@/events/emitMiniAppsEvent.js';\n\n/**\n * Defines special handlers by known paths, which Telegram recognizes as ports to receive events.\n */\nexport function defineEventHandlers() {\n  // Iterate over each path, where \"receiveEvent\" function should be\n  // defined. This function is called by external environment in case,\n  // it wants to emit some event.\n  [\n    ['TelegramGameProxy_receiveEvent'], // Windows Phone.\n    ['TelegramGameProxy', 'receiveEvent'], // Desktop.\n    ['Telegram', 'WebView', 'receiveEvent'], // Android and iOS.\n  ].forEach((path) => {\n    // Path starts from the \"window\" object.\n    let pointer = window as Record<string, any>;\n\n    path.forEach((item, idx, arr) => {\n      // We are on the last iteration, where function property name is passed.\n      if (idx === arr.length - 1) {\n        pointer[item] = emitMiniAppsEvent;\n        return;\n      }\n\n      if (!(item in pointer)) {\n        pointer[item] = {};\n      }\n      pointer = pointer[item];\n    });\n  });\n}\n", "/**\n * Removes global event handlers, used by the package.\n */\nexport function removeEventHandlers(): void {\n  ['TelegramGameProxy_receiveEvent', 'TelegramGameProxy', 'Telegram'].forEach((prop) => {\n    delete window[prop as keyof Window];\n  });\n}", "import { signalFor } from '@/events/listening/signalFor.js';\nimport type { EventName } from '@/events/types/events.js';\nimport type { EventListener } from '@/events/listening/types.js';\n\n/**\n * Removes the listener from the specified event.\n * @param event - event to listen.\n * @param listener - event listener to remove.\n * @param once - had this listener to be called only once.\n */\nexport function off<E extends EventName>(\n  event: E,\n  listener: EventListener<E>,\n  once?: boolean,\n): void {\n  signalFor(event).unsub(listener, once);\n}\n", "import type { RemoveListenerFn } from '@telegram-apps/signals';\n\nimport { lastEventSignal } from '@/events/listening/lastEvent.js';\nimport type { SubscribeListener } from '@/events/listening/types.js';\n\n/**\n * Subscribes to all events sent from the native Telegram application.\n * @param listener - event listener to bind.\n * @param once - should this listener be called only once.\n * @returns Function to remove bound event listener.\n */\nexport function subscribe(listener: SubscribeListener, once?: boolean): RemoveListenerFn {\n  return lastEventSignal().sub(listener, once);\n}\n", "import type { SubscribeListenerFn } from '@telegram-apps/signals';\n\nimport { $lastEvent, LastEvent } from '@/events/listening/lastEvent.js';\n\n/**\n * Remove a subscriber listening to all events sent from the native Telegram application.\n * @param listener - event listener to remove.\n * @param once - had this listener to be called only once.\n * @returns Function to remove bound event listener.\n */\nexport function unsubscribe(\n  listener: SubscribeListenerFn<LastEvent | undefined>,\n  once?: boolean,\n): void {\n  $lastEvent.unsub(listener, once);\n}\n", "type CaptureSameReqFn = (payload: { req_id: string }) => boolean;\n\n/**\n * Returns a function which can be used in `request` function `capture` property to capture\n * the event with the same request identifier.\n * @param reqId - request identifier.\n */\nexport function captureSameReq(reqId: string): CaptureSameReqFn {\n  return ({ req_id }) => req_id === reqId;\n}\n", "import type { Version } from '@telegram-apps/types';\n\nfunction parts(a: Version): number[] {\n  return a.split('.').map(Number);\n}\n\n/**\n * @param a - first version.\n * @param b - second version.\n * @returns\n * - `1` if the version \"a\" is greater than \"b\".\n * - `0` the version \"a\" is equal to \"b\".\n * - `-1` the version \"a\" is lower than \"b\".\n */\nexport function compareVersions(a: Version, b: Version): number {\n  const aParts = parts(a);\n  const bParts = parts(b);\n  const len = Math.max(aParts.length, bParts.length);\n\n  // Iterate over each part of versions and compare them. In case, part is\n  // missing, assume its value is equal to 0.\n  for (let i = 0; i < len; i += 1) {\n    const aVal = aParts[i] || 0\n    const bVal = bParts[i] || 0;\n\n    if (aVal === bVal) {\n      continue;\n    }\n    return aVal > bVal ? 1 : -1;\n  }\n  return 0;\n}\n", "import type { Version } from '@telegram-apps/types';\n\nimport { compareVersions } from '@/utils/compareVersions.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\n/**\n * Returns true if \"a\" version is less than or equal to \"b\" version.\n * @param a\n * @param b\n */\nfunction versionLessOrEqual(a: Version, b: Version): boolean {\n  return compareVersions(a, b) <= 0;\n}\n\n/**\n * Returns true in case, passed parameter in specified method is supported.\n * @param method - method name\n * @param param - method parameter\n * @param inVersion - platform version.\n */\nexport function supports<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n  inVersion: Version,\n): boolean;\n\n/**\n * Returns true in case, specified method is supported in a passed version.\n * @param method - method name.\n * @param inVersion - platform version.\n */\nexport function supports(method: MethodName, inVersion: Version): boolean;\n\nexport function supports(\n  method: MethodName,\n  paramOrVersion: Version | string,\n  inVersion?: string,\n): boolean {\n  // Method name, parameter, target version.\n  if (typeof inVersion === 'string') {\n    if (method === 'web_app_open_link') {\n      if (paramOrVersion === 'try_instant_view') {\n        return versionLessOrEqual('6.4', inVersion);\n      }\n      if (paramOrVersion === 'try_browser') {\n        return versionLessOrEqual('7.6', inVersion);\n      }\n    }\n\n    if (method === 'web_app_set_header_color') {\n      if (paramOrVersion === 'color') {\n        return versionLessOrEqual('6.9', inVersion);\n      }\n    }\n\n    if (method === 'web_app_close' && paramOrVersion === 'return_back') {\n      return versionLessOrEqual('7.6', inVersion);\n    }\n\n    if (method === 'web_app_setup_main_button' && paramOrVersion === 'has_shine_effect') {\n      return versionLessOrEqual('7.10', inVersion);\n    }\n  }\n\n  switch (method) {\n    case 'web_app_open_tg_link':\n    case 'web_app_open_invoice':\n    case 'web_app_setup_back_button':\n    case 'web_app_set_background_color':\n    case 'web_app_set_header_color':\n    case 'web_app_trigger_haptic_feedback':\n      return versionLessOrEqual('6.1', paramOrVersion);\n    case 'web_app_open_popup':\n      return versionLessOrEqual('6.2', paramOrVersion);\n    case 'web_app_close_scan_qr_popup':\n    case 'web_app_open_scan_qr_popup':\n    case 'web_app_read_text_from_clipboard':\n      return versionLessOrEqual('6.4', paramOrVersion);\n    case 'web_app_switch_inline_query':\n      return versionLessOrEqual('6.7', paramOrVersion);\n    case 'web_app_invoke_custom_method':\n    case 'web_app_request_write_access':\n    case 'web_app_request_phone':\n      return versionLessOrEqual('6.9', paramOrVersion);\n    case 'web_app_setup_settings_button':\n      return versionLessOrEqual('6.10', paramOrVersion);\n    case 'web_app_biometry_get_info':\n    case 'web_app_biometry_open_settings':\n    case 'web_app_biometry_request_access':\n    case 'web_app_biometry_request_auth':\n    case 'web_app_biometry_update_token':\n      return versionLessOrEqual('7.2', paramOrVersion);\n    case 'web_app_setup_swipe_behavior':\n      return versionLessOrEqual('7.7', paramOrVersion);\n    case 'web_app_share_to_story':\n      return versionLessOrEqual('7.8', paramOrVersion);\n    case 'web_app_setup_secondary_button':\n    case 'web_app_set_bottom_bar_color':\n      return versionLessOrEqual('7.10', paramOrVersion);\n    case 'web_app_request_safe_area':\n    case 'web_app_request_content_safe_area':\n    case 'web_app_request_fullscreen':\n    case 'web_app_exit_fullscreen':\n    case 'web_app_set_emoji_status':\n    case 'web_app_add_to_home_screen':\n    case 'web_app_check_home_screen':\n    case 'web_app_request_emoji_status_access':\n      return versionLessOrEqual('8.0', paramOrVersion);\n    default:\n      return [\n        'iframe_ready',\n        'iframe_will_reload',\n        'web_app_close',\n        'web_app_data_send',\n        'web_app_expand',\n        'web_app_open_link',\n        'web_app_ready',\n        'web_app_request_theme',\n        'web_app_request_viewport',\n        'web_app_setup_main_button',\n        'web_app_setup_closing_behavior',\n      ].includes(method);\n  }\n}\n", "import { isRecord } from '@telegram-apps/transformers';\nimport { TypedError } from '@telegram-apps/toolkit';\nimport type { Version } from '@telegram-apps/types';\n\nimport { ERR_METHOD_PARAMETER_UNSUPPORTED, ERR_METHOD_UNSUPPORTED } from '@/errors.js';\nimport { supports } from '@/methods/supports.js';\nimport { type PostEventFn, postEvent } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\nexport type OnUnsupportedFn = (\n  data: { version: Version } & (\n    | { method: MethodName }\n    | {\n    [M in MethodNameWithVersionedParams]: {\n      method: M;\n      param: MethodVersionedParams<M>;\n    };\n  }[MethodNameWithVersionedParams]),\n) => void;\n\nexport type CreatePostEventMode = 'strict' | 'non-strict';\n\n/**\n * Creates a function which checks if specified method and parameters are supported.\n *\n * If method or parameters are unsupported, the `onUnsupported` function will be called.\n *\n * If `strict` or `non-strict` value was passed as the second argument, the function\n * will create its own `onUnsupported` function with behavior depending on the value passed.\n *\n * - Passing `strict` will make function to throw a `TypedError` error\n * with `ERR_METHOD_UNSUPPORTED` or `ERR_METHOD_PARAMETER_UNSUPPORTED` type.\n * - Passing `non-strict` will just warn you about something being unsupported.\n *\n * @param version - Telegram Mini Apps version.\n * @param onUnsupportedOrMode - function or strict mode. Default: `strict`\n */\nexport function createPostEvent(\n  version: Version,\n  onUnsupportedOrMode?: OnUnsupportedFn | CreatePostEventMode,\n): PostEventFn {\n  onUnsupportedOrMode ||= 'strict';\n  const onUnsupported: OnUnsupportedFn = typeof onUnsupportedOrMode === 'function'\n    ? onUnsupportedOrMode\n    : data => {\n      const { method, version } = data;\n      let message: string;\n      let error: string;\n\n      if ('param' in data) {\n        message = `Parameter \"${data.param}\" of \"${method}\" method is unsupported in Mini Apps version ${version}`;\n        error = ERR_METHOD_PARAMETER_UNSUPPORTED;\n      } else {\n        message = `Method \"${method}\" is unsupported in Mini Apps version ${version}`;\n        error = ERR_METHOD_UNSUPPORTED;\n      }\n\n      if (onUnsupportedOrMode === 'strict') {\n        throw new TypedError(error, message);\n      }\n      return console.warn(message);\n    };\n\n  return ((method: any, params: any) => {\n    // Firstly, check if a method is supported.\n    if (!supports(method, version)) {\n      return onUnsupported({ version, method });\n    }\n\n    // Method could use parameters, which are supported only in specific versions of Mini Apps.\n    // We are validating only those parameters, which are not backward compatible.\n    if (\n      isRecord(params)\n      && method === 'web_app_set_header_color'\n      && 'color' in params\n      && !supports(method, 'color', version)\n    ) {\n      return onUnsupported({ version, method, param: 'color' });\n    }\n\n    return postEvent(method, params);\n  }) as PostEventFn;\n}\n", "import { CancelablePromise, TypedError } from '@telegram-apps/toolkit';\n\nimport { ERR_CUSTOM_METHOD_ERR_RESPONSE } from '@/errors.js';\nimport { captureSameReq } from '@/methods/captureSameReq.js';\nimport type { ExecuteWithOptions } from '@/types.js';\nimport type { CustomMethodName, CustomMethodParams } from '@/methods/types/index.js';\n\nimport { request } from './request.js';\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n * @throws {TypedError} ERR_CUSTOM_METHOD_ERR_RESPONSE\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: ExecuteWithOptions,\n): CancelablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n * @throws {TypedError} ERR_CUSTOM_METHOD_ERR_RESPONSE\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: ExecuteWithOptions,\n): CancelablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: ExecuteWithOptions,\n): CancelablePromise<unknown> {\n  return request('web_app_invoke_custom_method', 'custom_method_invoked', {\n    ...options || {},\n    params: { method, params, req_id: requestId },\n    capture: captureSameReq(requestId),\n  })\n    .then(({ result, error }) => {\n      if (error) {\n        throw new TypedError(ERR_CUSTOM_METHOD_ERR_RESPONSE, error);\n      }\n      return result;\n    });\n}\n", "import type { Signal } from '@telegram-apps/signals';\n\nimport { $eventSignalsCache } from '@/events/listening/signalFor.js';\nimport { $lastEvent, $lastEventCleanup } from '@/events/listening/lastEvent.js';\nimport { $targetOrigin } from '@/methods/$targetOrigin.js';\nimport { $debug } from '@/debug.js';\n\nfunction resetSignal(s: Signal<any>): void {\n  s.unsubAll();\n  s.reset();\n}\n\n/**\n * Resets the package state. Normally, you don't use this function in your application.\n * We are using it only for test purposes.\n */\nexport function resetPackageState() {\n  $lastEventCleanup()?.();\n\n  [\n    ...Object.values($eventSignalsCache()),\n    $eventSignalsCache,\n    $lastEvent,\n    $lastEventCleanup,\n    $targetOrigin,\n    $debug,\n  ].forEach(resetSignal);\n}", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;", "import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}", "/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;", "import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;", "import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  DisconnectRequest,\n  DisconnectResponse,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  IsConnectedRequest,\n  IsConnectedResponse,\n  SerializedWalletRequest,\n  SignAndSubmitTransactionRequest,\n  SignInRequest,\n  SignInResponse,\n  SignMessageRequest,\n  SignTransactionRequest,\n} from '@aptos-connect/wallet-api';\nimport { openPrompt, waitForPromptResponse } from './prompt';\nimport { addConnectedAccount, getConnectedAccounts, removeConnectedAccount } from './state';\n\nimport { isTelegramMiniApp, openTelegramPrompt } from './telegram';\n\nexport class WebWalletTransport {\n  constructor(\n    private readonly baseUrl: string,\n    private readonly provider: 'google' | 'apple' = 'google',\n    private readonly tgWebAppUrl?: string,\n  ) {\n    this.baseUrl = baseUrl;\n  }\n\n  async sendPromptRequest(request: SerializedWalletRequest) {\n    if (isTelegramMiniApp()) {\n      return openTelegramPrompt({\n        baseUrl: this.baseUrl,\n        provider: this.provider,\n        request,\n        tgWebAppUrl: this.tgWebAppUrl,\n      });\n    }\n\n    const url = new URL(`${this.baseUrl}/prompt/`);\n    url.searchParams.set('provider', this.provider);\n    const prompt = openPrompt(url);\n\n    return waitForPromptResponse(this.baseUrl, prompt, request);\n  }\n\n  async sendRequest(request: SerializedWalletRequest) {\n    switch (request.name) {\n      case IsConnectedRequest.name: {\n        const connectedAccounts = getConnectedAccounts();\n        return IsConnectedResponse.serialize(connectedAccounts.length > 0);\n      }\n      case GetConnectedAccountsRequest.name: {\n        const connectedAccounts = getConnectedAccounts();\n        return GetConnectedAccountsResponse.serialize(connectedAccounts);\n      }\n      case ConnectRequest.name: {\n        const serializedResponse = await this.sendPromptRequest(request);\n        const response = ConnectResponse.deserialize(serializedResponse);\n        if (response.args.status === 'approved') {\n          const { account, pairing } = response.args.args;\n          if (pairing === undefined) {\n            addConnectedAccount(account);\n          }\n        }\n        return serializedResponse;\n      }\n      case SignInRequest.name: {\n        const serializedResponse = await this.sendPromptRequest(request);\n        const response = SignInResponse.deserialize(serializedResponse, (request as unknown as SignInRequest).version);\n        if (response.args.status === 'approved') {\n          const { account } = response.args.args;\n          addConnectedAccount(account);\n        }\n        return serializedResponse;\n      }\n      case DisconnectRequest.name: {\n        const [activeAccount] = getConnectedAccounts();\n        if (activeAccount) {\n          removeConnectedAccount(activeAccount.address);\n        }\n        return DisconnectResponse.serialize({});\n      }\n      case SignMessageRequest.name:\n      case SignTransactionRequest.name:\n      case SignAndSubmitTransactionRequest.name: {\n        return this.sendPromptRequest(request);\n      }\n      default: {\n        throw new Error('Unexpected request');\n      }\n    }\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectResponse,\n  isTypedMessage,\n  PromptApprovalResponseMessage,\n  PromptConnectionRequestMessage,\n  PromptConnectionResponseMessage,\n  PromptUnauthorizedErrorMessage,\n  SerializedWalletRequest,\n  SerializedWalletResponse,\n} from '@aptos-connect/wallet-api';\n\nconst DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nconst PROMPT_POLLER_INTERVAL = 500;\n\nconst dismissalSerializedResponse = ConnectResponse.serialize({ status: 'dismissed' });\n\nexport class PromptUnauthorizedError extends Error {\n  constructor() {\n    super('Unauthorized');\n  }\n}\n\nexport function openPrompt(url: string | URL, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width,\n  };\n\n  const strOptions = Object.entries(options)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .reduce((acc, entry) => `${acc}, ${entry}`);\n\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, undefined, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n\n  return promptWindow;\n}\n\nexport async function waitForPromptResponse(baseUrl: string, promptWindow: Window, request: SerializedWalletRequest) {\n  return new Promise<SerializedWalletResponse>((resolve, reject) => {\n    const listeners = {\n      onMessage: (message: MessageEvent) => {\n        // Ignore messages from untrusted sources\n        if (message.source !== promptWindow || message.origin !== baseUrl) {\n          return;\n        }\n        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          reject(new PromptUnauthorizedError());\n          return;\n        }\n        if (isTypedMessage(PromptConnectionRequestMessage, message.data)) {\n          promptWindow.postMessage(new PromptConnectionResponseMessage(request), baseUrl);\n          return;\n        }\n        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve(message.data.serializedValue);\n        }\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve(dismissalSerializedResponse);\n        }\n      }, PROMPT_POLLER_INTERVAL),\n    };\n\n    window.addEventListener('message', listeners.onMessage);\n  });\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountInfo,\n  base64ToBytes,\n  bytesToBase64,\n  deserializeAccountInfo,\n  serializeAccountInfo,\n} from '@aptos-connect/wallet-api';\nimport { AccountAddress, Deserializer, Serializer } from '@aptos-labs/ts-sdk';\n\nconst localDappStateKey = '@aptos-connect/dapp-local-state';\n\n/**\n * Local dapp state loosely synced with the web wallet's state.\n * Due to browser restrictions (storage partitioning), it's no longer possible\n * to access the web wallet's state.\n */\ninterface DappLocalState {\n  connectedAccounts: AccountInfo[];\n}\n\nfunction serializeLocalDappState(state: DappLocalState): Uint8Array {\n  const serializer = new Serializer();\n  serializer.serializeU32AsUleb128(state.connectedAccounts.length);\n  for (const account of state.connectedAccounts) {\n    serializeAccountInfo(serializer, account);\n  }\n  return serializer.toUint8Array();\n}\n\nfunction deserializeLocalDappState(serializedValue: Uint8Array): DappLocalState {\n  const deserializer = new Deserializer(serializedValue);\n  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();\n  const connectedAccounts: AccountInfo[] = [];\n  for (let i = 0; i < connectedAccountsLength; i += 1) {\n    connectedAccounts.push(deserializeAccountInfo(deserializer));\n  }\n  return { connectedAccounts };\n}\n\nfunction getState(): DappLocalState {\n  const encodedValue = window.localStorage.getItem(localDappStateKey);\n  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };\n}\n\nfunction setState(state: DappLocalState) {\n  const serializedValue = serializeLocalDappState(state);\n  const encodedValue = bytesToBase64(serializedValue);\n  window.localStorage.setItem(localDappStateKey, encodedValue);\n}\n\nexport function getConnectedAccounts() {\n  const state = getState();\n  return state.connectedAccounts;\n}\n\nexport function addConnectedAccount(account: AccountInfo) {\n  const { connectedAccounts, ...state } = getState();\n  connectedAccounts.push(account);\n  setState({ ...state, connectedAccounts });\n}\n\nexport function removeConnectedAccount(address: AccountAddress) {\n  const { connectedAccounts, ...state } = getState();\n  const index = connectedAccounts.findIndex((a) => a.address.equals(address));\n  if (index >= 0) {\n    connectedAccounts.splice(index, 1);\n  }\n  setState({ ...state, connectedAccounts });\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  encodePopupWalletRequest,\n  makePopupWalletRequestChallenge,\n  SerializedWalletRequest,\n  SignedPopupWalletRequest,\n} from '@aptos-connect/wallet-api';\nimport { postEvent as postTelegramEvent } from '@telegram-apps/bridge';\nimport { v4 as randomUUID } from 'uuid';\nimport { createWalletRequest } from './createWalletRequest';\nimport { getClientIdentityKey } from './getClientIdentityKey';\nimport { getWalletResponse } from './getWalletResponse';\n\nexport async function openTelegramPrompt(args: {\n  baseUrl: string;\n  provider?: 'google' | 'apple';\n  request: SerializedWalletRequest;\n  tgWebAppUrl?: string;\n}) {\n  const { baseUrl, provider, request: body, tgWebAppUrl = '/AptosConnectBot/AptosConnect' } = args;\n  const identityKey = getClientIdentityKey();\n  const clientIdentityKey = identityKey.publicKey();\n  const requestId = randomUUID();\n  const timestamp = Date.now();\n\n  const challenge = makePopupWalletRequestChallenge({ body, id: requestId, timestamp });\n  const signature = identityKey.sign(challenge);\n\n  const signedWalletRequest: SignedPopupWalletRequest = {\n    body,\n    clientIdentityKey,\n    id: requestId,\n    signature,\n    timestamp,\n  };\n\n  // Telegram only supports start parameters up to 1024 characters\n  // If the encoded request is longer, we send it to the backend and mark\n  // the request as \"deferred\" by omitting the body\n  let encodedRequest = encodePopupWalletRequest(signedWalletRequest);\n  if (encodedRequest.length > 1024) {\n    void createWalletRequest(baseUrl, signedWalletRequest);\n    encodedRequest = encodePopupWalletRequest({\n      clientIdentityKey,\n      id: requestId,\n      signature,\n      timestamp,\n    });\n  }\n\n  const startParam = `prompt_${provider ?? ''}${encodedRequest}`;\n  postTelegramEvent('web_app_open_tg_link', {\n    path_full: `${tgWebAppUrl}?startapp=${startParam}`,\n  });\n\n  return getWalletResponse(baseUrl, clientIdentityKey, requestId);\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  bytesToBase64,\n  bytesToBase64url,\n  encodeWalletRequestBody,\n  SignedPopupWalletRequest,\n} from '@aptos-connect/wallet-api';\n\nexport async function createWalletRequest(baseUrl: string, request: SignedPopupWalletRequest) {\n  const encodedClientIdentityKey = bytesToBase64url(request.clientIdentityKey.toUint8Array());\n\n  const response = await fetch(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/`, {\n    body: JSON.stringify({\n      body: encodeWalletRequestBody(request.body),\n      id: request.id,\n      signature: bytesToBase64(request.signature.toUint8Array()),\n      timestamp: request.timestamp,\n    }),\n    headers: { Accept: 'application/json', 'Content-Type': 'application/json' },\n    method: 'post',\n  });\n\n  if (!response.ok) {\n    throw new Error('Failed creating the wallet request');\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519PrivateKey } from '@aptos-labs/ts-sdk';\n\nconst identityKeyStorageKey = '@aptos-connect/client-identity-key';\n\nexport function getClientIdentityKey() {\n  const serialized = window.localStorage.getItem(identityKeyStorageKey);\n  if (serialized) {\n    return new Ed25519PrivateKey(serialized);\n  }\n  const identityKey = Ed25519PrivateKey.generate();\n  window.localStorage.setItem(identityKeyStorageKey, identityKey.toString());\n  return identityKey;\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { base64ToBytes, bytesToBase64url, SerializedWalletResponse } from '@aptos-connect/wallet-api';\nimport { Ed25519PublicKey } from '@aptos-labs/ts-sdk';\nimport { smartPolling } from './smartPolling';\n\nexport async function getWalletResponse(\n  baseUrl: string,\n  clientIdentityKey: Ed25519PublicKey,\n  requestId: string,\n): Promise<SerializedWalletResponse> {\n  const encodedClientIdentityKey = bytesToBase64url(clientIdentityKey.toUint8Array());\n  const url = new URL(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/${requestId}/response/`);\n  const response = await smartPolling(() =>\n    fetch(url, {\n      headers: { Accept: 'application/json' },\n      method: 'get',\n    }),\n  );\n\n  const responseBody = await response.json();\n  const data = base64ToBytes(responseBody.data.body);\n  return { data };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-await-in-loop */\n\n/**\n * How long to wait after resuming before trying to fetch the resource again.\n * This gives time for the underlying resource to be persisted.\n */\nconst ON_RESUME_DELAY = 300;\n\n/**\n * How often to poll for the resource when the window is in the foreground.\n * This should typically not be needed, but it's a good fallback in case we\n * can't detect whether the window is in the background\n */\nconst FG_RESPONSE_POLLING_INTERVAL = 2000;\n\n/**\n * Polling interval when the window is in the background.\n * This can be arbitrarily long, but it's still good to keep polling as fallback.\n */\nconst BG_RESPONSE_POLLING_INTERVAL = 3000;\n\n/**\n * Given there's no \"cancel\" mechanism for polling, we should time out the polling after\n * an arbitrarily long time to prevent memory leaks.\n */\nconst POLLING_TIMEOUT = 5 * 60000;\n\nexport interface Timer extends Promise<void> {\n  cancel: () => void;\n}\n\nfunction waitFor(milliseconds: number): Timer {\n  let timeoutId: ReturnType<typeof setTimeout>;\n  let cancel = () => {};\n  const timer = new Promise((resolve) => {\n    timeoutId = setTimeout(resolve, milliseconds);\n    cancel = () => {\n      clearTimeout(timeoutId);\n      resolve();\n    };\n  }) as Timer;\n  timer.cancel = cancel;\n  return timer;\n}\n\n/**\n * Smart polling function that tries to reduce as much as possible the number of requests,\n * while still returning quickly after the resource becomes available.\n */\nexport async function smartPolling(callback: () => Promise<Response>): Promise<Response> {\n  let timer: Timer | undefined;\n  let justResumed = false;\n  let pollingInterval = BG_RESPONSE_POLLING_INTERVAL;\n\n  const onWindowFocus = () => {\n    justResumed = true;\n    pollingInterval = FG_RESPONSE_POLLING_INTERVAL;\n    timer?.cancel();\n  };\n\n  const onWindowBlur = () => {\n    pollingInterval = BG_RESPONSE_POLLING_INTERVAL;\n  };\n\n  window.addEventListener('focus', onWindowFocus);\n  window.addEventListener('blur', onWindowBlur);\n\n  try {\n    const startTime = Date.now();\n    while (Date.now() - startTime < POLLING_TIMEOUT) {\n      timer = waitFor(pollingInterval);\n      await timer;\n\n      if (justResumed) {\n        timer = waitFor(ON_RESUME_DELAY);\n        await timer;\n      }\n\n      const response = await callback();\n      if (response.status === 200) {\n        return response;\n      }\n      justResumed = false;\n    }\n    throw new Error('Timeout');\n  } finally {\n    window.removeEventListener('focus', onWindowFocus);\n    window.removeEventListener('blur', onWindowFocus);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport function isTelegramMiniApp() {\n  return (window as any).TelegramWebviewProxy !== undefined;\n}\n\nexport * from './openTelegramPrompt';\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_BACKEND_URL = 'https://identityconnect.com';\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport enum NetworkName {\n  DEVNET = 'devnet',\n  MAINNET = 'mainnet',\n  TESTNET = 'testnet',\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountData } from './account';\nimport { RegisteredDappDataBase } from './dapp';\nimport { ConnectedWalletData } from './wallet';\nimport { DappSpecificWallet } from './dappSpecificWallet';\n\nexport enum PairingStatus {\n  Finalized = 'FINALIZED',\n  Pending = 'PENDING',\n}\n\nexport interface BasePairingData {\n  createdAt: Date;\n  dappEd25519PublicKeyB64: string;\n  dappSpecificWallet?: DappSpecificWallet;\n  dappSpecificWalletId?: string;\n  expiresAt: Date;\n  id: string;\n  maxDappSequenceNumber: number;\n  maxWalletSequenceNumber: number;\n  registeredDapp: RegisteredDappDataBase;\n  registeredDappId: string;\n  status: PairingStatus;\n  updatedAt: Date;\n}\n\nexport interface NewPairingData extends BasePairingData {\n  maxDappSequenceNumber: -1;\n  maxWalletSequenceNumber: -1;\n  status: PairingStatus.Pending;\n}\n\nexport interface BaseFinalizedPairingData extends BasePairingData {\n  account: AccountData;\n  accountId: string;\n  status: PairingStatus.Finalized;\n  walletName: string;\n}\n\nexport interface AnonymousPairingData extends BaseFinalizedPairingData {\n  anonymousWallet: ConnectedWalletData;\n  anonymousWalletId: string;\n}\n\nexport type FinalizedPairingData = BaseFinalizedPairingData | AnonymousPairingData;\nexport type PairingData = NewPairingData | FinalizedPairingData;\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RegisteredDappDataBase } from './dapp';\n\n// region Duplicated from crypto to prevent dependency cycle\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\n// endregion\n\nexport enum SigningRequestTypes {\n  SIGN_AND_SUBMIT_TRANSACTION = 'SIGN_AND_SUBMIT_TRANSACTION',\n  SIGN_MESSAGE = 'SIGN_MESSAGE',\n  SIGN_TRANSACTION = 'SIGN_TRANSACTION',\n}\n\nexport enum SigningRequestStatus {\n  APPROVED = 'APPROVED',\n  CANCELLED = 'CANCELLED',\n  INVALID = 'INVALID',\n  PENDING = 'PENDING',\n  REJECTED = 'REJECTED',\n}\n\nexport interface SigningRequestData {\n  apiVersion: string;\n  createdAt: Date;\n  id: string;\n  networkName: string | null;\n  pairing: {\n    registeredDapp: RegisteredDappDataBase;\n  };\n  pairingId: string;\n  requestEnvelope: SecuredEnvelopeTransport;\n  requestType: SigningRequestTypes;\n  responseEnvelope?: SecuredEnvelopeTransport;\n  status: SigningRequestStatus;\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { AccountData } from './account';\nimport type { AnonymousPairingData } from './pairing';\nimport { DappSpecificWallet } from './dappSpecificWallet';\n\nexport enum WalletOSEnum {\n  Android = 'android',\n  IdentityConnect = 'ic',\n  Linux = 'linux',\n  Macos = 'osx',\n  Windows = 'win',\n  iOS = 'ios',\n}\n\nexport enum WalletPlatformEnum {\n  BraveExtension = 'brave-extension',\n  ChromeExtension = 'chrome-extension',\n  FirefoxExtension = 'firefox-extension',\n  /// Reserved for IC full custody\n  IcDappWallet = 'ic-dapp-wallet',\n  KiwiExtension = 'kiwi-extension',\n  NativeApp = 'native-app',\n  OperaExtension = 'opera-extension',\n  SafariExtension = 'safari-extension',\n}\n\nexport type WalletOS = `${WalletOSEnum}`;\nexport type WalletPlatform = `${WalletPlatformEnum}`;\n\nexport interface BaseWalletData {\n  createdAt: Date;\n  dappSpecificWallet?: DappSpecificWallet;\n  dappSpecificWalletId?: string;\n  icEd25519PublicKeyB64: string;\n  id: string;\n  updatedAt: Date;\n}\n\nexport interface NewWalletData extends BaseWalletData {\n  walletEd25519PublicKeyB64: null;\n}\n\nexport interface BaseConnectedWalletData extends BaseWalletData {\n  accounts: AccountData[];\n  deviceIdentifier: string;\n  platform: WalletPlatform;\n  platformOS: WalletOS;\n  userSubmittedAlias?: string;\n  walletEd25519PublicKeyB64: string;\n  walletName: string;\n}\n\nexport interface AuthenticatedWalletData extends BaseConnectedWalletData {\n  anonymousPairing: null;\n  user: { id: string; username: string };\n  userId: string;\n}\n\nexport interface AnonymousWalletData extends BaseConnectedWalletData {\n  anonymousPairing: AnonymousPairingData;\n  userId: null;\n}\n\nexport type ConnectedWalletData = AuthenticatedWalletData | AnonymousWalletData;\n\nexport type WalletData = NewWalletData | ConnectedWalletData;\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer, Hex, Serializable as BcsSerializableV2 } from '@aptos-labs/ts-sdk';\nimport { BCS } from 'aptos';\n\nexport type BcsSerializableV1 = { serialize(serializer: BCS.Serializer): void };\nexport type BcsDeserializableV1Class<T extends BcsSerializableV1> = {\n  deserialize(deserializer: BCS.Deserializer): T;\n};\nexport type BcsDeserializableV2Class<T extends BcsSerializableV2> = {\n  deserialize(deserializer: Deserializer): T;\n};\n\nfunction isBcsSerializableV1(value: any): value is BcsSerializableV1 {\n  return (value as BcsSerializableV1)?.serialize !== undefined;\n}\n\nfunction isBcsSerializableV2(value: any): value is BcsSerializableV2 {\n  return (\n    (value as BcsSerializableV2)?.serialize !== undefined &&\n    (value as BcsSerializableV2)?.bcsToBytes !== undefined &&\n    (value as BcsSerializableV2)?.bcsToHex !== undefined\n  );\n}\n\n/**\n * Check if a value is BCS serializable\n */\nexport function isBcsSerializable(value: any): value is BcsSerializableV1 | BcsSerializableV2 {\n  return isBcsSerializableV1(value) || isBcsSerializableV2(value);\n}\n\nexport function bcsSerialize(serializable: BcsSerializableV1 | BcsSerializableV2) {\n  if (isBcsSerializableV2(serializable)) {\n    return serializable.bcsToHex().toString();\n  }\n  const serializedValueBytes = BCS.bcsToBytes(serializable);\n  return Hex.fromHexInput(serializedValueBytes).toString();\n}\n\nexport function bcsDeserialize<T extends BcsSerializableV2>(\n  deserializableClass: BcsDeserializableV2Class<T>,\n  serializedValue: string,\n) {\n  const serializedValueBytes = Hex.fromHexString(serializedValue).toUint8Array();\n  const deserializer = new Deserializer(serializedValueBytes);\n  return deserializableClass.deserialize(deserializer);\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Hex } from '@aptos-labs/ts-sdk';\nimport type { EntryFunctionPayloadResponse } from '@aptos-labs/ts-sdk';\nimport type { EntryFunctionJsonTransactionPayload, JsonTransactionPayload } from '../types';\nimport { UnexpectedValueError } from './error';\n\ninterface SerializedUint8ArrayArg {\n  type: 'Uint8Array';\n  value: string;\n}\n\nfunction isSerializedUint8Array(arg: any): arg is SerializedUint8ArrayArg {\n  return arg?.type === 'Uint8Array' && typeof arg?.value === 'string';\n}\n\nfunction serializeEntryFunctionArg(arg: any): any {\n  if (arg instanceof Uint8Array) {\n    return {\n      type: 'Uint8Array',\n      value: Hex.fromHexInput(arg).toString(),\n    };\n  }\n  if (Array.isArray(arg)) {\n    return arg.map(serializeEntryFunctionArg);\n  }\n  return arg;\n}\n\nfunction deserializeEntryFunctionArg(arg: any): any {\n  if (isSerializedUint8Array(arg)) {\n    return Hex.fromHexInput(arg.value).toUint8Array();\n  }\n  if (Array.isArray(arg)) {\n    return arg.map(deserializeEntryFunctionArg);\n  }\n  return arg;\n}\n\nfunction serializeEntryFunctionPayload(payload: EntryFunctionPayloadResponse): EntryFunctionJsonTransactionPayload {\n  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);\n  return {\n    ...payload,\n    arguments: normalizedArgs,\n    type: 'entry_function_payload',\n  };\n}\n\nfunction deserializeEntryFunctionPayload(payload: EntryFunctionPayloadResponse): EntryFunctionJsonTransactionPayload {\n  const deserializedArgs = payload.arguments.map(deserializeEntryFunctionArg);\n  return {\n    ...payload,\n    arguments: deserializedArgs,\n    type: 'entry_function_payload',\n  };\n}\n\nexport function serializeJsonTransactionPayload(payload: JsonTransactionPayload): JsonTransactionPayload {\n  if (payload.type === 'entry_function_payload' || payload.type === undefined) {\n    return serializeEntryFunctionPayload(payload);\n  }\n  if (payload.type === 'multisig_payload') {\n    const innerPayload =\n      payload.transaction_payload !== undefined\n        ? serializeEntryFunctionPayload(payload.transaction_payload)\n        : undefined;\n    return { ...payload, transaction_payload: innerPayload };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeJsonTransactionPayload(payload: JsonTransactionPayload): JsonTransactionPayload {\n  if (payload.type === 'entry_function_payload' || payload.type === undefined) {\n    return deserializeEntryFunctionPayload(payload);\n  }\n  if (payload.type === 'multisig_payload') {\n    const innerPayload =\n      payload.transaction_payload !== undefined\n        ? deserializeEntryFunctionPayload(payload.transaction_payload)\n        : undefined;\n    return { ...payload, transaction_payload: innerPayload };\n  }\n  throw new UnexpectedValueError();\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class UnexpectedValueError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = 'UnexpectedValueError';\n    Object.setPrototypeOf(this, UnexpectedValueError.prototype);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  RawTransaction,\n  RawTransactionWithData,\n} from '@aptos-labs/ts-sdk';\nimport { TxnBuilderTypes } from 'aptos';\nimport { bcsDeserialize, bcsSerialize } from './bcsSerialization';\nimport { UnexpectedValueError } from './error';\n\nexport type SerializableRawTransaction = RawTransaction | FeePayerRawTransaction | MultiAgentRawTransaction;\n\nexport type SerializableRawTransactionV1 =\n  | TxnBuilderTypes.RawTransaction\n  | TxnBuilderTypes.FeePayerRawTransaction\n  | TxnBuilderTypes.MultiAgentRawTransaction;\n\nexport interface SerializedSimpleRawTransaction {\n  type: 'raw_txn';\n  value: string;\n}\n\nexport interface SerializedFeePayerRawTransaction {\n  type: 'fee_payer_raw_txn';\n  value: string;\n}\n\nexport interface SerializedMultiAgentRawTransaction {\n  type: 'multi_agent_raw_txn';\n  value: string;\n}\n\nexport type SerializedRawTransaction =\n  | SerializedSimpleRawTransaction\n  | SerializedFeePayerRawTransaction\n  | SerializedMultiAgentRawTransaction;\n\nexport function serializeRawTransaction(\n  rawTxn: RawTransaction | TxnBuilderTypes.RawTransaction,\n): SerializedSimpleRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: FeePayerRawTransaction | TxnBuilderTypes.FeePayerRawTransaction,\n): SerializedFeePayerRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: MultiAgentRawTransaction | TxnBuilderTypes.MultiAgentRawTransaction,\n): SerializedMultiAgentRawTransaction;\nexport function serializeRawTransaction(\n  rawTxn: SerializableRawTransaction | SerializableRawTransactionV1,\n): SerializedRawTransaction;\n\nexport function serializeRawTransaction(\n  rawTxn: SerializableRawTransaction | SerializableRawTransactionV1,\n): SerializedRawTransaction {\n  const value = bcsSerialize(rawTxn);\n  if ('fee_payer_address' in rawTxn) {\n    return { type: 'fee_payer_raw_txn', value };\n  }\n  if ('secondary_signer_addresses' in rawTxn) {\n    return { type: 'multi_agent_raw_txn', value };\n  }\n  if ('chain_id' in rawTxn) {\n    return { type: 'raw_txn', value };\n  }\n  throw new UnexpectedValueError('Invalid raw transaction type');\n}\n\nexport function deserializeRawTransaction(serialized: SerializedSimpleRawTransaction): RawTransaction;\nexport function deserializeRawTransaction(serialized: SerializedFeePayerRawTransaction): FeePayerRawTransaction;\nexport function deserializeRawTransaction(serialized: SerializedMultiAgentRawTransaction): MultiAgentRawTransaction;\nexport function deserializeRawTransaction(serialized: SerializedRawTransaction): SerializableRawTransaction;\n\nexport function deserializeRawTransaction(serialized: SerializedRawTransaction): SerializableRawTransaction {\n  switch (serialized.type) {\n    case 'raw_txn':\n      return bcsDeserialize(RawTransaction, serialized.value);\n    case 'fee_payer_raw_txn':\n      return bcsDeserialize(RawTransactionWithData, serialized.value) as FeePayerRawTransaction;\n    case 'multi_agent_raw_txn':\n      return bcsDeserialize(RawTransactionWithData, serialized.value) as MultiAgentRawTransaction;\n    default:\n      throw new UnexpectedValueError('Invalid raw transaction type');\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAuthenticator, TransactionPayload } from '@aptos-labs/ts-sdk';\nimport type {\n  SignAndSubmitTransactionRequestArgs,\n  SignAndSubmitTransactionRequestV1Args,\n  SignAndSubmitTransactionWithFeePayerRawTxnRequestArgs,\n  SignAndSubmitTransactionWithPayloadRequestArgs,\n  SignAndSubmitTransactionWithRawTxnRequestArgs,\n} from '../types';\nimport { JsonTransactionPayload, TransactionOptions } from '../types';\nimport { bcsDeserialize, bcsSerialize, isBcsSerializable } from './bcsSerialization';\n\nimport { UnexpectedValueError } from './error';\nimport { deserializeJsonTransactionPayload, serializeJsonTransactionPayload } from './jsonPayload';\nimport {\n  deserializeRawTransaction,\n  type SerializedFeePayerRawTransaction,\n  type SerializedSimpleRawTransaction,\n  serializeRawTransaction,\n} from './rawTxn';\n\nexport interface SerializedSignAndSubmitTransactionWithPayloadRequestArgs {\n  options?: TransactionOptions;\n  payload: JsonTransactionPayload | string;\n}\n\nexport interface SerializedSignAndSubmitTransactionWithRawTxnRequestArgs {\n  rawTxn: SerializedSimpleRawTransaction;\n}\n\nexport interface SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs {\n  feePayerAuthenticator: string;\n  rawTxn: SerializedFeePayerRawTransaction;\n}\n\nexport type SerializedSignAndSubmitTransactionRequestArgs =\n  | SerializedSignAndSubmitTransactionWithPayloadRequestArgs\n  | SerializedSignAndSubmitTransactionWithRawTxnRequestArgs\n  | SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs;\n\nexport function serializeSignAndSubmitTransactionRequestArgs(\n  args: SignAndSubmitTransactionRequestArgs | SignAndSubmitTransactionRequestV1Args,\n): SerializedSignAndSubmitTransactionRequestArgs {\n  if ('payload' in args) {\n    const serializedPayload = isBcsSerializable(args.payload)\n      ? bcsSerialize(args.payload)\n      : serializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload: serializedPayload };\n  }\n  if ('feePayerAuthenticator' in args) {\n    return {\n      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),\n      rawTxn: serializeRawTransaction(args.rawTxn),\n    };\n  }\n  if ('rawTxn' in args) {\n    return { rawTxn: serializeRawTransaction(args.rawTxn) };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithPayloadRequestArgs,\n): SignAndSubmitTransactionWithPayloadRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithRawTxnRequestArgs,\n): SignAndSubmitTransactionWithRawTxnRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionWithFeePayerRawTxnRequestArgs,\n): SignAndSubmitTransactionWithFeePayerRawTxnRequestArgs;\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionRequestArgs,\n): SignAndSubmitTransactionRequestArgs;\n\nexport function deserializeSignAndSubmitTransactionRequestArgs(\n  args: SerializedSignAndSubmitTransactionRequestArgs,\n): SignAndSubmitTransactionRequestArgs {\n  if ('payload' in args) {\n    const payload =\n      typeof args.payload === 'string'\n        ? bcsDeserialize(TransactionPayload, args.payload)\n        : deserializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload };\n  }\n  if ('feePayerAuthenticator' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    const feePayerAuthenticator = bcsDeserialize(AccountAuthenticator, args.feePayerAuthenticator);\n    return { feePayerAuthenticator, rawTxn: deserializedRawTxn };\n  }\n  if ('rawTxn' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    return { rawTxn: deserializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TransactionPayload } from '@aptos-labs/ts-sdk';\nimport type {\n  JsonTransactionPayload,\n  SignTransactionRequestArgs,\n  SignTransactionRequestV1Args,\n  SignTransactionWithPayloadRequestArgs,\n  SignTransactionWithRawTxnRequestArgs,\n  TransactionOptions,\n} from '../types';\nimport { bcsDeserialize, bcsSerialize, isBcsSerializable } from './bcsSerialization';\nimport { UnexpectedValueError } from './error';\nimport { deserializeJsonTransactionPayload, serializeJsonTransactionPayload } from './jsonPayload';\nimport type { SerializedRawTransaction } from './rawTxn';\nimport { deserializeRawTransaction, serializeRawTransaction } from './rawTxn';\n\nexport interface SerializedSignTransactionWithPayloadRequestArgs {\n  options?: TransactionOptions;\n  payload: JsonTransactionPayload | string;\n}\n\nexport interface SerializedSignTransactionWithRawTxnRequestArgs {\n  rawTxn: SerializedRawTransaction;\n}\n\nexport type SerializedSignTransactionRequestArgs =\n  | SerializedSignTransactionWithPayloadRequestArgs\n  | SerializedSignTransactionWithRawTxnRequestArgs;\n\nexport function serializeSignTransactionRequestArgs(\n  args: SignTransactionRequestArgs | SignTransactionRequestV1Args,\n): SerializedSignTransactionRequestArgs {\n  if ('payload' in args) {\n    const serializedPayload = isBcsSerializable(args.payload)\n      ? bcsSerialize(args.payload)\n      : serializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload: serializedPayload };\n  }\n  if ('rawTxn' in args) {\n    const serializedRawTxn = serializeRawTransaction(args.rawTxn);\n    return { rawTxn: serializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionWithPayloadRequestArgs,\n): SignTransactionWithPayloadRequestArgs;\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionWithRawTxnRequestArgs,\n): SignTransactionWithRawTxnRequestArgs;\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionRequestArgs,\n): SignTransactionRequestArgs;\n\nexport function deserializeSignTransactionRequestArgs(\n  args: SerializedSignTransactionRequestArgs,\n): SignTransactionRequestArgs {\n  if ('payload' in args) {\n    const payload =\n      typeof args.payload === 'string'\n        ? bcsDeserialize(TransactionPayload, args.payload)\n        : deserializeJsonTransactionPayload(args.payload);\n    return { options: args.options, payload };\n  }\n  if ('rawTxn' in args) {\n    const deserializedRawTxn = deserializeRawTransaction(args.rawTxn);\n    return { rawTxn: deserializedRawTxn };\n  }\n  throw new UnexpectedValueError();\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAuthenticator, RawTransaction } from '@aptos-labs/ts-sdk';\nimport type { SignTransactionResponseArgs } from '../types';\nimport { bcsDeserialize, bcsSerialize } from './bcsSerialization';\n\nexport interface SerializedSignTransactionWithPayloadResponseArgs {\n  accountAuthenticator: string;\n  rawTxn: string;\n}\n\nexport interface SerializedSignTransactionWithRawTxnResponseArgs {\n  accountAuthenticator: string;\n}\n\nexport type SerializedSignTransactionResponseArgs =\n  | SerializedSignTransactionWithPayloadResponseArgs\n  | SerializedSignTransactionWithRawTxnResponseArgs;\n\nexport function serializeSignTransactionResponseArgs(\n  args: SignTransactionResponseArgs,\n): SerializedSignTransactionResponseArgs {\n  const accountAuthenticator = bcsSerialize(args.accountAuthenticator);\n  if ('rawTxn' in args) {\n    const rawTxn = bcsSerialize(args.rawTxn);\n    return { accountAuthenticator, rawTxn };\n  }\n  return { accountAuthenticator };\n}\n\nexport function deserializeSignTransactionResponseArgs(\n  args: SerializedSignTransactionResponseArgs,\n): SignTransactionResponseArgs {\n  const accountAuthenticator = bcsDeserialize(AccountAuthenticator, args.accountAuthenticator);\n  if ('rawTxn' in args) {\n    const rawTxn = bcsDeserialize(RawTransaction, args.rawTxn);\n    return { accountAuthenticator, rawTxn };\n  }\n  return { accountAuthenticator };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { FullMessageFlags, FullMessageParams, FullMessageResult } from '../types';\n\nconst prefix = 'APTOS';\n\nexport function makeFullMessage(params: FullMessageParams, flags: FullMessageFlags): FullMessageResult {\n  let fullMessage = prefix;\n  if (flags.address) {\n    fullMessage += `\\naddress: ${params.address}`;\n  }\n  if (flags.application) {\n    fullMessage += `\\napplication: ${params.application}`;\n  }\n  if (flags.chainId) {\n    fullMessage += `\\nchainId: ${params.chainId}`;\n  }\n\n  fullMessage += `\\nmessage: ${params.message}`;\n  fullMessage += `\\nnonce: ${params.nonce}`;\n\n  return {\n    fullMessage,\n    prefix,\n  };\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  chainIdToNetwork,\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  makeUserApproval,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignInRequest,\n  SignInResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n  UserApproval,\n  UserDismissal,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  AnySignature,\n  AptosConfig,\n  Deserializer,\n  Ed25519Signature,\n  FeePayerRawTransaction,\n  generateRawTransaction,\n  Hex,\n} from '@aptos-labs/ts-sdk';\nimport { NetworkName } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { SignAndSubmitTransactionRequestArgs } from '@identity-connect/wallet-api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { normalizePayloadForIC } from './conversion';\nimport { ACPairingClient } from './PairingClient';\n\nexport interface WithSignerAddress {\n  signerAddress: AccountAddress;\n}\n\nexport interface ACDappClientConfig {\n  backendBaseURL?: string;\n  dappId?: string;\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n  provider?: 'google' | 'apple';\n  tgWebAppURL?: string;\n}\n\nexport class ACDappClient {\n  private readonly defaultNetworkName: NetworkName;\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  private readonly dappId?: string;\n  private readonly pairingClient: ACPairingClient;\n\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = 'google',\n    tgWebAppURL,\n  }: ACDappClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL, provider, tgWebAppURL);\n\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL,\n      },\n      defaultNetworkName,\n    });\n  }\n\n  // region Public API\n\n  private async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  private async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n\n  private async isIcAccount(address: AccountAddressInput) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find((account) => account.address.equals(AccountAddress.from(address))) !== undefined;\n  }\n\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n\n  async disconnect(address: AccountAddressInput) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n\n  async connect({\n    claimOptions,\n    preferredWalletName,\n  }: Omit<ConnectRequest.Args, 'dappId' | 'dappEd25519PublicKeyB64'> = {}) {\n    const dappKeypair = createEd25519KeyPair();\n    const injectedPreferredWalletName =\n      typeof window !== 'undefined' ? (window as any).AC_PREFERRED_WALLET_NAME : undefined;\n\n    const requestArgs = {\n      claimOptions,\n      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName,\n    } satisfies ConnectRequest.Args;\n\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n\n    if (response.args.status === 'approved') {\n      const { account, pairing } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({ account });\n    }\n    return response.args;\n  }\n\n  async signIn(args: SignInRequest.Args): Promise<UserDismissal | UserApproval<SignInResponse.ApprovalArgs>> {\n    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);\n\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n\n    const response = SignInResponse.deserialize(serializedResponse, serializedRequest.version);\n\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const { chainId } = args;\n      const network = chainIdToNetwork(chainId) as string;\n\n      let message: string;\n      let nonce: string;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error('Only UTF-8 encoded text is supported when using IC');\n      }\n\n      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(\n        signerAddress.toString(),\n        {\n          address: true,\n          application: true,\n          chainId: true,\n          message,\n          nonce,\n        },\n        { networkName: network as NetworkName },\n      );\n\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature =\n        signatureBytes.length === Ed25519Signature.LENGTH\n          ? new Ed25519Signature(signatureBytes)\n          : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval<SignMessageResponse.ApprovalArgs>({\n        fullMessage,\n        signature,\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: (SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction) & WithSignerAddress,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber,\n      } = normalizedArgs;\n\n      if (feePayer !== undefined) {\n        throw new Error('Sponsored transaction not currently supported');\n      }\n\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error('Multi-agent transactions not currently supported');\n      }\n\n      if (!('bcsToBytes' in payload)) {\n        throw new Error('Payload input format is only supported with Keyless accounts.');\n      }\n\n      const responseArgs = await this.pairingClient.signTransaction(\n        signerAddress.toString(),\n        {\n          options: {\n            expirationSecondsFromNow,\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n            sender: sender?.address.toString(),\n            sequenceNumber: sequenceNumber !== undefined ? Number(sequenceNumber) : undefined,\n          },\n          payload,\n        },\n        {\n          networkName: network as NetworkName | undefined,\n        },\n      );\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn,\n      });\n    }\n\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;\n      const aptosConfig = new AptosConfig({ network });\n\n      let convertedArgs: SignAndSubmitTransactionRequestArgs;\n      if (feePayer !== undefined) {\n        const payload = await normalizePayloadForIC(args.payload, aptosConfig);\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n          sender: signerAddress,\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address),\n        };\n      } else {\n        const payload = normalizePayloadForIC(args.payload);\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n        };\n      }\n\n      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network as NetworkName | undefined,\n      });\n      return makeUserApproval<SignAndSubmitTransactionResponse.ApprovalArgs>({ txnHash: hash });\n    }\n\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_FRONTEND_URL = 'https://aptosconnect.app';\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  AnyTransactionPayloadInstance,\n  AptosConfig,\n  EntryFunctionArgumentTypes,\n  generateTransactionPayload,\n  generateTransactionPayloadWithABI,\n  InputGenerateTransactionPayloadData,\n  SimpleEntryFunctionArgumentTypes,\n  TransactionPayload,\n} from '@aptos-labs/ts-sdk';\nimport { JsonTransactionPayload } from '@identity-connect/wallet-api';\n\ntype EntryFunctionArgument = SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes;\ntype SerializableArgument = undefined | null | number | string | boolean | Uint8Array | SerializableArgument[];\n\n/**\n * Return an equivalent argument value that can be safely serialized.\n */\nfunction convertToSerializableArgument(argument: EntryFunctionArgument): SerializableArgument {\n  if (argument === undefined || argument === null) {\n    return argument;\n  }\n\n  if (Array.isArray(argument)) {\n    return argument.map((subArgument) => convertToSerializableArgument(subArgument));\n  }\n\n  if (\n    typeof argument === 'string' ||\n    typeof argument === 'number' ||\n    typeof argument === 'boolean' ||\n    argument instanceof Uint8Array\n  ) {\n    return argument;\n  }\n\n  if (typeof argument === 'bigint') {\n    return argument.toString();\n  }\n\n  // ArrayBuffer\n  if (argument instanceof ArrayBuffer) {\n    return new Uint8Array(argument);\n  }\n\n  // MoveVector\n  if ('values' in argument) {\n    return argument.values.map((subArgument) => convertToSerializableArgument(subArgument));\n  }\n\n  // AccountAddress\n  if ('data' in argument) {\n    return AccountAddress.from(argument.data).toString();\n  }\n\n  // MoveOption\n  if (argument.value === undefined) {\n    return undefined;\n  }\n\n  if (\n    typeof argument.value === 'string' ||\n    typeof argument.value === 'number' ||\n    typeof argument.value === 'boolean' ||\n    argument.value instanceof Uint8Array\n  ) {\n    return argument.value;\n  }\n\n  if (typeof argument.value === 'bigint') {\n    return argument.value.toString();\n  }\n\n  throw new Error('Unexpected argument');\n}\n\n/**\n * Normalize payload input so that it's compatible with IC requests.\n * This variant is sync and will convert a payload generation input into a\n * `JsonTransactionPayload` when the ABI is not available\n */\nexport function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n): AnyTransactionPayloadInstance | JsonTransactionPayload;\n/**\n * Normalize payload input so that it's compatible with IC requests.\n * This variant is async and will generate a payload instance when an input is provided\n */\nexport async function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n  aptosConfig: AptosConfig,\n): Promise<AnyTransactionPayloadInstance>;\n\nexport function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n  aptosConfig?: AptosConfig,\n): AnyTransactionPayloadInstance | JsonTransactionPayload | Promise<AnyTransactionPayloadInstance> {\n  if ('bcsToBytes' in payload) {\n    return payload as AnyTransactionPayloadInstance;\n  }\n  if ('bytecode' in payload) {\n    // The signature of this function returns a promise, but it's actually sync code\n    return generateTransactionPayload(payload);\n  }\n  if (aptosConfig) {\n    return payload.abi !== undefined\n      ? generateTransactionPayloadWithABI({ ...payload, abi: payload.abi })\n      : generateTransactionPayload({ aptosConfig, ...payload });\n  }\n\n  const entryFunctionPayload = {\n    arguments: payload.functionArguments.map(convertToSerializableArgument),\n    function: payload.function,\n    type: 'entry_function_payload' as const,\n    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString()),\n  };\n\n  return 'multisigAddress' in payload\n    ? {\n        multisig_address: AccountAddress.from(payload.multisigAddress).toString(),\n        transaction_payload: entryFunctionPayload,\n        type: 'multisig_payload' as const,\n      }\n    : entryFunctionPayload;\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-await-in-loop */\n\nimport { AccountInfo } from '@aptos-connect/wallet-api';\nimport { AccountAddress } from '@aptos-labs/ts-sdk';\nimport {\n  CancelSigningRequestSerializedResponse,\n  CreateSigningRequestSerializedResponse,\n  FinalizedPairingData,\n  GetPairingSerializedResponse,\n  GetSigningRequestSerializedResponse,\n  NetworkName,\n  SerializedDate,\n  SigningRequestData,\n  SigningRequestStatus,\n  SigningRequestTypes,\n} from '@identity-connect/api';\nimport {\n  decodeBase64,\n  decryptEnvelope,\n  deserializeEd25519PublicKeyB64,\n  deserializePublicKeyB64,\n  Ed25519KeyPair,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  encryptAndSignEnvelope,\n  KeyTypes,\n  toKey,\n} from '@identity-connect/crypto';\nimport {\n  deserializeSignTransactionResponseArgs,\n  type SerializedSignAndSubmitTransactionRequestArgs,\n  type SerializedSignTransactionRequestArgs,\n  type SerializedSignTransactionResponseArgs,\n  serializeSignAndSubmitTransactionRequestArgs,\n  serializeSignTransactionRequestArgs,\n  type SignAndSubmitTransactionRequestArgs,\n  type SignAndSubmitTransactionResponseArgs,\n  SignMessageRequestArgs,\n  SignMessageResponseArgs,\n  type SignTransactionRequestArgs,\n  type SignTransactionResponseArgs,\n  type SignTransactionWithPayloadRequestArgs,\n  type SignTransactionWithPayloadResponseArgs,\n  type SignTransactionWithRawTxnRequestArgs,\n  type SignTransactionWithRawTxnResponseArgs,\n} from '@identity-connect/wallet-api';\nimport axios, { AxiosError, AxiosInstance, CreateAxiosDefaults, isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { PairingExpiredError, SignatureRequestError } from './errors';\nimport { DappPairingData, DappStateAccessors, windowStateAccessors } from './state';\nimport { CancelToken } from './types';\nimport { validateSignAndSubmitTransactionResponse, validateSignMessageResponse } from './utils';\n\nconst API_VERSION = '0.2.0' as const;\nconst SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nconst SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\n\nasync function waitFor(milliseconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\n\nasync function withRetries<Response>(\n  requestFn: () => Promise<Response>,\n  onError: (err: any) => void,\n  retries: number = 1,\n) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\n\nexport interface SignRequestOptions {\n  cancelToken?: CancelToken;\n  networkName?: NetworkName;\n}\n\nexport type OnDisconnectListener = (address: string) => void;\nexport type OnDisconnectListenerCleanup = () => void;\n\nexport interface ACPairingClientConfig {\n  accessors?: DappStateAccessors;\n  axiosConfig?: CreateAxiosDefaults;\n  defaultNetworkName?: NetworkName;\n}\n\nexport class ACPairingClient {\n  protected readonly accessors: DappStateAccessors;\n  private readonly defaultNetworkName: NetworkName;\n  protected readonly axiosInstance: AxiosInstance;\n  private readonly initPromise?: Promise<void>;\n\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET,\n  }: ACPairingClientConfig = {}) {\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig,\n    });\n\n    const isClientSideRendering = typeof window !== 'undefined';\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : undefined;\n  }\n\n  private async getPairing(id: string) {\n    const response = await this.axiosInstance.get<GetPairingSerializedResponse>(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n\n  private async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === undefined) {\n      return;\n    }\n\n    try {\n      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id,\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, undefined);\n    }\n  }\n\n  private async createSigningRequest<TRequestBody>(\n    pairing: DappPairingData,\n    type: string,\n    networkName: NetworkName,\n    requestBody: TRequestBody,\n  ) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(\n      async () => {\n        const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          sequenceNumber,\n          { apiVersion: API_VERSION, networkName, requestType: type },\n          requestBody,\n        );\n\n        const response = await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n          `v1/pairing/${pairing.pairingId}/signing-request/`,\n          requestEnvelope,\n        );\n\n        await this.accessors.update(pairing.accountAddress, {\n          ...pairing,\n          currSequenceNumber: sequenceNumber,\n        });\n\n        return response.data.data.signingRequest;\n      },\n      (err) => {\n        if (isAxiosError(err)) {\n          const errorMessage: string = err.response?.data?.message;\n          const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n          if (expectedSequenceNumber !== undefined) {\n            sequenceNumber = Number(expectedSequenceNumber);\n            return;\n          }\n        }\n        throw err;\n      },\n    );\n  }\n\n  private async getSigningRequest(id: string) {\n    const response = await this.axiosInstance.get<GetSigningRequestSerializedResponse | undefined>(\n      `v1/signing-request/${id}/`,\n      {\n        validateStatus: (status) => status === 200 || status === 404,\n      },\n    );\n    return response.data?.data?.signingRequest;\n  }\n\n  protected async deletePairing(pairingId: string, secretKey: Ed25519SecretKey, publicKey: Ed25519PublicKey) {\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      secretKey,\n      publicKey,\n      publicKey,\n      0, // ignored\n      {},\n      {},\n    );\n\n    await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n      `v1/pairing/${pairingId}/delete/`,\n      requestEnvelope,\n      { validateStatus: (status) => status === 204 || status === 404 },\n    );\n  }\n\n  async cancelSigningRequest(pairing: DappPairingData, id: string) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      sequenceNumber + 1,\n      {},\n      {},\n    );\n\n    const response = await this.axiosInstance.patch<CancelSigningRequestSerializedResponse>(\n      `v1/signing-request/${id}/cancel/`,\n      requestEnvelope,\n    );\n\n    // TODO: auto-sync sequence number on error\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1,\n    });\n\n    return response.data.data.signingRequest;\n  }\n\n  private async signRequest<TRequestBody, TResponseBody>(\n    address: string,\n    type: SigningRequestTypes,\n    requestBody: TRequestBody,\n    { cancelToken, networkName }: SignRequestOptions = {},\n  ) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The requested account is not paired');\n    }\n\n    let signingRequest: SerializedDate<SigningRequestData>;\n\n    try {\n      signingRequest = await this.createSigningRequest<TRequestBody>(\n        pairing,\n        type,\n        networkName || this.defaultNetworkName,\n        requestBody,\n      );\n\n      while (signingRequest.status === 'PENDING') {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          // TODO: send cancel request\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === '404') {\n        await this.accessors.update(address, undefined);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n\n    if (signingRequest.status !== 'APPROVED') {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n\n    const decrypted = decryptEnvelope<{}, TResponseBody & {}>(\n      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),\n      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),\n      signingRequest.responseEnvelope!,\n    );\n    return decrypted.privateMessage;\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({ publicKey, secretKey }: Ed25519KeyPair, finalizedPairing: SerializedDate<FinalizedPairingData>) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? undefined,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id,\n    });\n  }\n\n  async disconnect(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The specified account is not paired');\n    }\n\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(\n      pairing.pairingId,\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n    );\n    await this.accessors.update(address, undefined);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n\n  async signMessage(address: string, args: SignMessageRequestArgs, options?: SignRequestOptions) {\n    const response = await this.signRequest<SignMessageRequestArgs, SignMessageResponseArgs>(\n      address,\n      SigningRequestTypes.SIGN_MESSAGE,\n      args,\n      options,\n    );\n    validateSignMessageResponse(response);\n    return response;\n  }\n\n  // region signTransaction\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithPayloadRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithPayloadResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithRawTxnRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithRawTxnResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest<\n      SerializedSignTransactionRequestArgs,\n      SerializedSignTransactionResponseArgs\n    >(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n\n  // endregion\n\n  async signAndSubmitTransaction(\n    address: string,\n    args: SignAndSubmitTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignAndSubmitTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest<\n        SerializedSignAndSubmitTransactionRequestArgs,\n        SignAndSubmitTransactionResponseArgs\n      >(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map<AccountInfo>(\n      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({\n        address: AccountAddress.from(accountAddress),\n        publicKey:\n          accountPublicKeyB64 !== undefined\n            ? deserializePublicKeyB64(accountPublicKeyB64)\n            : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64),\n      }),\n    );\n  }\n\n  // endregion\n\n  private readonly onDisconnectListeners = new Set<OnDisconnectListener>();\n\n  onDisconnect(listener: OnDisconnectListener): OnDisconnectListenerCleanup {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SigningRequestStatus } from '@identity-connect/api';\n\nexport class SignatureRequestError extends Error {\n  constructor(status: SigningRequestStatus) {\n    super(status);\n    this.name = 'SignatureRequestError';\n    Object.setPrototypeOf(this, SignatureRequestError.prototype);\n  }\n}\n\nexport class UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields: string[]) {\n    const message = `Missing the following fields: ${missingFields.join(', ')}`;\n    super(message);\n    this.name = 'UnexpectedSignatureResponseError';\n    Object.setPrototypeOf(this, UnexpectedSignatureResponseError.prototype);\n  }\n}\n\nexport class PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = 'PairingExpiredError';\n    Object.setPrototypeOf(this, PairingExpiredError.prototype);\n  }\n}\n\nexport class UnregisteredDappError extends Error {\n  constructor() {\n    super('Dapp ID is invalid or not associated with a registered Dapp.');\n    this.name = 'UnregisteredDappError';\n    Object.setPrototypeOf(this, UnregisteredDappError.prototype);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface BaseDappPairingData {\n  accountAddress: string;\n  accountAlias?: string;\n  accountTransportEd25519PublicKeyB64: string;\n  currSequenceNumber: number;\n  dappEd25519PublicKeyB64: string;\n  dappEd25519SecretKeyB64: string;\n  dappWalletId?: string;\n  pairingId: string;\n}\n\n// Keeping this temporarily for backward compatibility\nexport interface PrevDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64: string;\n  accountPublicKeyB64?: undefined;\n}\n\nexport interface CurrDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64?: undefined;\n  accountPublicKeyB64: string;\n}\n\nexport type DappPairingData = PrevDappPairingData | CurrDappPairingData;\n\nexport type DappPairingDataMap = { [address: string]: DappPairingData };\n\nexport interface DappStateAccessors {\n  get: (address: string) => Promise<DappPairingData | undefined>;\n  getAll: () => Promise<DappPairingDataMap>;\n  update: (address: string, pairing?: DappPairingData) => Promise<void>;\n}\n\nexport const DAPP_PAIRINGS_WINDOW_STORAGE_KEY = 'icDappPairings';\n\n/**\n * Default implementation of DappStateAccessors that uses the Window localStorage API.\n * This should work for most dapps.\n */\nexport const windowStateAccessors: DappStateAccessors = {\n  async get(address: string) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? (JSON.parse(serialized) as DappPairingDataMap) : {};\n  },\n  async update(address: string, pairing?: DappPairingData) {\n    const pairings = await this.getAll();\n    if (pairing === undefined) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  },\n};\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SignAndSubmitTransactionResponseArgs, SignMessageResponseArgs } from '@identity-connect/wallet-api';\nimport { UnexpectedSignatureResponseError } from './errors';\n\nconst SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS: (keyof SignMessageResponseArgs)[] = [\n  'address',\n  'application',\n  'chainId',\n  'fullMessage',\n  'message',\n  'nonce',\n  'prefix',\n  'signature',\n];\n\nexport function validateSignMessageResponse(response: SignMessageResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\nconst SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS: (keyof SignAndSubmitTransactionResponseArgs)[] = ['hash'];\n\nexport function validateSignAndSubmitTransactionResponse(response: SignAndSubmitTransactionResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(\n    (field) => !providedFields.has(field),\n  );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { CreatePairingSerializedResponse, FinalizedPairingData, SerializedDate } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { UnregisteredDappError } from './errors';\nimport { ACPairingClient, ACPairingClientConfig } from './PairingClient';\nimport { openPrompt, waitForPromptResponse } from './prompt';\n\nexport interface ICDappClientConfig extends ACPairingClientConfig {\n  frontendBaseURL?: string;\n}\n\nexport class ICDappClient extends ACPairingClient {\n  private readonly frontendBaseURL: string;\n\n  constructor(\n    private readonly dappId: string,\n    { frontendBaseURL = DEFAULT_FRONTEND_URL, ...pairingClientConfig }: ICDappClientConfig = {},\n  ) {\n    super(pairingClientConfig);\n    this.frontendBaseURL = frontendBaseURL;\n  }\n\n  private async createPairingRequest(dappEd25519PublicKeyB64: string) {\n    try {\n      const response = await this.axiosInstance.post<CreatePairingSerializedResponse>('v1/pairing/', {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId,\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      // TODO: export typed errors from API\n      if (isAxiosError(err) && err.response?.data?.message === 'Dapp not found') {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const { publicKey, secretKey } = createEd25519KeyPair();\n    const dappEd25519PublicKeyB64 = encodeBase64(publicKey.key);\n\n    // Open the prompt without pairingId (for a snappier ux)\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n\n    let pairingId: string;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      // Close the prompt and have the dapp handle the error\n      promptWindow.close();\n      throw err;\n    }\n\n    // Update the prompt's URL as soon as a pairingId is available\n    url.searchParams.set('pairingId', pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse<SerializedDate<FinalizedPairingData>>(promptWindow);\n\n    if (promptResponse.status === 'dismissed') {\n      // Ignore the result. This is just a courtesy call, so if anything goes wrong\n      // the pairing will be removed during scheduled cleanup)\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return undefined;\n    }\n\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({ publicKey, secretKey }, finalizedPairing);\n\n    return finalizedPairing.account.accountAddress;\n  }\n\n  async offboard(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('This account is not paired');\n    }\n\n    const walletId = pairing.dappWalletId;\n    if (walletId === undefined) {\n      throw new Error('This account cannot be offboarded');\n    }\n\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse<{ offboarded: boolean }>(promptWindow);\n    if (response.status === 'approved' && response.args.offboarded) {\n      // If exported, disconnect the pairing to clean up\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nconst DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nconst PROMPT_POLLER_INTERVAL = 500;\n\nexport function openPrompt(url: string | URL, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width,\n  };\n\n  const strOptions = Object.entries(options)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .reduce((acc, entry) => `${acc}, ${entry}`);\n\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, undefined, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n\n  return promptWindow;\n}\n\nexport interface PromptApproval<TResponseArgs> {\n  args: TResponseArgs;\n  status: 'approved';\n}\n\nexport interface PromptDismissal {\n  status: 'dismissed';\n}\n\nexport type PromptResponse<TResponseArgs> = PromptApproval<TResponseArgs> | PromptDismissal;\n\nexport async function waitForPromptResponse<TResponseArgs>(promptWindow: Window) {\n  return new Promise<PromptResponse<TResponseArgs>>((resolve) => {\n    const listeners = {\n      onMessage: (message: MessageEvent) => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener('message', listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: 'approved',\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: 'dismissed',\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL),\n    };\n\n    window.addEventListener('message', listeners.onMessage);\n  });\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  IsConnectedRequest,\n  IsConnectedResponse,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport { NetworkName } from '@identity-connect/api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\n\nexport interface ACKeylessClientConfig {\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n  provider?: 'google' | 'apple';\n}\n\nexport class ACKeylessClient {\n  private readonly defaultNetworkName: NetworkName;\n\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = 'google',\n  }: ACKeylessClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL, provider);\n  }\n\n  // region Public API\n\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async disconnect() {\n    const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n\n  async connect() {\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args) {\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args) {\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { registerWallet } from '@aptos-labs/wallet-standard';\nimport { AptosConnectWalletConfig } from './AptosConnectWallet';\nimport { AptosConnectGoogleWallet } from './AptosConnectGoogleWallet';\nimport { AptosConnectAppleWallet } from './AptosConnectAppleWallet';\n\nexport * from './AptosConnectAccount';\nexport * from './AptosConnectWallet';\nexport { AptosConnectGoogleWallet, AptosConnectAppleWallet };\n\nexport function registerAptosConnect(config: AptosConnectWalletConfig = {}) {\n  const googleWalletPlugin = new AptosConnectGoogleWallet(config);\n  const appleWalletPlugin = new AptosConnectAppleWallet(config);\n  registerWallet(googleWalletPlugin);\n  registerWallet(appleWalletPlugin);\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AptosConnectNamespace,\n  AptosDisconnectNamespace,\n  AptosFeatures,\n  AptosGetAccountNamespace,\n  AptosGetNetworkNamespace,\n  AptosOnAccountChangeNamespace,\n  AptosOnNetworkChangeNamespace,\n  AptosSignAndSubmitTransactionFeature,\n  AptosSignAndSubmitTransactionNamespace,\n  AptosSignInNamespace,\n  AptosSignMessageNamespace,\n  AptosSignTransactionNamespace,\n  AptosWallet,\n} from '@aptos-labs/wallet-standard';\nimport { AptosConnectWallet, AptosConnectWalletConfig } from './AptosConnectWallet';\nimport { walletMetadata } from './config';\n\nexport class AptosConnectGoogleWallet extends AptosConnectWallet implements AptosWallet {\n  readonly name = walletMetadata.google.name;\n\n  readonly icon = walletMetadata.google.icon;\n\n  readonly url = walletMetadata.google.url;\n\n  constructor(config: AptosConnectWalletConfig) {\n    super({ ...config, provider: 'google' });\n  }\n\n  // region AptosWallet\n\n  get features(): AptosFeatures & AptosSignAndSubmitTransactionFeature {\n    return {\n      [AptosConnectNamespace]: {\n        connect: this.connect.bind(this),\n        version: '1.0.0',\n      },\n      [AptosDisconnectNamespace]: {\n        disconnect: this.disconnect.bind(this),\n        version: '1.0.0',\n      },\n      [AptosGetAccountNamespace]: {\n        account: this.getAccount.bind(this),\n        version: '1.0.0',\n      },\n      [AptosGetNetworkNamespace]: {\n        network: this.getNetwork.bind(this),\n        version: '1.0.0',\n      },\n      [AptosOnAccountChangeNamespace]: {\n        onAccountChange: this.onAccountChange.bind(this),\n        version: '1.0.0',\n      },\n      [AptosOnNetworkChangeNamespace]: {\n        onNetworkChange: this.onNetworkChange.bind(this),\n        version: '1.0.0',\n      },\n      [AptosSignAndSubmitTransactionNamespace]: {\n        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),\n        version: '1.1.0',\n      },\n      [AptosSignInNamespace]: {\n        signIn: this.signIn.bind(this),\n        version: '1.0.0',\n      },\n      [AptosSignMessageNamespace]: {\n        signMessage: this.signMessage.bind(this),\n        version: '1.0.0',\n      },\n      [AptosSignTransactionNamespace]: {\n        signTransaction: this.signTransaction.bind(this),\n        version: '1.1',\n      },\n    };\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClaimOptions } from '@aptos-connect/wallet-api';\nimport {\n  AccountAddress,\n  AccountAuthenticator,\n  AnyRawTransaction,\n  Aptos,\n  AptosConfig,\n  Ed25519PrivateKey,\n  HexInput,\n  MultiAgentTransaction,\n  Network,\n  NetworkToNodeAPI,\n  SimpleTransaction,\n} from '@aptos-labs/ts-sdk';\nimport {\n  AccountInfo,\n  APTOS_CHAINS,\n  AptosSignAndSubmitTransactionInput,\n  AptosSignAndSubmitTransactionOutput,\n  AptosSignInInput,\n  AptosSignInOutput,\n  AptosSignMessageInput,\n  AptosSignMessageOutput,\n  AptosSignTransactionInputV1_1,\n  AptosSignTransactionOutputV1_1,\n  AptosWalletError,\n  AptosWalletErrorCode,\n  NetworkInfo,\n  UserResponse,\n  UserResponseStatus,\n} from '@aptos-labs/wallet-standard';\nimport { deserializePublicKeyB64, serializePublicKeyB64 } from '@identity-connect/crypto';\nimport { ACDappClient, ACDappClientConfig } from '@identity-connect/dapp-sdk';\nimport { AptosConnectAccount } from './AptosConnectAccount';\nimport { customAccountToStandardAccount, networkToChainId, unwrapUserResponse } from './helpers';\n\ninterface SerializedCurrentAccount {\n  address: string;\n  publicKey: string;\n}\n\ntype WithSSOProvider<T> = T & {\n  provider: 'google' | 'apple';\n};\n\nexport interface AptosConnectWalletConfig extends Omit<ACDappClientConfig, 'defaultNetworkName' | 'provider'> {\n  claimSecretKey?: HexInput;\n  network?: Network;\n  preferredWalletName?: string;\n}\n\nexport abstract class AptosConnectWallet {\n  // region connectedAccount\n\n  protected static connectedAccountStorageKey = '@aptos-connect/connectedAccount';\n\n  protected static get connectedAccount(): AccountInfo | undefined {\n    const serialized = localStorage.getItem(AptosConnectWallet.connectedAccountStorageKey);\n    if (!serialized) {\n      return undefined;\n    }\n\n    try {\n      const { address, publicKey } = JSON.parse(serialized) as SerializedCurrentAccount;\n      return new AccountInfo({\n        address: AccountAddress.from(address),\n        publicKey: deserializePublicKeyB64(publicKey),\n      });\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.warn('Inconsistent state, resetting it');\n      this.connectedAccount = undefined;\n      return undefined;\n    }\n  }\n\n  protected static set connectedAccount(value: AccountInfo | undefined) {\n    if (value !== undefined) {\n      const serialized: SerializedCurrentAccount = {\n        address: value.address.toString(),\n        publicKey: serializePublicKeyB64(value.publicKey),\n      };\n      localStorage.setItem(AptosConnectWallet.connectedAccountStorageKey, JSON.stringify(serialized));\n    } else {\n      localStorage.removeItem(AptosConnectWallet.connectedAccountStorageKey);\n    }\n  }\n\n  // endregion\n\n  // region AptosWallet\n\n  readonly version = '1.0.0';\n\n  readonly chains = APTOS_CHAINS;\n\n  // eslint-disable-next-line class-methods-use-this\n  get accounts() {\n    const { connectedAccount } = AptosConnectWallet;\n    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];\n  }\n\n  // endregion\n\n  // PetraWallet\n\n  private readonly aptosClient: Aptos;\n\n  private readonly client: ACDappClient;\n\n  private readonly preferredWalletName?: string;\n  private readonly claimOptions?: ClaimOptions;\n\n  constructor({\n    claimSecretKey,\n    network = Network.MAINNET,\n    preferredWalletName,\n    ...clientConfig\n  }: WithSSOProvider<AptosConnectWalletConfig>) {\n    this.client = new ACDappClient(clientConfig);\n\n    if (!NetworkToNodeAPI[network]) {\n      throw new Error('Network not supported');\n    }\n\n    const aptosConfig = new AptosConfig({ network });\n    this.aptosClient = new Aptos(aptosConfig);\n    this.preferredWalletName = preferredWalletName;\n    this.claimOptions = claimSecretKey ? { network, secretKey: new Ed25519PrivateKey(claimSecretKey) } : undefined;\n  }\n\n  async connect(): Promise<UserResponse<AccountInfo>> {\n    // If this is an auto-connect, try not opening the prompt\n    const { connectedAccount } = AptosConnectWallet;\n    if (connectedAccount !== undefined) {\n      return { args: connectedAccount, status: UserResponseStatus.APPROVED };\n    }\n\n    const response = await this.client.connect({\n      claimOptions: this.claimOptions,\n      preferredWalletName: this.preferredWalletName,\n    });\n    if (response.status === 'dismissed') {\n      return { status: UserResponseStatus.REJECTED };\n    }\n\n    const newConnectedAccount = customAccountToStandardAccount(response.args.account);\n    AptosConnectWallet.connectedAccount = newConnectedAccount;\n\n    return {\n      args: newConnectedAccount,\n      status: UserResponseStatus.APPROVED,\n    };\n  }\n\n  async disconnect() {\n    const { connectedAccount } = AptosConnectWallet;\n    if (connectedAccount) {\n      await this.client.disconnect(connectedAccount.address);\n      AptosConnectWallet.connectedAccount = undefined;\n    }\n  }\n\n  async signIn(input: AptosSignInInput): Promise<UserResponse<AptosSignInOutput>> {\n    const response = await this.client.signIn({ network: this.aptosClient.config.network, ...input });\n\n    if (response.status === 'dismissed') {\n      return { status: UserResponseStatus.REJECTED };\n    }\n\n    const output = response.args;\n\n    AptosConnectWallet.connectedAccount = output.account;\n\n    return { args: output, status: UserResponseStatus.APPROVED };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getAccount(): Promise<AccountInfo> {\n    const { connectedAccount } = AptosConnectWallet;\n    if (!connectedAccount) {\n      // TODO: this function should fail gracefully\n      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);\n    }\n    return customAccountToStandardAccount(connectedAccount);\n  }\n\n  async getNetwork(): Promise<NetworkInfo> {\n    const { network } = this.aptosClient.config;\n    const chainId = await this.aptosClient.getChainId();\n    const url = NetworkToNodeAPI[network];\n    return {\n      chainId,\n      name: network,\n      url,\n    };\n  }\n\n  async signMessage(input: AptosSignMessageInput): Promise<UserResponse<AptosSignMessageOutput>> {\n    const { connectedAccount } = AptosConnectWallet;\n    if (!connectedAccount) {\n      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);\n    }\n\n    const chainId = networkToChainId(this.aptosClient.config.network);\n    const { message, nonce } = input;\n\n    const encoder = new TextEncoder();\n    const messageBytes = encoder.encode(message);\n    const nonceBytes = encoder.encode(nonce);\n\n    const response = await this.client.signMessage({\n      chainId,\n      message: messageBytes,\n      nonce: nonceBytes,\n      signerAddress: connectedAccount.address,\n    });\n\n    if (response.status === 'dismissed') {\n      return { status: UserResponseStatus.REJECTED };\n    }\n\n    const { fullMessage, signature } = response.args;\n\n    const extraResponseArgs = {\n      address: connectedAccount.address.toString(),\n      application: this.client.dappInfo.domain,\n      chainId,\n      message,\n      nonce,\n      prefix: 'APTOS' as const,\n    };\n\n    return {\n      args: {\n        fullMessage,\n        signature,\n        ...extraResponseArgs,\n      },\n      status: UserResponseStatus.APPROVED,\n    };\n  }\n\n  async signTransaction(rawTxn: AnyRawTransaction): Promise<UserResponse<AccountAuthenticator>>;\n  async signTransaction(args: AptosSignTransactionInputV1_1): Promise<UserResponse<AptosSignTransactionOutputV1_1>>;\n  async signTransaction(\n    txnOrArgs: AnyRawTransaction | AptosSignTransactionInputV1_1,\n    _asFeePayer?: boolean,\n  ): Promise<UserResponse<AccountAuthenticator | AptosSignTransactionOutputV1_1>> {\n    const { connectedAccount } = AptosConnectWallet;\n    if (!connectedAccount) {\n      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);\n    }\n\n    if ('bcsToBytes' in txnOrArgs) {\n      const transaction = txnOrArgs;\n      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : undefined;\n      const secondarySigners = transaction.secondarySignerAddresses?.map((address) => ({ address }));\n      const response = await this.client.signTransaction({\n        feePayer,\n        secondarySigners,\n        signerAddress: connectedAccount.address,\n        transaction: transaction.rawTransaction,\n      });\n      return unwrapUserResponse(response, (args) => args.authenticator);\n    }\n\n    const requestArgs = txnOrArgs;\n    const response = await this.client.signTransaction({\n      ...requestArgs,\n      signerAddress: connectedAccount.address,\n    });\n\n    return unwrapUserResponse(response, (responseArgs) => {\n      const { authenticator, rawTransaction } = responseArgs;\n      if (!rawTransaction) {\n        throw new Error('Expected raw transaction in response args');\n      }\n\n      const secondarySigners = requestArgs.secondarySigners ?? [];\n      let transaction: AnyRawTransaction;\n      if (secondarySigners.length > 0) {\n        transaction = new MultiAgentTransaction(\n          rawTransaction,\n          secondarySigners.map((s) => s.address),\n          requestArgs.feePayer?.address,\n        );\n      } else {\n        transaction = new SimpleTransaction(rawTransaction, requestArgs.feePayer?.address);\n      }\n\n      return {\n        authenticator,\n        rawTransaction: transaction,\n      };\n    });\n  }\n\n  async signAndSubmitTransaction(\n    args: AptosSignAndSubmitTransactionInput,\n  ): Promise<UserResponse<AptosSignAndSubmitTransactionOutput>> {\n    const { gasUnitPrice, maxGasAmount, payload } = args;\n\n    const { connectedAccount } = AptosConnectWallet;\n    if (!connectedAccount) {\n      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);\n    }\n\n    const response = await this.client.signAndSubmitTransaction({\n      gasUnitPrice,\n      maxGasAmount,\n      network: this.aptosClient.config.network,\n      payload,\n      signerAddress: connectedAccount.address,\n    });\n\n    if (response.status === 'dismissed') {\n      return { status: UserResponseStatus.REJECTED };\n    }\n\n    return {\n      args: { hash: response.args.txnHash },\n      status: UserResponseStatus.APPROVED,\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async onAccountChange(_callback?: (newAccount: AccountInfo) => void): Promise<void> {\n    // TODO\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async onNetworkChange(_callback?: (newNetwork: NetworkInfo) => void): Promise<void> {\n    // Not applicable\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  AnyPublicKey,\n  Ed25519PublicKey,\n  MultiEd25519PublicKey,\n  MultiKey,\n  PublicKey,\n  SigningScheme,\n} from '@aptos-labs/ts-sdk';\nimport { AccountInfo, APTOS_CHAINS, AptosWalletAccount } from '@aptos-labs/wallet-standard';\n\nexport class AptosConnectAccount implements AptosWalletAccount {\n  // region AptosWalletAccount\n\n  readonly chains = APTOS_CHAINS;\n\n  get address() {\n    return this.#address.toString();\n  }\n\n  get publicKey() {\n    return this.#publicKey.toUint8Array();\n  }\n\n  get signingScheme() {\n    if (this.#publicKey instanceof Ed25519PublicKey) {\n      return SigningScheme.Ed25519;\n    }\n    if (this.#publicKey instanceof MultiEd25519PublicKey) {\n      return SigningScheme.MultiEd25519;\n    }\n    if (this.#publicKey instanceof AnyPublicKey) {\n      return SigningScheme.SingleKey;\n    }\n    if (this.#publicKey instanceof MultiKey) {\n      return SigningScheme.MultiKey;\n    }\n    throw new Error('Unsupported public key type');\n  }\n\n  readonly label?: string;\n\n  readonly features = [];\n\n  // endregion\n\n  // region PetraAccount\n\n  readonly #address: AccountAddress;\n\n  readonly #publicKey: PublicKey;\n\n  constructor({ address, ansName, publicKey }: AccountInfo) {\n    this.#publicKey = publicKey;\n    this.#address = address;\n    this.label = ansName;\n  }\n\n  // endregion\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountInfo as ACAccountInfo, UserResponse as ACUserResponse } from '@aptos-connect/wallet-api';\nimport { Network, NetworkToChainId } from '@aptos-labs/ts-sdk';\nimport { AccountInfo, UserResponse, UserResponseStatus } from '@aptos-labs/wallet-standard';\n\nexport function customAccountToStandardAccount({ address, name, publicKey }: ACAccountInfo) {\n  return new AccountInfo({\n    address,\n    ansName: name,\n    publicKey,\n  });\n}\n\nexport function unwrapUserResponse<T, U>(response: ACUserResponse<T>, callback: (args: T) => U): UserResponse<U> {\n  if (response.status === 'dismissed') {\n    return { status: UserResponseStatus.REJECTED };\n  }\n  return { args: callback(response.args), status: UserResponseStatus.APPROVED };\n}\n\nexport function networkToChainId(network: Network): number {\n  switch (network) {\n    case Network.MAINNET:\n      return NetworkToChainId.mainnet;\n    case Network.TESTNET:\n      return NetworkToChainId.testnet;\n    default:\n      return NetworkToChainId.devnet;\n  }\n}\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const walletMetadata = {\n  apple: {\n    icon:\n      // eslint-disable-next-line max-len\n      'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxzdHlsZT4KICAgICAgICBwYXRoIHsKICAgICAgICAgICAgZmlsbDogYmxhY2s7CiAgICAgICAgfQoKICAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgICAgICAgIHBhdGggewogICAgICAgICAgICAgICAgZmlsbDogd2hpdGU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAuMzkzMiA4LjE4MjQyQzIwLjI1NzggOC4yOTA0MyAxNy44NjggOS42NzUzNyAxNy44NjggMTIuNzU0OUMxNy44NjggMTYuMzE2OCAyMC45MDkgMTcuNTc3IDIxIDE3LjYwODJDMjAuOTg2IDE3LjY4NSAyMC41MTY5IDE5LjMzMzkgMTkuMzk2NiAyMS4wMTQxQzE4LjM5NzcgMjIuNDkyNiAxNy4zNTQ1IDIzLjk2ODggMTUuNzY3NSAyMy45Njg4QzE0LjE4MDQgMjMuOTY4OCAxMy43NzIgMjMuMDIwNyAxMS45Mzk5IDIzLjAyMDdDMTAuMTU0NSAyMy4wMjA3IDkuNTE5NzIgMjQgOC4wNjgwNSAyNEM2LjYxNjM5IDI0IDUuNjAzNDkgMjIuNjMxOSA0LjQzODg5IDIwLjk1MTdDMy4wODk5MiAxOC45Nzg3IDIgMTUuOTEzNiAyIDEzLjAwNDVDMiA4LjMzODQzIDQuOTUwMDEgNS44NjM3OSA3Ljg1MzM0IDUuODYzNzlDOS4zOTYwMiA1Ljg2Mzc5IDEwLjY4MiA2LjkwNTQ5IDExLjY1MDUgNi45MDU0OUMxMi41NzI0IDYuOTA1NDkgMTQuMDEwMSA1LjgwMTM4IDE1Ljc2NTEgNS44MDEzOEMxNi40MzAzIDUuODAxMzggMTguODIwMiA1Ljg2Mzc5IDIwLjM5MzIgOC4xODI0MlpNMTQuOTMxOSAzLjgyNTk4QzE1LjY1NzggMi45NDAyOSAxNi4xNzEyIDEuNzExMzcgMTYuMTcxMiAwLjQ4MjQ0OEMxNi4xNzEyIDAuMzEyMDMxIDE2LjE1NzIgMC4xMzkyMTQgMTYuMTI2OSAwQzE0Ljk0NiAwLjA0NTYwNDYgMTMuNTQxIDAuODA4ODgxIDEyLjY5MzggMS44MTkzOEMxMi4wMjg2IDIuNTk3MDYgMTEuNDA3OCAzLjgyNTk4IDExLjQwNzggNS4wNzE3MUMxMS40MDc4IDUuMjU4OTMgMTEuNDM4MiA1LjQ0NjE0IDExLjQ1MjIgNS41MDYxNUMxMS41MjY4IDUuNTIwNTUgMTEuNjQ4MiA1LjUzNzM1IDExLjc2OTYgNS41MzczNUMxMi44MjkxIDUuNTM3MzUgMTQuMTYxOCA0LjgwNzY4IDE0LjkzMTkgMy44MjU5OFoiIC8+Cjwvc3ZnPg==',\n    name: 'Continue with Apple',\n    url: 'https://aptosconnect.app',\n  },\n  google: {\n    icon:\n      // eslint-disable-next-line max-len\n      'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg==',\n    name: 'Continue with Google',\n    url: 'https://aptosconnect.app',\n  },\n} as const;\n", "// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AptosConnectNamespace,\n  AptosDisconnectNamespace,\n  AptosFeatures,\n  AptosGetAccountNamespace,\n  AptosGetNetworkNamespace,\n  AptosOnAccountChangeNamespace,\n  AptosOnNetworkChangeNamespace,\n  AptosSignAndSubmitTransactionFeature,\n  AptosSignAndSubmitTransactionNamespace,\n  AptosSignInNamespace,\n  AptosSignMessageNamespace,\n  AptosSignTransactionNamespace,\n  AptosWallet,\n} from '@aptos-labs/wallet-standard';\nimport { AptosConnectWallet, AptosConnectWalletConfig } from './AptosConnectWallet';\nimport { walletMetadata } from './config';\n\nexport class AptosConnectAppleWallet extends AptosConnectWallet implements AptosWallet {\n  readonly name = walletMetadata.apple.name;\n\n  readonly icon = walletMetadata.apple.icon;\n\n  readonly url = walletMetadata.apple.url;\n\n  constructor(config: AptosConnectWalletConfig) {\n    super({ ...config, provider: 'apple' });\n  }\n\n  // region AptosWallet\n\n  get features(): AptosFeatures & AptosSignAndSubmitTransactionFeature {\n    return {\n      [AptosConnectNamespace]: {\n        connect: this.connect.bind(this),\n        version: '1.0.0',\n      },\n      [AptosDisconnectNamespace]: {\n        disconnect: this.disconnect.bind(this),\n        version: '1.0.0',\n      },\n      [AptosGetAccountNamespace]: {\n        account: this.getAccount.bind(this),\n        version: '1.0.0',\n      },\n      [AptosGetNetworkNamespace]: {\n        network: this.getNetwork.bind(this),\n        version: '1.0.0',\n      },\n      [AptosOnAccountChangeNamespace]: {\n        onAccountChange: this.onAccountChange.bind(this),\n        version: '1.0.0',\n      },\n      [AptosOnNetworkChangeNamespace]: {\n        onNetworkChange: this.onNetworkChange.bind(this),\n        version: '1.0.0',\n      },\n      [AptosSignAndSubmitTransactionNamespace]: {\n        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),\n        version: '1.1.0',\n      },\n      [AptosSignInNamespace]: {\n        signIn: this.signIn.bind(this),\n        version: '1.0.0',\n      },\n      [AptosSignMessageNamespace]: {\n        signMessage: this.signMessage.bind(this),\n        version: '1.0.0',\n      },\n      [AptosSignTransactionNamespace]: {\n        signTransaction: this.signTransaction.bind(this),\n        version: '1.1',\n      },\n    };\n  }\n\n  // endregion\n}\n", "export * from \"@aptos-labs/wallet-adapter-core\";\nexport * from \"./WalletProvider\";\nexport * from \"./components/AboutAptosConnect\";\nexport * from \"./components/AptosPrivacyPolicy\";\nexport * from \"./components/WalletItem\";\nexport * from \"./useWallet\";\n", "import {\n  AvailableWallets,\n  DappConfig,\n  AccountInfo,\n  AdapterWallet,\n  NetworkInfo,\n  InputTransactionData,\n  AptosSignAndSubmitTransactionOutput,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  AccountAuthenticator,\n  AptosSignMessageInput,\n  AptosSignMessageOutput,\n  AdapterNotDetectedWallet,\n  WalletCore,\n  Network,\n  InputSubmitTransactionData,\n  PendingTransactionResponse,\n  WalletReadyState,\n  AptosSignInInput,\n  AptosSignInOutput,\n} from \"@aptos-labs/wallet-adapter-core\";\nimport { ReactNode, FC, useState, useEffect, useCallback, useRef } from \"react\";\nimport { WalletContext } from \"./useWallet\";\n\nexport interface AptosWalletProviderProps {\n  children: ReactNode;\n  optInWallets?: ReadonlyArray<AvailableWallets>;\n  autoConnect?:\n    | boolean\n    | ((core: WalletCore, adapter: AdapterWallet) => Promise<boolean>);\n  dappConfig?: DappConfig;\n  disableTelemetry?: boolean;\n  onError?: (error: any) => void;\n}\n\nconst initialState: {\n  account: AccountInfo | null;\n  network: NetworkInfo | null;\n  connected: boolean;\n  wallet: AdapterWallet | null;\n} = {\n  connected: false,\n  account: null,\n  network: null,\n  wallet: null,\n};\n\nexport const AptosWalletAdapterProvider: FC<AptosWalletProviderProps> = ({\n  children,\n  optInWallets,\n  autoConnect = false,\n  dappConfig,\n  disableTelemetry = false,\n  onError,\n}: AptosWalletProviderProps) => {\n  const didAttemptAutoConnectRef = useRef(false);\n\n  const [{ account, network, connected, wallet }, setState] =\n    useState(initialState);\n\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [walletCore, setWalletCore] = useState<WalletCore>();\n\n  const [wallets, setWallets] = useState<ReadonlyArray<AdapterWallet>>([]);\n  const [notDetectedWallets, setNotDetectedWallets] = useState<\n    ReadonlyArray<AdapterNotDetectedWallet>\n  >([]);\n  // Initialize WalletCore on first load\n  useEffect(() => {\n    const walletCore = new WalletCore(\n      optInWallets,\n      dappConfig,\n      disableTelemetry\n    );\n    setWalletCore(walletCore);\n  }, []);\n\n  // Update initial Wallets state once WalletCore has been initialized\n  useEffect(() => {\n    setWallets(walletCore?.wallets ?? []);\n    setNotDetectedWallets(walletCore?.notDetectedWallets ?? []);\n  }, [walletCore]);\n\n  useEffect(() => {\n    // Only attempt to auto connect once per render and only if there are wallets\n    if (didAttemptAutoConnectRef.current || !walletCore?.wallets.length) {\n      return;\n    }\n    didAttemptAutoConnectRef.current = true;\n\n    // If auto connect is not set or is false, ignore the attempt\n    if (!autoConnect) {\n      setIsLoading(false);\n      return;\n    }\n\n    // Make sure the user has a previously connected wallet\n    const walletName = localStorage.getItem(\"AptosWalletName\");\n    if (!walletName) {\n      setIsLoading(false);\n      return;\n    }\n\n    // Make sure the wallet is installed\n    const selectedWallet = walletCore.wallets.find(\n      (e) => e.name === walletName\n    ) as AdapterWallet | undefined;\n    if (\n      !selectedWallet ||\n      selectedWallet.readyState !== WalletReadyState.Installed\n    ) {\n      setIsLoading(false);\n      return;\n    }\n\n    if (!connected) {\n      (async () => {\n        try {\n          let shouldConnect = true;\n\n          // Providing a function to autoConnect allows the dapp to determine\n          // whether to attempt to connect to the wallet using the `signIn`\n          // or `connect` method. If `signIn` is successful, the user can\n          // return `false` and skip the `connect` method.\n          if (typeof autoConnect === \"function\") {\n            shouldConnect = await autoConnect(walletCore, selectedWallet);\n          } else {\n            shouldConnect = autoConnect;\n          }\n\n          if (shouldConnect) await connect(walletName);\n        } catch (error) {\n          if (onError) onError(error);\n          return Promise.reject(error);\n        } finally {\n          setIsLoading(false);\n        }\n      })();\n    } else {\n      setIsLoading(false);\n    }\n  }, [autoConnect, wallets]);\n\n  const connect = async (walletName: string): Promise<void> => {\n    try {\n      setIsLoading(true);\n      await walletCore?.connect(walletName);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const signIn = async (args: {\n    walletName: string;\n    input: AptosSignInInput;\n  }): Promise<AptosSignInOutput> => {\n    if (!walletCore) {\n      throw new Error(\"WalletCore is not initialized\");\n    }\n\n    try {\n      setIsLoading(true);\n      return await walletCore?.signIn(args);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const disconnect = async (): Promise<void> => {\n    try {\n      await walletCore?.disconnect();\n    } catch (error) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  const signAndSubmitTransaction = async (\n    transaction: InputTransactionData\n  ): Promise<AptosSignAndSubmitTransactionOutput> => {\n    try {\n      if (!walletCore) {\n        throw new Error(\"WalletCore is not initialized\");\n      }\n      return await walletCore.signAndSubmitTransaction(transaction);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  const signTransaction = async (args: {\n    transactionOrPayload: AnyRawTransaction | InputTransactionData;\n    asFeePayer?: boolean;\n    options?: InputGenerateTransactionOptions & {\n      expirationSecondsFromNow?: number;\n      expirationTimestamp?: number;\n    };\n  }): Promise<{\n    authenticator: AccountAuthenticator;\n    rawTransaction: Uint8Array;\n  }> => {\n    const { transactionOrPayload, asFeePayer, options } = args;\n    if (!walletCore) {\n      throw new Error(\"WalletCore is not initialized\");\n    }\n    try {\n      return await walletCore.signTransaction({\n        transactionOrPayload,\n        asFeePayer,\n      });\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  const submitTransaction = async (\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse> => {\n    if (!walletCore) {\n      throw new Error(\"WalletCore is not initialized\");\n    }\n    try {\n      return await walletCore?.submitTransaction(transaction);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  const signMessage = async (\n    message: AptosSignMessageInput\n  ): Promise<AptosSignMessageOutput> => {\n    if (!walletCore) {\n      throw new Error(\"WalletCore is not initialized\");\n    }\n    try {\n      return await walletCore?.signMessage(message);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  const signMessageAndVerify = async (\n    message: AptosSignMessageInput\n  ): Promise<boolean> => {\n    if (!walletCore) {\n      throw new Error(\"WalletCore is not initialized\");\n    }\n    try {\n      return await walletCore?.signMessageAndVerify(message);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  const changeNetwork = async (network: Network) => {\n    if (!walletCore) {\n      throw new Error(\"WalletCore is not initialized\");\n    }\n    try {\n      return await walletCore?.changeNetwork(network);\n    } catch (error: any) {\n      if (onError) onError(error);\n      return Promise.reject(error);\n    }\n  };\n\n  // Handle the adapter's connect event\n  const handleConnect = (): void => {\n    setState((state) => {\n      return {\n        ...state,\n        connected: true,\n        account: walletCore?.account || null,\n        network: walletCore?.network || null,\n        wallet: walletCore?.wallet || null,\n      };\n    });\n  };\n\n  // Handle the adapter's account change event\n  const handleAccountChange = useCallback((): void => {\n    if (!connected) return;\n    if (!walletCore?.wallet) return;\n    setState((state) => {\n      return {\n        ...state,\n        account: walletCore?.account || null,\n      };\n    });\n  }, [connected]);\n\n  // Handle the adapter's network event\n  const handleNetworkChange = useCallback((): void => {\n    if (!connected) return;\n    if (!walletCore?.wallet) return;\n    setState((state) => {\n      return {\n        ...state,\n        network: walletCore?.network || null,\n      };\n    });\n  }, [connected]);\n\n  useEffect(() => {\n    if (connected) {\n      walletCore?.onAccountChange();\n      walletCore?.onNetworkChange();\n    }\n  }, [connected]);\n\n  // Handle the adapter's disconnect event\n  const handleDisconnect = (): void => {\n    if (!connected) return;\n    setState((state) => {\n      return {\n        ...state,\n        connected: false,\n        account: walletCore?.account || null,\n        network: walletCore?.network || null,\n        wallet: null,\n      };\n    });\n  };\n\n  const handleStandardWalletsAdded = (standardWallet: AdapterWallet): void => {\n    // Manage current wallet state by removing optional duplications\n    // as new wallets are coming\n    const existingWalletIndex = wallets.findIndex(\n      (wallet) => wallet.name == standardWallet.name\n    );\n    if (existingWalletIndex !== -1) {\n      // If wallet exists, replace it with the new wallet\n      setWallets((wallets) => [\n        ...wallets.slice(0, existingWalletIndex),\n        standardWallet,\n        ...wallets.slice(existingWalletIndex + 1),\n      ]);\n    } else {\n      // If wallet doesn't exist, add it to the array\n      setWallets((wallets) => [...wallets, standardWallet]);\n    }\n  };\n\n  const handleStandardNotDetectedWalletsAdded = (\n    notDetectedWallet: AdapterNotDetectedWallet\n  ): void => {\n    // Manage current wallet state by removing optional duplications\n    // as new wallets are coming\n    const existingWalletIndex = wallets.findIndex(\n      (wallet) => wallet.name == notDetectedWallet.name\n    );\n    if (existingWalletIndex !== -1) {\n      // If wallet exists, replace it with the new wallet\n      setNotDetectedWallets((wallets) => [\n        ...wallets.slice(0, existingWalletIndex),\n        notDetectedWallet,\n        ...wallets.slice(existingWalletIndex + 1),\n      ]);\n    } else {\n      // If wallet doesn't exist, add it to the array\n      setNotDetectedWallets((wallets) => [...wallets, notDetectedWallet]);\n    }\n  };\n\n  useEffect(() => {\n    walletCore?.on(\"connect\", handleConnect);\n    walletCore?.on(\"accountChange\", handleAccountChange);\n    walletCore?.on(\"networkChange\", handleNetworkChange);\n    walletCore?.on(\"disconnect\", handleDisconnect);\n    walletCore?.on(\"standardWalletsAdded\", handleStandardWalletsAdded);\n    walletCore?.on(\n      \"standardNotDetectedWalletAdded\",\n      handleStandardNotDetectedWalletsAdded\n    );\n    return () => {\n      walletCore?.off(\"connect\", handleConnect);\n      walletCore?.off(\"accountChange\", handleAccountChange);\n      walletCore?.off(\"networkChange\", handleNetworkChange);\n      walletCore?.off(\"disconnect\", handleDisconnect);\n      walletCore?.off(\"standardWalletsAdded\", handleStandardWalletsAdded);\n      walletCore?.off(\n        \"standardNotDetectedWalletAdded\",\n        handleStandardNotDetectedWalletsAdded\n      );\n    };\n  }, [wallets, account]);\n\n  return (\n    <WalletContext.Provider\n      value={{\n        connect,\n        signIn,\n        disconnect,\n        signAndSubmitTransaction,\n        signTransaction,\n        signMessage,\n        signMessageAndVerify,\n        changeNetwork,\n        submitTransaction,\n        account,\n        network,\n        connected,\n        wallet,\n        wallets,\n        notDetectedWallets,\n        isLoading,\n      }}\n    >\n      {children}\n    </WalletContext.Provider>\n  );\n};\n", "import { useContext, createContext } from \"react\";\nimport {\n  AccountAuthenticator,\n  AccountInfo,\n  AdapterWallet,\n  AnyRawTransaction,\n  AptosSignAndSubmitTransactionOutput,\n  InputTransactionData,\n  NetworkInfo,\n  AptosSignMessageInput,\n  AptosSignMessageOutput,\n  AdapterNotDetectedWallet,\n  Network,\n  AptosChangeNetworkOutput,\n  PendingTransactionResponse,\n  InputSubmitTransactionData,\n  AptosSignInInput,\n  AptosSignInOutput,\n} from \"@aptos-labs/wallet-adapter-core\";\n\nexport interface WalletContextState {\n  connected: boolean;\n  isLoading: boolean;\n  account: AccountInfo | null;\n  network: NetworkInfo | null;\n  connect(walletName: string): void;\n  signIn(args: {\n    walletName: string;\n    input: AptosSignInInput;\n  }): Promise<AptosSignInOutput | void>;\n  signAndSubmitTransaction(\n    transaction: InputTransactionData\n  ): Promise<AptosSignAndSubmitTransactionOutput>;\n  signTransaction(args: {\n    transactionOrPayload: AnyRawTransaction | InputTransactionData;\n    asFeePayer?: boolean;\n  }): Promise<{\n    authenticator: AccountAuthenticator;\n    rawTransaction: Uint8Array;\n  }>;\n  signMessage(message: AptosSignMessageInput): Promise<AptosSignMessageOutput>;\n  signMessageAndVerify(message: AptosSignMessageInput): Promise<boolean>;\n  disconnect(): void;\n  changeNetwork(network: Network): Promise<AptosChangeNetworkOutput>;\n  submitTransaction(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse>;\n  wallet: AdapterWallet | null;\n  wallets: ReadonlyArray<AdapterWallet>;\n  notDetectedWallets: ReadonlyArray<AdapterNotDetectedWallet>;\n}\n\nconst DEFAULT_CONTEXT = {\n  connected: false,\n};\n\nexport const WalletContext = createContext<WalletContextState>(\n  DEFAULT_CONTEXT as WalletContextState\n);\n\nexport function useWallet(): WalletContextState {\n  const context = useContext(WalletContext);\n  if (!context) {\n    throw new Error(\"useWallet must be used within a WalletContextState\");\n  }\n  return context;\n}\n", "import {\n  Dispatch,\n  ForwardRefExoticComponent,\n  ReactNode,\n  RefAttributes,\n  SVGProps,\n  SetStateAction,\n  createContext,\n  useContext,\n  useMemo,\n  useState,\n} from \"react\";\nimport { LinkGraphic } from \"../graphics/LinkGraphic\";\nimport { WalletGraphic } from \"../graphics/WalletGraphic\";\nimport { Web3Graphic } from \"../graphics/Web3Graphic\";\nimport { HeadlessComponentProps, createHeadlessComponent } from \"./utils\";\n\nexport const EXPLORE_ECOSYSTEM_URL =\n  \"https://aptosfoundation.org/ecosystem/projects/all\";\n\nconst AboutAptosConnectContext = createContext<{\n  screenIndex: number;\n  setScreenIndex: Dispatch<SetStateAction<number>>;\n} | null>(null);\n\nfunction useAboutAptosConnectContext(displayName: string) {\n  const context = useContext(AboutAptosConnectContext);\n\n  if (!context) {\n    throw new Error(\n      `\\`${displayName}\\` must be used within \\`AboutAptosConnect\\``,\n    );\n  }\n\n  return context;\n}\n\nconst educationScreens = [\n  {\n    Graphic: LinkGraphic,\n    Title: createHeadlessComponent(\"EducationScreen.Title\", \"h3\", {\n      children: \"A better way to login.\",\n    }),\n    Description: createHeadlessComponent(\"EducationScreen.Description\", \"p\", {\n      children:\n        \"Aptos Connect is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain.\",\n    }),\n  },\n  {\n    Graphic: WalletGraphic,\n    Title: createHeadlessComponent(\"EducationScreen.Title\", \"h2\", {\n      children: \"What is a wallet?\",\n    }),\n    Description: createHeadlessComponent(\"EducationScreen.Description\", \"p\", {\n      children:\n        \"Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs.\",\n    }),\n  },\n  {\n    Graphic: Web3Graphic,\n    Title: createHeadlessComponent(\"EducationScreen.Title\", \"h2\", {\n      children: \"Explore more of web3.\",\n    }),\n    Description: createHeadlessComponent(\"EducationScreen.Description\", \"p\", {\n      children: (\n        <>\n          Aptos Connect lets you take one account across any application built\n          on Aptos.{\" \"}\n          <a\n            href={EXPLORE_ECOSYSTEM_URL}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Explore the ecosystem\n          </a>\n          .\n        </>\n      ),\n    }),\n  },\n];\n\nconst educationScreenIndicators = Array(educationScreens.length)\n  .fill(null)\n  .map((_, index) =>\n    createHeadlessComponent(\n      \"AboutAptosConnect.ScreenIndicator\",\n      \"button\",\n      (displayName) => {\n        const context = useAboutAptosConnectContext(displayName);\n        const isActive = context.screenIndex - 1 === index;\n\n        return {\n          \"aria-label\": `Go to screen ${index + 1}`,\n          \"aria-current\": isActive ? \"step\" : undefined,\n          \"data-active\": isActive || undefined,\n          onClick: () => {\n            context.setScreenIndex(index + 1);\n          },\n        };\n      },\n    ),\n  );\n\nexport interface AboutAptosConnectEducationScreen {\n  /** A component that renders an SVG to illustrate the idea of the current screen. */\n  Graphic: ForwardRefExoticComponent<\n    Omit<SVGProps<SVGSVGElement>, \"ref\"> & RefAttributes<SVGSVGElement>\n  >;\n  /** A headless component that renders the title of the current screen. */\n  Title: ForwardRefExoticComponent<\n    HeadlessComponentProps & RefAttributes<HTMLHeadingElement>\n  >;\n  /** A headless component that renders the description text of the current screen. */\n  Description: ForwardRefExoticComponent<\n    HeadlessComponentProps & RefAttributes<HTMLParagraphElement>\n  >;\n  /** The index of the current education screen. */\n  screenIndex: number;\n  /** The total number of education screens. */\n  totalScreens: number;\n  /**\n   * An array of headless components for indicating the current screen of the set.\n   * Each indicator will navigate the user to the screen it represents when clicked.\n   */\n  screenIndicators: typeof educationScreenIndicators;\n  /**\n   * A function that navigates the user to the previous education screen.\n   * If the user is on the first education screen, they will be navigated to the\n   * initial wallet selection screen.\n   */\n  back: () => void;\n  /**\n   * A function that navigates the user to the next education screen.\n   * If the user is on the last education screen, they will be navigated to the\n   * initial wallet selection screen.\n   */\n  next: () => void;\n  /** A function that navigates the user to the initial wallet selection screen. */\n  cancel: () => void;\n}\n\nexport interface AboutAptosConnectProps {\n  /**\n   * A function for defining how each education screen should be rendered.\n   * Each screen is modeled as a uniform set of headless components and utilities\n   * that allow you to construct your UI and apply your own styles.\n   */\n  renderEducationScreen: (\n    screen: AboutAptosConnectEducationScreen,\n  ) => ReactNode;\n  /**\n   * The initial wallet selection UI that will be replaced by the education\n   * screens when `AboutAptosConnect.Trigger` is clicked.\n   */\n  children?: ReactNode;\n}\n\nconst Root = ({ renderEducationScreen, children }: AboutAptosConnectProps) => {\n  const [screenIndex, setScreenIndex] = useState(0);\n\n  const currentEducationScreen: AboutAptosConnectEducationScreen = useMemo(\n    () =>\n      educationScreens.map((screen, i) => ({\n        ...screen,\n        screenIndex: i,\n        totalScreens: educationScreens.length,\n        screenIndicators: educationScreenIndicators,\n        back: () => {\n          setScreenIndex(screenIndex - 1);\n        },\n        next: () => {\n          setScreenIndex(\n            screenIndex === educationScreens.length ? 0 : screenIndex + 1,\n          );\n        },\n        cancel: () => {\n          setScreenIndex(0);\n        },\n      }))[screenIndex - 1],\n    [screenIndex],\n  );\n\n  return (\n    <AboutAptosConnectContext.Provider value={{ screenIndex, setScreenIndex }}>\n      {screenIndex === 0\n        ? children\n        : renderEducationScreen(currentEducationScreen)}\n    </AboutAptosConnectContext.Provider>\n  );\n};\nRoot.displayName = \"AboutAptosConnect\";\n\nconst Trigger = createHeadlessComponent(\n  \"AboutAptosConnect.Trigger\",\n  \"button\",\n  (displayName) => {\n    const context = useAboutAptosConnectContext(displayName);\n\n    return {\n      onClick: () => {\n        context.setScreenIndex(1);\n      },\n    };\n  },\n);\n\n/**\n * A headless component for rendering education screens that explain the basics\n * of Aptos Connect and web3 wallets.\n */\nexport const AboutAptosConnect = Object.assign(Root, {\n  Trigger,\n});\n", "import { SVGProps, forwardRef } from \"react\";\n\nexport const LinkGraphic = forwardRef<SVGSVGElement, SVGProps<SVGSVGElement>>(\n  (props, ref) => {\n    return (\n      <svg\n        ref={ref}\n        width=\"102\"\n        height=\"132\"\n        viewBox=\"0 0 102 132\"\n        fill=\"none\"\n        {...props}\n      >\n        <g stroke=\"currentColor\" strokeMiterlimit=\"10\">\n          <path d=\"M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108\" />\n          <path d=\"m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923\" />\n          <path d=\"M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239\" />\n          <path d=\"m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z\" />\n          <path d=\"M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425\" />\n          <path d=\"M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z\" />\n        </g>\n      </svg>\n    );\n  },\n);\nLinkGraphic.displayName = \"LinkGraphic\";\n", "import { SVGProps, forwardRef } from \"react\";\n\nexport const WalletGraphic = forwardRef<SVGSVGElement, SVGProps<SVGSVGElement>>(\n  (props, ref) => {\n    return (\n      <svg\n        ref={ref}\n        width=\"128\"\n        height=\"102\"\n        viewBox=\"0 0 128 102\"\n        fill=\"none\"\n        {...props}\n      >\n        <path\n          fill=\"currentColor\"\n          d=\"m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z\"\n        />\n        <path\n          stroke=\"currentColor\"\n          strokeMiterlimit=\"10\"\n          d=\"M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7\"\n        />\n        <path\n          stroke=\"currentColor\"\n          strokeMiterlimit=\"10\"\n          d=\"M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4\"\n        />\n        <path\n          stroke=\"currentColor\"\n          strokeMiterlimit=\"10\"\n          d=\"M9.86 23.69V5.72h107.97v18.04H84.65\"\n        />\n        <path\n          stroke=\"currentColor\"\n          strokeMiterlimit=\"10\"\n          d=\"M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78\"\n        />\n      </svg>\n    );\n  },\n);\nWalletGraphic.displayName = \"WalletGraphic\";\n", "import { SVGProps, forwardRef } from \"react\";\n\nexport const Web3Graphic = forwardRef<SVGSVGElement, SVGProps<SVGSVGElement>>(\n  (props, ref) => {\n    return (\n      <svg\n        ref={ref}\n        width=\"142\"\n        height=\"108\"\n        viewBox=\"0 0 142 108\"\n        fill=\"none\"\n        {...props}\n      >\n        <g stroke=\"currentColor\" strokeLinejoin=\"round\">\n          <path d=\"m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5\" />\n          <path d=\"M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55\" />\n          <path d=\"M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55\" />\n          <path d=\"M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5\" />\n          <path d=\"M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55\" />\n          <path d=\"m105.44 30.8.11 9-.1-9Z\" />\n          <path d=\"M71 59.51v-9.07l34.44-19.64.11 9L78.5 55\" />\n          <path d=\"M71 59.51v-9.07l34.56 20.34.1 9.14L87 69\" />\n          <path d=\"M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79\" />\n          <path d=\"M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8\" />\n          <path d=\"m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z\" />\n        </g>\n      </svg>\n    );\n  },\n);\nWeb3Graphic.displayName = \"Web3Graphic\";\n", "import { Slot } from \"@radix-ui/react-slot\";\nimport { ReactNode, cloneElement, forwardRef, isValidElement } from \"react\";\n\nexport interface HeadlessComponentProps {\n  /** A class name for styling the element. */\n  className?: string;\n  /**\n   * Whether to render as the child element instead of the default element provided.\n   * All props will be merged into the child element.\n   */\n  asChild?: boolean;\n  children?: ReactNode;\n}\n\n/**\n * Gets an HTML element type from its tag name\n * @example\n * HTMLElementFromTag<\"img\"> // resolved type: HTMLImageElement\n */\ntype HTMLElementFromTag<T extends keyof JSX.IntrinsicElements> =\n  JSX.IntrinsicElements[T] extends React.ClassAttributes<infer Element>\n    ? Element\n    : HTMLElement;\n\nexport function createHeadlessComponent<\n  TElement extends keyof JSX.IntrinsicElements,\n>(\n  displayName: string,\n  elementType: TElement,\n  props?:\n    | JSX.IntrinsicElements[TElement]\n    | ((displayName: string) => JSX.IntrinsicElements[TElement]),\n) {\n  const component = forwardRef<\n    HTMLElementFromTag<TElement>,\n    HeadlessComponentProps\n  >(({ className, asChild, children }, ref) => {\n    const Component = asChild ? Slot : elementType;\n\n    const { children: defaultChildren, ...resolvedProps } =\n      typeof props === \"function\" ? props(displayName) : (props ?? {});\n    const resolvedChildren =\n      /**\n       * Use props' default children if no children are set in the component element's children and when asChild is true.\n       */\n      asChild && isValidElement(children) && !children.props.children\n        ? cloneElement(children, {}, defaultChildren)\n        : (children ?? defaultChildren);\n\n    return (\n      /**\n       * Due to the complexity of the types at play, TypeScript reports the\n       * following error for our JSX below:\n       *\n       * `Expression produces a union type that is too complex to represent.`\n       *\n       * We can safely ignore this error and retain accurate return types for\n       * consumers of this function. The only drawback is that type-checking is\n       * ignored for the JSX block below.\n       */\n      // @ts-expect-error\n      <Component ref={ref} className={className} {...resolvedProps}>\n        {resolvedChildren}\n      </Component>\n    );\n  });\n  component.displayName = displayName;\n\n  return component;\n}\n", "import { forwardRef } from \"react\";\nimport { SmallAptosLogo } from \"../graphics/SmallAptosLogo\";\nimport { HeadlessComponentProps, createHeadlessComponent } from \"./utils\";\n\nexport const APTOS_PRIVACY_POLICY_URL = \"https://aptoslabs.com/privacy\";\n\nconst Root = createHeadlessComponent(\"AptosPrivacyPolicy.Root\", \"div\");\n\nconst Disclaimer = createHeadlessComponent(\n  \"AptosPrivacyPolicy.Disclaimer\",\n  \"span\",\n  { children: \"By continuing, you agree to Aptos Labs'\" },\n);\n\nconst Link = createHeadlessComponent(\"AptosPrivacyPolicy.Disclaimer\", \"a\", {\n  href: APTOS_PRIVACY_POLICY_URL,\n  target: \"_blank\",\n  rel: \"noopener noreferrer\",\n  children: \"Privacy Policy\",\n});\n\nconst PoweredBy = forwardRef<\n  HTMLDivElement,\n  Pick<HeadlessComponentProps, \"className\">\n>(({ className }, ref) => {\n  return (\n    <div ref={ref} className={className}>\n      <span>Powered by</span>\n      <SmallAptosLogo />\n      <span>Aptos Labs</span>\n    </div>\n  );\n});\nPoweredBy.displayName = \"AptosPrivacyPolicy.PoweredBy\";\n\n/**\n * A headless component for rendering the Aptos Labs privacy policy disclaimer\n * that should be placed under the Aptos Connect login options.\n */\nexport const AptosPrivacyPolicy = Object.assign(Root, {\n  Disclaimer,\n  Link,\n  PoweredBy,\n});\n", "import { SVGProps, forwardRef } from \"react\";\n\nexport const SmallAptosLogo = forwardRef<\n  SVGSVGElement,\n  SVGProps<SVGSVGElement>\n>((props, ref) => {\n  return (\n    <svg\n      ref={ref}\n      width=\"12\"\n      height=\"12\"\n      viewBox=\"0 0 12 12\"\n      fill=\"none\"\n      {...props}\n    >\n      <path\n        fillRule=\"evenodd\"\n        clipRule=\"evenodd\"\n        d=\"M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z\"\n        fill=\"currentColor\"\n      />\n    </svg>\n  );\n});\nSmallAptosLogo.displayName = \"SmallAptosLogo\";\n", "import {\n  AdapterNotDetectedWallet,\n  AdapterWallet,\n  WalletReadyState,\n  isRedirectable,\n} from \"@aptos-labs/wallet-adapter-core\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { createContext, forwardRef, useCallback, useContext } from \"react\";\nimport { useWallet } from \"../useWallet\";\nimport { HeadlessComponentProps, createHeadlessComponent } from \"./utils\";\n\nexport interface WalletItemProps extends HeadlessComponentProps {\n  /** The wallet option to be displayed. */\n  wallet: AdapterWallet | AdapterNotDetectedWallet;\n  /** A callback to be invoked when the wallet is connected. */\n  onConnect?: () => void;\n}\n\nfunction useWalletItemContext(displayName: string) {\n  const context = useContext(WalletItemContext);\n\n  if (!context) {\n    throw new Error(`\\`${displayName}\\` must be used within \\`WalletItem\\``);\n  }\n\n  return context;\n}\n\nconst WalletItemContext = createContext<{\n  wallet: AdapterWallet | AdapterNotDetectedWallet;\n  connectWallet: () => void;\n} | null>(null);\n\nconst Root = forwardRef<HTMLDivElement, WalletItemProps>(\n  ({ wallet, onConnect, className, asChild, children }, ref) => {\n    const { connect } = useWallet();\n\n    const connectWallet = useCallback(() => {\n      connect(wallet.name);\n      onConnect?.();\n    }, [connect, wallet.name, onConnect]);\n\n    const isWalletReady = wallet.readyState === WalletReadyState.Installed;\n\n    const mobileSupport =\n      \"deeplinkProvider\" in wallet && wallet.deeplinkProvider;\n\n    if (!isWalletReady && isRedirectable() && !mobileSupport) return null;\n\n    const Component = asChild ? Slot : \"div\";\n\n    return (\n      <WalletItemContext.Provider value={{ wallet, connectWallet }}>\n        <Component ref={ref} className={className}>\n          {children}\n        </Component>\n      </WalletItemContext.Provider>\n    );\n  },\n);\nRoot.displayName = \"WalletItem\";\n\nconst Icon = createHeadlessComponent(\n  \"WalletItem.Icon\",\n  \"img\",\n  (displayName) => {\n    const context = useWalletItemContext(displayName);\n\n    return {\n      src: context.wallet.icon,\n      alt: `${context.wallet.name} icon`,\n    };\n  },\n);\n\nconst Name = createHeadlessComponent(\n  \"WalletItem.Name\",\n  \"div\",\n  (displayName) => {\n    const context = useWalletItemContext(displayName);\n\n    return {\n      children: context.wallet.name,\n    };\n  },\n);\n\nconst ConnectButton = createHeadlessComponent(\n  \"WalletItem.ConnectButton\",\n  \"button\",\n  (displayName) => {\n    const context = useWalletItemContext(displayName);\n\n    return {\n      onClick: context.connectWallet,\n      children: \"Connect\",\n    };\n  },\n);\n\nconst InstallLink = createHeadlessComponent(\n  \"WalletItem.InstallLink\",\n  \"a\",\n  (displayName) => {\n    const context = useWalletItemContext(displayName);\n\n    return {\n      href: context.wallet.url,\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n      children: \"Install\",\n    };\n  },\n);\n\n/** A headless component for rendering a wallet option's name, icon, and either connect button or install link. */\nexport const WalletItem = Object.assign(Root, {\n  Icon,\n  Name,\n  ConnectButton,\n  InstallLink,\n});\n", "import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n", "import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n"],
  "mappings": "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IAAA,2CAEAA,IAAAA,IAAA,oCAAA,EAAA,IAAA,qCAEAA,IAAAA,IAAA,gDAAA,EAAA,IAAA,iDAEAA,IAAAA,IAAA,4BAAA,EAAA,IAAA,6BAEAA,IAAAA,IAAA,UAAA,EAAA,IAAA,WAnEUA,MAAAA,MAAA,CAAA,CAAA;AAzBL,IA+FDC,KAA0G,EAC7G,GAA8C,CAC7C,sCACA,GACA,uDACF,GACC,GAAmC,CAClC,0CACA,GACA,kJACF,GACC,GAA4C,CAC3C,uCACA,GACA,2HACF,GACC,GAAqD,CACpD,kCACA,GACA,2HACF,GACC,GAA4D,CAC3D,0DACA,GACA,uDACF,GACC,GAAmC,CAClC,kDACA,GACA,2HACF,GACC,GAA6C,CAC5C,6FACA,GACA,uDACF,GACC,GAAkD,CACjD,qCACA,GACA,2DACF,GACC,GAA2D,CAC1D,6DACA,GACA,2HACF,GACC,GAAsD,CACrD,6CACA,GACA,2HACF,GACC,IAAuD,CACtD,8EACA,GACA,uDACF,GACC,IAA0C,CACzC,kCACA,GACA,uDACF,GACC,IAAoC,CACnC,yBACA,GACA,uEACF,GACC,IAA8C,CAC7C,wDACA,GACA,uEACF,GACC,IAAuC,CACtC,6DACA,GACA,gPACF,GACC,IAAiD,CAChD,uCACA,GACA,8IACF,GACC,IAA8C,CAC7C,uCACA,GACA,2DACF,GACC,IAAwC,CACvC,sCACA,GACA,8IACF,GACC,IAAiD,CAChD,uCACA,GACA,8IACF,GACC,IAA8C,CAC7C,uCACA,GACA,2DACF,GACC,IAAwC,CACvC,sCACA,GACA,8IACF,GACC,IAAqC,CACpC,qGACA,GACA,sFACF,GACC,IAAiD,CAChD,yDACA,GACA,8IACF,GACC,IAA2D,CAC1D,oDACA,GACA,8IACF,GACC,IAA+C,CAC9C,wCACA,GACA,8IACF,GACC,IAAmC,CAClC,iCACA,GACA,8IACF,GACC,IAA0C,CACzC,mDACA,GACA,uEACF,GACC,IAAqC,CACpC,gEACA,GACA,uDACF,GACC,IAA+C,CAC9C,0EACA,GACA,uDACF,GACC,IAA2D,CAC1D,2EACA,GAC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",
  "names": ["fn", "EventEmitter", "i", "l", "ee", "a2", "a3", "a4", "a5", "j", "on", "f", "nacl", "i", "r", "D", "I", "o", "c", "p", "q", "b", "t", "n", "A", "a", "Z", "M", "j", "S", "m", "d", "x", "y", "z", "import_eventemitter3", "cache", "memoizeAsync", "func", "key", "ttlMs", "args", "value", "timestamp", "result", "ParsingError", "message", "invalidReason", "HexInvalidReason", "Hex", "_Hex", "data", "bytesToHex", "str", "input", "ParsingError", "hexToBytes", "error", "hexInput", "other", "value", "index", "hexToAsciiString", "hex", "MAX_U8_NUMBER", "MAX_U16_NUMBER", "MAX_U32_NUMBER", "MAX_U64_BIG_INT", "MAX_U128_BIG_INT", "MAX_U256_BIG_INT", "h", "i", "g", "b", "d", "c", "a", "e", "f", "Serializable", "serializer", "Serializer", "bcsBytes", "Hex", "length", "bytes", "newBuffer", "values", "fn", "bytesLength", "value", "dv", "textEncoder", "ensureBoolean", "byteValue", "low", "MAX_U32_NUMBER", "high", "MAX_U64_BIG_INT", "MAX_U128_BIG_INT", "val", "valueArray", "item", "len", "hasValue", "__decorateClass", "checkNumberRange", "MAX_U8_NUMBER", "MAX_U16_NUMBER", "MAX_U256_BIG_INT", "outOfRangeErrorMessage", "min", "max", "validateNumberInRange", "minValue", "maxValue", "valueBigInt", "target", "propertyKey", "descriptor", "childFunction", "AddressInvalidReason", "_AccountAddress", "Serializable", "input", "ParsingError", "byte", "hex", "bytesToHex", "serializer", "bcsBytes", "deserializer", "bytes", "address", "maxMissingChars", "parsedInput", "addressBytes", "hexToBytes", "error", "args", "other", "value", "index", "AccountAddress", "createObjectAddress", "creatorAddress", "seed", "creatorBytes", "seedBytes", "bytes", "AccountAddress", "sha3_256", "sleep", "timeMs", "resolve", "getErrorMessage", "error", "nowInSeconds", "floorToWholeHour", "timestampInSeconds", "date", "base64UrlDecode", "base64Url", "base64", "paddedBase64", "decode", "base64UrlToBytes", "hexToAscii", "hex", "str", "n", "parseEncodedStruct", "structObj", "account_address", "module_name", "struct_name", "moduleName", "structName", "isEncodedStruct", "getFunctionParts", "functionArg", "funcNameParts", "moduleAddress", "functionName", "isValidFunctionInfo", "functionInfo", "parts", "AccountAddress", "APT_METADATA_ADDRESS_HEX", "AccountAddress", "KeylessErrorCategory", "KeylessErrorResolutionTip", "KeylessErrorType", "KeylessErrors", "KeylessError", "_KeylessError", "args", "innerError", "category", "resolutionTip", "type", "message", "details", "tip", "result", "AptosApiError", "getErrorMessage", "error", "apiType", "aptosRequest", "aptosResponse", "deriveErrorMessage", "traceId", "traceIdString", "errorPrelude", "serializeAnyPayloadForErrorMessage", "SERIALIZED_PAYLOAD_TRIM_TO_MAX_LENGTH", "payload", "serializedPayload", "VERSION", "request", "options", "client", "url", "method", "body", "contentType", "params", "overrides", "originMethod", "headers", "VERSION", "aptosRequest", "aptosRequestOpts", "aptosConfig", "apiType", "path", "fullUrl", "clientResponse", "aptosResponse", "AptosApiError", "indexerResponse", "get", "options", "aptosConfig", "overrides", "params", "contentType", "acceptType", "path", "originMethod", "type", "url", "aptosRequest", "getAptosFullNode", "paginateWithCursor", "options", "out", "cursor", "requestParams", "response", "get", "paginateWithObfuscatedCursor", "totalLimit", "newCursor", "getPageWithObfuscatedCursor", "newLimit", "getInfo", "args", "aptosConfig", "accountAddress", "data", "getAptosFullNode", "AccountAddress", "getModule", "getModuleInner", "memoizeAsync", "moduleName", "options", "convertSigningMessage", "message", "Hex", "APTOS_HARDENED_REGEX", "APTOS_BIP44_REGEX", "KeyType", "HARDENED_OFFSET", "isValidBIP44Path", "path", "isValidHardenedPath", "deriveKey", "hashSeed", "data", "digest", "hmac", "sha512", "CKDPriv", "key", "chainCode", "index", "buffer", "indexBytes", "zero", "removeApostrophes", "val", "splitPath", "mnemonicToSeed", "mnemonic", "normalizedMnemonic", "part", "_PrivateKey", "privateKey", "type", "aip80Prefix", "formattedPrivateKey", "Hex", "value", "strict", "data", "PrivateKey", "PublicKey", "Serializable", "args", "bytes", "Hex", "AccountPublicKey", "Signature", "Serializable", "bytes", "Hex", "_Secp256k1PublicKey", "PublicKey", "hexInput", "hex", "Hex", "length", "point", "secp256k1", "args", "message", "signature", "messageToVerify", "convertSigningMessage", "messageBytes", "messageSha3Bytes", "sha3_256", "signatureBytes", "serializer", "deserializer", "Secp256k1Signature", "bytes", "publicKey", "Secp256k1PublicKey", "_Secp256k1PrivateKey", "Serializable", "strict", "privateKeyHex", "PrivateKey", "path", "mnemonics", "isValidBIP44Path", "mnemonicToSeed", "seed", "privateKey", "HDKey", "messageToSign", "messageHashBytes", "Secp256k1PrivateKey", "_Secp256k1Signature", "Signature", "data", "AsyncQueue", "item", "resolve", "reject", "AsyncQueueCancelledError", "numInputsToPoseidonFunc", "poseidon1", "poseidon2", "poseidon3", "poseidon4", "poseidon5", "poseidon6", "poseidon7", "poseidon8", "poseidon9", "poseidon10", "poseidon11", "poseidon12", "poseidon13", "poseidon14", "poseidon15", "poseidon16", "BYTES_PACKED_PER_SCALAR", "MAX_NUM_INPUT_SCALARS", "MAX_NUM_INPUT_BYTES", "hashStrToField", "str", "maxSizeBytes", "strBytes", "hashBytesWithLen", "bytes", "packed", "padAndPackBytesWithLen", "poseidonHash", "padAndPackBytesNoLen", "paddedStrBytes", "padUint8ArrayWithZeros", "packBytes", "chunkUint8Array", "chunk", "bytesToBigIntLE", "array", "chunkSize", "result", "i", "bigIntToBytesLE", "value", "length", "val", "inputArray", "paddedSize", "paddedArray", "inputs", "Proof", "Serializable", "_AuthenticationKey", "Serializable", "args", "data", "hex", "Hex", "serializer", "deserializer", "bytes", "scheme", "input", "inputBytes", "hashInput", "hash", "sha3Hash", "hashDigest", "publicKey", "AccountAddress", "AuthenticationKey", "AbstractSignature", "_AbstractSignature", "Signature", "value", "Hex", "serializer", "deserializer", "AbstractPublicKey", "AccountPublicKey", "accountAddress", "AuthenticationKey", "args", "L", "isCanonicalEd25519Signature", "signature", "s", "i", "_Ed25519PublicKey", "AccountPublicKey", "hexInput", "hex", "Hex", "args", "message", "messageToVerify", "convertSigningMessage", "messageBytes", "signatureBytes", "publicKeyBytes", "ed25519", "AuthenticationKey", "serializer", "deserializer", "bytes", "publicKey", "Ed25519PublicKey", "_Ed25519PrivateKey", "Serializable", "strict", "privateKeyHex", "PrivateKey", "keyPair", "path", "mnemonics", "isValidHardenedPath", "mnemonicToSeed", "seed", "offset", "HARDENED_OFFSET", "key", "chainCode", "deriveKey", "segments", "splitPath", "el", "privateKey", "parentKeys", "segment", "CKDPriv", "messageToSign", "Ed25519Signature", "Ed25519PrivateKey", "_Ed25519Signature", "Signature", "data", "Deserializer", "_Deserializer", "data", "hex", "Hex", "length", "bytes", "value", "type", "len", "bool", "low", "high", "shift", "MAX_U32_NUMBER", "byte", "cls", "vector", "i", "EphemeralPublicKey", "_EphemeralPublicKey", "PublicKey", "publicKey", "publicKeyType", "Ed25519PublicKey", "args", "message", "signature", "serializer", "deserializer", "index", "EphemeralSignature", "_EphemeralSignature", "Signature", "signatureType", "Ed25519Signature", "hexInput", "data", "Hex", "Deserializer", "Bool", "_Bool", "Serializable", "value", "ensureBoolean", "serializer", "bcsBytes", "deserializer", "U256", "U8", "_U8", "validateNumberInRange", "MAX_U8_NUMBER", "U16", "_U16", "MAX_U16_NUMBER", "U32", "_U32", "MAX_U32_NUMBER", "U64", "_U64", "MAX_U64_BIG_INT", "U128", "_U128", "MAX_U128_BIG_INT", "_U256", "MAX_U256_BIG_INT", "MoveVector", "_MoveVector", "Serializable", "values", "serializer", "bcsBytes", "U8", "Serialized", "numbers", "hex", "Hex", "v", "U16", "U32", "U64", "U128", "U256", "Bool", "MoveString", "deserializer", "cls", "length", "i", "_Serialized", "value", "Deserializer", "vec", "_MoveString", "fixedStringBytes", "MoveOption", "_MoveOption", "vector", "RotationProofChallenge", "Serializable", "args", "AccountAddress", "MoveString", "U64", "MoveVector", "serializer", "ChainId", "_ChainId", "Serializable", "chainId", "serializer", "deserializer", "Identifier", "_Identifier", "Serializable", "identifier", "serializer", "deserializer", "validateFeePayerDataOnSubmission", "config", "args", "ValidateFeePayerDataOnSimulation", "target", "propertyKey", "descriptor", "originalMethod", "TokenActivitiesFieldsFragmentDoc", "AnsTokenFragmentFragmentDoc", "CurrentTokenOwnershipFieldsFragmentDoc", "GetAccountAddressesForAuthKey", "GetAccountCoinsCount", "GetAccountCoinsData", "GetAccountCollectionsWithOwnedTokens", "GetAccountOwnedTokens", "GetAccountOwnedTokensByTokenData", "GetAccountOwnedTokensFromCollection", "GetAccountTokensCount", "GetAccountTransactionsCount", "GetAuthKeysForPublicKey", "GetChainTopUserTransactions", "GetCollectionData", "GetCurrentFungibleAssetBalances", "GetDelegatedStakingActivities", "GetEvents", "GetFungibleAssetActivities", "GetFungibleAssetMetadata", "GetNames", "GetNumberOfDelegators", "GetObjectData", "GetProcessorStatus", "GetTableItemsData", "GetTableItemsMetadata", "GetTokenActivity", "GetCurrentTokenOwnership", "GetTokenData", "post", "options", "type", "originMethod", "path", "body", "acceptType", "contentType", "params", "aptosConfig", "overrides", "url", "aptosRequest", "postAptosFullNode", "postAptosIndexer", "postAptosFaucet", "modifiedAptosConfig", "postAptosPepperService", "postAptosProvingService", "getLedgerInfo", "args", "aptosConfig", "data", "getAptosFullNode", "getChainTopUserTransactions", "limit", "queryIndexer", "GetChainTopUserTransactions", "query", "originMethod", "postAptosIndexer", "getProcessorStatuses", "GetProcessorStatus", "getIndexerLastSuccessVersion", "response", "getProcessorStatus", "processorType", "getTableItem", "args", "aptosConfig", "handle", "data", "options", "postAptosFullNode", "getTableItemsData", "graphqlQuery", "GetTableItemsData", "queryIndexer", "getTableItemsMetadata", "GetTableItemsMetadata", "AptosApiType", "APTOS_COIN", "APTOS_FA", "RAW_TRANSACTION_SALT", "RAW_TRANSACTION_WITH_DATA_SALT", "ProcessorType", "FIREBASE_AUTH_ISS_PATTERN", "getTransactions", "args", "aptosConfig", "options", "paginateWithCursor", "getGasPriceEstimation", "memoizeAsync", "data", "getAptosFullNode", "getTransactionByVersion", "ledgerVersion", "getTransactionByHash", "transactionHash", "isTransactionPending", "e", "longWaitForTransaction", "waitForTransaction", "timeoutSecs", "checkSuccess", "isPending", "timeElapsed", "lastTxn", "lastError", "backoffIntervalMs", "backoffMultiplier", "handleAPIError", "AptosApiError", "startTime", "sleep", "WaitForTransactionError", "FailedTransactionError", "waitForIndexer", "processorType", "minimumLedgerVersion", "timeoutMilliseconds", "indexerVersion", "getIndexerLastSuccessVersion", "getProcessorStatus", "message", "lastSubmittedTransaction", "transaction", "getBlockByVersion", "block", "fillBlockTransactions", "getBlockByHeight", "blockHeight", "firstVersion", "lastVersion", "curVersion", "latestVersion", "fetchFutures", "pageSize", "i", "responses", "txns", "waitForIndexerOnVersion", "args", "waitForIndexer", "Table", "config", "args", "getTableItem", "waitForIndexerOnVersion", "getTableItemsData", "getTableItemsMetadata", "normalizeBundle", "cls", "value", "serializedBytes", "deserializer", "Deserializer", "NetworkToIndexerAPI", "NetworkToNodeAPI", "NetworkToFaucetAPI", "NetworkToPepperAPI", "NetworkToProverAPI", "Network", "NetworkToChainId", "_a", "AptosConfig", "settings", "aptosClient", "apiType", "NetworkToNodeAPI", "NetworkToFaucetAPI", "NetworkToIndexerAPI", "NetworkToPepperAPI", "NetworkToProverAPI", "url", "ignore", "FixedBytes", "_FixedBytes", "Serializable", "value", "Hex", "serializer", "deserializer", "length", "bytes", "EntryFunctionBytes", "_EntryFunctionBytes", "Serializable", "value", "FixedBytes", "serializer", "deserializer", "length", "fixedBytes", "MimeType", "TypeTagVariants", "ScriptTransactionArgumentVariants", "TransactionPayloadVariants", "TransactionInnerPayloadVariants", "TransactionExecutableVariants", "TransactionExtraConfigVariants", "TransactionVariants", "TransactionAuthenticatorVariant", "AccountAuthenticatorVariant", "PrivateKeyVariants", "AnyPublicKeyVariant", "anyPublicKeyVariantToString", "variant", "AnySignatureVariant", "EphemeralPublicKeyVariant", "EphemeralSignatureVariant", "EphemeralCertificateVariant", "ZkpVariant", "TransactionResponseType", "MoveFunctionVisibility", "MoveAbility", "RoleType", "SigningScheme", "SigningSchemeInput", "DeriveScheme", "FederatedKeylessPublicKey", "_FederatedKeylessPublicKey", "AccountPublicKey", "jwkAddress", "keylessPublicKey", "AccountAddress", "serializer", "Serializer", "AuthenticationKey", "args", "verifyKeylessSignatureWithJwkAndConfig", "deserializer", "KeylessPublicKey", "publicKey", "verifyKeylessSignature", "AnyPublicKey", "_AnyPublicKey", "Ed25519PublicKey", "Secp256k1PublicKey", "message", "signature", "AnySignature", "variantIndex", "_AnySignature", "Signature", "Ed25519Signature", "Secp256k1Signature", "KeylessSignature", "bitCount", "byte", "n", "MAX_NUM_KEYLESS_PUBLIC_FOR_MULTI_KEY", "AbstractMultiKey", "bits", "firstBitInByte", "bitmap", "dupCheckSet", "bit", "idx", "byteOffset", "index", "pk", "MultiKey", "_MultiKey", "publicKeys", "signaturesRequired", "signerIndices", "i", "singleSignature", "MultiKeySignature", "error", "keys", "anyPublicKey", "value", "_MultiKeySignature", "signatures", "nSignatures", "acc", "_MultiEd25519PublicKey", "threshold", "MultiEd25519Signature", "indices", "j", "bytes", "k", "begin", "length", "MultiEd25519PublicKey", "_MultiEd25519Signature", "AccountAuthenticator", "Serializable", "deserializer", "index", "AccountAuthenticatorEd25519", "AccountAuthenticatorMultiEd25519", "AccountAuthenticatorSingleKey", "AccountAuthenticatorMultiKey", "AccountAuthenticatorNoAccountAuthenticator", "AccountAuthenticatorAbstraction", "_AccountAuthenticatorEd25519", "public_key", "signature", "serializer", "Ed25519PublicKey", "Ed25519Signature", "_AccountAuthenticatorMultiEd25519", "MultiEd25519PublicKey", "MultiEd25519Signature", "_AccountAuthenticatorSingleKey", "AnyPublicKey", "AnySignature", "_AccountAuthenticatorMultiKey", "public_keys", "signatures", "MultiKey", "MultiKeySignature", "_AccountAuthenticatorNoAccountAuthenticator", "_AccountAuthenticatorAbstraction", "functionInfo", "signingMessageDigest", "authenticator", "accountIdentity", "isValidFunctionInfo", "Hex", "moduleAddress", "moduleName", "functionName", "getFunctionParts", "AccountAddress", "variant", "abstractSignature", "abstractPublicKey", "ModuleId", "_ModuleId", "address", "name", "moduleId", "parts", "Identifier", "TypeTag", "_TypeTag", "typeArgs", "StructTag", "TypeTagBool", "TypeTagU8", "TypeTagU64", "TypeTagU128", "TypeTagAddress", "TypeTagSigner", "TypeTagVector", "TypeTagStruct", "TypeTagU16", "TypeTagU32", "TypeTagU256", "TypeTagGeneric", "_TypeTagBool", "_deserializer", "_TypeTagU8", "_TypeTagU16", "_TypeTagU32", "_TypeTagU64", "_TypeTagU128", "_TypeTagU256", "_TypeTagAddress", "_TypeTagSigner", "TypeTagReference", "_TypeTagReference", "value", "_TypeTagGeneric", "_TypeTagVector", "_TypeTagStruct", "typePredicate", "typeArg", "structName", "_StructTag", "module_name", "type_args", "stringStructTag", "StructTag", "AccountAddress", "Identifier", "objectStructTag", "typeArg", "StructTag", "AccountAddress", "Identifier", "deserializeFromScriptArgument", "deserializer", "index", "U8", "U64", "U128", "MoveVector", "Bool", "U16", "U32", "U256", "Serialized", "TransactionPayload", "Serializable", "TransactionPayloadScript", "TransactionPayloadEntryFunction", "TransactionPayloadMultiSig", "TransactionInnerPayload", "_TransactionPayloadScript", "script", "serializer", "Script", "_TransactionPayloadEntryFunction", "entryFunction", "EntryFunction", "_TransactionPayloadMultiSig", "multiSig", "value", "MultiSig", "_EntryFunction", "module_name", "function_name", "type_args", "args", "module_id", "ModuleId", "item", "TypeTag", "length", "i", "fixedBytesLength", "fixedBytes", "EntryFunctionBytes", "_Script", "bytecode", "scriptArgument", "_MultiSig", "multisig_address", "transaction_payload", "payloadPresent", "MultiSigTransactionPayload", "_MultiSigTransactionPayload", "TransactionInnerPayloadV1", "_TransactionInnerPayloadV1", "executable", "extra_config", "TransactionExecutable", "TransactionExtraConfig", "TransactionExecutableScript", "TransactionExecutableEntryFunction", "TransactionExecutableEmpty", "_TransactionExecutableScript", "_TransactionExecutableEntryFunction", "_TransactionExecutableEmpty", "_", "TransactionExtraConfigV1", "_TransactionExtraConfigV1", "multisigAddress", "replayProtectionNonce", "RawTransaction", "_RawTransaction", "sender", "sequence_number", "payload", "max_gas_amount", "gas_unit_price", "expiration_timestamp_secs", "chain_id", "ChainId", "RawTransactionWithData", "MultiAgentRawTransaction", "FeePayerRawTransaction", "_MultiAgentRawTransaction", "raw_txn", "secondary_signer_addresses", "rawTxn", "secondarySignerAddresses", "_FeePayerRawTransaction", "fee_payer_address", "feePayerAddress", "TransactionAuthenticator", "TransactionAuthenticatorEd25519", "TransactionAuthenticatorMultiEd25519", "TransactionAuthenticatorMultiAgent", "TransactionAuthenticatorFeePayer", "TransactionAuthenticatorSingleSender", "_TransactionAuthenticatorEd25519", "public_key", "signature", "Ed25519PublicKey", "Ed25519Signature", "_TransactionAuthenticatorMultiEd25519", "MultiEd25519PublicKey", "MultiEd25519Signature", "_TransactionAuthenticatorMultiAgent", "secondary_signers", "AccountAuthenticator", "_TransactionAuthenticatorFeePayer", "fee_payer", "address", "authenticator", "_TransactionAuthenticatorSingleSender", "SignedTransaction", "_SignedTransaction", "SimpleTransaction", "_SimpleTransaction", "rawTransaction", "feePayerPresent", "MultiAgentTransaction", "_MultiAgentTransaction", "deriveTransactionType", "transaction", "generateSigningMessage", "bytes", "domainSeparator", "hash", "sha3Hash", "prefix", "body", "mergedArray", "generateSigningMessageForTransaction", "transaction", "rawTxn", "deriveTransactionType", "generateSigningMessage", "RAW_TRANSACTION_WITH_DATA_SALT", "RAW_TRANSACTION_SALT", "Ed25519Account", "_Ed25519Account", "args", "privateKey", "address", "AccountAddress", "Ed25519PrivateKey", "path", "mnemonic", "message", "AccountAuthenticatorEd25519", "isSingleKeySigner", "obj", "SingleKeyAccount", "_SingleKeyAccount", "AnyPublicKey", "scheme", "Secp256k1PrivateKey", "AccountAuthenticatorSingleKey", "AnySignature", "account", "Account", "legacy", "publicKey", "TWO_WEEKS_IN_SECONDS", "_EphemeralKeyPair", "Serializable", "expiryDateSecs", "blinder", "EphemeralPublicKey", "floorToWholeHour", "nowInSeconds", "Hex", "generateBlinder", "fields", "padAndPackBytesWithLen", "bytesToBigIntLE", "nonceHash", "poseidonHash", "serializer", "deserializer", "variantIndex", "bytes", "Deserializer", "data", "EphemeralSignature", "EphemeralKeyPair", "randomBytes", "isKeylessSigner", "_AbstractKeylessAccount", "ephemeralKeyPair", "uidKey", "uidVal", "aud", "pepper", "proof", "proofFetchCallback", "jwt", "verificationKeyHash", "EventEmitter", "ZeroKnowledgeSig", "status", "pepperBytes", "promise", "error", "signature", "aptosConfig", "KeylessError", "header", "jwtDecode", "verificationKey", "getKeylessConfig", "ephemeralPublicKey", "ephemeralSignature", "KeylessSignature", "base64UrlDecode", "EphemeralCertificate", "raw", "signMess", "TransactionAndProof", "fetchJWK", "AbstractKeylessAccount", "KeylessAccount", "_KeylessAccount", "KeylessPublicKey", "iss", "getIssAudAndUidVal", "FederatedKeylessAccount", "_FederatedKeylessAccount", "FederatedKeylessPublicKey", "jwkAddress", "MultiKeyAccount", "_MultiKeyAccount", "multiKey", "signers", "signer", "bitPositions", "signersAndBitPosition", "index", "a", "b", "value", "publicKeys", "signaturesRequired", "MultiKey", "AccountAuthenticatorMultiKey", "promises", "signatures", "MultiKeySignature", "MultiEd25519Account", "AccountAuthenticatorMultiEd25519", "MultiEd25519Signature", "deserializeSchemeAndAddress", "signingScheme", "SigningScheme", "serializeKeylessAccountCommon", "deserializeKeylessAccountCommon", "AccountUtils", "toBytes", "Serializer", "anyPublicKey", "federatedKeylessAccount", "multiKeyAccount", "toHexStringWithoutPrefix", "toHexString", "deserialize", "keylessComponents", "jwtClaims", "audless", "length", "i", "keylessAccountFromHex", "hex", "fromHex", "federatedKeylessAccountFromHex", "multiKeyAccountFromHex", "singleKeyAccountFromHex", "ed25519AccountFromHex", "fromBytes", "AbstractedAccount", "_AbstractedAccount", "accountAddress", "authenticationFunction", "isValidFunctionInfo", "AbstractPublicKey", "digest", "AbstractSignature", "AccountAuthenticatorAbstraction", "sha3_256", "_DerivableAbstractedAccount", "abstractPublicKey", "daaAccountAddress", "functionInfo", "accountIdentifier", "moduleAddress", "moduleName", "functionName", "hash", "s2", "isValidIdentifier", "str", "isValidWhitespaceCharacter", "char", "isGeneric", "isRef", "isPrimitive", "consumeWhitespace", "tagStr", "pos", "i", "innerChar", "TypeTagParserErrorType", "TypeTagParserError", "typeTagStr", "invalidReason", "parseTypeTag", "typeStr", "options", "allowGenerics", "saved", "innerTypes", "curTypes", "cur", "currentStr", "expectedTypes", "newType", "parseTypeTagInner", "savedPop", "savedStr", "savedTypes", "savedExpectedTypes", "parsedTypeTag", "nextChar", "types", "trimmedStr", "lowerCaseTrimmed", "TypeTagSigner", "TypeTagBool", "TypeTagAddress", "TypeTagU8", "TypeTagU16", "TypeTagU32", "TypeTagU64", "TypeTagU128", "TypeTagU256", "TypeTagVector", "actualType", "TypeTagReference", "TypeTagGeneric", "structParts", "address", "AccountAddress", "TypeTagStruct", "StructTag", "Identifier", "isBool", "arg", "isString", "isNumber", "convertNumber", "isLargeNumber", "isEmptyOption", "isEncodedEntryFunctionArgument", "isBcsBool", "isBcsU8", "isBcsU16", "isBcsU32", "isBcsU64", "isBcsU128", "isBcsU256", "isBcsAddress", "isBcsString", "isBcsFixedBytes", "MoveVector", "MoveOption", "Bool", "MoveString", "FixedBytes", "U8", "U16", "U32", "U64", "U128", "U256", "isScriptDataInput", "throwTypeMismatch", "expectedType", "position", "findFirstNonSignerArg", "functionAbi", "index", "param", "TEXT_ENCODER", "standardizeTypeTags", "typeArguments", "typeArg", "fetchModuleAbi", "moduleAddress", "moduleName", "aptosConfig", "getModule", "fetchFunctionAbi", "functionName", "moduleAbi", "func", "fetchEntryFunctionAbi", "moduleAddress", "moduleName", "functionName", "aptosConfig", "functionAbi", "fetchFunctionAbi", "numSigners", "findFirstNonSignerArg", "params", "i", "parseTypeTag", "fetchViewFunctionAbi", "returnTypes", "convertArgument", "functionAbiOrModuleAbi", "arg", "position", "genericTypeParams", "options", "param", "func", "checkOrConvertArgument", "moduleAbi", "isEncodedEntryFunctionArgument", "checkType", "parseArg", "isBool", "Bool", "isString", "throwTypeMismatch", "AccountAddress", "num", "convertNumber", "U8", "U16", "U32", "isLargeNumber", "U64", "U128", "U256", "genericIndex", "MoveVector", "TEXT_ENCODER", "item", "MoveString", "FixedBytes", "isEmptyOption", "innerParam", "TypeTagBool", "MoveOption", "TypeTagAddress", "TypeTagU8", "TypeTagU16", "TypeTagU32", "TypeTagU64", "TypeTagU128", "TypeTagU256", "s", "isBcsBool", "isBcsAddress", "isBcsU8", "isBcsU16", "isBcsU32", "isBcsU64", "isBcsU128", "isBcsU256", "TypeTagStruct", "isBcsString", "generateTransactionPayload", "args", "isScriptDataInput", "generateTransactionPayloadScript", "getFunctionParts", "fetchAbi", "generateTransactionPayloadWithABI", "typeArguments", "standardizeTypeTags", "functionArguments", "entryFunctionPayload", "EntryFunction", "multisigAddress", "TransactionPayloadMultiSig", "MultiSig", "MultiSigTransactionPayload", "TransactionPayloadEntryFunction", "generateViewFunctionPayload", "generateViewFunctionPayloadWithABI", "TransactionPayloadScript", "Script", "Hex", "generateRawTransaction", "sender", "payload", "feePayerAddress", "getChainId", "NetworkToChainId", "getLedgerInfo", "getGasUnitPrice", "getGasPriceEstimation", "getSequenceNumberForAny", "getSequenceNumber", "getInfo", "chainId", "gasEstimate", "sequenceNumber", "maxGasAmount", "gasUnitPrice", "expireTimestamp", "replayProtectionNonce", "txnPayload", "convertPayloadToInnerPayload", "RawTransaction", "ChainId", "TransactionInnerPayloadV1", "TransactionExecutableScript", "TransactionExtraConfigV1", "TransactionExecutableEntryFunction", "innerPayload", "executable", "TransactionExecutableEmpty", "buildTransaction", "rawTxn", "signers", "signer", "MultiAgentTransaction", "SimpleTransaction", "generateSignedTransactionForSimulation", "signerPublicKey", "transaction", "secondarySignersPublicKeys", "feePayerPublicKey", "accountAuthenticator", "getAuthenticatorForSimulation", "transactionToSign", "FeePayerRawTransaction", "secondaryAccountAuthenticators", "publicKey", "feePayerAuthenticator", "transactionAuthenticator", "TransactionAuthenticatorFeePayer", "SignedTransaction", "MultiAgentRawTransaction", "TransactionAuthenticatorMultiAgent", "AccountAuthenticatorEd25519", "TransactionAuthenticatorEd25519", "AccountAuthenticatorSingleKey", "AccountAuthenticatorMultiKey", "TransactionAuthenticatorSingleSender", "AccountAuthenticatorNoAccountAuthenticator", "accountPublicKey", "KeylessPublicKey", "FederatedKeylessPublicKey", "Secp256k1PublicKey", "AnyPublicKey", "invalidSignature", "Ed25519Signature", "Ed25519PublicKey", "AnySignature", "KeylessSignature", "MultiKey", "MultiKeySignature", "pubKey", "_", "generateSignedTransaction", "additionalSignersAuthenticators", "senderAuthenticator", "normalizeBundle", "AccountAuthenticator", "txnAuthenticator", "AccountAuthenticatorMultiEd25519", "TransactionAuthenticatorMultiEd25519", "hashValues", "input", "hash", "sha3Hash", "TRANSACTION_PREFIX", "fetchAbi", "key", "moduleAddress", "moduleName", "functionName", "aptosConfig", "abi", "fetch", "memoizeAsync", "generateTransaction", "args", "payload", "buildTransactionPayload", "buildRawTransaction", "data", "generateTransactionPayloadData", "generateTransactionPayload", "sender", "options", "feePayerAddress", "isFeePayerTransactionInput", "AccountAddress", "isMultiAgentTransactionInput", "secondarySignerAddresses", "buildTransaction", "getSigningMessage", "transaction", "generateSigningMessageForTransaction", "signTransaction", "signer", "signAsFeePayer", "simulateTransaction", "signerPublicKey", "secondarySignersPublicKeys", "feePayerPublicKey", "signedTransaction", "generateSignedTransactionForSimulation", "postAptosFullNode", "submitTransaction", "transactionSubmitter", "maybeTransactionSubmitter", "generateSignedTransaction", "e", "signedTxn", "SignedTransaction", "Deserializer", "KeylessPublicKey", "FederatedKeylessPublicKey", "AbstractKeylessAccount", "signAndSubmitTransaction", "feePayer", "rest", "isKeylessSigner", "feePayerAuthenticator", "senderAuthenticator", "signAndSubmitAsFeePayer", "packagePublishAbi", "TypeTagVector", "publicPackageTransaction", "account", "metadataBytes", "moduleBytecode", "totalByteCode", "bytecode", "MoveVector", "getInfo", "getModules", "accountAddress", "paginateWithObfuscatedCursor", "getModulesPage", "response", "cursor", "getPageWithObfuscatedCursor", "getModule", "getTransactions", "paginateWithCursor", "getResources", "getResourcesPage", "getResource", "resourceType", "getAptosFullNode", "lookupOriginalAccountAddress", "authenticationKey", "resource", "handle", "authKeyAddress", "originalAddress", "getTableItem", "err", "AptosApiError", "getAccountTokensCount", "whereCondition", "queryIndexer", "GetAccountTokensCount", "getAccountOwnedTokens", "graphqlQuery", "GetAccountOwnedTokens", "getAccountOwnedTokensFromCollectionAddress", "collectionAddress", "ownerAddress", "collAddress", "GetAccountOwnedTokensFromCollection", "getAccountCollectionsWithOwnedTokens", "GetAccountCollectionsWithOwnedTokens", "getAccountTransactionsCount", "address", "GetAccountTransactionsCount", "getAccountCoinsData", "args", "aptosConfig", "accountAddress", "options", "address", "AccountAddress", "whereCondition", "graphqlQuery", "GetAccountCoinsData", "queryIndexer", "getAccountCoinsCount", "data", "GetAccountCoinsCount", "getAccountOwnedObjects", "GetObjectData", "deriveAccountFromPrivateKey", "privateKey", "throwIfNoAccountFound", "accounts", "deriveOwnedAccountsFromPrivateKey", "Account", "doesAccountExistAtAddress", "args", "aptosConfig", "accountAddress", "options", "resources", "ownedObjects", "getResources", "getAccountOwnedObjects", "accountResource", "r", "authKey", "error", "rotateAuthKeyAbi", "TypeTagU8", "TypeTagVector", "rotateAuthKey", "fromAccount", "dangerouslySkipVerification", "rotateAuthKeyWithChallenge", "Ed25519Account", "MultiEd25519Account", "pendingTxn", "rotateAuthKeyUnverified", "rotateAuthKeyTxnResponse", "waitForTransaction", "verificationTxn", "generateTransaction", "signAndSubmitTransaction", "accountInfo", "getInfo", "newAccount", "Account", "challengeHex", "RotationProofChallenge", "AccountAddress", "proofSignedByCurrentKey", "proofSignedByNewKey", "rawTxn", "U8", "MoveVector", "rotateAuthKeyUnverifiedAbi", "toAuthKey", "getAccountsForPublicKey", "publicKey", "noMultiKey", "AbstractMultiKey", "allPublicKeys", "AnyPublicKey", "Ed25519PublicKey", "defaultAccountData", "multiPublicKeys", "addressAndLastTxnVersion", "getDefaultAccountInfoForPublicKey", "getMultiKeysForPublicKey", "result", "data", "authKeyToPublicKey", "key", "authKeyAccountAddressPairs", "getAccountAddressesForAuthKeys", "authKeyAccountAddressPair", "a", "b", "deriveOwnedAccountsFromSigner", "signer", "Ed25519PrivateKey", "Secp256k1PrivateKey", "deriveOwnedAccountsFromPrivateKey", "SingleKeyAccount", "KeylessAccount", "FederatedKeylessAccount", "deriveOwnedAccountsFromKeylessSigner", "MultiKeyAccount", "keylessAccount", "addressesAndPublicKeys", "keylessAccountParams", "accounts", "MultiEd25519PublicKey", "MultiKey", "privateKey", "singleKeyAccount", "isLegacy", "includeUnverified", "anyPublicKey", "baseKey", "variant", "anyPublicKeyVariantToString", "whereCondition", "graphqlQuery", "GetAuthKeysForPublicKey", "queryIndexer", "entry", "Deserializer", "authKeys", "GetAccountAddressesForAuthKey", "AuthenticationKey", "Hex", "getLatestTransactionVersionForAddress", "transactions", "getTransactions", "derivedAddress", "lastTransactionVersion", "exists", "view", "payload", "viewFunctionPayload", "generateViewFunctionPayload", "serializer", "Serializer", "bytes", "postAptosFullNode", "viewJson", "addAuthenticationFunctionTransaction", "sender", "authenticationFunction", "moduleAddress", "moduleName", "functionName", "getFunctionParts", "TypeTagAddress", "TypeTagStruct", "stringStructTag", "removeAuthenticationFunctionTransaction", "removeDispatchableAuthenticatorTransaction", "AccountAbstraction", "config", "functionInfos", "functionInfo", "functionInfoOption", "getModules", "getModulesPage", "getModule", "getResourcesPage", "getResource", "lookupOriginalAccountAddress", "waitForIndexerOnVersion", "getAccountTokensCount", "getAccountOwnedTokens", "getAccountOwnedTokensFromCollectionAddress", "getAccountCollectionsWithOwnedTokens", "getAccountTransactionsCount", "getAccountCoinsData", "getAccountCoinsCount", "APTOS_COIN", "APTOS_FA", "coinType", "faMetadataAddress", "minimumLedgerVersion", "coinAssetType", "memoizeAsync", "pairedCoinTypeStruct", "isEncodedStruct", "parseEncodedStruct", "faAddress", "createObjectAddress", "addr", "balanceStr", "deriveAccountFromPrivateKey", "coinTransferAbi", "TypeTagU64", "transferCoinTransaction", "recipient", "amount", "Coin", "PropertyTypeMap", "defaultDigitalAssetType", "getDigitalAssetData", "digitalAssetAddress", "GetTokenData", "getCurrentDigitalAssetOwnership", "GetCurrentTokenOwnership", "getOwnedDigitalAssets", "ownerAddress", "getDigitalAssetActivity", "GetTokenActivity", "createCollectionAbi", "TypeTagBool", "createCollectionTransaction", "creator", "MoveString", "U64", "MAX_U64_BIG_INT", "Bool", "getCollectionData", "GetCollectionData", "getCollectionDataByCreatorAddressAndCollectionName", "creatorAddress", "collectionName", "address", "getCollectionDataByCreatorAddress", "getCollectionDataByCollectionId", "collectionId", "getCollectionId", "mintDigitalAssetAbi", "mintDigitalAssetTransaction", "collection", "description", "name", "uri", "propertyKeys", "propertyTypes", "propertyValues", "convertedPropertyType", "type", "getPropertyValueRaw", "transferDigitalAssetAbi", "objectStructTag", "TypeTagGeneric", "transferDigitalAssetTransaction", "digitalAssetType", "mintSoulBoundAbi", "mintSoulBoundTransaction", "account", "burnDigitalAssetAbi", "burnDigitalAssetTransaction", "freezeDigitalAssetAbi", "freezeDigitalAssetTransferTransaction", "unfreezeDigitalAssetAbi", "unfreezeDigitalAssetTransferTransaction", "setDigitalAssetDescriptionAbi", "setDigitalAssetDescriptionTransaction", "setDigitalAssetNameAbi", "setDigitalAssetNameTransaction", "setDigitalAssetURIAbi", "setDigitalAssetURITransaction", "addDigitalAssetPropertyAbi", "addDigitalAssetPropertyTransaction", "propertyKey", "propertyType", "propertyValue", "getSinglePropertyValueRaw", "removeDigitalAssetPropertyAbi", "removeDigitalAssetPropertyTransaction", "updateDigitalAssetPropertyAbi", "updateDigitalAssetPropertyTransaction", "addDigitalAssetTypedPropertyAbi", "addDigitalAssetTypedPropertyTransaction", "updateDigitalAssetTypedPropertyAbi", "updateDigitalAssetTypedPropertyTransaction", "results", "typ", "index", "typeTag", "parseTypeTag", "checkOrConvertArgument", "DigitalAsset", "MAX_EVENT_TYPE_LENGTH", "checkEventTypeLength", "eventType", "getModuleEventsByEventType", "getEvents", "getAccountEventsByCreationNumber", "creationNumber", "getAccountEventsByEventType", "GetEvents", "Event", "fundAccount", "timeout", "postAptosFaucet", "txnHash", "res", "Faucet", "fundTxn", "waitForIndexer", "getFungibleAssetMetadata", "GetFungibleAssetMetadata", "getFungibleAssetActivities", "GetFungibleAssetActivities", "getCurrentFungibleAssetBalances", "GetCurrentFungibleAssetBalances", "faTransferAbi", "transferFungibleAsset", "fungibleAssetMetadataAddress", "transferFungibleAssetBetweenStores", "fromStore", "toStore", "FungibleAsset", "General", "getLedgerInfo", "getBlockByVersion", "getBlockByHeight", "getChainTopUserTransactions", "getIndexerLastSuccessVersion", "processorType", "getProcessorStatus", "VALIDATION_RULES_DESCRIPTION", "isValidANSSegment", "fragment", "isValidANSName", "first", "second", "rest", "SubdomainExpirationPolicy", "isActiveANSName", "isTLDExpired", "isExpired", "LOCAL_ANS_ACCOUNT_ADDRESS", "NetworkToAnsContract", "getRouterAddress", "aptosConfig", "address", "unwrapOption", "option", "getOwnerAddress", "args", "name", "routerAddress", "domainName", "subdomainName", "isValidANSName", "res", "view", "owner", "AccountAddress", "registerName", "expiration", "sender", "targetAddress", "toAddress", "options", "transferable", "hasSubdomainPolicy", "years", "registrationDuration", "generateTransaction", "tldExpiration", "getExpiration", "expirationDateInMillisecondsSinceEpoch", "getPrimaryName", "setPrimaryName", "getTargetAddress", "target", "setTargetAddress", "getName", "queryIndexer", "GetNames", "sanitizeANSName", "isActiveANSName", "getAccountNames", "accountAddress", "expirationDate", "getANSExpirationDate", "getAccountDomains", "getAccountSubdomains", "getDomainSubdomains", "domain", "gracePeriodInSeconds", "gracePeriodInDays", "now", "renewDomain", "renewalDuration", "ANS", "config", "getNumberOfDelegators", "poolAddress", "data", "GetNumberOfDelegators", "getNumberOfDelegatorsForAllPools", "query", "getDelegatedStakingActivities", "delegatorAddress", "GetDelegatedStakingActivities", "Staking", "waitForIndexerOnVersion", "Build", "Simulate", "simulateTransaction", "__decorateClass", "ValidateFeePayerDataOnSimulation", "Submit", "validateFeePayerDataOnSubmission", "submitTransaction", "AccountSequenceNumber", "account", "maxWaitTime", "maximumInFlight", "sleepTime", "sleep", "nextNumber", "startTime", "nowInSeconds", "e", "sequenceNumber", "getInfo", "promiseFulfilledStatus", "TransactionWorkerEventsEnum", "TransactionWorker", "EventEmitter", "AsyncQueue", "transaction", "pendingTransaction", "signAndSubmitTransaction", "error", "AsyncQueueCancelledError", "awaitingTransactions", "sequenceNumbers", "sentTransactions", "i", "sentTransaction", "waitFor", "waitForTransaction", "executedTransaction", "transactionData", "TransactionManagement", "d", "Transaction", "getTransactions", "getTransactionByVersion", "getTransactionByHash", "isTransactionPending", "getGasPriceEstimation", "getSigningMessage", "publicPackageTransaction", "rotateAuthKey", "signTransaction", "signAsFeePayer", "signAndSubmitAsFeePayer", "getPepper", "jwt", "ephemeralKeyPair", "uidKey", "derivationPath", "body", "Hex", "postAptosPepperService", "getProof", "pepper", "maxExpHorizonSecs", "getKeylessConfig", "KeylessAccount", "decodedJwt", "jwtDecode", "json", "postAptosProvingService", "proofPoints", "groth16Zkp", "Groth16Zkp", "ZeroKnowledgeSig", "ZkProof", "EphemeralSignature", "deriveKeylessAccount", "jwkAddress", "proofFetchCallback", "verificationKey", "proofPromise", "proof", "publicKey", "FederatedKeylessPublicKey", "lookupOriginalAccountAddress", "FederatedKeylessAccount", "KeylessPublicKey", "updateFederatedKeylessJwkSetTransaction", "iss", "jwksUrl", "FIREBASE_AUTH_ISS_PATTERN", "response", "errorMessage", "KeylessError", "jwks", "MoveVector", "key", "Keyless", "getObjectData", "graphqlQuery", "GetObjectData", "getObjectDataByObjectAddress", "objectAddress", "whereCondition", "AptosObject", "Aptos", "AptosConfig", "Account", "AccountAbstraction", "Coin", "DigitalAsset", "Event", "Faucet", "FungibleAsset", "General", "Table", "ignore", "applyMixin", "targetClass", "baseClass", "baseClassProp", "propertyName", "propertyDescriptor", "EPK_HORIZON_SECS", "MAX_AUD_VAL_BYTES", "MAX_UID_KEY_BYTES", "MAX_UID_VAL_BYTES", "MAX_ISS_VAL_BYTES", "MAX_EXTRA_FIELD_BYTES", "MAX_JWT_HEADER_B64_BYTES", "MAX_COMMITED_EPK_BYTES", "_KeylessPublicKey", "AccountPublicKey", "idCommitment", "idcBytes", "serializer", "Serializer", "AuthenticationKey", "verifyKeylessSignatureWithJwkAndConfig", "verifyKeylessSignature", "deserializer", "addressSeed", "computeIdCommitment", "jwtPayload", "uidVal", "message", "signature", "jwk", "keylessConfig", "KeylessSignature", "fetchJWK", "trainingWheelsPubkey", "zkSig", "groth16Proof", "publicInputsHash", "getPublicInputsHash", "proofAndStatement", "Groth16ProofAndStatement", "innerKeylessPublicKey", "fields", "padAndPackBytesWithLen", "bytesToBigIntLE", "hashStrToField", "encode", "poseidonHash", "kid", "keylessPubKey", "allJWKs", "jwkAddr", "getKeylessJWKs", "jwksForIssuer", "aud", "bigIntToBytesLE", "_KeylessSignature", "Signature", "jwtHeader", "ephemeralCertificate", "expiryDateSecs", "ephemeralPublicKey", "ephemeralSignature", "parseJwtHeader", "EphemeralCertificate", "EphemeralPublicKey", "Ed25519PublicKey", "Ed25519Signature", "_EphemeralCertificate", "variant", "_G1Bytes", "Serializable", "bytes", "point", "yFlag", "Fp", "bn254", "x", "bytesToBn254FpBE", "y", "negY", "yToUse", "G1Bytes", "result", "bytesToNumberBE", "_G2Bytes", "x0", "x1", "Fp2", "G2Bytes", "_Groth16Zkp", "Proof", "a", "b", "c", "_Groth16ProofAndStatement", "generateSigningMessage", "_ZkProof", "_ZeroKnowledgeSig", "expHorizonSecs", "trainingWheelsSignature", "extraField", "overrideAudVal", "Deserializer", "KeylessConfiguration", "_KeylessConfiguration", "maxExtraFieldBytes", "maxJwtHeaderB64Bytes", "maxIssValBytes", "maxCommitedEpkBytes", "Groth16VerificationKey", "_Groth16VerificationKey", "alphaG1", "betaG2", "deltaG2", "gammaAbcG1", "gammaG2", "sha3_256", "proofA", "proofB", "proofC", "vkAlpha1", "vkBeta2", "vkGamma2", "vkDelta2", "vkIC", "g1", "Fp12", "accum", "pairingAccumGamma", "pairingAB", "pairingAlphaBeta", "pairingCDelta", "product", "memoizeAsync", "vk", "getKeylessConfigurationResource", "getGroth16VerificationKeyResource", "getIssAudAndUidVal", "getErrorMessage", "resourceType", "getAptosFullNode", "resource", "jwkMap", "entry", "jwkStruct", "jwkData", "MoveJWK", "hexToAsciiString", "_MoveJWK", "kty", "alg", "n", "struct", "uint8Array", "base64UrlToBytes", "scalars", "chunkInto24Bytes", "chunk", "chunks", "paddedChunk", "header", "AbstractionAuthDataVariant", "REQUIRED_FEATURES", "isWalletWithRequiredFeatureSet", "wallet", "additionalFeatures", "feature", "getAptosWallets", "get", "on", "getWallets", "wallets", "aptosWallets", "AptosWalletErrorCode", "AptosWalletErrors", "UserResponseStatus", "AptosSignAndSubmitTransactionNamespace", "AptosSignInNamespace", "AptosSignMessageNamespace", "AptosSignTransactionNamespace", "AptosConnectNamespace", "AptosDisconnectNamespace", "AptosGetAccountNamespace", "AptosGetNetworkNamespace", "AptosOnAccountChangeNamespace", "AptosOnNetworkChangeNamespace", "AccountInfo", "_AccountInfo", "Serializable", "address", "publicKey", "ansName", "AccountAddress", "serializer", "Ed25519PublicKey", "SigningScheme", "MultiEd25519PublicKey", "AnyPublicKey", "MultiKey", "deserializer", "variant", "APTOS_DEVNET_CHAIN", "APTOS_TESTNET_CHAIN", "APTOS_LOCALNET_CHAIN", "APTOS_MAINNET_CHAIN", "APTOS_CHAINS", "AptosWalletErrorCode", "AptosWalletErrors", "AptosWalletError", "_AptosWalletError", "code", "message", "UserResponseStatus", "import_tweetnacl", "AccountInfo", "_AccountInfo", "Serializable", "address", "publicKey", "ansName", "AccountAddress", "serializer", "Ed25519PublicKey", "SigningScheme", "MultiEd25519PublicKey", "AnyPublicKey", "MultiKey", "deserializer", "variant", "AptosWalletErrorCode", "AptosWalletErrors", "UserResponseStatus", "m", "AccountAddress", "EntryFunctionArgumentVariant", "i", "SigningScheme", "TransactionPayloadInputVariant", "Serializer", "Deserializer", "ConnectRequest", "d", "ConnectResponse", "DisconnectRequest", "DisconnectResponse", "SignInRequest", "_", "SignInResponse", "GetConnectedAccountsRequest", "GetConnectedAccountsResponse", "IsConnectedRequest", "IsConnectedResponse", "SignAndSubmitTransactionRequest", "SignAndSubmitTransactionResponse", "SignMessageRequest", "SignMessageResponse", "SignTransactionRequest", "TransactionPayload", "SignTransactionResponse", "AccountAuthenticator", "RawTransaction", "_PromptConnectionRequestMessage", "_PromptConnectionResponseMessage", "_PromptApprovalResponseMessage", "_PromptUnauthorizedErrorMessage", "Serializer", "AccountAddress", "KeyTypes", "nacl", "m", "x", "ed2curve", "nacl", "nacl", "e", "x", "sha3_256", "Ed25519Signature", "a", "AptosEd25519PublicKey", "AccountConnectionAction", "u", "e", "r", "n", "S", "t", "e", "w", "D", "W", "d", "A", "r", "n", "o", "a", "c", "s", "u", "P", "i", "m", "p", "E", "f", "g", "U", "O", "t", "T", "_", "e", "n", "o", "r", "a", "C", "i", "f", "b", "P", "S", "j", "m", "f", "t", "I", "i", "p", "webViewProxy", "object", "fn", "hasWebviewProxy", "value", "isIframe", "d", "e", "t", "n", "F", "r", "e", "d", "m", "R", "$", "S", "U", "m", "S", "V", "R", "B", "$", "q", "r", "e", "t", "n", "o", "s", "u", "c", "a", "y", "e", "c", "S", "g", "u", "s", "i", "t", "l", "o", "f", "d", "n", "a", "h", "p", "j", "b", "$debug", "signal", "logInfo", "logError", "createLogger", "transformers", "object", "string", "value", "createTransformerGen", "number", "boolean", "$lastEvent", "signal", "$lastEventCleanup", "$eventSignalsCache", "signal", "ERR_UNKNOWN_ENV", "$targetOrigin", "signal", "postEvent", "eventType", "eventData", "logInfo", "w", "hasWebviewProxy", "message", "isIframe", "external", "object", "fn", "TypedError", "ERR_UNKNOWN_ENV", "i", "v", "i", "URL", "i", "x", "a", "b", "c", "d", "y", "q", "s", "t", "v3", "v4", "i", "f", "s", "x", "y", "z", "n", "K", "H", "i", "l", "N", "M", "j", "W", "t", "a", "b", "c", "d", "e", "T", "v5", "a", "i", "bytesToBase64", "bytesToBase64url", "base64ToBytes", "pe", "ConnectResponse", "NetworkName", "PairingStatus", "SigningRequestTypes", "SigningRequestStatus", "WalletOSEnum", "WalletPlatformEnum", "a", "Hex", "AccountAuthenticator", "RawTransaction", "ta", "waitFor", "i", "e", "AccountAddress", "NetworkName", "encodeBase64", "a", "AptosConfig", "e", "AccountInfo", "r", "_AptosConnectWallet", "Network", "APTOS_CHAINS", "AccountAddress", "UserResponseStatus", "s", "o", "response", "t", "n", "AptosConnectNamespace", "AptosDisconnectNamespace", "AptosGetAccountNamespace", "AptosGetNetworkNamespace", "AptosOnAccountChangeNamespace", "AptosOnNetworkChangeNamespace", "AptosSignAndSubmitTransactionNamespace", "AptosSignInNamespace", "AptosSignMessageNamespace", "AptosSignTransactionNamespace", "WALLET_ADAPTER_CORE_VERSION", "GA4", "aptosGAID", "injectGA", "gtag", "a", "b", "c", "dataLayer", "window", "push", "arguments", "gaID", "head", "document", "getElementsByTagName", "myScript", "createElement", "setAttribute", "that", "onload", "Date", "send_page_view", "insertBefore", "children", "WalletError", "message", "error", "Error", "WalletNotSelectedError", "name", "WalletNotReadyError", "WalletConnectionError", "WalletDisconnectionError", "WalletAccountError", "WalletGetNetworkError", "WalletAccountChangeError", "WalletNetworkChangeError", "WalletNotConnectedError", "WalletSignMessageError", "WalletSignMessageAndVerifyError", "WalletSignAndSubmitMessageError", "WalletSignTransactionError", "WalletNotSupportedMethod", "WalletChangeNetworkError", "WalletSubmitTransactionError", "WalletNotFoundError", "WalletReadyState", "NetworkName", "ChainIdToAnsSupportedNetworkMap", "APTOS_CONNECT_BASE_URL", "APTOS_CONNECT_ACCOUNT_URL", "isMobile", "test", "navigator", "userAgent", "isInAppBrowser", "isIphone", "isAndroid", "isRedirectable", "generalizedErrorMessage", "getAptosConfig", "networkInfo", "dappConfig", "pluginSettings", "TRANSACTION_SUBMITTER", "transactionSubmitter", "isAptosNetwork", "currentNetwork", "convertNetwork", "isAptosLiveNetwork", "apiKey", "aptosApiKeys", "AptosConfig", "network", "clientConfig", "API_KEY", "knownNetworks", "okx", "url", "isKnownNetwork", "Object", "values", "includes", "Network", "CUSTOM", "fullnode", "NetworkToNodeAPI", "fetchDevnetChainId", "aptos", "Aptos", "getChainId", "handlePublishPackageTransaction", "transactionInput", "metadataBytes", "data", "functionArguments", "Hex", "fromHexInput", "toUint8Array", "byteCode", "Array", "isArray", "map", "byte", "MAINNET", "TESTNET", "DEVNET", "LOCAL", "LOCAL_STORAGE_ITEM_KEY", "setLocalStorage", "walletName", "localStorage", "setItem", "removeLocalStorage", "removeItem", "getLocalStorage", "getItem", "partitionWallets", "wallets", "partitionFunction", "isInstalledOrLoadable", "defaultWallets", "moreWallets", "wallet", "readyState", "isInstallRequired", "isWalletReady", "truncateAddress", "address", "slice", "isAptosConnectWallet", "startsWith", "getAptosConnectWallets", "aptosConnectWallets", "otherWallets", "groupAndSortWallets", "options", "sortAptosConnectWallets", "sort", "sortAvailableWallets", "sortInstallableWallets", "availableWallets", "installableWallets", "aptosStandardSupportedWalletList", "icon", "isAIP62Standard", "deeplinkProvider", "crossChainStandardSupportedWalletList", "getSDKWallets", "sdkWallets", "AptosConnectGoogleWallet", "dappId", "aptosConnectDappId", "aptosConnect", "AptosConnectAppleWallet", "WalletCore", "EventEmitter", "optInWallets", "disableTelemetry", "_wallet", "_sdkWallets", "_standard_wallets", "_standard_not_detected_wallets", "_network", "_connected", "_connecting", "_account", "_optInWallets", "_disableTelemetry", "ga4", "_dappConfig", "fetchExtensionAIP62AptosWallets", "fetchSDKAIP62AptosWallets", "appendNotDetectedStandardSupportedWallets", "getAptosWallets", "aptosWallets", "on", "setExtensionAIP62Wallets", "removeRegisterListener", "removeUnregisterListener", "extensionwWallets", "excludeWallet", "isValid", "isWalletWithRequiredFeatureSet", "index", "findIndex", "notDetctedWallet", "splice", "alreadyExists", "some", "w", "isAptosNativeWallet", "emit", "walletRegistry", "crossChainWallets", "supportedWallet", "existingStandardWallet", "find", "length", "recordEvent", "eventName", "additionalInfo", "network_url", "adapter_core_version", "send_to", "ensureWalletExists", "ensureAccountExists", "account", "setAnsName", "aptosConfig", "chainId", "ansName", "ans", "getPrimaryName", "toString", "console", "log", "clearData", "setWallet", "setAccount", "setNetwork", "isConnected", "notDetectedWallets", "connect", "selectedWallet", "uninstalledWallet", "parameter", "ref", "location", "allDetectedWallets", "encodeURIComponent", "href", "origin", "concat", "connectWallet", "response", "features", "_state", "status", "UserResponseStatus", "REJECTED", "args", "output", "signIn", "input", "onConnect", "errMsg", "disconnect", "signAndSubmitTransaction", "shouldUseTxnSubmitter", "transaction", "signAndSubmitTransactionMethod", "signTransactionResponse", "function", "version", "build", "simple", "sender", "payload", "gasUnitPrice", "maxGasAmount", "withFeePayer", "signTransaction", "transactionOrPayload", "submitTransaction", "senderAuthenticator", "authenticator", "pluginParams", "hash", "asFeePayer", "signTransactionV1_1StandardInput", "walletSignTransactionMethod", "rawTransaction", "bcsToBytes", "expirationTimestamp", "expirationSecondsFromNow", "sequenceNumber", "accountSequenceNumber", "AccountAddress", "from", "signMessage", "additionalSignersAuthenticators", "transactionType", "multiAgentTxn", "transaction_type", "submit", "multiAgent", "onAccountChange", "onNetworkChange", "changeNetwork", "to", "NetworkToChainId", "signMessageAndVerify", "signingMessage", "TextEncoder", "encode", "fullMessage", "publicKey", "verifySignatureAsync", "signature", "throwErrorWithReason", "verifySignature", "import_react", "import_jsx_runtime", "React", "i", "Slot", "props", "Slottable", "Fragment", "import_react", "import_jsx_runtime", "import_react", "import_jsx_runtime", "setState", "walletCore", "_a", "e", "network", "wallet", "wallets", "jsx", "forwardRef", "jsxs", "createContext", "useContext", "_", "useState", "i", "Root", "useCallback", "WalletReadyState", "Slot"]
}
