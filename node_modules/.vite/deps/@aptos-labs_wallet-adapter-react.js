import {
  require_jsx_runtime
} from "./chunk-TG2L3OCW.js";
import {
  Ae,
  AxiosError,
  B,
  Dt,
  E,
  Gn,
  Gt,
  HDKey,
  O,
  Se,
  U,
  Ur,
  V,
  W,
  Wn,
  _e,
  a,
  a2,
  axios_default,
  bcs_exports,
  bn254,
  bytesToHex,
  bytesToNumberBE,
  decode,
  e,
  ed25519,
  encode,
  f,
  getWallets,
  h,
  hexToBytes,
  hmac,
  isAxiosError,
  jwtDecode,
  k,
  l,
  mnemonicToSeedSync,
  n,
  o,
  ot,
  pa,
  pe,
  qs,
  r,
  randomBytes,
  require_nacl_fast,
  require_poseidon_lite,
  s,
  secp256k1,
  sha3_256,
  sha512,
  t,
  ut,
  z
} from "./chunk-M6W3NF76.js";
import {
  eventemitter3_default
} from "./chunk-EPY2PYUF.js";
import "./chunk-5GFRP27I.js";
import {
  require_react
} from "./chunk-AFOL7T4F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i27 = 0, l14 = handlers.length, ee2 = new Array(l14); i27 < l14; i27++) {
        ee2[i27] = handlers[i27].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a24, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i27;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a24), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a24, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a24, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a24, a32, a42, a52), true;
        }
        for (i27 = 1, args = new Array(len - 1); i27 < len; i27++) {
          args[i27 - 1] = arguments[i27];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j5;
        for (i27 = 0; i27 < length; i27++) {
          if (listeners[i27].once) this.removeListener(event, listeners[i27].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i27].fn.call(listeners[i27].context);
              break;
            case 2:
              listeners[i27].fn.call(listeners[i27].context, a1);
              break;
            case 3:
              listeners[i27].fn.call(listeners[i27].context, a1, a24);
              break;
            case 4:
              listeners[i27].fn.call(listeners[i27].context, a1, a24, a32);
              break;
            default:
              if (!args) for (j5 = 1, args = new Array(len - 1); j5 < len; j5++) {
                args[j5 - 1] = arguments[j5];
              }
              listeners[i27].fn.apply(listeners[i27].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i27 = 0, events = [], length = listeners.length; i27 < length; i27++) {
          if (listeners[i27].fn !== fn2 || once && !listeners[i27].once || context && listeners[i27].context !== context) {
            events.push(listeners[i27]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module) {
    (function(root, f13) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f13(require_nacl_fast());
      else root.ed2curve = f13(root.nacl);
    })(exports, function(nacl3) {
      "use strict";
      if (!nacl3) throw new Error("tweetnacl not loaded");
      var gf = function(init) {
        var i27, r18 = new Float64Array(16);
        if (init) for (i27 = 0; i27 < init.length; i27++) r18[i27] = init[i27];
        return r18;
      };
      var gf0 = gf(), gf1 = gf([1]), D5 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I6 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o26) {
        var c7;
        var i27;
        for (i27 = 0; i27 < 16; i27++) {
          o26[i27] += 65536;
          c7 = Math.floor(o26[i27] / 65536);
          o26[(i27 + 1) * (i27 < 15 ? 1 : 0)] += c7 - 1 + 37 * (c7 - 1) * (i27 === 15 ? 1 : 0);
          o26[i27] -= c7 * 65536;
        }
      }
      function sel25519(p11, q7, b8) {
        var t18, c7 = ~(b8 - 1);
        for (var i27 = 0; i27 < 16; i27++) {
          t18 = c7 & (p11[i27] ^ q7[i27]);
          p11[i27] ^= t18;
          q7[i27] ^= t18;
        }
      }
      function unpack25519(o26, n94) {
        var i27;
        for (i27 = 0; i27 < 16; i27++) o26[i27] = n94[2 * i27] + (n94[2 * i27 + 1] << 8);
        o26[15] &= 32767;
      }
      function A15(o26, a24, b8) {
        var i27;
        for (i27 = 0; i27 < 16; i27++) o26[i27] = a24[i27] + b8[i27] | 0;
      }
      function Z2(o26, a24, b8) {
        var i27;
        for (i27 = 0; i27 < 16; i27++) o26[i27] = a24[i27] - b8[i27] | 0;
      }
      function M4(o26, a24, b8) {
        var i27, j5, t18 = new Float64Array(31);
        for (i27 = 0; i27 < 31; i27++) t18[i27] = 0;
        for (i27 = 0; i27 < 16; i27++) {
          for (j5 = 0; j5 < 16; j5++) {
            t18[i27 + j5] += a24[i27] * b8[j5];
          }
        }
        for (i27 = 0; i27 < 15; i27++) {
          t18[i27] += 38 * t18[i27 + 16];
        }
        for (i27 = 0; i27 < 16; i27++) o26[i27] = t18[i27];
        car25519(o26);
        car25519(o26);
      }
      function S4(o26, a24) {
        M4(o26, a24, a24);
      }
      function inv25519(o26, i27) {
        var c7 = gf();
        var a24;
        for (a24 = 0; a24 < 16; a24++) c7[a24] = i27[a24];
        for (a24 = 253; a24 >= 0; a24--) {
          S4(c7, c7);
          if (a24 !== 2 && a24 !== 4) M4(c7, c7, i27);
        }
        for (a24 = 0; a24 < 16; a24++) o26[a24] = c7[a24];
      }
      function pack25519(o26, n94) {
        var i27, j5, b8;
        var m13 = gf(), t18 = gf();
        for (i27 = 0; i27 < 16; i27++) t18[i27] = n94[i27];
        car25519(t18);
        car25519(t18);
        car25519(t18);
        for (j5 = 0; j5 < 2; j5++) {
          m13[0] = t18[0] - 65517;
          for (i27 = 1; i27 < 15; i27++) {
            m13[i27] = t18[i27] - 65535 - (m13[i27 - 1] >> 16 & 1);
            m13[i27 - 1] &= 65535;
          }
          m13[15] = t18[15] - 32767 - (m13[14] >> 16 & 1);
          b8 = m13[15] >> 16 & 1;
          m13[14] &= 65535;
          sel25519(t18, m13, 1 - b8);
        }
        for (i27 = 0; i27 < 16; i27++) {
          o26[2 * i27] = t18[i27] & 255;
          o26[2 * i27 + 1] = t18[i27] >> 8;
        }
      }
      function par25519(a24) {
        var d15 = new Uint8Array(32);
        pack25519(d15, a24);
        return d15[0] & 1;
      }
      function vn(x5, xi, y10, yi, n94) {
        var i27, d15 = 0;
        for (i27 = 0; i27 < n94; i27++) d15 |= x5[xi + i27] ^ y10[yi + i27];
        return (1 & d15 - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x5, xi, y10, yi) {
        return vn(x5, xi, y10, yi, 32);
      }
      function neq25519(a24, b8) {
        var c7 = new Uint8Array(32), d15 = new Uint8Array(32);
        pack25519(c7, a24);
        pack25519(d15, b8);
        return crypto_verify_32(c7, 0, d15, 0);
      }
      function pow2523(o26, i27) {
        var c7 = gf();
        var a24;
        for (a24 = 0; a24 < 16; a24++) c7[a24] = i27[a24];
        for (a24 = 250; a24 >= 0; a24--) {
          S4(c7, c7);
          if (a24 !== 1) M4(c7, c7, i27);
        }
        for (a24 = 0; a24 < 16; a24++) o26[a24] = c7[a24];
      }
      function set25519(r18, a24) {
        var i27;
        for (i27 = 0; i27 < 16; i27++) r18[i27] = a24[i27] | 0;
      }
      function unpackneg(r18, p11) {
        var t18 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r18[2], gf1);
        unpack25519(r18[1], p11);
        S4(num, r18[1]);
        M4(den, num, D5);
        Z2(num, num, r18[2]);
        A15(den, r18[2], den);
        S4(den2, den);
        S4(den4, den2);
        M4(den6, den4, den2);
        M4(t18, den6, num);
        M4(t18, t18, den);
        pow2523(t18, t18);
        M4(t18, t18, num);
        M4(t18, t18, den);
        M4(t18, t18, den);
        M4(r18[0], t18, den);
        S4(chk, r18[0]);
        M4(chk, chk, den);
        if (neq25519(chk, num)) M4(r18[0], r18[0], I6);
        S4(chk, r18[0]);
        M4(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r18[0]) === p11[31] >> 7) Z2(r18[0], gf0, r18[0]);
        M4(r18[3], r18[0], r18[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z6 = new Uint8Array(32), q7 = [gf(), gf(), gf(), gf()], a24 = gf(), b8 = gf();
        if (unpackneg(q7, pk)) return null;
        var y10 = q7[1];
        A15(a24, gf1, y10);
        Z2(b8, gf1, y10);
        inv25519(b8, b8);
        M4(a24, a24, b8);
        pack25519(z6, a24);
        return z6;
      }
      function convertSecretKey(sk) {
        var d15 = new Uint8Array(64), o26 = new Uint8Array(32), i27;
        nacl3.lowlevel.crypto_hash(d15, sk, 32);
        d15[0] &= 248;
        d15[31] &= 127;
        d15[31] |= 64;
        for (i27 = 0; i27 < 32; i27++) o26[i27] = d15[i27];
        for (i27 = 0; i27 < 64; i27++) d15[i27] = 0;
        return o26;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
          publicKey,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter34 = __toESM(require_eventemitter3(), 1);

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YOZBVVKL.mjs
var n2 = /* @__PURE__ */ new Map();
function m(r18, e20, t18) {
  return async (...s11) => {
    if (n2.has(e20)) {
      let { value: i27, timestamp: u9 } = n2.get(e20);
      if (t18 === void 0 || Date.now() - u9 <= t18) return i27;
    }
    let a24 = await r18(...s11);
    return n2.set(e20, { value: a24, timestamp: Date.now() }), a24;
  };
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IF4UU2MT.mjs
var s2 = class extends Error {
  constructor(e20, i27) {
    super(e20), this.invalidReason = i27;
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-STY74NUA.mjs
var u = ((n94) => (n94.TOO_SHORT = "too_short", n94.INVALID_LENGTH = "invalid_length", n94.INVALID_HEX_CHARS = "invalid_hex_chars", n94))(u || {});
var a3 = class e2 {
  constructor(t18) {
    this.data = t18;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromHexString(t18) {
    let r18 = t18;
    if (r18.startsWith("0x") && (r18 = r18.slice(2)), r18.length === 0) throw new s2("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
    if (r18.length % 2 !== 0) throw new s2("Hex string must be an even number of hex characters.", "invalid_length");
    try {
      return new e2(hexToBytes(r18));
    } catch (n94) {
      throw new s2(`Hex string contains invalid hex characters: ${n94?.message}`, "invalid_hex_chars");
    }
  }
  static fromHexInput(t18) {
    return t18 instanceof Uint8Array ? new e2(t18) : e2.fromHexString(t18);
  }
  static hexInputToUint8Array(t18) {
    return t18 instanceof Uint8Array ? t18 : e2.fromHexString(t18).toUint8Array();
  }
  static hexInputToString(t18) {
    return e2.fromHexInput(t18).toString();
  }
  static hexInputToStringWithoutPrefix(t18) {
    return e2.fromHexInput(t18).toStringWithoutPrefix();
  }
  static isValid(t18) {
    try {
      return e2.fromHexString(t18), { valid: true };
    } catch (r18) {
      return { valid: false, invalidReason: r18?.invalidReason, invalidReasonMessage: r18?.message };
    }
  }
  equals(t18) {
    return this.data.length !== t18.data.length ? false : this.data.every((r18, n94) => r18 === t18.data[n94]);
  }
};
var l2 = (e20) => new TextDecoder().decode(a3.fromHexInput(e20).toUint8Array());

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-56CNRT2K.mjs
var t2 = 255;
var n3 = 65535;
var U2 = 4294967295;
var _ = 18446744073709551615n;
var o2 = 340282366920938463463374607431768211455n;
var i = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KDMSOCZY.mjs
var h2 = Object.defineProperty;
var i2 = Object.getOwnPropertyDescriptor;
var j = (g5, b8, d15, c7) => {
  for (var a24 = c7 > 1 ? void 0 : c7 ? i2(b8, d15) : b8, e20 = g5.length - 1, f13; e20 >= 0; e20--) (f13 = g5[e20]) && (a24 = (c7 ? f13(b8, d15, a24) : f13(a24)) || a24);
  return c7 && a24 && h2(b8, d15, a24), a24;
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-EBMEXURY.mjs
var B2 = class {
  bcsToBytes() {
    let e20 = new n4();
    return this.serialize(e20), e20.toUint8Array();
  }
  bcsToHex() {
    let e20 = this.bcsToBytes();
    return a3.fromHexInput(e20);
  }
  toStringWithoutPrefix() {
    return this.bcsToHex().toStringWithoutPrefix();
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
};
var n4 = class {
  constructor(e20 = 64) {
    if (e20 <= 0) throw new Error("Length needs to be greater than 0");
    this.buffer = new ArrayBuffer(e20), this.offset = 0;
  }
  ensureBufferWillHandleSize(e20) {
    for (; this.buffer.byteLength < this.offset + e20; ) {
      let t18 = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(t18).set(new Uint8Array(this.buffer)), this.buffer = t18;
    }
  }
  appendToBuffer(e20) {
    this.ensureBufferWillHandleSize(e20.length), new Uint8Array(this.buffer, this.offset).set(e20), this.offset += e20.length;
  }
  serializeWithFunction(e20, t18, i27) {
    this.ensureBufferWillHandleSize(t18);
    let a24 = new DataView(this.buffer, this.offset);
    e20.apply(a24, [0, i27, true]), this.offset += t18;
  }
  serializeStr(e20) {
    let t18 = new TextEncoder();
    this.serializeBytes(t18.encode(e20));
  }
  serializeBytes(e20) {
    this.serializeU32AsUleb128(e20.length), this.appendToBuffer(e20);
  }
  serializeFixedBytes(e20) {
    this.appendToBuffer(e20);
  }
  serializeBool(e20) {
    p(e20);
    let t18 = e20 ? 1 : 0;
    this.appendToBuffer(new Uint8Array([t18]));
  }
  serializeU8(e20) {
    this.appendToBuffer(new Uint8Array([e20]));
  }
  serializeU16(e20) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, e20);
  }
  serializeU32(e20) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, e20);
  }
  serializeU64(e20) {
    let t18 = BigInt(e20) & BigInt(U2), i27 = BigInt(e20) >> BigInt(32);
    this.serializeU32(Number(t18)), this.serializeU32(Number(i27));
  }
  serializeU128(e20) {
    let t18 = BigInt(e20) & _, i27 = BigInt(e20) >> BigInt(64);
    this.serializeU64(t18), this.serializeU64(i27);
  }
  serializeU256(e20) {
    let t18 = BigInt(e20) & o2, i27 = BigInt(e20) >> BigInt(128);
    this.serializeU128(t18), this.serializeU128(i27);
  }
  serializeU32AsUleb128(e20) {
    let t18 = e20, i27 = [];
    for (; t18 >>> 7; ) i27.push(t18 & 127 | 128), t18 >>>= 7;
    i27.push(t18), this.appendToBuffer(new Uint8Array(i27));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(e20) {
    e20.serialize(this);
  }
  serializeVector(e20) {
    this.serializeU32AsUleb128(e20.length), e20.forEach((t18) => {
      t18.serialize(this);
    });
  }
  serializeOption(e20, t18) {
    let i27 = e20 !== void 0;
    this.serializeBool(i27), i27 && (typeof e20 == "string" ? this.serializeStr(e20) : e20 instanceof Uint8Array ? t18 !== void 0 ? this.serializeFixedBytes(e20) : this.serializeBytes(e20) : e20.serialize(this));
  }
  serializeOptionStr(e20) {
    e20 === void 0 ? this.serializeU32AsUleb128(0) : (this.serializeU32AsUleb128(1), this.serializeStr(e20));
  }
};
j([o3(0, t2)], n4.prototype, "serializeU8", 1), j([o3(0, n3)], n4.prototype, "serializeU16", 1), j([o3(0, U2)], n4.prototype, "serializeU32", 1), j([o3(BigInt(0), _)], n4.prototype, "serializeU64", 1), j([o3(BigInt(0), o2)], n4.prototype, "serializeU128", 1), j([o3(BigInt(0), i)], n4.prototype, "serializeU256", 1), j([o3(0, U2)], n4.prototype, "serializeU32AsUleb128", 1);
function p(r18) {
  if (typeof r18 != "boolean") throw new Error(`${r18} is not a boolean value`);
}
var A = (r18, e20, t18) => `${r18} is out of range: [${e20}, ${t18}]`;
function z2(r18, e20, t18) {
  let i27 = BigInt(r18);
  if (i27 > BigInt(t18) || i27 < BigInt(e20)) throw new Error(A(r18, e20, t18));
}
function o3(r18, e20) {
  return (t18, i27, a24) => {
    let g5 = a24.value;
    return a24.value = function(u9) {
      return z2(u9, r18, e20), g5.apply(this, [u9]);
    }, a24;
  };
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RGKRCZ36.mjs
var u2 = ((s11) => (s11.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", s11.INVALID_HEX_CHARS = "invalid_hex_chars", s11.TOO_SHORT = "too_short", s11.TOO_LONG = "too_long", s11.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", s11.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", s11.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", s11.INVALID_PADDING_STRICTNESS = "INVALID_PADDING_STRICTNESS", s11))(u2 || {});
var e3 = class e4 extends B2 {
  constructor(t18) {
    if (super(), t18.length !== e4.LENGTH) throw new s2("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
    this.data = t18;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((t18) => t18 === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let t18 = bytesToHex(this.data);
    return this.isSpecial() && (t18 = t18[t18.length - 1]), t18;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toStringShort() {
    return `0x${this.toStringShortWithoutPrefix()}`;
  }
  toStringShortWithoutPrefix() {
    let t18 = bytesToHex(this.data).replace(/^0+/, "");
    return t18 === "" ? "0" : t18;
  }
  toUint8Array() {
    return this.data;
  }
  serialize(t18) {
    t18.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(t18) {
    let r18 = this.bcsToBytes();
    t18.serializeBytes(r18);
  }
  serializeForScriptFunction(t18) {
    t18.serializeU32AsUleb128(3), t18.serialize(this);
  }
  static deserialize(t18) {
    let r18 = t18.deserializeFixedBytes(e4.LENGTH);
    return new e4(r18);
  }
  static fromStringStrict(t18) {
    if (!t18.startsWith("0x")) throw new s2("Hex string must start with a leading 0x.", "leading_zero_x_required");
    let r18 = e4.fromString(t18);
    if (t18.length !== e4.LONG_STRING_LENGTH + 2) if (r18.isSpecial()) {
      if (t18.length !== 3) throw new s2(`The given hex string ${t18} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
    } else throw new s2(`The given hex string ${t18} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
    return r18;
  }
  static fromString(t18, { maxMissingChars: r18 = 4 } = {}) {
    let n94 = t18;
    if (t18.startsWith("0x") && (n94 = t18.slice(2)), n94.length === 0) throw new s2("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
    if (n94.length > 64) throw new s2("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
    if (r18 > 63 || r18 < 0) throw new s2(`maxMissingChars must be between or equal to 0 and 63. Received ${r18}`, "INVALID_PADDING_STRICTNESS");
    let o26;
    try {
      o26 = hexToBytes(n94.padStart(64, "0"));
    } catch (h10) {
      throw new s2(`Hex characters are invalid: ${h10?.message}`, "invalid_hex_chars");
    }
    let d15 = new e4(o26);
    if (n94.length < 64 - r18 && !d15.isSpecial()) throw new s2(`Hex string is too short, must be ${64 - r18} to 64 chars long, excluding the leading 0x. You may need to fix 
the addresss by padding it with 0s before passing it to \`fromString\` (e.g. <addressString>.padStart(64, '0')). 
Received ${t18}`, "too_short");
    return d15;
  }
  static from(t18, { maxMissingChars: r18 = 4 } = {}) {
    return typeof t18 == "string" ? e4.fromString(t18, { maxMissingChars: r18 }) : t18 instanceof Uint8Array ? new e4(t18) : t18;
  }
  static fromStrict(t18) {
    return typeof t18 == "string" ? e4.fromStringStrict(t18) : t18 instanceof Uint8Array ? new e4(t18) : t18;
  }
  static isValid(t18) {
    try {
      return t18.strict ? e4.fromStrict(t18.input) : e4.from(t18.input), { valid: true };
    } catch (r18) {
      return { valid: false, invalidReason: r18?.invalidReason, invalidReasonMessage: r18?.message };
    }
  }
  equals(t18) {
    return this.data.length !== t18.data.length ? false : this.data.every((r18, n94) => r18 === t18.data[n94]);
  }
};
e3.LENGTH = 32, e3.LONG_STRING_LENGTH = 64, e3.ZERO = e3.from("0x0"), e3.ONE = e3.from("0x1"), e3.TWO = e3.from("0x2"), e3.THREE = e3.from("0x3"), e3.FOUR = e3.from("0x4"), e3.A = e3.from("0xA");
var l3 = e3;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HNBVYE3N.mjs
var d = (e20, r18) => {
  let t18 = e20.bcsToBytes(), s11 = typeof r18 == "string" ? Buffer.from(r18, "utf8") : r18, o26 = new Uint8Array([...t18, ...s11, 254]);
  return new l3(sha3_256(o26));
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-7DQDJ2SA.mjs
async function f2(n94) {
  return new Promise((e20) => {
    setTimeout(e20, n94);
  });
}
function A2(n94) {
  return n94 instanceof Error ? n94.message : String(n94);
}
var _2 = () => Math.floor(Date.now() / 1e3);
function x(n94) {
  let e20 = new Date(n94 * 1e3);
  return e20.setMinutes(0), e20.setSeconds(0), e20.setMilliseconds(0), Math.floor(e20.getTime() / 1e3);
}
function S(n94) {
  let e20 = n94.replace(/-/g, "+").replace(/_/g, "/"), t18 = e20 + "==".substring(0, (3 - e20.length % 3) % 3);
  return decode(t18);
}
function h3(n94) {
  let e20 = n94.replace(/-/g, "+").replace(/_/g, "/");
  for (; e20.length % 4 !== 0; ) e20 += "=";
  return new Uint8Array(Buffer.from(e20, "base64"));
}
var a4 = (n94) => {
  let e20 = "";
  for (let t18 = 2; t18 < n94.length; t18 += 2) e20 += String.fromCharCode(parseInt(n94.substring(t18, t18 + 2), 16));
  return e20;
};
var M = (n94) => {
  let { account_address: e20, module_name: t18, struct_name: o26 } = n94, s11 = a4(t18), c7 = a4(o26);
  return `${e20}::${s11}::${c7}`;
};
var y = (n94) => typeof n94 == "object" && !Array.isArray(n94) && n94 !== null && "account_address" in n94 && "module_name" in n94 && "struct_name" in n94 && typeof n94.account_address == "string" && typeof n94.module_name == "string" && typeof n94.struct_name == "string";
function v(n94) {
  let e20 = n94.split("::");
  if (e20.length !== 3) throw new Error(`Invalid function ${n94}`);
  let t18 = e20[0], o26 = e20[1], s11 = e20[2];
  return { moduleAddress: t18, moduleName: o26, functionName: s11 };
}
function w(n94) {
  let e20 = n94.split("::");
  return e20.length === 3 && l3.isValid({ input: e20[0] }).valid;
}
var I = l3.A.toStringLong();

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6WDVDEQZ.mjs
var l4 = ((t18) => (t18[t18.API_ERROR = 0] = "API_ERROR", t18[t18.EXTERNAL_API_ERROR = 1] = "EXTERNAL_API_ERROR", t18[t18.SESSION_EXPIRED = 2] = "SESSION_EXPIRED", t18[t18.INVALID_STATE = 3] = "INVALID_STATE", t18[t18.INVALID_SIGNATURE = 4] = "INVALID_SIGNATURE", t18[t18.UNKNOWN = 5] = "UNKNOWN", t18))(l4 || {});
var O2 = ((s11) => (s11.REAUTHENTICATE = "Re-authentiate to continue using your keyless account", s11.REAUTHENTICATE_UNSURE = "Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support", s11.UPDATE_REQUEST_PARAMS = "Update the invalid request parameters and reauthenticate.", s11.RATE_LIMIT_EXCEEDED = "Cache the keyless account and reuse it to avoid making too many requests.  Keyless accounts are valid until either the EphemeralKeyPair expires, when the JWK is rotated, or when the proof verifying key is changed, whichever comes soonest.", s11.SERVER_ERROR = "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx", s11.CALL_PRECHECK = "Call `await account.checkKeylessAccountValidity()` to wait for asyncronous changes and check for account validity before signing or serializing.", s11.REINSTANTIATE = "Try instantiating the account again.  Avoid manipulating the account object directly", s11.JOIN_SUPPORT_GROUP = "For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx", s11.UNKNOWN = "Error unknown. For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx", s11))(O2 || {});
var u3 = ((e20) => (e20[e20.EPHEMERAL_KEY_PAIR_EXPIRED = 0] = "EPHEMERAL_KEY_PAIR_EXPIRED", e20[e20.PROOF_NOT_FOUND = 1] = "PROOF_NOT_FOUND", e20[e20.ASYNC_PROOF_FETCH_FAILED = 2] = "ASYNC_PROOF_FETCH_FAILED", e20[e20.INVALID_PROOF_VERIFICATION_FAILED = 3] = "INVALID_PROOF_VERIFICATION_FAILED", e20[e20.INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND = 4] = "INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND", e20[e20.INVALID_JWT_SIG = 5] = "INVALID_JWT_SIG", e20[e20.INVALID_JWT_JWK_NOT_FOUND = 6] = "INVALID_JWT_JWK_NOT_FOUND", e20[e20.INVALID_JWT_ISS_NOT_RECOGNIZED = 7] = "INVALID_JWT_ISS_NOT_RECOGNIZED", e20[e20.INVALID_JWT_FEDERATED_ISS_NOT_SUPPORTED = 8] = "INVALID_JWT_FEDERATED_ISS_NOT_SUPPORTED", e20[e20.INVALID_TW_SIG_VERIFICATION_FAILED = 9] = "INVALID_TW_SIG_VERIFICATION_FAILED", e20[e20.INVALID_TW_SIG_PUBLIC_KEY_NOT_FOUND = 10] = "INVALID_TW_SIG_PUBLIC_KEY_NOT_FOUND", e20[e20.INVALID_EXPIRY_HORIZON = 11] = "INVALID_EXPIRY_HORIZON", e20[e20.JWT_PARSING_ERROR = 12] = "JWT_PARSING_ERROR", e20[e20.JWK_FETCH_FAILED = 13] = "JWK_FETCH_FAILED", e20[e20.JWK_FETCH_FAILED_FEDERATED = 14] = "JWK_FETCH_FAILED_FEDERATED", e20[e20.RATE_LIMIT_EXCEEDED = 15] = "RATE_LIMIT_EXCEEDED", e20[e20.PEPPER_SERVICE_INTERNAL_ERROR = 16] = "PEPPER_SERVICE_INTERNAL_ERROR", e20[e20.PEPPER_SERVICE_BAD_REQUEST = 17] = "PEPPER_SERVICE_BAD_REQUEST", e20[e20.PEPPER_SERVICE_OTHER = 18] = "PEPPER_SERVICE_OTHER", e20[e20.PROVER_SERVICE_INTERNAL_ERROR = 19] = "PROVER_SERVICE_INTERNAL_ERROR", e20[e20.PROVER_SERVICE_BAD_REQUEST = 20] = "PROVER_SERVICE_BAD_REQUEST", e20[e20.PROVER_SERVICE_OTHER = 21] = "PROVER_SERVICE_OTHER", e20[e20.FULL_NODE_CONFIG_LOOKUP_ERROR = 22] = "FULL_NODE_CONFIG_LOOKUP_ERROR", e20[e20.FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR = 23] = "FULL_NODE_VERIFICATION_KEY_LOOKUP_ERROR", e20[e20.FULL_NODE_JWKS_LOOKUP_ERROR = 24] = "FULL_NODE_JWKS_LOOKUP_ERROR", e20[e20.FULL_NODE_OTHER = 25] = "FULL_NODE_OTHER", e20[e20.SIGNATURE_TYPE_INVALID = 26] = "SIGNATURE_TYPE_INVALID", e20[e20.SIGNATURE_EXPIRED = 27] = "SIGNATURE_EXPIRED", e20[e20.MAX_EXPIRY_HORIZON_EXCEEDED = 28] = "MAX_EXPIRY_HORIZON_EXCEEDED", e20[e20.EPHEMERAL_SIGNATURE_VERIFICATION_FAILED = 29] = "EPHEMERAL_SIGNATURE_VERIFICATION_FAILED", e20[e20.TRAINING_WHEELS_SIGNATURE_MISSING = 30] = "TRAINING_WHEELS_SIGNATURE_MISSING", e20[e20.TRAINING_WHEELS_SIGNATURE_VERIFICATION_FAILED = 31] = "TRAINING_WHEELS_SIGNATURE_VERIFICATION_FAILED", e20[e20.PROOF_VERIFICATION_FAILED = 32] = "PROOF_VERIFICATION_FAILED", e20[e20.UNKNOWN = 33] = "UNKNOWN", e20))(u3 || {});
var A3 = { 0: ["The ephemeral keypair has expired.", 2, "Re-authentiate to continue using your keyless account"], 1: ["The required proof could not be found.", 3, "Call `await account.checkKeylessAccountValidity()` to wait for asyncronous changes and check for account validity before signing or serializing."], 2: ["The required proof failed to fetch.", 3, "Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support"], 3: ["The provided proof is invalid.", 3, "Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support"], 4: ["The verification key used to authenticate was updated.", 2, "Re-authentiate to continue using your keyless account"], 5: ["The JWK was found, but JWT failed verification", 3, "Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support"], 6: ["The JWK required to verify the JWT could not be found. The JWK may have been rotated out.", 2, "Re-authentiate to continue using your keyless account"], 7: ["The JWT issuer is not recognized.", 3, "Update the invalid request parameters and reauthenticate."], 8: ["The JWT issuer is not supported by the Federated Keyless ", 0, "Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support"], 9: ["The training wheels signature is invalid.", 3, "Try re-authentiating. If the error persists join the telegram group at https://t.me/+h5CN-W35yUFiYzkx for further support"], 10: ["The public key used to verify the training wheels signature was not found.", 2, "Re-authentiate to continue using your keyless account"], 11: ["The expiry horizon is invalid.", 2, "Re-authentiate to continue using your keyless account"], 13: ["Failed to fetch JWKS.", 1, "For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 14: ["Failed to fetch JWKS for Federated Keyless provider.", 1, "For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 15: ["Rate limit exceeded. Too many requests in a short period.", 0, "Cache the keyless account and reuse it to avoid making too many requests.  Keyless accounts are valid until either the EphemeralKeyPair expires, when the JWK is rotated, or when the proof verifying key is changed, whichever comes soonest."], 16: ["Internal error from Pepper service.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 17: ["Bad request sent to Pepper service.", 0, "Update the invalid request parameters and reauthenticate."], 18: ["Unknown error from Pepper service.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 19: ["Internal error from Prover service.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 20: ["Bad request sent to Prover service.", 0, "Update the invalid request parameters and reauthenticate."], 21: ["Unknown error from Prover service.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 12: ["Error when parsing JWT. This should never happen. Join https://t.me/+h5CN-W35yUFiYzkx for support", 3, "Try instantiating the account again.  Avoid manipulating the account object directly"], 22: ["Error when looking up on-chain keyless configuration.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 23: ["Error when looking up on-chain verification key.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 24: ["Error when looking up on-chain JWKS.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 25: ["Unknown error from full node.", 0, "Try again later.  See aptosApiError error for more context. For additional support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 26: ["The signature is not a valid Keyless signature.", 4, "For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"], 27: ["The ephemeral key pair used to sign the message has expired.", 4, "Re-authentiate to continue using your keyless account"], 28: ["The expiry horizon on the signature exceeds the maximum allowed value.", 4, "Re-authentiate to continue using your keyless account"], 29: ["Failed to verify the ephemeral signature with the ephemeral public key.", 4, "Re-authentiate to continue using your keyless account"], 30: ["The training wheels signature is missing but is required by the Keyless configuration.", 4, "Re-authentiate to continue using your keyless account"], 31: ["Failed to verify the training wheels signature with the training wheels public key.", 4, "Re-authentiate to continue using your keyless account"], 32: ["The proof verification failed.", 4, "Re-authentiate to continue using your keyless account"], 33: ["An unknown error has occurred.", 5, "Error unknown. For support join the telegram group at https://t.me/+h5CN-W35yUFiYzkx"] };
var N = class _3 extends Error {
  constructor(o26) {
    let { innerError: r18, category: E9, resolutionTip: i27, type: R6, message: t18 = A3[R6][0], details: I6 } = o26;
    super(t18), this.name = "KeylessError", this.innerError = r18, this.category = E9, this.resolutionTip = i27, this.type = R6, this.details = I6, this.message = _3.constructMessage(t18, i27, r18, I6);
  }
  static constructMessage(o26, r18, E9, i27) {
    let R6 = `
Message: ${o26}`;
    return i27 && (R6 += `
Details: ${i27}`), E9 instanceof T ? R6 += `
AptosApiError: ${E9.message}` : E9 !== void 0 && (R6 += `
Error: ${A2(E9)}`), R6 += `
KeylessErrorResolutionTip: ${r18}`, R6;
  }
  static fromErrorType(o26) {
    let { error: r18, type: E9, details: i27 } = o26, [R6, t18, I6] = A3[E9];
    return new _3({ message: R6, details: i27, innerError: r18, category: t18, resolutionTip: I6, type: E9 });
  }
};
var T = class extends Error {
  constructor({ apiType: o26, aptosRequest: r18, aptosResponse: E9 }) {
    super(S2({ apiType: o26, aptosRequest: r18, aptosResponse: E9 })), this.name = "AptosApiError", this.url = E9.url, this.status = E9.status, this.statusText = E9.statusText, this.data = E9.data, this.request = r18;
  }
};
function S2({ apiType: _8, aptosRequest: o26, aptosResponse: r18 }) {
  let E9 = r18.headers?.traceparent?.split("-")[1], i27 = E9 ? `(trace_id:${E9}) ` : "", R6 = `Request to [${_8}]: ${o26.method} ${r18.url ?? o26.url} ${i27}failed with`;
  return _8 === "Indexer" && r18.data?.errors?.[0]?.message != null ? `${R6}: ${r18.data.errors[0].message}` : r18.data?.message != null && r18.data?.error_code != null ? `${R6}: ${JSON.stringify(r18.data)}` : `${R6} status: ${r18.statusText}(code:${r18.status}) and response body: ${P(r18.data)}`;
}
var n5 = 400;
function P(_8) {
  let o26 = JSON.stringify(_8);
  return o26.length <= n5 ? o26 : `truncated(original_size:${o26.length}): ${o26.slice(0, n5 / 2)}...${o26.slice(-n5 / 2)}`;
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZIB2TU7B.mjs
var o4 = "3.1.3";

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KJW3XYRT.mjs
async function A4(s11, u9) {
  let { url: t18, method: n94, body: i27, contentType: a24, params: o26, overrides: e20, originMethod: R6 } = s11, p11 = { ...e20?.HEADERS, "x-aptos-client": `aptos-typescript-sdk/${o4}`, "content-type": a24 ?? "application/json", "x-aptos-typescript-sdk-origin-method": R6 };
  return e20?.AUTH_TOKEN && (p11.Authorization = `Bearer ${e20?.AUTH_TOKEN}`), e20?.API_KEY && (p11.Authorization = `Bearer ${e20?.API_KEY}`), u9.provider({ url: t18, method: n94, body: i27, params: o26, headers: p11, overrides: e20 });
}
async function P2(s11, u9, t18) {
  let { url: n94, path: i27 } = s11, a24 = i27 ? `${n94}/${i27}` : n94, o26 = await A4({ ...s11, url: a24 }, u9.client), e20 = { status: o26.status, statusText: o26.statusText ?? "No status text provided", data: o26.data, headers: o26.headers, config: o26.config, request: o26.request, url: a24 };
  if (e20.status === 401) throw new T({ apiType: t18, aptosRequest: s11, aptosResponse: e20 });
  if (t18 === "Indexer") {
    let R6 = e20.data;
    if (R6.errors) throw new T({ apiType: t18, aptosRequest: s11, aptosResponse: e20 });
    e20.data = R6.data;
  } else if ((t18 === "Pepper" || t18 === "Prover") && e20.status >= 400) throw new T({ apiType: t18, aptosRequest: s11, aptosResponse: e20 });
  if (e20.status >= 200 && e20.status < 300) return e20;
  throw new T({ apiType: t18, aptosRequest: s11, aptosResponse: e20 });
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MGMCLJQC.mjs
async function i3(e20) {
  let { aptosConfig: t18, overrides: s11, params: r18, contentType: n94, acceptType: a24, path: p11, originMethod: o26, type: R6 } = e20, d15 = t18.getRequestUrl(R6);
  return P2({ url: d15, method: "GET", originMethod: o26, path: p11, contentType: n94, acceptType: a24, params: r18, overrides: { ...t18.clientConfig, ...s11 } }, t18, e20.type);
}
async function y2(e20) {
  let { aptosConfig: t18 } = e20;
  return i3({ ...e20, type: "Fullnode", overrides: { ...t18.clientConfig, ...t18.fullnodeConfig, ...e20.overrides, HEADERS: { ...t18.clientConfig?.HEADERS, ...t18.fullnodeConfig?.HEADERS } } });
}
async function q(e20) {
  let t18 = new Array(0), s11, r18 = e20.params;
  do {
    let n94 = await i3({ type: "Fullnode", aptosConfig: e20.aptosConfig, originMethod: e20.originMethod, path: e20.path, params: r18, overrides: e20.overrides });
    s11 = n94.headers["x-aptos-cursor"], delete n94.headers, t18.push(...n94.data), r18.start = s11;
  } while (s11 != null);
  return t18;
}
async function A5(e20) {
  let t18 = new Array(0), s11, r18 = e20.params, n94 = r18.limit;
  do {
    let { response: a24, cursor: p11 } = await m2({ ...e20 });
    if (s11 = p11, t18.push(...a24.data), e20?.params && (e20.params.start = s11), n94 !== void 0) {
      let o26 = n94 - t18.length;
      if (o26 <= 0) break;
      r18.limit = o26;
    }
  } while (s11 != null);
  return t18;
}
async function m2(e20) {
  let t18, s11 = {};
  typeof e20.params?.cursor == "string" && (s11.start = e20.params.cursor), typeof e20.params?.limit == "number" && (s11.limit = e20.params.limit);
  let r18 = await i3({ type: "Fullnode", aptosConfig: e20.aptosConfig, originMethod: e20.originMethod, path: e20.path, params: s11, overrides: e20.overrides });
  return t18 = r18.headers["x-aptos-cursor"], { response: r18, cursor: t18 };
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NIXUOEWL.mjs
async function g(o26) {
  let { aptosConfig: e20, accountAddress: t18 } = o26, { data: n94 } = await y2({ aptosConfig: e20, originMethod: "getInfo", path: `accounts/${l3.from(t18).toString()}` });
  return n94;
}
async function f3(o26) {
  return o26.options?.ledgerVersion !== void 0 ? c(o26) : m(async () => c(o26), `module-${o26.accountAddress}-${o26.moduleName}`, 1e3 * 60 * 5)();
}
async function c(o26) {
  let { aptosConfig: e20, accountAddress: t18, moduleName: n94, options: i27 } = o26, { data: u9 } = await y2({ aptosConfig: e20, originMethod: "getModule", path: `accounts/${l3.from(t18).toString()}/module/${n94}`, params: { ledger_version: i27?.ledgerVersion } });
  return u9;
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DPW6ELCQ.mjs
var o5 = (n94) => typeof n94 == "string" ? a3.isValid(n94).valid ? n94 : new TextEncoder().encode(n94) : n94;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-C3Q23D22.mjs
var d2 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var m3 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
var y3 = ((t18) => (t18.ED25519 = "ed25519 seed", t18))(y3 || {});
var u4 = 2147483648;
function D(e20) {
  return m3.test(e20);
}
function E2(e20) {
  return d2.test(e20);
}
var A6 = (e20, t18) => {
  let r18 = hmac.create(sha512, e20).update(t18).digest();
  return { key: r18.slice(0, 32), chainCode: r18.slice(32) };
};
var f4 = ({ key: e20, chainCode: t18 }, r18) => {
  let n94 = new ArrayBuffer(4);
  new DataView(n94).setUint32(0, r18);
  let o26 = new Uint8Array(n94), s11 = new Uint8Array([0]), a24 = new Uint8Array([...s11, ...e20, ...o26]);
  return A6(t18, a24);
};
var x2 = (e20) => e20.replace(/'/g, "");
var U3 = (e20) => e20.split("/").slice(1).map(x2);
var h4 = (e20) => {
  let t18 = e20.trim().split(/\s+/).map((r18) => r18.toLowerCase()).join(" ");
  return mnemonicToSeedSync(t18);
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ROT6S6BM.mjs
var a5 = class a6 {
  static formatPrivateKey(i27, n94) {
    let e20 = a6.AIP80_PREFIXES[n94], t18 = i27;
    return typeof t18 == "string" && t18.startsWith(e20) && (t18 = t18.split("-")[2]), `${e20}${a3.fromHexInput(t18).toString()}`;
  }
  static parseHexInput(i27, n94, e20) {
    let t18, p11 = a6.AIP80_PREFIXES[n94];
    if (typeof i27 == "string") if (!e20 && !i27.startsWith(p11)) t18 = a3.fromHexInput(i27), e20 !== false && console.warn("[Aptos SDK] It is recommended that private keys are AIP-80 compliant (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md). You can fix the private key by formatting it with `PrivateKey.formatPrivateKey(privateKey: string, type: 'ed25519' | 'secp256k1'): string`.");
    else if (i27.startsWith(p11)) t18 = a3.fromHexString(i27.split("-")[2]);
    else throw e20 ? new Error("Invalid HexString input while parsing private key. Must AIP-80 compliant string.") : new Error("Invalid HexString input while parsing private key.");
    else t18 = a3.fromHexInput(i27);
    return t18;
  }
};
a5.AIP80_PREFIXES = { ed25519: "ed25519-priv-", secp256k1: "secp256k1-priv-" };
var o6 = a5;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WSR5EBJM.mjs
var r2 = class extends B2 {
  async verifySignatureAsync(t18) {
    return this.verifySignature(t18);
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  toString() {
    let t18 = this.toUint8Array();
    return a3.fromHexInput(t18).toString();
  }
};
var n6 = class extends r2 {
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WCMW2L3P.mjs
var o7 = class extends B2 {
  toUint8Array() {
    return this.bcsToBytes();
  }
  toString() {
    let i27 = this.toUint8Array();
    return a3.fromHexInput(i27).toString();
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CO67Y6YE.mjs
var i4 = class i5 extends r2 {
  constructor(e20) {
    super();
    let t18 = a3.fromHexInput(e20), { length: r18 } = t18.toUint8Array();
    if (r18 === i5.LENGTH) this.key = t18;
    else if (r18 === i5.COMPRESSED_LENGTH) {
      let o26 = secp256k1.ProjectivePoint.fromHex(t18.toUint8Array());
      this.key = a3.fromHexInput(o26.toRawBytes(false));
    } else throw new Error(`PublicKey length should be ${i5.LENGTH} or ${i5.COMPRESSED_LENGTH}, received ${r18}`);
  }
  verifySignature(e20) {
    let { message: t18, signature: r18 } = e20, o26 = o5(t18), c7 = a3.fromHexInput(o26).toUint8Array(), P7 = sha3_256(c7), x5 = r18.toUint8Array();
    return secp256k1.verify(x5, P7, this.key.toUint8Array(), { lowS: true });
  }
  async verifySignatureAsync(e20) {
    return this.verifySignature(e20);
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e20) {
    e20.serializeBytes(this.key.toUint8Array());
  }
  deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new l5(t18);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new i5(t18);
  }
  static isPublicKey(e20) {
    return e20 instanceof i5;
  }
  static isInstance(e20) {
    return "key" in e20 && e20.key?.data?.length === i5.LENGTH;
  }
};
i4.LENGTH = 65, i4.COMPRESSED_LENGTH = 33;
var m4 = i4;
var n7 = class n8 extends B2 {
  constructor(e20, t18) {
    super();
    let r18 = o6.parseHexInput(e20, "secp256k1", t18);
    if (r18.toUint8Array().length !== n8.LENGTH) throw new Error(`PrivateKey length should be ${n8.LENGTH}`);
    this.key = r18;
  }
  static generate() {
    let e20 = secp256k1.utils.randomPrivateKey();
    return new n8(e20, false);
  }
  static fromDerivationPath(e20, t18) {
    if (!D(e20)) throw new Error(`Invalid derivation path ${e20}`);
    return n8.fromDerivationPathInner(e20, h4(t18));
  }
  static fromDerivationPathInner(e20, t18) {
    let { privateKey: r18 } = HDKey.fromMasterSeed(t18).derive(e20);
    if (r18 === null) throw new Error("Invalid key");
    return new n8(r18, false);
  }
  sign(e20) {
    let t18 = o5(e20), r18 = a3.fromHexInput(t18), o26 = sha3_256(r18.toUint8Array()), c7 = secp256k1.sign(o26, this.key.toUint8Array(), { lowS: true });
    return new l5(c7.toCompactRawBytes());
  }
  publicKey() {
    let e20 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new m4(e20);
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.toAIP80String();
  }
  toHexString() {
    return this.key.toString();
  }
  toAIP80String() {
    return o6.formatPrivateKey(this.key.toString(), "secp256k1");
  }
  serialize(e20) {
    e20.serializeBytes(this.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new n8(t18, false);
  }
  static isPrivateKey(e20) {
    return e20 instanceof n8;
  }
};
n7.LENGTH = 32;
var v2 = n7;
var a7 = class a8 extends o7 {
  constructor(e20) {
    super();
    let t18 = a3.fromHexInput(e20);
    if (t18.toUint8Array().length !== a8.LENGTH) throw new Error(`Signature length should be ${a8.LENGTH}, received ${t18.toUint8Array().length}`);
    this.data = t18;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e20) {
    e20.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new a8(t18);
  }
};
a7.LENGTH = 64;
var l5 = a7;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A5L76YP7.mjs
var i6 = class {
  constructor() {
    this.queue = [];
    this.pendingDequeue = [];
    this.cancelled = false;
  }
  enqueue(e20) {
    if (this.cancelled = false, this.pendingDequeue.length > 0) {
      this.pendingDequeue.shift()?.resolve(e20);
      return;
    }
    this.queue.push(e20);
  }
  async dequeue() {
    return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((e20, u9) => {
      this.pendingDequeue.push({ resolve: e20, reject: u9 });
    });
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  cancel() {
    this.cancelled = true, this.pendingDequeue.forEach(async ({ reject: e20 }) => {
      e20(new n9("Task cancelled"));
    }), this.pendingDequeue = [], this.queue.length = 0;
  }
  isCancelled() {
    return this.cancelled;
  }
  pendingDequeueLength() {
    return this.pendingDequeue.length;
  }
};
var n9 = class extends Error {
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GOXRBEIJ.mjs
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);
var i7 = [import_poseidon_lite.poseidon1, import_poseidon_lite.poseidon2, import_poseidon_lite.poseidon3, import_poseidon_lite.poseidon4, import_poseidon_lite.poseidon5, import_poseidon_lite.poseidon6, import_poseidon_lite.poseidon7, import_poseidon_lite.poseidon8, import_poseidon_lite.poseidon9, import_poseidon_lite.poseidon10, import_poseidon_lite.poseidon11, import_poseidon_lite.poseidon12, import_poseidon_lite.poseidon13, import_poseidon_lite.poseidon14, import_poseidon_lite.poseidon15, import_poseidon_lite.poseidon16];
var g2 = 31;
var m5 = 16;
var s3 = (m5 - 1) * g2;
function C(n94, t18) {
  let o26 = new TextEncoder().encode(n94);
  return $(o26, t18);
}
function $(n94, t18) {
  if (n94.length > t18) throw new Error(`Inputted bytes of length ${n94} is longer than ${t18}`);
  let r18 = _4(n94, t18);
  return M2(r18);
}
function T2(n94, t18) {
  if (n94.length > t18) throw new Error(`Input bytes of length ${n94} is longer than ${t18}`);
  let r18 = k2(n94, t18);
  return P3(r18);
}
function _4(n94, t18) {
  if (n94.length > t18) throw new Error(`Input bytes of length ${n94} is longer than ${t18}`);
  return T2(n94, t18).concat([BigInt(n94.length)]);
}
function P3(n94) {
  if (n94.length > s3) throw new Error(`Can't pack more than ${s3}.  Was given ${n94.length} bytes`);
  return L(n94, g2).map((t18) => N2(t18));
}
function L(n94, t18) {
  let r18 = [];
  for (let o26 = 0; o26 < n94.length; o26 += t18) r18.push(n94.subarray(o26, o26 + t18));
  return r18;
}
function N2(n94) {
  let t18 = BigInt(0);
  for (let r18 = n94.length - 1; r18 >= 0; r18 -= 1) t18 = t18 << BigInt(8) | BigInt(n94[r18]);
  return t18;
}
function W2(n94, t18) {
  let r18 = BigInt(n94), o26 = new Uint8Array(t18);
  for (let e20 = 0; e20 < t18; e20 += 1) o26[e20] = Number(r18 & BigInt(255)), r18 >>= BigInt(8);
  return o26;
}
function k2(n94, t18) {
  if (t18 < n94.length) throw new Error("Padded size must be greater than or equal to the input array size.");
  let r18 = new Uint8Array(t18);
  r18.set(n94);
  for (let o26 = n94.length; o26 < t18; o26 += 1) r18[o26] = 0;
  return r18;
}
function M2(n94) {
  if (n94.length > i7.length) throw new Error(`Unable to hash input of length ${n94.length}.  Max input length is ${i7.length}`);
  return i7[n94.length - 1](n94);
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XJJVJOX5.mjs
var e5 = class extends B2 {
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FGFLPH5K.mjs
var r3 = class r4 extends B2 {
  constructor(t18) {
    super();
    let { data: e20 } = t18, i27 = a3.fromHexInput(e20);
    if (i27.toUint8Array().length !== r4.LENGTH) throw new Error(`Authentication Key length should be ${r4.LENGTH}`);
    this.data = i27;
  }
  serialize(t18) {
    t18.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(t18) {
    let e20 = t18.deserializeFixedBytes(r4.LENGTH);
    return new r4({ data: e20 });
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromSchemeAndBytes(t18) {
    let { scheme: e20, input: i27 } = t18, u9 = a3.fromHexInput(i27).toUint8Array(), h10 = new Uint8Array([...u9, e20]), a24 = sha3_256.create();
    a24.update(h10);
    let y10 = a24.digest();
    return new r4({ data: y10 });
  }
  static fromPublicKeyAndScheme(t18) {
    let { publicKey: e20 } = t18;
    return e20.authKey();
  }
  static fromPublicKey(t18) {
    let { publicKey: e20 } = t18;
    return e20.authKey();
  }
  derivedAddress() {
    return new l3(this.data.toUint8Array());
  }
};
r3.LENGTH = 32;
var s4 = r3;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RQX6JOEN.mjs
var n10 = class e6 extends o7 {
  constructor(r18) {
    super(), this.value = a3.fromHexInput(r18).toUint8Array();
  }
  serialize(r18) {
    r18.serializeBytes(this.value);
  }
  static deserialize(r18) {
    return new e6(r18.deserializeBytes());
  }
};
var a10 = class extends n6 {
  constructor(r18) {
    super(), this.accountAddress = r18;
  }
  authKey() {
    return new s4({ data: this.accountAddress.toUint8Array() });
  }
  verifySignature(r18) {
    throw new Error("This function is not implemented for AbstractPublicKey.");
  }
  async verifySignatureAsync(r18) {
    throw new Error("This function is not implemented for AbstractPublicKey.");
  }
  serialize(r18) {
    throw new Error("This function is not implemented for AbstractPublicKey.");
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UQWF24SS.mjs
var m6 = [237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16];
function T3(I6) {
  let e20 = I6.toUint8Array().slice(32);
  for (let t18 = m6.length - 1; t18 >= 0; t18 -= 1) {
    if (e20[t18] < m6[t18]) return true;
    if (e20[t18] > m6[t18]) return false;
  }
  return false;
}
var n11 = class n12 extends n6 {
  constructor(e20) {
    super();
    let t18 = a3.fromHexInput(e20);
    if (t18.toUint8Array().length !== n12.LENGTH) throw new Error(`PublicKey length should be ${n12.LENGTH}`);
    this.key = t18;
  }
  verifySignature(e20) {
    let { message: t18, signature: i27 } = e20;
    if (!T3(i27)) return false;
    let a24 = o5(t18), u9 = a3.fromHexInput(a24).toUint8Array(), c7 = i27.toUint8Array(), l14 = this.key.toUint8Array();
    return ed25519.verify(c7, u9, l14);
  }
  async verifySignatureAsync(e20) {
    return this.verifySignature(e20);
  }
  authKey() {
    return s4.fromSchemeAndBytes({ scheme: 0, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e20) {
    e20.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new n12(t18);
  }
  static isPublicKey(e20) {
    return e20 instanceof n12;
  }
  static isInstance(e20) {
    return "key" in e20 && e20.key?.data?.length === n12.LENGTH;
  }
};
n11.LENGTH = 32;
var f6 = n11;
var r5 = class r6 extends B2 {
  constructor(e20, t18) {
    super();
    let i27 = o6.parseHexInput(e20, "ed25519", t18);
    if (i27.toUint8Array().length !== r6.LENGTH) throw new Error(`PrivateKey length should be ${r6.LENGTH}`);
    this.signingKey = i27;
  }
  static generate() {
    let e20 = ed25519.utils.randomPrivateKey();
    return new r6(e20, false);
  }
  static fromDerivationPath(e20, t18) {
    if (!E2(e20)) throw new Error(`Invalid derivation path ${e20}`);
    return r6.fromDerivationPathInner(e20, h4(t18));
  }
  static fromDerivationPathInner(e20, t18, i27 = u4) {
    let { key: a24, chainCode: u9 } = A6(r6.SLIP_0010_SEED, t18), c7 = U3(e20).map((g5) => parseInt(g5, 10)), { key: l14 } = c7.reduce((g5, w5) => f4(g5, w5 + i27), { key: a24, chainCode: u9 });
    return new r6(l14, false);
  }
  publicKey() {
    let e20 = ed25519.getPublicKey(this.signingKey.toUint8Array());
    return new f6(e20);
  }
  sign(e20) {
    let t18 = o5(e20), i27 = a3.fromHexInput(t18).toUint8Array(), a24 = ed25519.sign(i27, this.signingKey.toUint8Array());
    return new h6(a24);
  }
  toUint8Array() {
    return this.signingKey.toUint8Array();
  }
  toString() {
    return this.toAIP80String();
  }
  toHexString() {
    return this.signingKey.toString();
  }
  toAIP80String() {
    return o6.formatPrivateKey(this.signingKey.toString(), "ed25519");
  }
  serialize(e20) {
    e20.serializeBytes(this.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new r6(t18, false);
  }
  static isPrivateKey(e20) {
    return e20 instanceof r6;
  }
};
r5.LENGTH = 32, r5.SLIP_0010_SEED = "ed25519 seed";
var z3 = r5;
var s5 = class s6 extends o7 {
  constructor(e20) {
    super();
    let t18 = a3.fromHexInput(e20);
    if (t18.toUint8Array().length !== s6.LENGTH) throw new Error(`Signature length should be ${s6.LENGTH}`);
    this.data = t18;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e20) {
    e20.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes();
    return new s6(t18);
  }
};
s5.LENGTH = 64;
var h6 = s5;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FLZPUYXQ.mjs
var a11 = class d4 {
  constructor(e20) {
    this.buffer = new ArrayBuffer(e20.length), new Uint8Array(this.buffer).set(e20, 0), this.offset = 0;
  }
  static fromHex(e20) {
    let i27 = a3.hexInputToUint8Array(e20);
    return new d4(i27);
  }
  read(e20) {
    if (this.offset + e20 > this.buffer.byteLength) throw new Error("Reached to the end of buffer");
    let i27 = this.buffer.slice(this.offset, this.offset + e20);
    return this.offset += e20, i27;
  }
  remaining() {
    return this.buffer.byteLength - this.offset;
  }
  assertFinished() {
    if (this.remaining() !== 0) throw new Error("Buffer has remaining bytes");
  }
  deserializeStr() {
    let e20 = this.deserializeBytes();
    return new TextDecoder().decode(e20);
  }
  deserializeOptionStr() {
    return this.deserializeOption("string");
  }
  deserializeOption(e20, i27) {
    if (this.deserializeBool()) {
      if (e20 === "string") return this.deserializeStr();
      if (e20 === "bytes") return this.deserializeBytes();
      if (e20 === "fixedBytes") {
        if (i27 === void 0) throw new Error("Fixed bytes length not provided");
        return this.deserializeFixedBytes(i27);
      }
      return this.deserialize(e20);
    }
  }
  deserializeBytes() {
    let e20 = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(e20));
  }
  deserializeFixedBytes(e20) {
    return new Uint8Array(this.read(e20));
  }
  deserializeBool() {
    let e20 = new Uint8Array(this.read(1))[0];
    if (e20 !== 1 && e20 !== 0) throw new Error("Invalid boolean value");
    return e20 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    let e20 = this.deserializeU32(), i27 = this.deserializeU32();
    return BigInt(BigInt(i27) << BigInt(32) | BigInt(e20));
  }
  deserializeU128() {
    let e20 = this.deserializeU64(), i27 = this.deserializeU64();
    return BigInt(i27 << BigInt(64) | e20);
  }
  deserializeU256() {
    let e20 = this.deserializeU128(), i27 = this.deserializeU128();
    return BigInt(i27 << BigInt(128) | e20);
  }
  deserializeUleb128AsU32() {
    let e20 = BigInt(0), i27 = 0;
    for (; e20 < U2; ) {
      let r18 = this.deserializeU8();
      if (e20 |= BigInt(r18 & 127) << BigInt(i27), (r18 & 128) === 0) break;
      i27 += 7;
    }
    if (e20 > U2) throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    return Number(e20);
  }
  deserialize(e20) {
    return e20.deserialize(this);
  }
  deserializeVector(e20) {
    let i27 = this.deserializeUleb128AsU32(), r18 = new Array();
    for (let n94 = 0; n94 < i27; n94 += 1) r18.push(this.deserialize(e20));
    return r18;
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CFQFFP6N.mjs
var c3 = class i8 extends r2 {
  constructor(e20) {
    super();
    let r18 = e20.constructor.name;
    switch (r18) {
      case f6.name:
        this.publicKey = e20, this.variant = 0;
        break;
      default:
        throw new Error(`Unsupported key for EphemeralPublicKey - ${r18}`);
    }
  }
  verifySignature(e20) {
    let { message: r18, signature: a24 } = e20;
    return this.publicKey.verifySignature({ message: r18, signature: a24.signature });
  }
  async verifySignatureAsync(e20) {
    return this.verifySignature(e20);
  }
  serialize(e20) {
    if (this.publicKey instanceof f6) e20.serializeU32AsUleb128(0), this.publicKey.serialize(e20);
    else throw new Error("Unknown public key type");
  }
  static deserialize(e20) {
    let r18 = e20.deserializeUleb128AsU32();
    switch (r18) {
      case 0:
        return new i8(f6.deserialize(e20));
      default:
        throw new Error(`Unknown variant index for EphemeralPublicKey: ${r18}`);
    }
  }
  static isPublicKey(e20) {
    return e20 instanceof i8;
  }
};
var p3 = class i9 extends o7 {
  constructor(e20) {
    super();
    let r18 = e20.constructor.name;
    switch (r18) {
      case h6.name:
        this.signature = e20;
        break;
      default:
        throw new Error(`Unsupported signature for EphemeralSignature - ${r18}`);
    }
  }
  static fromHex(e20) {
    let r18 = a3.fromHexInput(e20), a24 = new a11(r18.toUint8Array());
    return i9.deserialize(a24);
  }
  serialize(e20) {
    if (this.signature instanceof h6) e20.serializeU32AsUleb128(0), this.signature.serialize(e20);
    else throw new Error("Unknown signature type");
  }
  static deserialize(e20) {
    let r18 = e20.deserializeUleb128AsU32();
    switch (r18) {
      case 0:
        return new i9(h6.deserialize(e20));
      default:
        throw new Error(`Unknown variant index for EphemeralSignature: ${r18}`);
    }
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ORMOQWWH.mjs
var U5 = class i10 extends B2 {
  constructor(e20) {
    super(), p(e20), this.value = e20;
  }
  serialize(e20) {
    e20.serializeBool(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(5), e20.serialize(this);
  }
  deserialize(e20) {
    return new a12(e20.deserializeU256());
  }
  static deserialize(e20) {
    return new i10(e20.deserializeBool());
  }
};
var p4 = class i11 extends B2 {
  constructor(e20) {
    super(), z2(e20, 0, t2), this.value = e20;
  }
  serialize(e20) {
    e20.serializeU8(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(0), e20.serialize(this);
  }
  static deserialize(e20) {
    return new i11(e20.deserializeU8());
  }
};
var b2 = class i12 extends B2 {
  constructor(e20) {
    super(), z2(e20, 0, n3), this.value = e20;
  }
  serialize(e20) {
    e20.serializeU16(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(6), e20.serialize(this);
  }
  static deserialize(e20) {
    return new i12(e20.deserializeU16());
  }
};
var y5 = class i13 extends B2 {
  constructor(e20) {
    super(), z2(e20, 0, U2), this.value = e20;
  }
  serialize(e20) {
    e20.serializeU32(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(7), e20.serialize(this);
  }
  static deserialize(e20) {
    return new i13(e20.deserializeU32());
  }
};
var m7 = class i14 extends B2 {
  constructor(e20) {
    super(), z2(e20, BigInt(0), _), this.value = BigInt(e20);
  }
  serialize(e20) {
    e20.serializeU64(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(1), e20.serialize(this);
  }
  static deserialize(e20) {
    return new i14(e20.deserializeU64());
  }
};
var B4 = class i15 extends B2 {
  constructor(e20) {
    super(), z2(e20, BigInt(0), o2), this.value = BigInt(e20);
  }
  serialize(e20) {
    e20.serializeU128(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(2), e20.serialize(this);
  }
  static deserialize(e20) {
    return new i15(e20.deserializeU128());
  }
};
var a12 = class i16 extends B2 {
  constructor(e20) {
    super(), z2(e20, BigInt(0), i), this.value = BigInt(e20);
  }
  serialize(e20) {
    e20.serializeU256(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(8), e20.serialize(this);
  }
  static deserialize(e20) {
    return new i16(e20.deserializeU256());
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Q4W3WJ2U.mjs
var t3 = class i17 extends B2 {
  constructor(e20) {
    super(), this.values = e20;
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    if (this.values[0] !== void 0 && !(this.values[0] instanceof p4)) {
      new p5(this.bcsToBytes()).serializeForScriptFunction(e20);
      return;
    }
    e20.serializeU32AsUleb128(4), e20.serialize(this);
  }
  static U8(e20) {
    let r18;
    if (Array.isArray(e20) && e20.length === 0) r18 = [];
    else if (Array.isArray(e20) && typeof e20[0] == "number") r18 = e20;
    else if (typeof e20 == "string") {
      let n94 = a3.fromHexInput(e20);
      r18 = Array.from(n94.toUint8Array());
    } else if (e20 instanceof Uint8Array) r18 = Array.from(e20);
    else throw new Error("Invalid input type, must be an number[], Uint8Array, or hex string");
    return new i17(r18.map((n94) => new p4(n94)));
  }
  static U16(e20) {
    return new i17(e20.map((r18) => new b2(r18)));
  }
  static U32(e20) {
    return new i17(e20.map((r18) => new y5(r18)));
  }
  static U64(e20) {
    return new i17(e20.map((r18) => new m7(r18)));
  }
  static U128(e20) {
    return new i17(e20.map((r18) => new B4(r18)));
  }
  static U256(e20) {
    return new i17(e20.map((r18) => new a12(r18)));
  }
  static Bool(e20) {
    return new i17(e20.map((r18) => new U5(r18)));
  }
  static MoveString(e20) {
    return new i17(e20.map((r18) => new a13(r18)));
  }
  serialize(e20) {
    e20.serializeVector(this.values);
  }
  static deserialize(e20, r18) {
    let n94 = e20.deserializeUleb128AsU32(), l14 = new Array();
    for (let w5 = 0; w5 < n94; w5 += 1) l14.push(r18.deserialize(e20));
    return new i17(l14);
  }
};
var p5 = class i18 extends B2 {
  constructor(e20) {
    super(), this.value = a3.fromHexInput(e20).toUint8Array();
  }
  serialize(e20) {
    e20.serializeBytes(this.value);
  }
  serializeForEntryFunction(e20) {
    this.serialize(e20);
  }
  serializeForScriptFunction(e20) {
    e20.serializeU32AsUleb128(9), this.serialize(e20);
  }
  static deserialize(e20) {
    return new i18(e20.deserializeBytes());
  }
  toMoveVector(e20) {
    let r18 = new a11(this.bcsToBytes());
    r18.deserializeUleb128AsU32();
    let n94 = r18.deserializeVector(e20);
    return new t3(n94);
  }
};
var a13 = class i19 extends B2 {
  constructor(e20) {
    super(), this.value = e20;
  }
  serialize(e20) {
    e20.serializeStr(this.value);
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  serializeForScriptFunction(e20) {
    let n94 = new TextEncoder().encode(this.value);
    t3.U8(n94).serializeForScriptFunction(e20);
  }
  static deserialize(e20) {
    return new i19(e20.deserializeStr());
  }
};
var A8 = class i20 extends B2 {
  constructor(e20) {
    super(), typeof e20 < "u" && e20 !== null ? this.vec = new t3([e20]) : this.vec = new t3([]), [this.value] = this.vec.values;
  }
  serializeForEntryFunction(e20) {
    let r18 = this.bcsToBytes();
    e20.serializeBytes(r18);
  }
  unwrap() {
    if (this.isSome()) return this.vec.values[0];
    throw new Error("Called unwrap on a MoveOption with no value");
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(e20) {
    this.vec.serialize(e20);
  }
  static U8(e20) {
    return new i20(e20 != null ? new p4(e20) : void 0);
  }
  static U16(e20) {
    return new i20(e20 != null ? new b2(e20) : void 0);
  }
  static U32(e20) {
    return new i20(e20 != null ? new y5(e20) : void 0);
  }
  static U64(e20) {
    return new i20(e20 != null ? new m7(e20) : void 0);
  }
  static U128(e20) {
    return new i20(e20 != null ? new B4(e20) : void 0);
  }
  static U256(e20) {
    return new i20(e20 != null ? new a12(e20) : void 0);
  }
  static Bool(e20) {
    return new i20(e20 != null ? new U5(e20) : void 0);
  }
  static MoveString(e20) {
    return new i20(e20 != null ? new a13(e20) : void 0);
  }
  static deserialize(e20, r18) {
    let n94 = t3.deserialize(e20, r18);
    return new i20(n94.values[0]);
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2XQKGWHQ.mjs
var c4 = class extends B2 {
  constructor(e20) {
    super();
    this.accountAddress = l3.ONE;
    this.moduleName = new a13("account");
    this.structName = new a13("RotationProofChallenge");
    this.sequenceNumber = new m7(e20.sequenceNumber), this.originator = e20.originator, this.currentAuthKey = e20.currentAuthKey, this.newPublicKey = t3.U8(e20.newPublicKey.toUint8Array());
  }
  serialize(e20) {
    e20.serialize(this.accountAddress), e20.serialize(this.moduleName), e20.serialize(this.structName), e20.serialize(this.sequenceNumber), e20.serialize(this.originator), e20.serialize(this.currentAuthKey), e20.serialize(this.newPublicKey);
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XKUIMGKU.mjs
var r7 = class a14 extends B2 {
  constructor(e20) {
    super(), this.chainId = e20;
  }
  serialize(e20) {
    e20.serializeU8(this.chainId);
  }
  static deserialize(e20) {
    let s11 = e20.deserializeU8();
    return new a14(s11);
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-N6YTF76Q.mjs
var r8 = class t4 extends B2 {
  constructor(i27) {
    super(), this.identifier = i27;
  }
  serialize(i27) {
    i27.serializeStr(this.identifier);
  }
  static deserialize(i27) {
    let s11 = i27.deserializeStr();
    return new t4(s11);
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QREVMGQZ.mjs
function i21(a24, t18) {
  if (!(a24.getTransactionSubmitter() !== void 0 || t18.transactionSubmitter !== void 0) && t18.transaction.feePayerAddress && !t18.feePayerAuthenticator) throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
}
function o8(a24, t18, n94) {
  let e20 = n94.value;
  return n94.value = async function(...r18) {
    return e20.apply(this, r18);
  }, n94;
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UL777LTI.mjs
var i22 = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var a15 = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
  subdomain_expiration_policy
  domain_expiration_timestamp
}
    `;
var n13 = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var _5 = `
    query getAccountAddressesForAuthKey($where_condition: auth_key_account_addresses_bool_exp, $order_by: [auth_key_account_addresses_order_by!]) {
  auth_key_account_addresses(where: $where_condition, order_by: $order_by) {
    auth_key
    account_address
    last_transaction_version
    is_auth_key_used
  }
}
    `;
var u6 = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var c5 = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var d5 = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var y6 = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${n13}`;
var l7 = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${n13}`;
var p6 = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${n13}`;
var m8 = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var g3 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var b3 = `
    query getAuthKeysForPublicKey($where_condition: public_key_auth_keys_bool_exp, $order_by: [public_key_auth_keys_order_by!]) {
  public_key_auth_keys(where: $where_condition, order_by: $order_by) {
    public_key
    public_key_type
    auth_key
    account_public_key
    last_transaction_version
    is_public_key_used
    signature_type
  }
}
    `;
var T4 = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var k3 = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    uri
    total_minted_v2
    token_standard
    table_handle_v1
    mutable_uri
    mutable_description
    max_supply
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    cdn_asset_uris {
      cdn_image_uri
      asset_uri
      animation_optimizer_retry_count
      cdn_animation_uri
      cdn_json_uri
      image_optimizer_retry_count
      json_parser_retry_count
      raw_animation_uri
      raw_image_uri
    }
  }
}
    `;
var $2 = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var h7 = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var f7 = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `;
var A9 = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var G = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
    supply_v2
    maximum_v2
  }
}
    `;
var w3 = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${a15}`;
var q2 = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var v3 = `
    query getObjectData($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var C2 = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `;
var Q = `
    query getTableItemsData($where_condition: table_items_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_items_order_by!]) {
  table_items(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    decoded_key
    decoded_value
    key
    table_handle
    transaction_version
    write_set_change_index
  }
}
    `;
var x3 = `
    query getTableItemsMetadata($where_condition: table_metadatas_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_metadatas_order_by!]) {
  table_metadatas(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    handle
    key_type
    value_type
  }
}
    `;
var F = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${i22}`;
var D2 = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${n13}`;
var O3 = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QVLV73OB.mjs
async function o9(e20) {
  let { type: t18, originMethod: s11, path: i27, body: r18, acceptType: R6, contentType: f13, params: c7, aptosConfig: n94, overrides: A15 } = e20, d15 = n94.getRequestUrl(t18);
  return P2({ url: d15, method: "POST", originMethod: s11, path: i27, body: r18, contentType: f13, acceptType: R6, params: c7, overrides: A15 }, n94, e20.type);
}
async function q3(e20) {
  let { aptosConfig: t18 } = e20;
  return o9({ ...e20, type: "Fullnode", overrides: { ...t18.clientConfig, ...t18.fullnodeConfig, ...e20.overrides, HEADERS: { ...t18.clientConfig?.HEADERS, ...t18.fullnodeConfig?.HEADERS } } });
}
async function C3(e20) {
  let { aptosConfig: t18 } = e20;
  return o9({ ...e20, type: "Indexer", overrides: { ...t18.clientConfig, ...t18.indexerConfig, ...e20.overrides, HEADERS: { ...t18.clientConfig?.HEADERS, ...t18.indexerConfig?.HEADERS } } });
}
async function E4(e20) {
  let { aptosConfig: t18 } = e20, s11 = { ...t18, clientConfig: { ...t18.clientConfig } };
  return delete s11?.clientConfig?.API_KEY, o9({ ...e20, type: "Faucet", overrides: { ...s11.clientConfig, ...s11.faucetConfig, ...e20.overrides, HEADERS: { ...s11.clientConfig?.HEADERS, ...s11.faucetConfig?.HEADERS } } });
}
async function a16(e20) {
  return o9({ ...e20, type: "Pepper" });
}
async function m9(e20) {
  return o9({ ...e20, type: "Prover" });
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-TZRRQMCT.mjs
async function d6(o26) {
  let { aptosConfig: s11 } = o26, { data: e20 } = await y2({ aptosConfig: s11, originMethod: "getLedgerInfo", path: "" });
  return e20;
}
async function C4(o26) {
  let { aptosConfig: s11, limit: e20 } = o26;
  return (await a17({ aptosConfig: s11, query: { query: T4, variables: { limit: e20 } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
}
async function a17(o26) {
  let { aptosConfig: s11, query: e20, originMethod: t18 } = o26, { data: r18 } = await C3({ aptosConfig: s11, originMethod: t18 ?? "queryIndexer", path: "", body: e20, overrides: { WITH_CREDENTIALS: false } });
  return r18;
}
async function u7(o26) {
  let { aptosConfig: s11 } = o26;
  return (await a17({ aptosConfig: s11, query: { query: C2 }, originMethod: "getProcessorStatuses" })).processor_status;
}
async function h8(o26) {
  let s11 = await u7({ aptosConfig: o26.aptosConfig });
  return BigInt(s11[0].last_success_version);
}
async function T5(o26) {
  let { aptosConfig: s11, processorType: e20 } = o26;
  return (await a17({ aptosConfig: s11, query: { query: C2, variables: { where_condition: { processor: { _eq: e20 } } } }, originMethod: "getProcessorStatus" })).processor_status[0];
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JEEUU42Q.mjs
async function b4(t18) {
  let { aptosConfig: a24, handle: e20, data: o26, options: r18 } = t18;
  return (await q3({ aptosConfig: a24, originMethod: "getTableItem", path: `tables/${e20}/item`, params: { ledger_version: r18?.ledgerVersion }, body: o26 })).data;
}
async function f8(t18) {
  let { aptosConfig: a24, options: e20 } = t18, o26 = { query: Q, variables: { where_condition: e20?.where, offset: e20?.offset, limit: e20?.limit, order_by: e20?.orderBy } };
  return (await a17({ aptosConfig: a24, query: o26, originMethod: "getTableItemsData" })).table_items;
}
async function T6(t18) {
  let { aptosConfig: a24, options: e20 } = t18, o26 = { query: x3, variables: { where_condition: e20?.where, offset: e20?.offset, limit: e20?.limit, order_by: e20?.orderBy } };
  return (await a17({ aptosConfig: a24, query: o26, originMethod: "getTableItemsMetadata" })).table_metadatas;
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JCFTAG5Z.mjs
var t5 = ((S4) => (S4.FULLNODE = "Fullnode", S4.INDEXER = "Indexer", S4.FAUCET = "Faucet", S4.PEPPER = "Pepper", S4.PROVER = "Prover", S4))(t5 || {});
var n14 = "0x1::aptos_coin::AptosCoin";
var A10 = "0x000000000000000000000000000000000000000000000000000000000000000a";
var T7 = "APTOS::RawTransaction";
var a18 = "APTOS::RawTransactionWithData";
var O4 = ((_8) => (_8.ACCOUNT_RESTORATION_PROCESSOR = "account_restoration_processor", _8.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", _8.DEFAULT = "default_processor", _8.EVENTS_PROCESSOR = "events_processor", _8.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", _8.STAKE_PROCESSOR = "stake_processor", _8.TOKEN_V2_PROCESSOR = "token_v2_processor", _8.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", _8.OBJECT_PROCESSOR = "objects_processor", _8))(O4 || {});
var r9 = /^https:\/\/securetoken\.google\.com\/[a-zA-Z0-9-_]+$/;

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DAGUHPTV.mjs
async function H(o26) {
  let { aptosConfig: n94, options: t18 } = o26;
  return q({ aptosConfig: n94, originMethod: "getTransactions", path: "transactions", params: { start: t18?.offset, limit: t18?.limit } });
}
async function W3(o26) {
  let { aptosConfig: n94 } = o26;
  return m(async () => {
    let { data: t18 } = await y2({ aptosConfig: n94, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
    return t18;
  }, `gas-price-${n94.network}`, 1e3 * 60 * 5)();
}
async function O5(o26) {
  let { aptosConfig: n94, ledgerVersion: t18 } = o26, { data: s11 } = await y2({ aptosConfig: n94, originMethod: "getTransactionByVersion", path: `transactions/by_version/${t18}` });
  return s11;
}
async function y7(o26) {
  let { aptosConfig: n94, transactionHash: t18 } = o26, { data: s11 } = await y2({ aptosConfig: n94, path: `transactions/by_hash/${t18}`, originMethod: "getTransactionByHash" });
  return s11;
}
async function q4(o26) {
  let { aptosConfig: n94, transactionHash: t18 } = o26;
  try {
    return (await y7({ aptosConfig: n94, transactionHash: t18 })).type === "pending_transaction";
  } catch (s11) {
    if (s11?.status === 404) return true;
    throw s11;
  }
}
async function R(o26) {
  let { aptosConfig: n94, transactionHash: t18 } = o26, { data: s11 } = await y2({ aptosConfig: n94, path: `transactions/wait_by_hash/${t18}`, originMethod: "longWaitForTransaction" });
  return s11;
}
async function z4(o26) {
  let { aptosConfig: n94, transactionHash: t18, options: s11 } = o26, r18 = s11?.timeoutSecs ?? 20, u9 = s11?.checkSuccess ?? true, e20 = true, p11 = 0, i27, g5, l14 = 200, h10 = 1.5;
  function c7(a24) {
    if (!(a24 instanceof T) || (g5 = a24, a24.status !== 404 && a24.status >= 400 && a24.status < 500)) throw a24;
  }
  try {
    i27 = await y7({ aptosConfig: n94, transactionHash: t18 }), e20 = i27.type === "pending_transaction";
  } catch (a24) {
    c7(a24);
  }
  if (e20) {
    let a24 = Date.now();
    try {
      i27 = await R({ aptosConfig: n94, transactionHash: t18 }), e20 = i27.type === "pending_transaction";
    } catch (w5) {
      c7(w5);
    }
    p11 = (Date.now() - a24) / 1e3;
  }
  for (; e20 && !(p11 >= r18); ) {
    try {
      if (i27 = await y7({ aptosConfig: n94, transactionHash: t18 }), e20 = i27.type === "pending_transaction", !e20) break;
    } catch (a24) {
      c7(a24);
    }
    await f2(l14), p11 += l14 / 1e3, l14 *= h10;
  }
  if (i27 === void 0) throw g5 || new m10(`Fetching transaction ${t18} failed and timed out after ${r18} seconds`, i27);
  if (i27.type === "pending_transaction") throw new m10(`Transaction ${t18} timed out in pending state after ${r18} seconds`, i27);
  if (!u9) return i27;
  if (!i27.success) throw new T8(`Transaction ${t18} failed with an error: ${i27.vm_status}`, i27);
  return i27;
}
async function U6(o26) {
  let { aptosConfig: n94, processorType: t18 } = o26, s11 = BigInt(o26.minimumLedgerVersion), r18 = 3e3, u9 = (/* @__PURE__ */ new Date()).getTime(), e20 = BigInt(-1);
  for (; e20 < s11; ) {
    if ((/* @__PURE__ */ new Date()).getTime() - u9 > r18) throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    if (t18 === void 0 ? e20 = await h8({ aptosConfig: n94 }) : e20 = (await T5({ aptosConfig: n94, processorType: t18 })).last_success_version, e20 >= s11) break;
    await f2(200);
  }
}
var m10 = class extends Error {
  constructor(n94, t18) {
    super(n94), this.lastSubmittedTransaction = t18;
  }
};
var T8 = class extends Error {
  constructor(n94, t18) {
    super(n94), this.transaction = t18;
  }
};
async function X(o26) {
  let { aptosConfig: n94, ledgerVersion: t18, options: s11 } = o26, { data: r18 } = await y2({ aptosConfig: n94, originMethod: "getBlockByVersion", path: `blocks/by_version/${t18}`, params: { with_transactions: s11?.withTransactions } });
  return P4({ block: r18, ...o26 });
}
async function j2(o26) {
  let { aptosConfig: n94, blockHeight: t18, options: s11 } = o26, { data: r18 } = await y2({ aptosConfig: n94, originMethod: "getBlockByHeight", path: `blocks/by_height/${t18}`, params: { with_transactions: s11?.withTransactions } });
  return P4({ block: r18, ...o26 });
}
async function P4(o26) {
  let { aptosConfig: n94, block: t18, options: s11 } = o26;
  if (s11?.withTransactions) {
    t18.transactions = t18.transactions ?? [];
    let r18 = t18.transactions[t18.transactions.length - 1], u9 = BigInt(t18.first_version), e20 = BigInt(t18.last_version), p11 = r18?.version, i27;
    if (p11 === void 0 ? i27 = u9 - 1n : i27 = BigInt(p11), i27 === e20) return t18;
    let g5 = [], l14 = 100n;
    for (let c7 = i27 + 1n; c7 < e20; c7 += BigInt(100)) g5.push(H({ aptosConfig: n94, options: { offset: c7, limit: Math.min(Number(l14), Number(e20 - c7 + 1n)) } }));
    let h10 = await Promise.all(g5);
    for (let c7 of h10) t18.transactions.push(...c7);
  }
  return t18;
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XZQAMU5W.mjs
async function i23(o26) {
  o26.minimumLedgerVersion !== void 0 && await U6({ aptosConfig: o26.config, minimumLedgerVersion: o26.minimumLedgerVersion, processorType: o26.processorType });
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GMEBV7NZ.mjs
var a19 = class {
  constructor(e20) {
    this.config = e20;
  }
  async getTableItem(e20) {
    return b4({ aptosConfig: this.config, ...e20 });
  }
  async getTableItemsData(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "default_processor" }), f8({ aptosConfig: this.config, ...e20 });
  }
  async getTableItemsMetadata(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "default_processor" }), T6({ aptosConfig: this.config, ...e20 });
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CW35YAMN.mjs
function t6(i27, r18) {
  let l14 = r18.bcsToBytes(), a24 = new a11(l14);
  return i27.deserialize(a24);
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4RXKALLC.mjs
var s7 = { mainnet: "https://api.mainnet.aptoslabs.com/v1/graphql", testnet: "https://api.testnet.aptoslabs.com/v1/graphql", devnet: "https://api.devnet.aptoslabs.com/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" };
var o11 = { mainnet: "https://api.mainnet.aptoslabs.com/v1", testnet: "https://api.testnet.aptoslabs.com/v1", devnet: "https://api.devnet.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" };
var p7 = { devnet: "https://faucet.devnet.aptoslabs.com", local: "http://127.0.0.1:8081" };
var a20 = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/pepper/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/pepper/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/pepper/v0", local: "https://api.devnet.aptoslabs.com/keyless/pepper/v0" };
var n15 = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/prover/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/prover/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/prover/v0", local: "https://api.devnet.aptoslabs.com/keyless/prover/v0" };
var e7 = ((t18) => (t18.MAINNET = "mainnet", t18.TESTNET = "testnet", t18.DEVNET = "devnet", t18.LOCAL = "local", t18.CUSTOM = "custom", t18))(e7 || {});
var r10 = { mainnet: 1, testnet: 2, local: 4 };

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/aptos-client/dist/browser/index.browser.mjs
async function aptosClient(options) {
  return jsonRequest(options);
}
async function jsonRequest(options) {
  const { requestUrl, requestConfig } = buildRequest(options);
  const res = await fetch(requestUrl, requestConfig);
  const data = await res.json();
  return {
    status: res.status,
    statusText: res.statusText,
    data,
    headers: res.headers,
    config: requestConfig
  };
}
function buildRequest(options) {
  var _a2, _b, _c;
  const headers = new Headers();
  Object.entries((_a2 = options == null ? void 0 : options.headers) != null ? _a2 : {}).forEach(([key, value]) => {
    headers.append(key, String(value));
  });
  const body = options.body instanceof Uint8Array ? options.body : JSON.stringify(options.body);
  const withCredentialsOption = (_b = options.overrides) == null ? void 0 : _b.WITH_CREDENTIALS;
  let credentials;
  if (withCredentialsOption === false) {
    credentials = "omit";
  } else if (withCredentialsOption === true) {
    credentials = "include";
  } else {
    credentials = withCredentialsOption != null ? withCredentialsOption : "include";
  }
  const requestConfig = {
    method: options.method,
    headers,
    body,
    credentials
  };
  const params = new URLSearchParams();
  Object.entries((_c = options.params) != null ? _c : {}).forEach(([key, value]) => {
    if (value !== void 0) {
      params.append(key, String(value));
    }
  });
  const requestUrl = options.url + (params.size > 0 ? `?${params.toString()}` : "");
  return { requestUrl, requestConfig };
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Y7ZQTLH4.mjs
var a21 = class {
  constructor(e20) {
    if (e20?.fullnode || e20?.indexer || e20?.faucet || e20?.pepper || e20?.prover) {
      if (e20?.network === "custom") console.info("Note: using CUSTOM network will require queries to lookup ChainId");
      else if (!e20?.network) throw new Error("Custom endpoints require a network to be specified");
    }
    this.network = e20?.network ?? "devnet", this.fullnode = e20?.fullnode, this.faucet = e20?.faucet, this.pepper = e20?.pepper, this.prover = e20?.prover, this.indexer = e20?.indexer, this.client = e20?.client ?? { provider: aptosClient }, this.clientConfig = e20?.clientConfig ?? {}, this.fullnodeConfig = e20?.fullnodeConfig ?? {}, this.indexerConfig = e20?.indexerConfig ?? {}, this.faucetConfig = e20?.faucetConfig ?? {}, this.transactionGenerationConfig = e20?.transactionGenerationConfig ?? {}, this.pluginConfig = e20?.pluginSettings ? { ...e20.pluginSettings, IGNORE_TRANSACTION_SUBMITTER: false } : void 0;
  }
  getRequestUrl(e20) {
    switch (e20) {
      case "Fullnode":
        if (this.fullnode !== void 0) return this.fullnode;
        if (this.network === "custom") throw new Error("Please provide a custom full node url");
        return o11[this.network];
      case "Faucet":
        if (this.faucet !== void 0) return this.faucet;
        if (this.network === "testnet") throw new Error("There is no way to programmatically mint testnet APT, you must use the minting site at https://aptos.dev/network/faucet");
        if (this.network === "mainnet") throw new Error("There is no mainnet faucet");
        if (this.network === "custom") throw new Error("Please provide a custom faucet url");
        return p7[this.network];
      case "Indexer":
        if (this.indexer !== void 0) return this.indexer;
        if (this.network === "custom") throw new Error("Please provide a custom indexer url");
        return s7[this.network];
      case "Pepper":
        if (this.pepper !== void 0) return this.pepper;
        if (this.network === "custom") throw new Error("Please provide a custom pepper service url");
        return a20[this.network];
      case "Prover":
        if (this.prover !== void 0) return this.prover;
        if (this.network === "custom") throw new Error("Please provide a custom prover service url");
        return n15[this.network];
      default:
        throw Error(`apiType ${e20} is not supported`);
    }
  }
  isPepperServiceRequest(e20) {
    return a20[this.network] === e20;
  }
  isProverServiceRequest(e20) {
    return n15[this.network] === e20;
  }
  getDefaultMaxGasAmount() {
    return this.transactionGenerationConfig?.defaultMaxGasAmount ?? 2e5;
  }
  getDefaultTxnExpirySecFromNow() {
    return this.transactionGenerationConfig?.defaultTxnExpirySecFromNow ?? 20;
  }
  setIgnoreTransactionSubmitter(e20) {
    this.pluginConfig && (this.pluginConfig.IGNORE_TRANSACTION_SUBMITTER = e20);
  }
  getTransactionSubmitter() {
    if (this.pluginConfig !== void 0 && this.pluginConfig.IGNORE_TRANSACTION_SUBMITTER !== true) return this.pluginConfig.TRANSACTION_SUBMITTER;
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MT2RJ7H3.mjs
var t7 = class a22 extends B2 {
  constructor(e20) {
    super(), this.value = a3.fromHexInput(e20).toUint8Array();
  }
  serialize(e20) {
    e20.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(e20) {
    e20.serialize(this);
  }
  serializeForScriptFunction(e20) {
    e20.serialize(this);
  }
  static deserialize(e20, s11) {
    let o26 = e20.deserializeFixedBytes(s11);
    return new a22(o26);
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-TOBQ5UE6.mjs
var t8 = class l8 extends B2 {
  constructor(e20) {
    super(), this.value = new t7(e20);
  }
  serialize(e20) {
    e20.serialize(this.value);
  }
  serializeForEntryFunction(e20) {
    e20.serializeU32AsUleb128(this.value.value.length), e20.serialize(this);
  }
  static deserialize(e20, s11) {
    let a24 = t7.deserialize(e20, s11);
    return new l8(a24.value);
  }
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IJE2LVZG.mjs
var u8 = ((e20) => (e20.JSON = "application/json", e20.BCS = "application/x-bcs", e20.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", e20.BCS_VIEW_FUNCTION = "application/x.aptos.view_function+bcs", e20))(u8 || {});
var y8 = ((n94) => (n94[n94.Bool = 0] = "Bool", n94[n94.U8 = 1] = "U8", n94[n94.U64 = 2] = "U64", n94[n94.U128 = 3] = "U128", n94[n94.Address = 4] = "Address", n94[n94.Signer = 5] = "Signer", n94[n94.Vector = 6] = "Vector", n94[n94.Struct = 7] = "Struct", n94[n94.U16 = 8] = "U16", n94[n94.U32 = 9] = "U32", n94[n94.U256 = 10] = "U256", n94[n94.Reference = 254] = "Reference", n94[n94.Generic = 255] = "Generic", n94))(y8 || {});
var d7 = ((s11) => (s11[s11.U8 = 0] = "U8", s11[s11.U64 = 1] = "U64", s11[s11.U128 = 2] = "U128", s11[s11.Address = 3] = "Address", s11[s11.U8Vector = 4] = "U8Vector", s11[s11.Bool = 5] = "Bool", s11[s11.U16 = 6] = "U16", s11[s11.U32 = 7] = "U32", s11[s11.U256 = 8] = "U256", s11[s11.Serialized = 9] = "Serialized", s11))(d7 || {});
var c6 = ((e20) => (e20[e20.Script = 0] = "Script", e20[e20.EntryFunction = 2] = "EntryFunction", e20[e20.Multisig = 3] = "Multisig", e20[e20.Payload = 4] = "Payload", e20))(c6 || {});
var l9 = ((o26) => (o26[o26.V1 = 0] = "V1", o26))(l9 || {});
var _6 = ((i27) => (i27[i27.Script = 0] = "Script", i27[i27.EntryFunction = 1] = "EntryFunction", i27[i27.Empty = 2] = "Empty", i27))(_6 || {});
var x4 = ((o26) => (o26[o26.V1 = 0] = "V1", o26))(x4 || {});
var h9 = ((p11) => (p11[p11.MultiAgentTransaction = 0] = "MultiAgentTransaction", p11[p11.FeePayerTransaction = 1] = "FeePayerTransaction", p11))(h9 || {});
var m11 = ((r18) => (r18[r18.Ed25519 = 0] = "Ed25519", r18[r18.MultiEd25519 = 1] = "MultiEd25519", r18[r18.MultiAgent = 2] = "MultiAgent", r18[r18.FeePayer = 3] = "FeePayer", r18[r18.SingleSender = 4] = "SingleSender", r18))(m11 || {});
var v4 = ((a24) => (a24[a24.Ed25519 = 0] = "Ed25519", a24[a24.MultiEd25519 = 1] = "MultiEd25519", a24[a24.SingleKey = 2] = "SingleKey", a24[a24.MultiKey = 3] = "MultiKey", a24[a24.NoAccountAuthenticator = 4] = "NoAccountAuthenticator", a24[a24.Abstraction = 5] = "Abstraction", a24))(v4 || {});
var S3 = ((p11) => (p11.Ed25519 = "ed25519", p11.Secp256k1 = "secp256k1", p11))(S3 || {});
var R3 = ((e20) => (e20[e20.Ed25519 = 0] = "Ed25519", e20[e20.Secp256k1 = 1] = "Secp256k1", e20[e20.Keyless = 3] = "Keyless", e20[e20.FederatedKeyless = 4] = "FederatedKeyless", e20))(R3 || {});
function B5(t18) {
  switch (t18) {
    case 0:
      return "ed25519";
    case 1:
      return "secp256k1";
    case 3:
      return "keyless";
    case 4:
      return "federated_keyless";
    default:
      throw new Error("Unknown public key variant");
  }
}
var b5 = ((i27) => (i27[i27.Ed25519 = 0] = "Ed25519", i27[i27.Secp256k1 = 1] = "Secp256k1", i27[i27.Keyless = 3] = "Keyless", i27))(b5 || {});
var M3 = ((o26) => (o26[o26.Ed25519 = 0] = "Ed25519", o26))(M3 || {});
var k4 = ((o26) => (o26[o26.Ed25519 = 0] = "Ed25519", o26))(k4 || {});
var f9 = ((o26) => (o26[o26.ZkProof = 0] = "ZkProof", o26))(f9 || {});
var C5 = ((o26) => (o26[o26.Groth16 = 0] = "Groth16", o26))(C5 || {});
var T9 = ((g5) => (g5.Pending = "pending_transaction", g5.User = "user_transaction", g5.Genesis = "genesis_transaction", g5.BlockMetadata = "block_metadata_transaction", g5.StateCheckpoint = "state_checkpoint_transaction", g5.Validator = "validator_transaction", g5.BlockEpilogue = "block_epilogue_transaction", g5))(T9 || {});
var E6 = ((i27) => (i27.PRIVATE = "private", i27.PUBLIC = "public", i27.FRIEND = "friend", i27))(E6 || {});
var U7 = ((e20) => (e20.STORE = "store", e20.DROP = "drop", e20.KEY = "key", e20.COPY = "copy", e20))(U7 || {});
var I3 = ((p11) => (p11.VALIDATOR = "validator", p11.FULL_NODE = "full_node", p11))(I3 || {});
var W4 = ((e20) => (e20[e20.Ed25519 = 0] = "Ed25519", e20[e20.MultiEd25519 = 1] = "MultiEd25519", e20[e20.SingleKey = 2] = "SingleKey", e20[e20.MultiKey = 3] = "MultiKey", e20))(W4 || {});
var F2 = ((p11) => (p11[p11.Ed25519 = 0] = "Ed25519", p11[p11.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", p11))(F2 || {});
var A11 = ((r18) => (r18[r18.DeriveAuid = 251] = "DeriveAuid", r18[r18.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", r18[r18.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", r18[r18.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", r18[r18.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", r18))(A11 || {});

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GXDOOLCG.mjs
var V2 = class n16 extends n6 {
  constructor(e20, t18) {
    super(), this.jwkAddress = l3.from(e20), this.keylessPublicKey = t18;
  }
  authKey() {
    let e20 = new n4();
    return e20.serializeU32AsUleb128(4), e20.serializeFixedBytes(this.bcsToBytes()), s4.fromSchemeAndBytes({ scheme: 2, input: e20.toUint8Array() });
  }
  verifySignature(e20) {
    try {
      return zn({ ...e20, publicKey: this }), true;
    } catch {
      return false;
    }
  }
  serialize(e20) {
    this.jwkAddress.serialize(e20), this.keylessPublicKey.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = l3.deserialize(e20), r18 = v5.deserialize(e20);
    return new n16(t18, r18);
  }
  static isPublicKey(e20) {
    return e20 instanceof n16;
  }
  async verifySignatureAsync(e20) {
    return Cr({ ...e20, publicKey: this });
  }
  static create(e20) {
    return new n16(e20.jwkAddress, v5.create(e20));
  }
  static fromJwtAndPepper(e20) {
    return new n16(e20.jwkAddress, v5.fromJwtAndPepper(e20));
  }
  static isInstance(e20) {
    return "jwkAddress" in e20 && e20.jwkAddress instanceof l3 && "keylessPublicKey" in e20 && e20.keylessPublicKey instanceof v5;
  }
};
var E7 = class n17 extends n6 {
  constructor(e20) {
    if (super(), this.publicKey = e20, e20 instanceof f6) this.variant = 0;
    else if (e20 instanceof m4) this.variant = 1;
    else if (e20 instanceof v5) this.variant = 3;
    else if (e20 instanceof V2) this.variant = 4;
    else throw new Error("Unsupported public key type");
  }
  verifySignature(e20) {
    let { message: t18, signature: r18 } = e20;
    if (this.publicKey instanceof v5) throw new Error("Use verifySignatureAsync to verify Keyless signatures");
    return this.publicKey.verifySignature({ message: t18, signature: r18.signature });
  }
  async verifySignatureAsync(e20) {
    if (!(e20.signature instanceof U8)) {
      if (e20.options?.throwErrorWithReason) throw new Error("Signature must be an instance of AnySignature");
      return false;
    }
    return await this.publicKey.verifySignatureAsync({ ...e20, signature: e20.signature.signature });
  }
  authKey() {
    return s4.fromSchemeAndBytes({ scheme: 2, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(this.variant), this.publicKey.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32(), r18;
    switch (t18) {
      case 0:
        r18 = f6.deserialize(e20);
        break;
      case 1:
        r18 = m4.deserialize(e20);
        break;
      case 3:
        r18 = v5.deserialize(e20);
        break;
      case 4:
        r18 = V2.deserialize(e20);
        break;
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${t18}`);
    }
    return new n17(r18);
  }
  static isPublicKey(e20) {
    return e20 instanceof n17;
  }
  isEd25519() {
    return this.publicKey instanceof f6;
  }
  isSecp256k1PublicKey() {
    return this.publicKey instanceof m4;
  }
  static isInstance(e20) {
    return "publicKey" in e20 && "variant" in e20;
  }
};
var U8 = class n18 extends o7 {
  constructor(e20) {
    if (super(), this.signature = e20, e20 instanceof h6) this.variant = 0;
    else if (e20 instanceof l5) this.variant = 1;
    else if (e20 instanceof ee) this.variant = 3;
    else throw new Error("Unsupported signature type");
  }
  toUint8Array() {
    return console.warn("[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. Use AnySignature.bcsToBytes() instead."), this.bcsToBytes();
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(this.variant), this.signature.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32(), r18;
    switch (t18) {
      case 0:
        r18 = h6.deserialize(e20);
        break;
      case 1:
        r18 = l5.deserialize(e20);
        break;
      case 3:
        r18 = ee.deserialize(e20);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${t18}`);
    }
    return new n18(r18);
  }
  static isInstance(e20) {
    return "signature" in e20 && typeof e20.signature == "object" && e20.signature !== null && "toUint8Array" in e20.signature;
  }
};
function ea(n94) {
  let e20 = n94;
  return e20 -= e20 >> 1 & 1431655765, e20 = (e20 & 858993459) + (e20 >> 2 & 858993459), (e20 + (e20 >> 4) & 252645135) * 16843009 >> 24;
}
var Nn = 3;
var we = class extends n6 {
  constructor(e20) {
    super(), this.publicKeys = e20.publicKeys;
  }
  createBitmap(e20) {
    let { bits: t18 } = e20, r18 = 128, i27 = new Uint8Array([0, 0, 0, 0]), o26 = /* @__PURE__ */ new Set();
    return t18.forEach((s11, a24) => {
      if (a24 + 1 > this.publicKeys.length) throw new Error(`Signature index ${a24 + 1} is out of public keys range, ${this.publicKeys.length}.`);
      if (o26.has(s11)) throw new Error(`Duplicate bit ${s11} detected.`);
      o26.add(s11);
      let c7 = Math.floor(s11 / 8), d15 = i27[c7];
      d15 |= r18 >> s11 % 8, i27[c7] = d15;
    }), i27;
  }
  getIndex(e20) {
    let t18 = this.publicKeys.findIndex((r18) => r18.toString() === e20.toString());
    if (t18 !== -1) return t18;
    throw new Error(`Public key ${e20} not found in multi key set ${this.publicKeys}`);
  }
};
var W5 = class n19 extends we {
  constructor(e20) {
    let { publicKeys: t18, signaturesRequired: r18 } = e20;
    if (super({ publicKeys: t18 }), r18 < 1) throw new Error("The number of required signatures needs to be greater than 0");
    if (t18.length < r18) throw new Error(`Provided ${t18.length} public keys is smaller than the ${r18} required signatures`);
    if (this.publicKeys = t18.map((i27) => i27 instanceof E7 ? i27 : new E7(i27)), r18 > Nn && this.publicKeys.filter((o26) => o26.variant === 3 || o26.variant === 4).length > Nn) throw new Error(`Construction of MultiKey with more than ${Nn} keyless public keys is not allowed when signaturesRequired 
          is greater than ${Nn}. This is because a maximum of 3 keyless signatures are supported for a 
          K-of-N MultiKey transaction.`);
    this.signaturesRequired = r18;
  }
  getSignaturesRequired() {
    return this.signaturesRequired;
  }
  verifySignature(e20) {
    let { message: t18, signature: r18 } = e20;
    if (r18.signatures.length !== this.signaturesRequired) throw new Error("The number of signatures does not match the number of required signatures");
    let i27 = r18.bitMapToSignerIndices();
    for (let o26 = 0; o26 < r18.signatures.length; o26 += 1) {
      let s11 = r18.signatures[o26];
      if (!this.publicKeys[i27[o26]].verifySignature({ message: t18, signature: s11 })) return false;
    }
    return true;
  }
  async verifySignatureAsync(e20) {
    let { signature: t18 } = e20;
    try {
      if (!(t18 instanceof me)) throw new Error("Signature is not a MultiKeySignature");
      if (t18.signatures.length !== this.signaturesRequired) throw new Error("The number of signatures does not match the number of required signatures");
      let r18 = t18.bitMapToSignerIndices();
      for (let i27 = 0; i27 < t18.signatures.length; i27 += 1) {
        let o26 = t18.signatures[i27];
        if (!await this.publicKeys[r18[i27]].verifySignatureAsync({ ...e20, signature: o26 })) return false;
      }
      return true;
    } catch (r18) {
      if (e20.options?.throwErrorWithReason) throw r18;
      return false;
    }
  }
  authKey() {
    return s4.fromSchemeAndBytes({ scheme: 3, input: this.toUint8Array() });
  }
  serialize(e20) {
    e20.serializeVector(this.publicKeys), e20.serializeU8(this.signaturesRequired);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeVector(E7), r18 = e20.deserializeU8();
    return new n19({ publicKeys: t18, signaturesRequired: r18 });
  }
  getIndex(e20) {
    let t18 = e20 instanceof E7 ? e20 : new E7(e20);
    return super.getIndex(t18);
  }
  static isInstance(e20) {
    return "publicKeys" in e20 && "signaturesRequired" in e20;
  }
};
var oe = class oe2 extends o7 {
  constructor(e20) {
    super();
    let { signatures: t18, bitmap: r18 } = e20;
    if (t18.length > oe2.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${oe2.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = t18.map((o26) => o26 instanceof U8 ? o26 : new U8(o26)), !(r18 instanceof Uint8Array)) this.bitmap = oe2.createBitmap({ bits: r18 });
    else {
      if (r18.length !== oe2.BITMAP_LEN) throw new Error(`"bitmap" length should be ${oe2.BITMAP_LEN}`);
      this.bitmap = r18;
    }
    let i27 = this.bitmap.reduce((o26, s11) => o26 + ea(s11), 0);
    if (i27 !== this.signatures.length) throw new Error(`Expecting ${i27} signatures from the bitmap, but got ${this.signatures.length}`);
  }
  static createBitmap(e20) {
    let { bits: t18 } = e20, r18 = 128, i27 = new Uint8Array([0, 0, 0, 0]), o26 = /* @__PURE__ */ new Set();
    return t18.forEach((s11) => {
      if (s11 >= oe2.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${oe2.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (o26.has(s11)) throw new Error("Duplicate bits detected.");
      o26.add(s11);
      let a24 = Math.floor(s11 / 8), c7 = i27[a24];
      c7 |= r18 >> s11 % 8, i27[a24] = c7;
    }), i27;
  }
  bitMapToSignerIndices() {
    let e20 = [];
    for (let t18 = 0; t18 < this.bitmap.length; t18 += 1) {
      let r18 = this.bitmap[t18];
      for (let i27 = 0; i27 < 8; i27 += 1) (r18 & 128 >> i27) !== 0 && e20.push(t18 * 8 + i27);
    }
    return e20;
  }
  serialize(e20) {
    e20.serializeVector(this.signatures), e20.serializeBytes(this.bitmap);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeVector(U8), r18 = e20.deserializeBytes();
    return new oe2({ signatures: t18, bitmap: r18 });
  }
};
oe.BITMAP_LEN = 4, oe.MAX_SIGNATURES_SUPPORTED = oe.BITMAP_LEN * 8;
var me = oe;
var se = class se2 extends we {
  constructor(e20) {
    let { publicKeys: t18, threshold: r18 } = e20;
    if (super({ publicKeys: t18 }), t18.length > se2.MAX_KEYS || t18.length < se2.MIN_KEYS) throw new Error(`Must have between ${se2.MIN_KEYS} and ${se2.MAX_KEYS} public keys, inclusive`);
    if (r18 < se2.MIN_THRESHOLD || r18 > t18.length) throw new Error(`Threshold must be between ${se2.MIN_THRESHOLD} and ${t18.length}, inclusive`);
    this.publicKeys = t18, this.threshold = r18;
  }
  getSignaturesRequired() {
    return this.threshold;
  }
  verifySignature(e20) {
    let { message: t18, signature: r18 } = e20;
    if (!(r18 instanceof Te)) return false;
    let i27 = [];
    for (let o26 = 0; o26 < 4; o26 += 1) for (let s11 = 0; s11 < 8; s11 += 1) if ((r18.bitmap[o26] & 1 << 7 - s11) !== 0) {
      let c7 = o26 * 8 + s11;
      i27.push(c7);
    }
    if (i27.length !== r18.signatures.length) throw new Error("Bitmap and signatures length mismatch");
    if (i27.length < this.threshold) throw new Error("Not enough signatures");
    for (let o26 = 0; o26 < i27.length; o26 += 1) if (!this.publicKeys[i27[o26]].verifySignature({ message: t18, signature: r18.signatures[o26] })) return false;
    return true;
  }
  async verifySignatureAsync(e20) {
    return this.verifySignature(e20);
  }
  authKey() {
    return s4.fromSchemeAndBytes({ scheme: 1, input: this.toUint8Array() });
  }
  toUint8Array() {
    let e20 = new Uint8Array(this.publicKeys.length * f6.LENGTH + 1);
    return this.publicKeys.forEach((t18, r18) => {
      e20.set(t18.toUint8Array(), r18 * f6.LENGTH);
    }), e20[this.publicKeys.length * f6.LENGTH] = this.threshold, e20;
  }
  serialize(e20) {
    e20.serializeBytes(this.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes(), r18 = t18[t18.length - 1], i27 = [];
    for (let o26 = 0; o26 < t18.length - 1; o26 += f6.LENGTH) {
      let s11 = o26;
      i27.push(new f6(t18.subarray(s11, s11 + f6.LENGTH)));
    }
    return new se2({ publicKeys: i27, threshold: r18 });
  }
  static deserializeWithoutLength(e20) {
    let t18 = e20.remaining(), r18 = e20.deserializeFixedBytes(t18), i27 = r18[r18.length - 1], o26 = [];
    for (let s11 = 0; s11 < r18.length - 1; s11 += f6.LENGTH) {
      let a24 = s11;
      o26.push(new f6(r18.subarray(a24, a24 + f6.LENGTH)));
    }
    return new se2({ publicKeys: o26, threshold: i27 });
  }
  getIndex(e20) {
    return super.getIndex(e20);
  }
};
se.MAX_KEYS = 32, se.MIN_KEYS = 2, se.MIN_THRESHOLD = 1;
var fe = se;
var ae = class ae2 extends o7 {
  constructor(e20) {
    super();
    let { signatures: t18, bitmap: r18 } = e20;
    if (t18.length > ae2.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${ae2.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = t18, !(r18 instanceof Uint8Array)) this.bitmap = ae2.createBitmap({ bits: r18 });
    else {
      if (r18.length !== ae2.BITMAP_LEN) throw new Error(`"bitmap" length should be ${ae2.BITMAP_LEN}`);
      this.bitmap = r18;
    }
  }
  toUint8Array() {
    let e20 = new Uint8Array(this.signatures.length * h6.LENGTH + ae2.BITMAP_LEN);
    return this.signatures.forEach((t18, r18) => {
      e20.set(t18.toUint8Array(), r18 * h6.LENGTH);
    }), e20.set(this.bitmap, this.signatures.length * h6.LENGTH), e20;
  }
  serialize(e20) {
    e20.serializeBytes(this.toUint8Array());
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes(), r18 = t18.subarray(t18.length - 4), i27 = [];
    for (let o26 = 0; o26 < t18.length - r18.length; o26 += h6.LENGTH) {
      let s11 = o26;
      i27.push(new h6(t18.subarray(s11, s11 + h6.LENGTH)));
    }
    return new ae2({ signatures: i27, bitmap: r18 });
  }
  static createBitmap(e20) {
    let { bits: t18 } = e20, r18 = 128, i27 = new Uint8Array([0, 0, 0, 0]), o26 = /* @__PURE__ */ new Set();
    return t18.forEach((s11, a24) => {
      if (s11 >= ae2.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${ae2.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (o26.has(s11)) throw new Error("Duplicate bits detected.");
      if (a24 > 0 && s11 <= t18[a24 - 1]) throw new Error("The bits need to be sorted in ascending order.");
      o26.add(s11);
      let c7 = Math.floor(s11 / 8), d15 = i27[c7];
      d15 |= r18 >> s11 % 8, i27[c7] = d15;
    }), i27;
  }
};
ae.MAX_SIGNATURES_SUPPORTED = 32, ae.BITMAP_LEN = 4;
var Te = ae;
var L2 = class extends B2 {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return Se2.load(e20);
      case 1:
        return Oe.load(e20);
      case 2:
        return te.load(e20);
      case 3:
        return _e2.load(e20);
      case 4:
        return Rt.load(e20);
      case 5:
        return dt.load(e20);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${t18}`);
    }
  }
  isEd25519() {
    return this instanceof Se2;
  }
  isMultiEd25519() {
    return this instanceof Oe;
  }
  isSingleKey() {
    return this instanceof te;
  }
  isMultiKey() {
    return this instanceof _e2;
  }
};
var Se2 = class n20 extends L2 {
  constructor(e20, t18) {
    super(), this.public_key = e20, this.signature = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), this.public_key.serialize(e20), this.signature.serialize(e20);
  }
  static load(e20) {
    let t18 = f6.deserialize(e20), r18 = h6.deserialize(e20);
    return new n20(t18, r18);
  }
};
var Oe = class n21 extends L2 {
  constructor(e20, t18) {
    super(), this.public_key = e20, this.signature = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(1), this.public_key.serialize(e20), this.signature.serialize(e20);
  }
  static load(e20) {
    let t18 = fe.deserialize(e20), r18 = Te.deserialize(e20);
    return new n21(t18, r18);
  }
};
var te = class n22 extends L2 {
  constructor(e20, t18) {
    super(), this.public_key = e20, this.signature = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(2), this.public_key.serialize(e20), this.signature.serialize(e20);
  }
  static load(e20) {
    let t18 = E7.deserialize(e20), r18 = U8.deserialize(e20);
    return new n22(t18, r18);
  }
};
var _e2 = class n23 extends L2 {
  constructor(e20, t18) {
    super(), this.public_keys = e20, this.signatures = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(3), this.public_keys.serialize(e20), this.signatures.serialize(e20);
  }
  static load(e20) {
    let t18 = W5.deserialize(e20), r18 = me.deserialize(e20);
    return new n23(t18, r18);
  }
};
var Rt = class n24 extends L2 {
  serialize(e20) {
    e20.serializeU32AsUleb128(4);
  }
  static load(e20) {
    return new n24();
  }
};
var dt = class n25 extends L2 {
  constructor(e20, t18, r18, i27) {
    if (super(), !w(e20)) throw new Error(`Invalid function info ${e20} passed into AccountAuthenticatorAbstraction`);
    this.functionInfo = e20, this.authenticator = r18, this.signingMessageDigest = a3.fromHexInput(a3.fromHexInput(t18).toUint8Array()), this.accountIdentity = i27;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(5);
    let { moduleAddress: t18, moduleName: r18, functionName: i27 } = v(this.functionInfo);
    l3.fromString(t18).serialize(e20), e20.serializeStr(r18), e20.serializeStr(i27), this.accountIdentity ? e20.serializeU32AsUleb128(1) : e20.serializeU32AsUleb128(0), e20.serializeBytes(this.signingMessageDigest.toUint8Array()), this.accountIdentity ? e20.serializeBytes(this.authenticator) : e20.serializeFixedBytes(this.authenticator), this.accountIdentity && e20.serializeBytes(this.accountIdentity);
  }
  static load(e20) {
    let t18 = l3.deserialize(e20), r18 = e20.deserializeStr(), i27 = e20.deserializeStr(), o26 = e20.deserializeUleb128AsU32();
    if (o26 === 0) {
      let s11 = e20.deserializeBytes(), a24 = e20.deserializeFixedBytes(e20.remaining());
      return new n25(`${t18}::${r18}::${i27}`, s11, a24);
    }
    if (o26 === 1) {
      let s11 = e20.deserializeBytes(), a24 = e20.deserializeBytes(), c7 = e20.deserializeBytes();
      return new n25(`${t18}::${r18}::${i27}`, s11, a24, c7);
    }
    throw new Error(`Unknown variant index for AccountAuthenticatorAbstraction: ${o26}`);
  }
};
var rn = class n26 extends B2 {
  constructor(e20, t18) {
    super(), this.address = e20, this.name = t18;
  }
  static fromStr(e20) {
    let t18 = e20.split("::");
    if (t18.length !== 2) throw new Error("Invalid module id.");
    return new n26(l3.fromString(t18[0]), new r8(t18[1]));
  }
  serialize(e20) {
    this.address.serialize(e20), this.name.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = l3.deserialize(e20), r18 = r8.deserialize(e20);
    return new n26(t18, r18);
  }
};
var R4 = class n27 extends B2 {
  deserialize(e20) {
    let t18 = l3.deserialize(e20), r18 = r8.deserialize(e20), i27 = r8.deserialize(e20), o26 = e20.deserializeVector(n27);
    return new ke(t18, r18, i27, o26);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return B6.load(e20);
      case 1:
        return ce.load(e20);
      case 2:
        return q5.load(e20);
      case 3:
        return Ge.load(e20);
      case 4:
        return D3.load(e20);
      case 5:
        return pt.load(e20);
      case 6:
        return C6.load(e20);
      case 7:
        return m12.load(e20);
      case 8:
        return ze.load(e20);
      case 9:
        return Ne.load(e20);
      case 10:
        return Be.load(e20);
      case 255:
        return O6.load(e20);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${t18}`);
    }
  }
  isBool() {
    return this instanceof B6;
  }
  isAddress() {
    return this instanceof D3;
  }
  isGeneric() {
    return this instanceof O6;
  }
  isSigner() {
    return this instanceof pt;
  }
  isVector() {
    return this instanceof C6;
  }
  isStruct() {
    return this instanceof m12;
  }
  isU8() {
    return this instanceof ce;
  }
  isU16() {
    return this instanceof ze;
  }
  isU32() {
    return this instanceof Ne;
  }
  isU64() {
    return this instanceof q5;
  }
  isU128() {
    return this instanceof Ge;
  }
  isU256() {
    return this instanceof Be;
  }
  isPrimitive() {
    return this instanceof pt || this instanceof D3 || this instanceof B6 || this instanceof ce || this instanceof ze || this instanceof Ne || this instanceof q5 || this instanceof Ge || this instanceof Be;
  }
};
var B6 = class n28 extends R4 {
  toString() {
    return "bool";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0);
  }
  static load(e20) {
    return new n28();
  }
};
var ce = class n29 extends R4 {
  toString() {
    return "u8";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(1);
  }
  static load(e20) {
    return new n29();
  }
};
var ze = class n30 extends R4 {
  toString() {
    return "u16";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(8);
  }
  static load(e20) {
    return new n30();
  }
};
var Ne = class n31 extends R4 {
  toString() {
    return "u32";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(9);
  }
  static load(e20) {
    return new n31();
  }
};
var q5 = class n32 extends R4 {
  toString() {
    return "u64";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(2);
  }
  static load(e20) {
    return new n32();
  }
};
var Ge = class n33 extends R4 {
  toString() {
    return "u128";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(3);
  }
  static load(e20) {
    return new n33();
  }
};
var Be = class n34 extends R4 {
  toString() {
    return "u256";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(10);
  }
  static load(e20) {
    return new n34();
  }
};
var D3 = class n35 extends R4 {
  toString() {
    return "address";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(4);
  }
  static load(e20) {
    return new n35();
  }
};
var pt = class n36 extends R4 {
  toString() {
    return "signer";
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(5);
  }
  static load(e20) {
    return new n36();
  }
};
var Bn = class n37 extends R4 {
  constructor(t18) {
    super();
    this.value = t18;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(t18) {
    t18.serializeU32AsUleb128(254);
  }
  static load(t18) {
    let r18 = R4.deserialize(t18);
    return new n37(r18);
  }
};
var O6 = class n38 extends R4 {
  constructor(t18) {
    super();
    this.value = t18;
    if (t18 < 0) throw new Error("Generic type parameter index cannot be negative");
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(t18) {
    t18.serializeU32AsUleb128(255), t18.serializeU32(this.value);
  }
  static load(t18) {
    let r18 = t18.deserializeU32();
    return new n38(r18);
  }
};
var C6 = class n39 extends R4 {
  constructor(t18) {
    super();
    this.value = t18;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  static u8() {
    return new n39(new ce());
  }
  serialize(t18) {
    t18.serializeU32AsUleb128(6), this.value.serialize(t18);
  }
  static load(t18) {
    let r18 = R4.deserialize(t18);
    return new n39(r18);
  }
};
var m12 = class n40 extends R4 {
  constructor(t18) {
    super();
    this.value = t18;
  }
  toString() {
    let t18 = "";
    return this.value.typeArgs.length > 0 && (t18 = `<${this.value.typeArgs.map((r18) => r18.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${t18}`;
  }
  serialize(t18) {
    t18.serializeU32AsUleb128(7), this.value.serialize(t18);
  }
  static load(t18) {
    let r18 = ke.deserialize(t18);
    return new n40(r18);
  }
  isTypeTag(t18, r18, i27) {
    return this.value.moduleName.identifier === r18 && this.value.name.identifier === i27 && this.value.address.equals(t18);
  }
  isString() {
    return this.isTypeTag(l3.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(l3.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(l3.ONE, "object", "Object");
  }
  isDelegationKey() {
    return this.isTypeTag(l3.ONE, "permissioned_delegation", "DelegationKey");
  }
  isRateLimiter() {
    return this.isTypeTag(l3.ONE, "rate_limiter", "RateLimiter");
  }
};
var ke = class n41 extends B2 {
  constructor(e20, t18, r18, i27) {
    super(), this.address = e20, this.moduleName = t18, this.name = r18, this.typeArgs = i27;
  }
  serialize(e20) {
    e20.serialize(this.address), e20.serialize(this.moduleName), e20.serialize(this.name), e20.serializeVector(this.typeArgs);
  }
  static deserialize(e20) {
    let t18 = l3.deserialize(e20), r18 = r8.deserialize(e20), i27 = r8.deserialize(e20), o26 = e20.deserializeVector(R4);
    return new n41(t18, r18, i27, o26);
  }
};
function K() {
  return new ke(l3.ONE, new r8("string"), new r8("String"), []);
}
function ue(n94) {
  return new ke(l3.ONE, new r8("object"), new r8("Object"), [n94]);
}
function ta(n94) {
  let e20 = n94.deserializeUleb128AsU32();
  switch (e20) {
    case 0:
      return p4.deserialize(n94);
    case 1:
      return m7.deserialize(n94);
    case 2:
      return B4.deserialize(n94);
    case 3:
      return l3.deserialize(n94);
    case 4:
      return t3.deserialize(n94, p4);
    case 5:
      return U5.deserialize(n94);
    case 6:
      return b2.deserialize(n94);
    case 7:
      return y5.deserialize(n94);
    case 8:
      return a12.deserialize(n94);
    case 9:
      return p5.deserialize(n94);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${e20}`);
  }
}
var tt = class extends B2 {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return Ot.load(e20);
      case 2:
        return zt.load(e20);
      case 3:
        return Nt.load(e20);
      case 4:
        return Mn.deserialize(e20);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${t18}`);
    }
  }
};
var Ot = class n42 extends tt {
  constructor(e20) {
    super(), this.script = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), this.script.serialize(e20);
  }
  static load(e20) {
    let t18 = Gt2.deserialize(e20);
    return new n42(t18);
  }
};
var zt = class n43 extends tt {
  constructor(e20) {
    super(), this.entryFunction = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(2), this.entryFunction.serialize(e20);
  }
  static load(e20) {
    let t18 = Me.deserialize(e20);
    return new n43(t18);
  }
};
var Nt = class n44 extends tt {
  constructor(e20) {
    super(), this.multiSig = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(3), this.multiSig.serialize(e20);
  }
  static load(e20) {
    let t18 = on.deserialize(e20);
    return new n44(t18);
  }
};
var Me = class n45 {
  constructor(e20, t18, r18, i27) {
    this.module_name = e20, this.function_name = t18, this.type_args = r18, this.args = i27;
  }
  static build(e20, t18, r18, i27) {
    return new n45(rn.fromStr(e20), new r8(t18), r18, i27);
  }
  serialize(e20) {
    this.module_name.serialize(e20), this.function_name.serialize(e20), e20.serializeVector(this.type_args), e20.serializeU32AsUleb128(this.args.length), this.args.forEach((t18) => {
      t18.serializeForEntryFunction(e20);
    });
  }
  static deserialize(e20) {
    let t18 = rn.deserialize(e20), r18 = r8.deserialize(e20), i27 = e20.deserializeVector(R4), o26 = e20.deserializeUleb128AsU32(), s11 = new Array();
    for (let a24 = 0; a24 < o26; a24 += 1) {
      let c7 = e20.deserializeUleb128AsU32(), d15 = t8.deserialize(e20, c7);
      s11.push(d15);
    }
    return new n45(t18, r18, i27, s11);
  }
};
var Gt2 = class n46 {
  constructor(e20, t18, r18) {
    this.bytecode = e20, this.type_args = t18, this.args = r18;
  }
  serialize(e20) {
    e20.serializeBytes(this.bytecode), e20.serializeVector(this.type_args), e20.serializeU32AsUleb128(this.args.length), this.args.forEach((t18) => {
      t18.serializeForScriptFunction(e20);
    });
  }
  static deserialize(e20) {
    let t18 = e20.deserializeBytes(), r18 = e20.deserializeVector(R4), i27 = e20.deserializeUleb128AsU32(), o26 = new Array();
    for (let s11 = 0; s11 < i27; s11 += 1) {
      let a24 = ta(e20);
      o26.push(a24);
    }
    return new n46(t18, r18, o26);
  }
};
var on = class n47 {
  constructor(e20, t18) {
    this.multisig_address = e20, this.transaction_payload = t18;
  }
  serialize(e20) {
    this.multisig_address.serialize(e20), this.transaction_payload === void 0 ? e20.serializeBool(false) : (e20.serializeBool(true), this.transaction_payload.serialize(e20));
  }
  static deserialize(e20) {
    let t18 = l3.deserialize(e20), r18 = e20.deserializeBool(), i27;
    return r18 && (i27 = sn.deserialize(e20)), new n47(t18, i27);
  }
};
var sn = class n48 extends B2 {
  constructor(e20) {
    super(), this.transaction_payload = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), this.transaction_payload.serialize(e20);
  }
  static deserialize(e20) {
    return e20.deserializeUleb128AsU32(), new n48(Me.deserialize(e20));
  }
};
var Mn = class extends tt {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return lt.load(e20);
      default:
        throw new Error(`Unknown variant index for TransactionInnerPayload: ${t18}`);
    }
  }
};
var lt = class n49 extends Mn {
  constructor(e20, t18) {
    super(), this.executable = e20, this.extra_config = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(4), e20.serializeU32AsUleb128(0), this.executable.serialize(e20), this.extra_config.serialize(e20);
  }
  static load(e20) {
    let t18 = Bt.deserialize(e20), r18 = Vn.deserialize(e20);
    return new n49(t18, r18);
  }
};
var Bt = class {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return an.load(e20);
      case 1:
        return Mt.load(e20);
      case 2:
        return cn.load(e20);
      default:
        throw new Error(`Unknown variant index for TransactionExecutable: ${t18}`);
    }
  }
};
var an = class n50 extends Bt {
  constructor(e20) {
    super(), this.script = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), this.script.serialize(e20);
  }
  static load(e20) {
    let t18 = Gt2.deserialize(e20);
    return new n50(t18);
  }
};
var Mt = class n51 extends Bt {
  constructor(e20) {
    super(), this.entryFunction = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(1), this.entryFunction.serialize(e20);
  }
  static load(e20) {
    let t18 = Me.deserialize(e20);
    return new n51(t18);
  }
};
var cn = class n52 extends Bt {
  serialize(e20) {
    e20.serializeU32AsUleb128(2);
  }
  static load(e20) {
    return new n52();
  }
};
var Vn = class {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return gt.load(e20);
      default:
        throw new Error(`Unknown variant index for TransactionExtraConfig: ${t18}`);
    }
  }
};
var gt = class n53 extends Vn {
  constructor(e20, t18) {
    super(), this.multisigAddress = e20, this.replayProtectionNonce = t18 !== void 0 ? BigInt(t18) : void 0;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), e20.serializeOption(this.multisigAddress), e20.serializeOption(this.replayProtectionNonce !== void 0 ? new m7(this.replayProtectionNonce) : void 0);
  }
  static load(e20) {
    let t18 = e20.deserializeOption(l3), r18 = e20.deserializeOption(m7);
    return new n53(t18, r18?.value);
  }
};
var Ae2 = class n54 extends B2 {
  constructor(e20, t18, r18, i27, o26, s11, a24) {
    super(), this.sender = e20, this.sequence_number = t18, this.payload = r18, this.max_gas_amount = i27, this.gas_unit_price = o26, this.expiration_timestamp_secs = s11, this.chain_id = a24;
  }
  serialize(e20) {
    this.sender.serialize(e20), e20.serializeU64(this.sequence_number), this.payload.serialize(e20), e20.serializeU64(this.max_gas_amount), e20.serializeU64(this.gas_unit_price), e20.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = l3.deserialize(e20), r18 = e20.deserializeU64(), i27 = tt.deserialize(e20), o26 = e20.deserializeU64(), s11 = e20.deserializeU64(), a24 = e20.deserializeU64(), c7 = r7.deserialize(e20);
    return new n54(t18, r18, i27, o26, s11, a24, c7);
  }
};
var Hn = class extends B2 {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return yt.load(e20);
      case 1:
        return mt.load(e20);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${t18}`);
    }
  }
};
var yt = class n55 extends Hn {
  constructor(e20, t18) {
    super(), this.raw_txn = e20, this.secondary_signer_addresses = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), this.raw_txn.serialize(e20), e20.serializeVector(this.secondary_signer_addresses);
  }
  static load(e20) {
    let t18 = Ae2.deserialize(e20), r18 = e20.deserializeVector(l3);
    return new n55(t18, r18);
  }
};
var mt = class n56 extends Hn {
  constructor(e20, t18, r18) {
    super(), this.raw_txn = e20, this.secondary_signer_addresses = t18, this.fee_payer_address = r18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(1), this.raw_txn.serialize(e20), e20.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(e20);
  }
  static load(e20) {
    let t18 = Ae2.deserialize(e20), r18 = e20.deserializeVector(l3), i27 = l3.deserialize(e20);
    return new n56(t18, r18, i27);
  }
};
var Ve = class extends B2 {
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return ft.load(e20);
      case 1:
        return Vt.load(e20);
      case 2:
        return At.load(e20);
      case 3:
        return ht.load(e20);
      case 4:
        return nt.load(e20);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${t18}`);
    }
  }
  isEd25519() {
    return this instanceof ft;
  }
  isMultiEd25519() {
    return this instanceof Vt;
  }
  isMultiAgent() {
    return this instanceof At;
  }
  isFeePayer() {
    return this instanceof ht;
  }
  isSingleSender() {
    return this instanceof nt;
  }
};
var ft = class n57 extends Ve {
  constructor(e20, t18) {
    super(), this.public_key = e20, this.signature = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(0), this.public_key.serialize(e20), this.signature.serialize(e20);
  }
  static load(e20) {
    let t18 = f6.deserialize(e20), r18 = h6.deserialize(e20);
    return new n57(t18, r18);
  }
};
var Vt = class n58 extends Ve {
  constructor(e20, t18) {
    super(), this.public_key = e20, this.signature = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(1), this.public_key.serialize(e20), this.signature.serialize(e20);
  }
  static load(e20) {
    let t18 = fe.deserialize(e20), r18 = Te.deserialize(e20);
    return new n58(t18, r18);
  }
};
var At = class n59 extends Ve {
  constructor(e20, t18, r18) {
    super(), this.sender = e20, this.secondary_signer_addresses = t18, this.secondary_signers = r18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(2), this.sender.serialize(e20), e20.serializeVector(this.secondary_signer_addresses), e20.serializeVector(this.secondary_signers);
  }
  static load(e20) {
    let t18 = L2.deserialize(e20), r18 = e20.deserializeVector(l3), i27 = e20.deserializeVector(L2);
    return new n59(t18, r18, i27);
  }
};
var ht = class n60 extends Ve {
  constructor(e20, t18, r18, i27) {
    super(), this.sender = e20, this.secondary_signer_addresses = t18, this.secondary_signers = r18, this.fee_payer = i27;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(3), this.sender.serialize(e20), e20.serializeVector(this.secondary_signer_addresses), e20.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(e20), this.fee_payer.authenticator.serialize(e20);
  }
  static load(e20) {
    let t18 = L2.deserialize(e20), r18 = e20.deserializeVector(l3), i27 = e20.deserializeVector(L2), o26 = l3.deserialize(e20), s11 = L2.deserialize(e20), a24 = { address: o26, authenticator: s11 };
    return new n60(t18, r18, i27, a24);
  }
};
var nt = class n61 extends Ve {
  constructor(e20) {
    super(), this.sender = e20;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(4), this.sender.serialize(e20);
  }
  static load(e20) {
    let t18 = L2.deserialize(e20);
    return new n61(t18);
  }
};
var He = class n62 extends B2 {
  constructor(e20, t18) {
    super(), this.raw_txn = e20, this.authenticator = t18;
  }
  serialize(e20) {
    this.raw_txn.serialize(e20), this.authenticator.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = Ae2.deserialize(e20), r18 = Ve.deserialize(e20);
    return new n62(t18, r18);
  }
};
var Ln = class n63 extends B2 {
  constructor(e20, t18) {
    super(), this.rawTransaction = e20, this.feePayerAddress = t18;
  }
  serialize(e20) {
    this.rawTransaction.serialize(e20), this.feePayerAddress === void 0 ? e20.serializeBool(false) : (e20.serializeBool(true), this.feePayerAddress.serialize(e20));
  }
  static deserialize(e20) {
    let t18 = Ae2.deserialize(e20), r18 = e20.deserializeBool(), i27;
    return r18 && (i27 = l3.deserialize(e20)), new n63(t18, i27);
  }
};
var qn = class n64 extends B2 {
  constructor(e20, t18, r18) {
    super(), this.rawTransaction = e20, this.feePayerAddress = r18, this.secondarySignerAddresses = t18;
  }
  serialize(e20) {
    this.rawTransaction.serialize(e20), e20.serializeVector(this.secondarySignerAddresses), this.feePayerAddress === void 0 ? e20.serializeBool(false) : (e20.serializeBool(true), this.feePayerAddress.serialize(e20));
  }
  static deserialize(e20) {
    let t18 = Ae2.deserialize(e20), r18 = e20.deserializeVector(l3), i27 = e20.deserializeBool(), o26;
    return i27 && (o26 = l3.deserialize(e20)), new n64(t18, r18, o26);
  }
};
function $n(n94) {
  return n94.feePayerAddress ? new mt(n94.rawTransaction, n94.secondarySignerAddresses ?? [], n94.feePayerAddress) : n94.secondarySignerAddresses ? new yt(n94.rawTransaction, n94.secondarySignerAddresses) : n94.rawTransaction;
}
function rt(n94, e20) {
  let t18 = sha3_256.create();
  if (!e20.startsWith("APTOS::")) throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${e20}`);
  t18.update(e20);
  let r18 = t18.digest(), i27 = n94, o26 = new Uint8Array(r18.length + i27.length);
  return o26.set(r18), o26.set(i27, r18.length), o26;
}
function Pe(n94) {
  let e20 = $n(n94);
  return n94.feePayerAddress ? rt(e20.bcsToBytes(), a18) : n94.secondarySignerAddresses ? rt(e20.bcsToBytes(), a18) : rt(e20.bcsToBytes(), T7);
}
var Q2 = class n65 {
  constructor(e20) {
    this.signingScheme = 0;
    let { privateKey: t18, address: r18 } = e20;
    this.privateKey = t18, this.publicKey = t18.publicKey(), this.accountAddress = r18 ? l3.from(r18) : this.publicKey.authKey().derivedAddress();
  }
  static generate() {
    let e20 = z3.generate();
    return new n65({ privateKey: e20 });
  }
  static fromDerivationPath(e20) {
    let { path: t18, mnemonic: r18 } = e20, i27 = z3.fromDerivationPath(t18, r18);
    return new n65({ privateKey: i27 });
  }
  verifySignature(e20) {
    return this.publicKey.verifySignature(e20);
  }
  async verifySignatureAsync(e20) {
    return this.publicKey.verifySignatureAsync({ ...e20, signature: e20.signature });
  }
  signWithAuthenticator(e20) {
    return new Se2(this.publicKey, this.privateKey.sign(e20));
  }
  signTransactionWithAuthenticator(e20) {
    return new Se2(this.publicKey, this.signTransaction(e20));
  }
  sign(e20) {
    return this.privateKey.sign(e20);
  }
  signTransaction(e20) {
    return this.sign(Pe(e20));
  }
};
function vr(n94) {
  return typeof n94 == "object" && n94 !== null && "getAnyPublicKey" in n94 && typeof n94.getAnyPublicKey == "function";
}
var ne = class n66 {
  constructor(e20) {
    this.signingScheme = 2;
    let { privateKey: t18, address: r18 } = e20;
    this.privateKey = t18, this.publicKey = new E7(t18.publicKey()), this.accountAddress = r18 ? l3.from(r18) : this.publicKey.authKey().derivedAddress();
  }
  getAnyPublicKey() {
    return this.publicKey;
  }
  static generate(e20 = {}) {
    let { scheme: t18 = 0 } = e20, r18;
    switch (t18) {
      case 0:
        r18 = z3.generate();
        break;
      case 2:
        r18 = v2.generate();
        break;
      default:
        throw new Error(`Unsupported signature scheme ${t18}`);
    }
    return new n66({ privateKey: r18 });
  }
  static fromDerivationPath(e20) {
    let { scheme: t18 = 0, path: r18, mnemonic: i27 } = e20, o26;
    switch (t18) {
      case 0:
        o26 = z3.fromDerivationPath(r18, i27);
        break;
      case 2:
        o26 = v2.fromDerivationPath(r18, i27);
        break;
      default:
        throw new Error(`Unsupported signature scheme ${t18}`);
    }
    return new n66({ privateKey: o26 });
  }
  verifySignature(e20) {
    return this.publicKey.verifySignature(e20);
  }
  async verifySignatureAsync(e20) {
    return this.publicKey.verifySignatureAsync({ ...e20, signature: e20.signature });
  }
  signWithAuthenticator(e20) {
    return new te(this.publicKey, this.sign(e20));
  }
  signTransactionWithAuthenticator(e20) {
    return new te(this.publicKey, this.signTransaction(e20));
  }
  sign(e20) {
    return new U8(this.privateKey.sign(e20));
  }
  signTransaction(e20) {
    return this.sign(Pe(e20));
  }
  static fromEd25519Account(e20) {
    return new n66({ privateKey: e20.privateKey, address: e20.accountAddress });
  }
};
var Le = class {
  static generate(e20 = {}) {
    let { scheme: t18 = 0, legacy: r18 = true } = e20;
    return t18 === 0 && r18 ? Q2.generate() : ne.generate({ scheme: t18 });
  }
  static fromPrivateKey(e20) {
    let { privateKey: t18, address: r18, legacy: i27 = true } = e20;
    return t18 instanceof z3 && i27 ? new Q2({ privateKey: t18, address: r18 }) : new ne({ privateKey: t18, address: r18 });
  }
  static fromPrivateKeyAndAddress(e20) {
    return this.fromPrivateKey(e20);
  }
  static fromDerivationPath(e20) {
    let { scheme: t18 = 0, mnemonic: r18, path: i27, legacy: o26 = true } = e20;
    return t18 === 0 && o26 ? Q2.fromDerivationPath({ mnemonic: r18, path: i27 }) : ne.fromDerivationPath({ scheme: t18, mnemonic: r18, path: i27 });
  }
  static authKey(e20) {
    let { publicKey: t18 } = e20;
    return t18.authKey();
  }
  verifySignature(e20) {
    return this.publicKey.verifySignature(e20);
  }
  async verifySignatureAsync(e20) {
    return this.publicKey.verifySignatureAsync(e20);
  }
};
var oa = 1209600;
var Ht = class Ht2 extends B2 {
  constructor(e20) {
    super();
    let { privateKey: t18, expiryDateSecs: r18, blinder: i27 } = e20;
    this.privateKey = t18, this.publicKey = new c3(t18.publicKey()), this.expiryDateSecs = r18 || x(_2() + oa), this.blinder = i27 !== void 0 ? a3.fromHexInput(i27).toUint8Array() : sa();
    let o26 = _4(this.publicKey.bcsToBytes(), 93);
    o26.push(BigInt(this.expiryDateSecs)), o26.push(N2(this.blinder));
    let s11 = M2(o26);
    this.nonce = s11.toString();
  }
  getPublicKey() {
    return this.publicKey;
  }
  isExpired() {
    return Math.floor(Date.now() / 1e3) > this.expiryDateSecs;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(this.publicKey.variant), e20.serializeBytes(this.privateKey.toUint8Array()), e20.serializeU64(this.expiryDateSecs), e20.serializeFixedBytes(this.blinder);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32(), r18;
    switch (t18) {
      case 0:
        r18 = z3.deserialize(e20);
        break;
      default:
        throw new Error(`Unknown variant index for EphemeralPublicKey: ${t18}`);
    }
    let i27 = e20.deserializeU64(), o26 = e20.deserializeFixedBytes(31);
    return new Ht2({ privateKey: r18, expiryDateSecs: Number(i27), blinder: o26 });
  }
  static fromBytes(e20) {
    return Ht2.deserialize(new a11(e20));
  }
  static generate(e20) {
    let t18;
    switch (e20?.scheme) {
      case 0:
      default:
        t18 = z3.generate();
    }
    return new Ht2({ privateKey: t18, expiryDateSecs: e20?.expiryDateSecs });
  }
  sign(e20) {
    if (this.isExpired()) throw new Error("EphemeralKeyPair has expired");
    return new p3(this.privateKey.sign(e20));
  }
};
Ht.BLINDER_LENGTH = 31;
var bt = Ht;
function sa() {
  return randomBytes(bt.BLINDER_LENGTH);
}
function jn(n94) {
  return n94 != null && typeof n94.checkKeylessAccountValidity == "function";
}
var Lt = class Lt2 extends B2 {
  constructor(t18) {
    super();
    this.signingScheme = 2;
    let { address: r18, ephemeralKeyPair: i27, publicKey: o26, uidKey: s11, uidVal: a24, aud: c7, pepper: d15, proof: l14, proofFetchCallback: g5, jwt: p11, verificationKeyHash: y10 } = t18;
    if (this.ephemeralKeyPair = i27, this.publicKey = o26, this.accountAddress = r18 ? l3.from(r18) : this.publicKey.authKey().derivedAddress(), this.uidKey = s11, this.uidVal = a24, this.aud = c7, this.jwt = p11, this.emitter = new eventemitter3_default(), this.proofOrPromise = l14, l14 instanceof de) this.proof = l14;
    else {
      if (g5 === void 0) throw new Error("Must provide callback for async proof fetch");
      this.emitter.on("proofFetchFinish", async (_8) => {
        await g5(_8), this.emitter.removeAllListeners();
      }), this.init(l14);
    }
    let h10 = a3.fromHexInput(d15).toUint8Array();
    if (h10.length !== Lt2.PEPPER_LENGTH) throw new Error(`Pepper length in bytes should be ${Lt2.PEPPER_LENGTH}`);
    if (this.pepper = h10, y10 !== void 0) {
      if (a3.hexInputToUint8Array(y10).length !== 32) throw new Error("verificationKeyHash must be 32 bytes");
      this.verificationKeyHash = a3.hexInputToUint8Array(y10);
    }
  }
  getAnyPublicKey() {
    return new E7(this.publicKey);
  }
  async init(t18) {
    try {
      this.proof = await t18, this.emitter.emit("proofFetchFinish", { status: "Success" });
    } catch (r18) {
      r18 instanceof Error ? this.emitter.emit("proofFetchFinish", { status: "Failed", error: r18.toString() }) : this.emitter.emit("proofFetchFinish", { status: "Failed", error: "Unknown" });
    }
  }
  serialize(t18) {
    if (this.accountAddress.serialize(t18), t18.serializeStr(this.jwt), t18.serializeStr(this.uidKey), t18.serializeFixedBytes(this.pepper), this.ephemeralKeyPair.serialize(t18), this.proof === void 0) throw new Error("Cannot serialize - proof undefined");
    this.proof.serialize(t18), t18.serializeOption(this.verificationKeyHash, 32);
  }
  static partialDeserialize(t18) {
    let r18 = l3.deserialize(t18), i27 = t18.deserializeStr(), o26 = t18.deserializeStr(), s11 = t18.deserializeFixedBytes(31), a24 = bt.deserialize(t18), c7 = de.deserialize(t18), d15 = t18.deserializeOption("fixedBytes", 32);
    return { address: r18, jwt: i27, uidKey: o26, pepper: s11, ephemeralKeyPair: a24, proof: c7, verificationKeyHash: d15 };
  }
  isExpired() {
    return this.ephemeralKeyPair.isExpired();
  }
  signWithAuthenticator(t18) {
    let r18 = new U8(this.sign(t18)), i27 = new E7(this.publicKey);
    return new te(i27, r18);
  }
  signTransactionWithAuthenticator(t18) {
    let r18 = new U8(this.signTransaction(t18)), i27 = new E7(this.publicKey);
    return new te(i27, r18);
  }
  async waitForProofFetch() {
    this.proofOrPromise instanceof Promise && await this.proofOrPromise;
  }
  async checkKeylessAccountValidity(t18) {
    if (this.isExpired()) throw N.fromErrorType({ type: 0 });
    if (await this.waitForProofFetch(), this.proof === void 0) throw N.fromErrorType({ type: 2 });
    let r18 = jwtDecode(this.jwt, { header: true });
    if (r18.kid === void 0) throw N.fromErrorType({ type: 12, details: "checkKeylessAccountValidity failed. JWT is missing 'kid' in header. This should never happen." });
    if (this.verificationKeyHash !== void 0) {
      let { verificationKey: i27 } = await $t({ aptosConfig: t18 });
      if (a3.hexInputToString(i27.hash()) !== a3.hexInputToString(this.verificationKeyHash)) throw N.fromErrorType({ type: 4 });
    } else console.warn("[Aptos SDK] The verification key hash was not set. Proof may be invalid if the verification key has rotated.");
    await Lt2.fetchJWK({ aptosConfig: t18, publicKey: this.publicKey, kid: r18.kid });
  }
  sign(t18) {
    let { expiryDateSecs: r18 } = this.ephemeralKeyPair;
    if (this.isExpired()) throw N.fromErrorType({ type: 0 });
    if (this.proof === void 0) throw N.fromErrorType({ type: 1, details: "Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing." });
    let i27 = this.ephemeralKeyPair.getPublicKey(), o26 = this.ephemeralKeyPair.sign(t18);
    return new ee({ jwtHeader: S(this.jwt.split(".")[0]), ephemeralCertificate: new qt(this.proof, 0), expiryDateSecs: r18, ephemeralPublicKey: i27, ephemeralSignature: o26 });
  }
  signTransaction(t18) {
    if (this.proof === void 0) throw N.fromErrorType({ type: 1, details: "Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing." });
    let r18 = $n(t18), o26 = new Wn2(r18, this.proof.proof).hash();
    return this.sign(o26);
  }
  getSigningMessage(t18) {
    if (this.proof === void 0) throw N.fromErrorType({ type: 1, details: "Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing." });
    let r18 = $n(t18);
    return new Wn2(r18, this.proof.proof).hash();
  }
  verifySignature(t18) {
    return this.publicKey.verifySignature(t18);
  }
  async verifySignatureAsync(t18) {
    return this.publicKey.verifySignatureAsync({ ...t18 });
  }
  static async fetchJWK(t18) {
    return Ir(t18);
  }
};
Lt.PEPPER_LENGTH = 31;
var pe2 = Lt;
var Wn2 = class extends B2 {
  constructor(t18, r18) {
    super();
    this.domainSeparator = "APTOS::TransactionAndProof";
    this.transaction = t18, this.proof = r18;
  }
  serialize(t18) {
    t18.serializeFixedBytes(this.transaction.bcsToBytes()), t18.serializeOption(this.proof);
  }
  hash() {
    return rt(this.bcsToBytes(), this.domainSeparator);
  }
};
var he = class n67 extends pe2 {
  constructor(e20) {
    let t18 = v5.create(e20);
    super({ publicKey: t18, ...e20 }), this.publicKey = t18;
  }
  serialize(e20) {
    super.serialize(e20);
  }
  static deserialize(e20) {
    let { address: t18, proof: r18, ephemeralKeyPair: i27, jwt: o26, uidKey: s11, pepper: a24, verificationKeyHash: c7 } = pe2.partialDeserialize(e20), { iss: d15, aud: l14, uidVal: g5 } = qe({ jwt: o26, uidKey: s11 });
    return new n67({ address: t18, proof: r18, ephemeralKeyPair: i27, iss: d15, uidKey: s11, uidVal: g5, aud: l14, pepper: a24, jwt: o26, verificationKeyHash: c7 });
  }
  static fromBytes(e20) {
    return n67.deserialize(new a11(a3.hexInputToUint8Array(e20)));
  }
  static create(e20) {
    let { address: t18, proof: r18, jwt: i27, ephemeralKeyPair: o26, pepper: s11, uidKey: a24 = "sub", proofFetchCallback: c7, verificationKey: d15, verificationKeyHash: l14 } = e20;
    if (l14 && d15) throw new Error("Cannot provide both verificationKey and verificationKeyHash");
    let { iss: g5, aud: p11, uidVal: y10 } = qe({ jwt: i27, uidKey: a24 });
    return new n67({ address: t18, proof: r18, ephemeralKeyPair: o26, iss: g5, uidKey: a24, uidVal: y10, aud: p11, pepper: s11, jwt: i27, proofFetchCallback: c7, verificationKeyHash: l14 ?? (d15 ? d15.hash() : void 0) });
  }
};
var Ke = class n68 extends pe2 {
  constructor(e20) {
    let t18 = V2.create(e20);
    super({ publicKey: t18, ...e20 }), this.publicKey = t18, this.audless = e20.audless ?? false;
  }
  serialize(e20) {
    super.serialize(e20), this.publicKey.jwkAddress.serialize(e20);
  }
  static deserialize(e20) {
    let { address: t18, proof: r18, ephemeralKeyPair: i27, jwt: o26, uidKey: s11, pepper: a24, verificationKeyHash: c7 } = pe2.partialDeserialize(e20), d15 = l3.deserialize(e20), { iss: l14, aud: g5, uidVal: p11 } = qe({ jwt: o26, uidKey: s11 });
    return new n68({ address: t18, proof: r18, ephemeralKeyPair: i27, iss: l14, uidKey: s11, uidVal: p11, aud: g5, pepper: a24, jwt: o26, verificationKeyHash: c7, jwkAddress: d15 });
  }
  static fromBytes(e20) {
    return n68.deserialize(a11.fromHex(e20));
  }
  static create(e20) {
    let { address: t18, proof: r18, jwt: i27, ephemeralKeyPair: o26, pepper: s11, jwkAddress: a24, uidKey: c7 = "sub", proofFetchCallback: d15, verificationKey: l14, verificationKeyHash: g5 } = e20;
    if (g5 && l14) throw new Error("Cannot provide both verificationKey and verificationKeyHash");
    let { iss: p11, aud: y10, uidVal: h10 } = qe({ jwt: i27, uidKey: c7 });
    return new n68({ address: t18, proof: r18, ephemeralKeyPair: o26, iss: p11, uidKey: c7, uidVal: h10, aud: y10, pepper: s11, jwkAddress: l3.from(a24), jwt: i27, proofFetchCallback: d15, verificationKeyHash: g5 ?? (l14 ? l14.hash() : void 0) });
  }
};
var $e = class n69 {
  constructor(e20) {
    this.signingScheme = 3;
    let { multiKey: t18, address: r18 } = e20, i27 = e20.signers.map((a24) => a24 instanceof Q2 ? ne.fromEd25519Account(a24) : a24);
    if (t18.signaturesRequired > i27.length) throw new Error(`Not enough signers provided to satisfy the required signatures. Need ${t18.signaturesRequired} signers, but only ${i27.length} provided`);
    if (t18.signaturesRequired < i27.length) throw new Error(`More signers provided than required. Need ${t18.signaturesRequired} signers, but ${i27.length} provided`);
    this.publicKey = t18, this.accountAddress = r18 ? l3.from(r18) : this.publicKey.authKey().derivedAddress();
    let o26 = [];
    for (let a24 of i27) o26.push(this.publicKey.getIndex(a24.getAnyPublicKey()));
    let s11 = i27.map((a24, c7) => [a24, o26[c7]]);
    s11.sort((a24, c7) => a24[1] - c7[1]), this.signers = s11.map((a24) => a24[0]), this.signerIndicies = s11.map((a24) => a24[1]), this.signaturesBitmap = this.publicKey.createBitmap({ bits: o26 });
  }
  static fromPublicKeysAndSigners(e20) {
    let { address: t18, publicKeys: r18, signaturesRequired: i27, signers: o26 } = e20, s11 = new W5({ publicKeys: r18, signaturesRequired: i27 });
    return new n69({ multiKey: s11, signers: o26, address: t18 });
  }
  static isMultiKeySigner(e20) {
    return e20 instanceof n69;
  }
  signWithAuthenticator(e20) {
    return new _e2(this.publicKey, this.sign(e20));
  }
  signTransactionWithAuthenticator(e20) {
    return new _e2(this.publicKey, this.signTransaction(e20));
  }
  async waitForProofFetch() {
    let t18 = this.signers.filter((r18) => r18 instanceof pe2).map(async (r18) => r18.waitForProofFetch());
    await Promise.all(t18);
  }
  async checkKeylessAccountValidity(e20) {
    let r18 = this.signers.filter((i27) => i27 instanceof pe2).map((i27) => i27.checkKeylessAccountValidity(e20));
    await Promise.all(r18);
  }
  sign(e20) {
    let t18 = [];
    for (let r18 of this.signers) t18.push(r18.sign(e20));
    return new me({ signatures: t18, bitmap: this.signaturesBitmap });
  }
  signTransaction(e20) {
    let t18 = [];
    for (let r18 of this.signers) t18.push(r18.signTransaction(e20));
    return new me({ signatures: t18, bitmap: this.signaturesBitmap });
  }
  verifySignature(e20) {
    return this.publicKey.verifySignature(e20);
  }
  async verifySignatureAsync(e20) {
    return await this.publicKey.verifySignatureAsync(e20);
  }
};
var Wt = class {
  constructor(e20) {
    this.signingScheme = 1;
    let { signers: t18, publicKey: r18, address: i27 } = e20;
    if (this.publicKey = r18, this.accountAddress = i27 ? l3.from(i27) : this.publicKey.authKey().derivedAddress(), r18.threshold > t18.length) throw new Error(`Not enough signers provided to satisfy the required signatures. Need ${r18.threshold} signers, but only ${t18.length} provided`);
    if (r18.threshold < t18.length) throw new Error(`More signers provided than required. Need ${r18.threshold} signers, but ${t18.length} provided`);
    let o26 = [];
    for (let a24 of t18) o26.push(this.publicKey.getIndex(a24.publicKey()));
    let s11 = t18.map((a24, c7) => [a24, o26[c7]]);
    s11.sort((a24, c7) => a24[1] - c7[1]), this.signers = s11.map((a24) => a24[0]), this.signerIndices = s11.map((a24) => a24[1]), this.signaturesBitmap = this.publicKey.createBitmap({ bits: o26 });
  }
  verifySignature(e20) {
    return this.publicKey.verifySignature(e20);
  }
  async verifySignatureAsync(e20) {
    return this.publicKey.verifySignatureAsync({ ...e20, signature: e20.signature });
  }
  signWithAuthenticator(e20) {
    return new Oe(this.publicKey, this.sign(e20));
  }
  signTransactionWithAuthenticator(e20) {
    return new Oe(this.publicKey, this.signTransaction(e20));
  }
  sign(e20) {
    let t18 = [];
    for (let r18 of this.signers) t18.push(r18.sign(e20));
    return new Te({ signatures: t18, bitmap: this.signaturesBitmap });
  }
  signTransaction(e20) {
    return this.sign(Pe(e20));
  }
};
function uo(n94) {
  let e20 = n94.deserializeUleb128AsU32();
  if (!Object.values(W4).includes(e20)) throw new Error(`Deserialization of Account failed: SigningScheme variant ${e20} is invalid`);
  return { address: l3.deserialize(n94), signingScheme: e20 };
}
function po(n94, e20) {
  if (e20.serializeStr(n94.jwt), e20.serializeStr(n94.uidKey), e20.serializeFixedBytes(n94.pepper), n94.ephemeralKeyPair.serialize(e20), n94.proof === void 0) throw new Error("Cannot serialize - proof undefined");
  n94.proof.serialize(e20), e20.serializeOption(n94.verificationKeyHash, 32);
}
function lo(n94) {
  let e20 = n94.deserializeStr(), t18 = n94.deserializeStr(), r18 = n94.deserializeFixedBytes(31), i27 = bt.deserialize(n94), o26 = de.deserialize(n94), s11 = n94.deserializeOption("fixedBytes", 32);
  return { jwt: e20, uidKey: t18, pepper: r18, ephemeralKeyPair: i27, proof: o26, verificationKeyHash: s11 };
}
var go;
((g5) => {
  function n94(p11) {
    let y10 = new n4();
    switch (y10.serializeU32AsUleb128(p11.signingScheme), p11.accountAddress.serialize(y10), p11.signingScheme) {
      case 0:
        return p11.privateKey.serialize(y10), y10.toUint8Array();
      case 2: {
        if (!vr(p11)) throw new Error("Account is not a SingleKeySigner");
        let h10 = p11.getAnyPublicKey();
        switch (y10.serializeU32AsUleb128(h10.variant), h10.variant) {
          case 3:
            return po(p11, y10), y10.toUint8Array();
          case 4: {
            let _8 = p11;
            return po(_8, y10), _8.publicKey.jwkAddress.serialize(y10), y10.serializeBool(_8.audless), y10.toUint8Array();
          }
          case 1:
          case 0:
            return p11.privateKey.serialize(y10), y10.toUint8Array();
          default:
            throw new Error(`Invalid public key variant: ${h10.variant}`);
        }
      }
      case 3: {
        let h10 = p11;
        return h10.publicKey.serialize(y10), y10.serializeU32AsUleb128(h10.signers.length), h10.signers.forEach((_8) => {
          y10.serializeFixedBytes(n94(_8));
        }), y10.toUint8Array();
      }
      default:
        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${p11.signingScheme}`);
    }
  }
  g5.toBytes = n94;
  function e20(p11) {
    return a3.hexInputToStringWithoutPrefix(n94(p11));
  }
  g5.toHexStringWithoutPrefix = e20;
  function t18(p11) {
    return a3.hexInputToString(n94(p11));
  }
  g5.toHexString = t18;
  function r18(p11) {
    let { address: y10, signingScheme: h10 } = uo(p11);
    switch (h10) {
      case 0: {
        let _8 = z3.deserialize(p11);
        return new Q2({ privateKey: _8, address: y10 });
      }
      case 2: {
        let _8 = p11.deserializeUleb128AsU32();
        switch (_8) {
          case 0: {
            let G3 = z3.deserialize(p11);
            return new ne({ privateKey: G3, address: y10 });
          }
          case 1: {
            let G3 = v2.deserialize(p11);
            return new ne({ privateKey: G3, address: y10 });
          }
          case 3: {
            let G3 = lo(p11), J = qe(G3);
            return new he({ ...G3, ...J });
          }
          case 4: {
            let G3 = lo(p11), J = l3.deserialize(p11), Ue2 = p11.deserializeBool(), Je = qe(G3);
            return new Ke({ ...G3, ...Je, jwkAddress: J, audless: Ue2 });
          }
          default:
            throw new Error(`Unsupported public key variant ${_8}`);
        }
      }
      case 3: {
        let _8 = W5.deserialize(p11), G3 = p11.deserializeUleb128AsU32(), J = new Array();
        for (let Ue2 = 0; Ue2 < G3; Ue2 += 1) {
          let Je = r18(p11);
          if (!vr(Je) && !(Je instanceof Q2)) throw new Error("Deserialization of MultiKeyAccount failed. Signer is not a SingleKeySigner or Ed25519Account");
          J.push(Je);
        }
        return new $e({ multiKey: _8, signers: J, address: y10 });
      }
      default:
        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${h10}`);
    }
  }
  g5.deserialize = r18;
  function i27(p11) {
    let y10 = d15(p11);
    if (!(y10 instanceof he)) throw new Error("Deserialization of KeylessAccount failed");
    return y10;
  }
  g5.keylessAccountFromHex = i27;
  function o26(p11) {
    let y10 = d15(p11);
    if (!(y10 instanceof Ke)) throw new Error("Deserialization of FederatedKeylessAccount failed");
    return y10;
  }
  g5.federatedKeylessAccountFromHex = o26;
  function s11(p11) {
    let y10 = d15(p11);
    if (!(y10 instanceof $e)) throw new Error("Deserialization of MultiKeyAccount failed");
    return y10;
  }
  g5.multiKeyAccountFromHex = s11;
  function a24(p11) {
    let y10 = d15(p11);
    if (!(y10 instanceof ne)) throw new Error("Deserialization of SingleKeyAccount failed");
    return y10;
  }
  g5.singleKeyAccountFromHex = a24;
  function c7(p11) {
    let y10 = d15(p11);
    if (!(y10 instanceof Q2)) throw new Error("Deserialization of Ed25519Account failed");
    return y10;
  }
  g5.ed25519AccountFromHex = c7;
  function d15(p11) {
    return r18(a11.fromHex(p11));
  }
  g5.fromHex = d15;
  function l14(p11) {
    return d15(p11);
  }
  g5.fromBytes = l14;
})(go || (go = {}));
var Qn = class n70 extends Le {
  constructor({ signer: t18, accountAddress: r18, authenticationFunction: i27 }) {
    super();
    this.signingScheme = 2;
    if (!w(i27)) throw new Error(`Invalid authentication function ${i27} passed into AbstractedAccount`);
    this.authenticationFunction = i27, this.accountAddress = r18, this.publicKey = new a10(this.accountAddress), this.sign = (o26) => new n10(t18(o26));
  }
  static fromPermissionedSigner({ signer: t18, accountAddress: r18 }) {
    return new n70({ signer: (i27) => {
      let o26 = new n4();
      return t18.publicKey.serialize(o26), t18.sign(i27).serialize(o26), o26.toUint8Array();
    }, accountAddress: r18 ?? t18.accountAddress, authenticationFunction: "0x1::permissioned_delegation::authenticate" });
  }
  signWithAuthenticator(t18) {
    return new dt(this.authenticationFunction, sha3_256(t18), this.sign(sha3_256(t18)).toUint8Array());
  }
  signTransactionWithAuthenticator(t18) {
    return this.signWithAuthenticator(Pe(t18));
  }
  signTransaction(t18) {
    return this.sign(Pe(t18));
  }
  setSigner(t18) {
    this.sign = (r18) => new n10(t18(r18));
  }
};
var un = class un2 extends Qn {
  constructor({ signer: e20, authenticationFunction: t18, abstractPublicKey: r18 }) {
    let i27 = new l3(un2.computeAccountAddress(t18, r18));
    super({ accountAddress: i27, signer: e20, authenticationFunction: t18 }), this.abstractPublicKey = r18;
  }
  static computeAccountAddress(e20, t18) {
    if (!w(e20)) throw new Error(`Invalid authentication function ${e20} passed into DerivableAbstractedAccount`);
    let [r18, i27, o26] = e20.split("::"), s11 = sha3_256.create(), a24 = new n4();
    l3.fromString(r18).serialize(a24), a24.serializeStr(i27), a24.serializeStr(o26), s11.update(a24.toUint8Array());
    let c7 = new n4();
    return c7.serializeBytes(t18), s11.update(c7.toUint8Array()), s11.update(new Uint8Array([un2.ADDRESS_DOMAIN_SEPERATOR])), s11.digest();
  }
  signWithAuthenticator(e20) {
    return new dt(this.authenticationFunction, sha3_256(e20), this.sign(sha3_256(e20)).value, this.abstractPublicKey);
  }
};
un.ADDRESS_DOMAIN_SEPERATOR = 5;
function fo(n94) {
  return !!n94.match(/^[_a-zA-Z0-9]+$/);
}
function Ao(n94) {
  return !!n94.match(/\s/);
}
function da(n94) {
  return !!n94.match(/^T[0-9]+$/);
}
function pa2(n94) {
  return !!n94.match(/^&.+$/);
}
function la(n94) {
  switch (n94) {
    case "signer":
    case "address":
    case "bool":
    case "u8":
    case "u16":
    case "u32":
    case "u64":
    case "u128":
    case "u256":
      return true;
    default:
      return false;
  }
}
function ga(n94, e20) {
  let t18 = e20;
  for (; t18 < n94.length; t18 += 1) {
    let r18 = n94[t18];
    if (!Ao(r18)) break;
  }
  return t18;
}
var ya = ((h10) => (h10.InvalidTypeTag = "unknown type", h10.UnexpectedGenericType = "unexpected generic type", h10.UnexpectedTypeArgumentClose = "unexpected '>'", h10.UnexpectedWhitespaceCharacter = "unexpected whitespace character", h10.UnexpectedComma = "unexpected ','", h10.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", h10.MissingTypeArgumentClose = "no matching '>' for '<'", h10.MissingTypeArgument = "no type argument before ','", h10.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", h10.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", h10.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", h10.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", h10.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", h10.InvalidAddress = "struct address must be valid", h10))(ya || {});
var H2 = class extends Error {
  constructor(e20, t18) {
    super(`Failed to parse typeTag '${e20}', ${t18}`);
  }
};
function xe(n94, e20) {
  let t18 = e20?.allowGenerics ?? false, r18 = [], i27 = [], o26 = [], s11 = 0, a24 = "", c7 = 1;
  for (; s11 < n94.length; ) {
    let d15 = n94[s11];
    if (d15 === "<") r18.push({ savedExpectedTypes: c7, savedStr: a24, savedTypes: o26 }), a24 = "", o26 = [], c7 = 1;
    else if (d15 === ">") {
      if (a24 !== "") {
        let h10 = dn(a24, i27, t18);
        o26.push(h10);
      }
      let l14 = r18.pop();
      if (l14 === void 0) throw new H2(n94, "unexpected '>'");
      if (c7 !== o26.length) throw new H2(n94, "type argument count doesn't match expected amount");
      let { savedStr: g5, savedTypes: p11, savedExpectedTypes: y10 } = l14;
      i27 = o26, o26 = p11, a24 = g5, c7 = y10;
    } else if (d15 === ",") {
      if (r18.length === 0) throw new H2(n94, "unexpected ','");
      if (a24.length === 0) throw new H2(n94, "no type argument before ','");
      let l14 = dn(a24, i27, t18);
      i27 = [], o26.push(l14), a24 = "", c7 += 1;
    } else if (Ao(d15)) {
      let l14 = false;
      if (a24.length !== 0) {
        let p11 = dn(a24, i27, t18);
        i27 = [], o26.push(p11), a24 = "", l14 = true;
      }
      s11 = ga(n94, s11);
      let g5 = n94[s11];
      if (s11 < n94.length && l14 && g5 !== "," && g5 !== ">") throw new H2(n94, "unexpected whitespace character");
      continue;
    } else a24 += d15;
    s11 += 1;
  }
  if (r18.length > 0) throw new H2(n94, "no matching '>' for '<'");
  switch (o26.length) {
    case 0:
      return dn(a24, i27, t18);
    case 1:
      if (a24 === "") return o26[0];
      throw new H2(n94, "unexpected ','");
    default:
      throw new H2(n94, "unexpected whitespace character");
  }
}
function dn(n94, e20, t18) {
  let r18 = n94.trim(), i27 = r18.toLowerCase();
  if (la(i27) && e20.length > 0) throw new H2(n94, "primitive types not expected to have type arguments");
  switch (r18.toLowerCase()) {
    case "signer":
      return new pt();
    case "bool":
      return new B6();
    case "address":
      return new D3();
    case "u8":
      return new ce();
    case "u16":
      return new ze();
    case "u32":
      return new Ne();
    case "u64":
      return new q5();
    case "u128":
      return new Ge();
    case "u256":
      return new Be();
    case "vector":
      if (e20.length !== 1) throw new H2(n94, "vector type expected to have exactly one type argument");
      return new C6(e20[0]);
    default:
      if (pa2(r18)) {
        let a24 = r18.substring(1);
        return new Bn(dn(a24, e20, t18));
      }
      if (da(r18)) {
        if (t18) return new O6(Number(r18.split("T")[1]));
        throw new H2(n94, "unexpected generic type");
      }
      if (!r18.match(/:/)) throw new H2(n94, "unknown type");
      let o26 = r18.split("::");
      if (o26.length !== 3) throw new H2(n94, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
      let s11;
      try {
        s11 = l3.fromString(o26[0]);
      } catch {
        throw new H2(n94, "struct address must be valid");
      }
      if (!fo(o26[1])) throw new H2(n94, "module name must only contain alphanumeric or '_' characters");
      if (!fo(o26[2])) throw new H2(n94, "struct name must only contain alphanumeric or '_' characters");
      return new m12(new ke(s11, new r8(o26[1]), new r8(o26[2]), e20));
  }
}
function ho(n94) {
  return typeof n94 == "boolean";
}
function We(n94) {
  return typeof n94 == "string";
}
function ma(n94) {
  return typeof n94 == "number";
}
function Jn(n94) {
  if (ma(n94)) return n94;
  if (We(n94) && n94 !== "") return Number.parseInt(n94, 10);
}
function Zn(n94) {
  return typeof n94 == "number" || typeof n94 == "bigint" || typeof n94 == "string";
}
function bo(n94) {
  return n94 == null;
}
function wo(n94) {
  return kr(n94) || Ur2(n94) || Dr(n94) || Rr(n94) || Or(n94) || zr(n94) || Nr(n94) || Yn(n94) || Fr(n94) || fa(n94) || n94 instanceof t3 || n94 instanceof A8;
}
function kr(n94) {
  return n94 instanceof U5;
}
function Yn(n94) {
  return n94 instanceof l3;
}
function Fr(n94) {
  return n94 instanceof a13;
}
function fa(n94) {
  return n94 instanceof t7;
}
function Ur2(n94) {
  return n94 instanceof p4;
}
function Dr(n94) {
  return n94 instanceof b2;
}
function Rr(n94) {
  return n94 instanceof y5;
}
function Or(n94) {
  return n94 instanceof m7;
}
function zr(n94) {
  return n94 instanceof B4;
}
function Nr(n94) {
  return n94 instanceof a12;
}
function To(n94) {
  return "bytecode" in n94;
}
function I4(n94, e20) {
  throw new Error(`Type mismatch for argument ${e20}, expected '${n94}'`);
}
function So(n94) {
  let e20 = n94.params.findIndex((t18) => t18 !== "signer" && t18 !== "&signer");
  return e20 < 0 ? n94.params.length : e20;
}
var Aa = new TextEncoder();
function Xn(n94) {
  return n94?.map((e20) => We(e20) ? xe(e20) : e20) ?? [];
}
async function ha(n94, e20, t18) {
  return (await er({ aptosConfig: t18, accountAddress: n94, moduleName: e20 })).abi;
}
async function Br(n94, e20, t18, r18) {
  let i27 = await ha(n94, e20, r18);
  if (!i27) throw new Error(`Could not find module ABI for '${n94}::${e20}'`);
  return i27.exposed_functions.find((o26) => o26.name === t18);
}
async function Po(n94, e20, t18, r18) {
  let i27 = await Br(n94, e20, t18, r18);
  if (!i27) throw new Error(`Could not find entry function ABI for '${n94}::${e20}::${t18}'`);
  if (!i27.is_entry) throw new Error(`'${n94}::${e20}::${t18}' is not an entry function`);
  let o26 = So(i27), s11 = [];
  for (let a24 = o26; a24 < i27.params.length; a24 += 1) s11.push(xe(i27.params[a24], { allowGenerics: true }));
  return { signers: o26, typeParameters: i27.generic_type_params, parameters: s11 };
}
async function Ko(n94, e20, t18, r18) {
  let i27 = await Br(n94, e20, t18, r18);
  if (!i27) throw new Error(`Could not find view function ABI for '${n94}::${e20}::${t18}'`);
  if (!i27.is_view) throw new Error(`'${n94}::${e20}::${t18}' is not an view function`);
  let o26 = [];
  for (let a24 = 0; a24 < i27.params.length; a24 += 1) o26.push(xe(i27.params[a24], { allowGenerics: true }));
  let s11 = [];
  for (let a24 = 0; a24 < i27.return.length; a24 += 1) s11.push(xe(i27.return[a24], { allowGenerics: true }));
  return { typeParameters: i27.generic_type_params, parameters: o26, returnTypes: s11 };
}
function Mr(n94, e20, t18, r18, i27, o26) {
  let s11;
  if ("exposed_functions" in e20) {
    let a24 = e20.exposed_functions.find((c7) => c7.name === n94);
    if (!a24) throw new Error(`Could not find function ABI for '${e20.address}::${e20.name}::${n94}'`);
    if (r18 >= a24.params.length) throw new Error(`Too many arguments for '${n94}', expected ${a24.params.length}`);
    s11 = xe(a24.params[r18], { allowGenerics: true });
  } else {
    if (r18 >= e20.parameters.length) throw new Error(`Too many arguments for '${n94}', expected ${e20.parameters.length}`);
    s11 = e20.parameters[r18];
  }
  return wt(t18, s11, r18, i27, "exposed_functions" in e20 ? e20 : void 0, o26);
}
function wt(n94, e20, t18, r18, i27, o26) {
  return wo(n94) ? (Gr(e20, n94, t18), n94) : ba(n94, e20, t18, r18, i27, o26);
}
function ba(n94, e20, t18, r18, i27, o26) {
  if (e20.isBool()) {
    if (ho(n94)) return new U5(n94);
    if (We(n94)) {
      if (n94 === "true") return new U5(true);
      if (n94 === "false") return new U5(false);
    }
    I4("boolean", t18);
  }
  if (e20.isAddress()) {
    if (We(n94)) return l3.fromString(n94);
    if (n94 && typeof n94 == "object" && "data" in n94 && n94.data instanceof Uint8Array) return new l3(n94.data);
    I4("string | AccountAddress", t18);
  }
  if (e20.isU8()) {
    let s11 = Jn(n94);
    if (s11 !== void 0) return new p4(s11);
    I4("number | string", t18);
  }
  if (e20.isU16()) {
    let s11 = Jn(n94);
    if (s11 !== void 0) return new b2(s11);
    I4("number | string", t18);
  }
  if (e20.isU32()) {
    let s11 = Jn(n94);
    if (s11 !== void 0) return new y5(s11);
    I4("number | string", t18);
  }
  if (e20.isU64()) {
    if (Zn(n94)) return new m7(BigInt(n94));
    I4("bigint | number | string", t18);
  }
  if (e20.isU128()) {
    if (Zn(n94)) return new B4(BigInt(n94));
    I4("bigint | number | string", t18);
  }
  if (e20.isU256()) {
    if (Zn(n94)) return new a12(BigInt(n94));
    I4("bigint | number | string", t18);
  }
  if (e20.isGeneric()) {
    let s11 = e20.value;
    if (s11 < 0 || s11 >= r18.length) throw new Error(`Generic argument ${e20.toString()} is invalid for argument ${t18}`);
    return wt(n94, r18[s11], t18, r18, i27);
  }
  if (e20.isVector()) {
    if (e20.value.isU8()) {
      if (We(n94)) return t3.U8(Aa.encode(n94));
      if (n94 instanceof Uint8Array) return t3.U8(n94);
      if (n94 instanceof ArrayBuffer) return t3.U8(new Uint8Array(n94));
    }
    if (We(n94) && n94.startsWith("[")) return wt(JSON.parse(n94), e20, t18, r18);
    if (Array.isArray(n94)) return new t3(n94.map((s11) => wt(s11, e20.value, t18, r18, i27)));
    throw new Error(`Type mismatch for argument ${t18}, type '${e20.toString()}'`);
  }
  if (e20.isStruct()) {
    if (e20.isString()) {
      if (We(n94)) return new a13(n94);
      I4("string", t18);
    }
    if (e20.isObject()) {
      if (We(n94)) return l3.fromString(n94);
      if (n94 && typeof n94 == "object" && "data" in n94 && n94.data instanceof Uint8Array) return new l3(n94.data);
      I4("string | AccountAddress", t18);
    }
    if (e20.isDelegationKey() || e20.isRateLimiter()) {
      if (n94 instanceof Uint8Array) return new t7(n94);
      I4("Uint8Array", t18);
    }
    if (e20.isOption()) {
      if (bo(n94)) {
        let a24 = e20.value.typeArgs[0];
        return a24 instanceof B6 ? new A8(null) : a24 instanceof D3 ? new A8(null) : a24 instanceof ce ? new A8(null) : a24 instanceof ze ? new A8(null) : a24 instanceof Ne ? new A8(null) : a24 instanceof q5 ? new A8(null) : a24 instanceof Ge ? new A8(null) : a24 instanceof Be ? new A8(null) : new A8(null);
      }
      return new A8(wt(n94, e20.value.typeArgs[0], t18, r18, i27));
    }
    if (i27?.structs.find((a24) => a24.name === e20.value.name.identifier)?.fields.length === 0 && n94 instanceof Uint8Array) return new t7(n94);
    if (n94 instanceof Uint8Array && o26?.allowUnknownStructs) return console.warn(`Unsupported struct input type for argument ${t18}. Continuing since 'allowUnknownStructs' is enabled.`), new t7(n94);
    throw new Error(`Unsupported struct input type for argument ${t18}, type '${e20.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${t18}, type '${e20.toString()}'`);
}
function Gr(n94, e20, t18) {
  if (n94.isBool()) {
    if (kr(e20)) return;
    I4("Bool", t18);
  }
  if (n94.isAddress()) {
    if (Yn(e20)) return;
    I4("AccountAddress", t18);
  }
  if (n94.isU8()) {
    if (Ur2(e20)) return;
    I4("U8", t18);
  }
  if (n94.isU16()) {
    if (Dr(e20)) return;
    I4("U16", t18);
  }
  if (n94.isU32()) {
    if (Rr(e20)) return;
    I4("U32", t18);
  }
  if (n94.isU64()) {
    if (Or(e20)) return;
    I4("U64", t18);
  }
  if (n94.isU128()) {
    if (zr(e20)) return;
    I4("U128", t18);
  }
  if (n94.isU256()) {
    if (Nr(e20)) return;
    I4("U256", t18);
  }
  if (n94.isVector()) {
    if (e20 instanceof t3) {
      e20.values.length > 0 && Gr(n94.value, e20.values[0], t18);
      return;
    }
    I4("MoveVector", t18);
  }
  if (n94 instanceof m12) {
    if (n94.isString()) {
      if (Fr(e20)) return;
      I4("MoveString", t18);
    }
    if (n94.isObject()) {
      if (Yn(e20)) return;
      I4("AccountAddress", t18);
    }
    if (n94.isOption()) {
      if (e20 instanceof A8) {
        e20.value !== void 0 && Gr(n94.value.typeArgs[0], e20.value, t18);
        return;
      }
      I4("MoveOption", t18);
    }
  }
  throw new Error(`Type mismatch for argument ${t18}, expected '${n94.toString()}'`);
}
async function tr(n94) {
  if (To(n94)) return Pa(n94);
  let { moduleAddress: e20, moduleName: t18, functionName: r18 } = v(n94.function), i27 = await vo({ key: "entry-function", moduleAddress: e20, moduleName: t18, functionName: r18, aptosConfig: n94.aptosConfig, abi: n94.abi, fetch: Po });
  return Ta({ ...n94, abi: i27 });
}
function Ta(n94) {
  let e20 = n94.abi, { moduleAddress: t18, moduleName: r18, functionName: i27 } = v(n94.function), o26 = Xn(n94.typeArguments);
  if (o26.length !== e20.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${e20.typeParameters.length}, received ${o26.length}`);
  let s11 = n94.functionArguments.map((c7, d15) => Mr(n94.function, e20, c7, d15, o26));
  if (s11.length !== e20.parameters.length) throw new Error(`Too few arguments for '${t18}::${r18}::${i27}', expected ${e20.parameters.length} but got ${s11.length}`);
  let a24 = Me.build(`${t18}::${r18}`, i27, o26, s11);
  if ("multisigAddress" in n94) {
    let c7 = l3.from(n94.multisigAddress);
    return new Nt(new on(c7, new sn(a24)));
  }
  return new zt(a24);
}
async function xo(n94) {
  let { moduleAddress: e20, moduleName: t18, functionName: r18 } = v(n94.function), i27 = await vo({ key: "view-function", moduleAddress: e20, moduleName: t18, functionName: r18, aptosConfig: n94.aptosConfig, abi: n94.abi, fetch: Ko });
  return Sa({ abi: i27, ...n94 });
}
function Sa(n94) {
  let e20 = n94.abi, { moduleAddress: t18, moduleName: r18, functionName: i27 } = v(n94.function), o26 = Xn(n94.typeArguments);
  if (o26.length !== e20.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${e20.typeParameters.length}, received ${o26.length}`);
  let s11 = n94?.functionArguments?.map((a24, c7) => Mr(n94.function, e20, a24, c7, o26)) ?? [];
  if (s11.length !== e20.parameters.length) throw new Error(`Too few arguments for '${t18}::${r18}::${i27}', expected ${e20.parameters.length} but got ${s11.length}`);
  return Me.build(`${t18}::${r18}`, i27, o26, s11);
}
function Pa(n94) {
  return new Ot(new Gt2(a3.fromHexInput(n94.bytecode).toUint8Array(), Xn(n94.typeArguments), n94.functionArguments));
}
async function Ka(n94) {
  let { aptosConfig: e20, sender: t18, payload: r18, options: i27, feePayerAddress: o26 } = n94;
  if (i27?.replayProtectionNonce !== void 0 && i27?.accountSequenceNumber !== void 0) throw new Error("Cannot specify both replayProtectionNonce and accountSequenceNumber in options.");
  let s11 = async () => r10[e20.network] ? { chainId: r10[e20.network] } : { chainId: (await d6({ aptosConfig: e20 })).chain_id }, a24 = async () => i27?.gasUnitPrice ? { gasEstimate: i27.gasUnitPrice } : { gasEstimate: (await W3({ aptosConfig: e20 })).gas_estimate }, c7 = async () => {
    let J = async () => i27?.accountSequenceNumber !== void 0 ? i27.accountSequenceNumber : i27?.replayProtectionNonce !== void 0 ? 0xdeadbeefn : (await g({ aptosConfig: e20, accountAddress: t18 })).sequence_number;
    if (o26 && l3.from(o26).equals(l3.ZERO)) try {
      return await J();
    } catch {
      return 0;
    }
    else return J();
  }, [{ chainId: d15 }, { gasEstimate: l14 }, g5] = await Promise.all([s11(), a24(), c7()]), { maxGasAmount: p11, gasUnitPrice: y10, expireTimestamp: h10, replayProtectionNonce: _8 } = { maxGasAmount: i27?.maxGasAmount ? BigInt(i27.maxGasAmount) : BigInt(e20.getDefaultMaxGasAmount()), gasUnitPrice: i27?.gasUnitPrice ?? BigInt(l14), expireTimestamp: i27?.expireTimestamp ?? BigInt(Math.floor(Date.now() / 1e3) + e20.getDefaultTxnExpirySecFromNow()), replayProtectionNonce: i27?.replayProtectionNonce ? BigInt(i27.replayProtectionNonce) : void 0 }, G3 = r18;
  return _8 !== void 0 && (G3 = xa(r18, _8)), new Ae2(l3.from(t18), BigInt(g5), G3, BigInt(p11), BigInt(y10), BigInt(h10), new r7(d15));
}
function xa(n94, e20) {
  if (n94 instanceof Ot) return new lt(new an(n94.script), new gt(void 0, e20));
  if (n94 instanceof zt) return new lt(new Mt(n94.entryFunction), new gt(void 0, e20));
  if (n94 instanceof Nt) {
    let t18 = n94.multiSig.transaction_payload, r18;
    if (t18 === void 0 || t18?.transaction_payload === void 0) r18 = new cn();
    else if (t18.transaction_payload instanceof Me) r18 = new Mt(t18.transaction_payload);
    else throw new Error("Scripts are not supported in multi-sig transactions.");
    return new lt(r18, new gt(n94.multiSig.multisig_address, e20));
  } else throw new Error(`Unsupported payload type: ${n94}`);
}
async function Vr(n94) {
  let { aptosConfig: e20, sender: t18, payload: r18, options: i27, feePayerAddress: o26 } = n94, s11 = await Ka({ aptosConfig: e20, sender: t18, payload: r18, options: i27, feePayerAddress: o26 });
  if ("secondarySignerAddresses" in n94) {
    let a24 = n94.secondarySignerAddresses?.map((c7) => l3.from(c7)) ?? [];
    return new qn(s11, a24, n94.feePayerAddress ? l3.from(n94.feePayerAddress) : void 0);
  }
  return new Ln(s11, n94.feePayerAddress ? l3.from(n94.feePayerAddress) : void 0);
}
function Eo(n94) {
  let { signerPublicKey: e20, transaction: t18, secondarySignersPublicKeys: r18, feePayerPublicKey: i27 } = n94, o26 = jt(e20);
  if (t18.feePayerAddress) {
    let a24 = new mt(t18.rawTransaction, t18.secondarySignerAddresses ?? [], t18.feePayerAddress), c7 = [];
    t18.secondarySignerAddresses && (r18 ? c7 = r18.map((g5) => jt(g5)) : c7 = Array.from({ length: t18.secondarySignerAddresses.length }, () => jt(void 0)));
    let d15 = jt(i27), l14 = new ht(o26, t18.secondarySignerAddresses ?? [], c7, { address: t18.feePayerAddress, authenticator: d15 });
    return new He(a24.raw_txn, l14).bcsToBytes();
  }
  if (t18.secondarySignerAddresses) {
    let a24 = new yt(t18.rawTransaction, t18.secondarySignerAddresses), c7 = [];
    r18 ? c7 = r18.map((l14) => jt(l14)) : c7 = Array.from({ length: t18.secondarySignerAddresses.length }, () => jt(void 0));
    let d15 = new At(o26, t18.secondarySignerAddresses, c7);
    return new He(a24.raw_txn, d15).bcsToBytes();
  }
  let s11;
  if (o26 instanceof Se2) s11 = new ft(o26.public_key, o26.signature);
  else if (o26 instanceof te || o26 instanceof _e2) s11 = new nt(o26);
  else if (o26 instanceof Rt) s11 = new nt(o26);
  else throw new Error("Invalid public key");
  return new He(t18.rawTransaction, s11).bcsToBytes();
}
function jt(n94) {
  if (!n94) return new Rt();
  let t18 = v5.isInstance(n94) || V2.isInstance(n94) || m4.isInstance(n94) ? new E7(n94) : n94, r18 = new h6(new Uint8Array(64));
  if (f6.isInstance(t18)) return new Se2(t18, r18);
  if (E7.isInstance(t18)) return v5.isInstance(t18.publicKey) ? new te(t18, new U8(ee.getSimulationSignature())) : new te(t18, new U8(r18));
  if (W5.isInstance(t18)) return new _e2(t18, new me({ signatures: t18.publicKeys.map((i27) => v5.isInstance(i27.publicKey) || V2.isInstance(i27.publicKey) ? new U8(ee.getSimulationSignature()) : new U8(r18)), bitmap: t18.createBitmap({ bits: Array(t18.publicKeys.length).fill(0).map((i27, o26) => o26) }) }));
  throw new Error("Unsupported PublicKey used for simulations");
}
function Hr(n94) {
  let { transaction: e20, feePayerAuthenticator: t18, additionalSignersAuthenticators: r18 } = n94, i27 = t6(L2, n94.senderAuthenticator), o26;
  if (e20.feePayerAddress) {
    if (!t18) throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    o26 = new ht(i27, e20.secondarySignerAddresses ?? [], r18 ?? [], { address: e20.feePayerAddress, authenticator: t18 });
  } else if (e20.secondarySignerAddresses) {
    if (!r18) throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
    o26 = new At(i27, e20.secondarySignerAddresses, r18);
  } else i27 instanceof Se2 ? o26 = new ft(i27.public_key, i27.signature) : i27 instanceof Oe ? o26 = new Vt(i27.public_key, i27.signature) : o26 = new nt(i27);
  return new He(e20.rawTransaction, o26).bcsToBytes();
}
function Co(n94) {
  let e20 = sha3_256.create();
  for (let t18 of n94) e20.update(t18);
  return e20.digest();
}
var Ea = Co(["APTOS::Transaction"]);
async function vo({ key: n94, moduleAddress: e20, moduleName: t18, functionName: r18, aptosConfig: i27, abi: o26, fetch: s11 }) {
  return o26 !== void 0 ? o26 : m(async () => s11(e20, t18, r18, i27), `${n94}-${i27.network}-${e20}-${t18}-${r18}`, 1e3 * 60 * 5)();
}
async function f10(n94) {
  let e20 = await va(n94);
  return Ia(n94, e20);
}
async function va(n94) {
  let { aptosConfig: e20, data: t18 } = n94, r18, i27;
  return "bytecode" in t18 ? i27 = await tr(t18) : "multisigAddress" in t18 ? (r18 = { aptosConfig: e20, multisigAddress: t18.multisigAddress, function: t18.function, functionArguments: t18.functionArguments, typeArguments: t18.typeArguments, abi: t18.abi }, i27 = await tr(r18)) : (r18 = { aptosConfig: e20, function: t18.function, functionArguments: t18.functionArguments, typeArguments: t18.typeArguments, abi: t18.abi }, i27 = await tr(r18)), i27;
}
async function Ia(n94, e20) {
  let { aptosConfig: t18, sender: r18, options: i27 } = n94, o26;
  if (_a(n94) && (o26 = l3.ZERO.toString()), ka(n94)) {
    let { secondarySignerAddresses: s11 } = n94;
    return Vr({ aptosConfig: t18, sender: r18, payload: e20, options: i27, secondarySignerAddresses: s11, feePayerAddress: o26 });
  }
  return Vr({ aptosConfig: t18, sender: r18, payload: e20, options: i27, feePayerAddress: o26 });
}
function _a(n94) {
  return n94.withFeePayer === true;
}
function ka(n94) {
  return "secondarySignerAddresses" in n94;
}
function Io(n94) {
  let { transaction: e20 } = n94;
  return Pe(e20);
}
function nr(n94) {
  let { signer: e20, transaction: t18 } = n94;
  return e20.signTransactionWithAuthenticator(t18);
}
function rr(n94) {
  let { signer: e20, transaction: t18 } = n94;
  if (!t18.feePayerAddress) throw new Error(`Transaction ${t18} is not a Fee Payer transaction`);
  return t18.feePayerAddress = e20.accountAddress, nr({ signer: e20, transaction: t18 });
}
async function Lr(n94) {
  let { aptosConfig: e20, transaction: t18, signerPublicKey: r18, secondarySignersPublicKeys: i27, feePayerPublicKey: o26, options: s11 } = n94, a24 = Eo({ transaction: t18, signerPublicKey: r18, secondarySignersPublicKeys: i27, feePayerPublicKey: o26, options: s11 }), { data: c7 } = await q3({ aptosConfig: e20, body: a24, path: "transactions/simulate", params: { estimate_gas_unit_price: n94.options?.estimateGasUnitPrice ?? false, estimate_max_gas_amount: n94.options?.estimateMaxGasAmount ?? false, estimate_prioritized_gas_unit_price: n94.options?.estimatePrioritizedGasUnitPrice ?? false }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return c7;
}
async function pn(n94) {
  let { aptosConfig: e20, transactionSubmitter: t18 } = n94, r18 = t18 === void 0 ? e20.getTransactionSubmitter() : t18;
  if (r18) return r18.submitTransaction(n94);
  let i27 = Hr({ ...n94 });
  try {
    let { data: o26 } = await q3({ aptosConfig: e20, body: i27, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
    return o26;
  } catch (o26) {
    let s11 = He.deserialize(new a11(i27));
    throw s11.authenticator.isSingleSender() && s11.authenticator.sender.isSingleKey() && (s11.authenticator.sender.public_key.publicKey instanceof v5 || s11.authenticator.sender.public_key.publicKey instanceof V2) && await pe2.fetchJWK({ aptosConfig: e20, publicKey: s11.authenticator.sender.public_key.publicKey, kid: s11.authenticator.sender.signature.signature.getJwkKid() }), o26;
  }
}
async function it(n94) {
  let { aptosConfig: e20, signer: t18, feePayer: r18, transaction: i27, ...o26 } = n94;
  jn(t18) && await t18.checkKeylessAccountValidity(e20), jn(r18) && await r18.checkKeylessAccountValidity(e20);
  let s11 = n94.feePayerAuthenticator || r18 && rr({ signer: r18, transaction: i27 }), a24 = nr({ signer: t18, transaction: i27 });
  return pn({ aptosConfig: e20, transaction: i27, senderAuthenticator: a24, feePayerAuthenticator: s11, ...o26 });
}
async function _o(n94) {
  let { aptosConfig: e20, senderAuthenticator: t18, feePayer: r18, transaction: i27, ...o26 } = n94;
  jn(r18) && await r18.checkKeylessAccountValidity(e20);
  let s11 = rr({ signer: r18, transaction: i27 });
  return pn({ aptosConfig: e20, transaction: i27, senderAuthenticator: t18, feePayerAuthenticator: s11, ...o26 });
}
var Fa = { typeParameters: [], parameters: [C6.u8(), new C6(C6.u8())] };
async function ko(n94) {
  let { aptosConfig: e20, account: t18, metadataBytes: r18, moduleBytecode: i27, options: o26 } = n94, s11 = i27.map((a24) => t3.U8(a24));
  return f10({ aptosConfig: e20, sender: l3.from(t18), data: { function: "0x1::code::publish_package_txn", functionArguments: [t3.U8(r18), new t3(s11)], abi: Fa }, options: o26 });
}
async function Qt(n94) {
  return g(n94);
}
async function Fo(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94;
  return A5({ aptosConfig: e20, originMethod: "getModules", path: `accounts/${l3.from(t18).toString()}/modules`, params: { ledger_version: r18?.ledgerVersion, limit: r18?.limit ?? 1e3 } });
}
async function Uo(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94, { response: i27, cursor: o26 } = await m2({ aptosConfig: e20, originMethod: "getModulesPage", path: `accounts/${l3.from(t18).toString()}/modules`, params: { ledger_version: r18?.ledgerVersion, cursor: r18?.cursor, limit: r18?.limit ?? 100 } });
  return { modules: i27.data, cursor: o26 };
}
async function er(n94) {
  return f3(n94);
}
async function $r(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94;
  return q({ aptosConfig: e20, originMethod: "getTransactions", path: `accounts/${l3.from(t18).toString()}/transactions`, params: { start: r18?.offset, limit: r18?.limit } });
}
async function Wr(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94;
  return A5({ aptosConfig: e20, originMethod: "getResources", path: `accounts/${l3.from(t18).toString()}/resources`, params: { ledger_version: r18?.ledgerVersion, limit: r18?.limit ?? 999 } });
}
async function Do(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94, { response: i27, cursor: o26 } = await m2({ aptosConfig: e20, originMethod: "getResourcesPage", path: `accounts/${l3.from(t18).toString()}/resources`, params: { ledger_version: r18?.ledgerVersion, cursor: r18?.cursor, limit: r18?.limit ?? 100 } });
  return { resources: i27.data, cursor: o26 };
}
async function jr(n94) {
  let { aptosConfig: e20, accountAddress: t18, resourceType: r18, options: i27 } = n94, { data: o26 } = await y2({ aptosConfig: e20, originMethod: "getResource", path: `accounts/${l3.from(t18).toString()}/resource/${r18}`, params: { ledger_version: i27?.ledgerVersion } });
  return o26.data;
}
async function Jt(n94) {
  let { aptosConfig: e20, authenticationKey: t18, options: r18 } = n94, i27 = await jr({ aptosConfig: e20, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: r18 }), { address_map: { handle: o26 } } = i27, s11 = l3.from(t18);
  try {
    let a24 = await b4({ aptosConfig: e20, handle: o26, data: { key: s11.toString(), key_type: "address", value_type: "address" }, options: r18 });
    return l3.from(a24);
  } catch (a24) {
    if (a24 instanceof T && a24.data.error_code === "table_item_not_found") return s11;
    throw a24;
  }
}
async function Ro(n94) {
  let { aptosConfig: e20, accountAddress: t18 } = n94, i27 = { owner_address: { _eq: l3.from(t18).toStringLong() }, amount: { _gt: 0 } }, s11 = await a17({ aptosConfig: e20, query: { query: m8, variables: { where_condition: i27 } }, originMethod: "getAccountTokensCount" });
  return s11.current_token_ownerships_v2_aggregate.aggregate ? s11.current_token_ownerships_v2_aggregate.aggregate.count : 0;
}
async function Oo(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94, o26 = { owner_address: { _eq: l3.from(t18).toStringLong() }, amount: { _gt: 0 } };
  r18?.tokenStandard && (o26.token_standard = { _eq: r18?.tokenStandard });
  let s11 = { query: y6, variables: { where_condition: o26, offset: r18?.offset, limit: r18?.limit, order_by: r18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: s11, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
}
async function zo(n94) {
  let { aptosConfig: e20, accountAddress: t18, collectionAddress: r18, options: i27 } = n94, o26 = l3.from(t18).toStringLong(), s11 = l3.from(r18).toStringLong(), a24 = { owner_address: { _eq: o26 }, current_token_data: { collection_id: { _eq: s11 } }, amount: { _gt: 0 } };
  i27?.tokenStandard && (a24.token_standard = { _eq: i27?.tokenStandard });
  let c7 = { query: p6, variables: { where_condition: a24, offset: i27?.offset, limit: i27?.limit, order_by: i27?.orderBy } };
  return (await a17({ aptosConfig: e20, query: c7, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
}
async function No(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94, o26 = { owner_address: { _eq: l3.from(t18).toStringLong() } };
  r18?.tokenStandard && (o26.current_collection = { token_standard: { _eq: r18?.tokenStandard } });
  let s11 = { query: d5, variables: { where_condition: o26, offset: r18?.offset, limit: r18?.limit, order_by: r18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: s11, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
}
async function Go(n94) {
  let { aptosConfig: e20, accountAddress: t18 } = n94, r18 = l3.from(t18).toStringLong(), o26 = await a17({ aptosConfig: e20, query: { query: g3, variables: { address: r18 } }, originMethod: "getAccountTransactionsCount" });
  return o26.account_transactions_aggregate.aggregate ? o26.account_transactions_aggregate.aggregate.count : 0;
}
async function Qr(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94, i27 = l3.from(t18).toStringLong(), o26 = { ...r18?.where, owner_address: { _eq: i27 } }, s11 = { query: c5, variables: { where_condition: o26, offset: r18?.offset, limit: r18?.limit, order_by: r18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: s11, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
}
async function Bo(n94) {
  let { aptosConfig: e20, accountAddress: t18 } = n94, r18 = l3.from(t18).toStringLong(), o26 = await a17({ aptosConfig: e20, query: { query: u6, variables: { address: r18 } }, originMethod: "getAccountCoinsCount" });
  if (!o26.current_fungible_asset_balances_aggregate.aggregate) throw Error("Failed to get the count of account coins");
  return o26.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function Jr(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94, o26 = { owner_address: { _eq: l3.from(t18).toStringLong() } }, s11 = { query: v3, variables: { where_condition: o26, offset: r18?.offset, limit: r18?.limit, order_by: r18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: s11, originMethod: "getAccountOwnedObjects" })).current_objects;
}
async function Mo(n94) {
  let { aptosConfig: e20, privateKey: t18, options: r18 } = n94, i27 = r18?.throwIfNoAccountFound ?? false, o26 = await ir({ aptosConfig: e20, privateKey: t18 });
  if (o26.length === 0) {
    if (i27) throw new Error("No existing account found for private key.");
    return Le.fromPrivateKey({ privateKey: t18 });
  }
  return o26[0];
}
async function Vo(n94) {
  let { aptosConfig: e20, accountAddress: t18, options: r18 } = n94;
  try {
    let [i27, o26] = await Promise.all([Wr({ aptosConfig: e20, accountAddress: t18 }), Jr({ aptosConfig: e20, accountAddress: t18, options: { limit: 1 } })]), s11 = i27.find((c7) => c7.type === "0x1::account::Account");
    if (!s11 && o26.length === 0) return false;
    if (!r18?.withAuthKey) return true;
    let a24;
    return s11 ? a24 = s11.data.authentication_key : a24 = t18.toStringLong(), a24 === r18.withAuthKey.toString();
  } catch (i27) {
    throw new Error(`Error while checking if account exists at ${t18.toString()}: ${i27}`);
  }
}
var Ua = { typeParameters: [], parameters: [new ce(), C6.u8(), new ce(), C6.u8(), C6.u8(), C6.u8()] };
async function Ho(n94) {
  let { aptosConfig: e20, fromAccount: t18, dangerouslySkipVerification: r18, options: i27 } = n94;
  if ("toNewPrivateKey" in n94) return qr({ aptosConfig: e20, fromAccount: t18, toNewPrivateKey: n94.toNewPrivateKey, options: i27 });
  let o26;
  if ("toAccount" in n94) {
    if (n94.toAccount instanceof Q2) return qr({ aptosConfig: e20, fromAccount: t18, toNewPrivateKey: n94.toAccount.privateKey, options: i27 });
    if (n94.toAccount instanceof Wt) return qr({ aptosConfig: e20, fromAccount: t18, toAccount: n94.toAccount, options: i27 });
    o26 = n94.toAccount.publicKey.authKey();
  } else if ("toAuthKey" in n94) o26 = n94.toAuthKey;
  else throw new Error("Invalid arguments");
  let s11 = await Ra({ aptosConfig: e20, fromAccount: t18, toAuthKey: o26, options: i27 });
  if (r18 === true) return s11;
  let a24 = await z4({ aptosConfig: e20, transactionHash: s11.hash });
  if (!a24.success) throw new Error(`Failed to rotate authentication key - ${a24}`);
  let c7 = await f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::account::set_originating_address", functionArguments: [] } });
  return it({ aptosConfig: e20, signer: n94.toAccount, transaction: c7 });
}
async function qr(n94) {
  let { aptosConfig: e20, fromAccount: t18, options: r18 } = n94, i27 = await Qt({ aptosConfig: e20, accountAddress: t18.accountAddress }), o26;
  "toNewPrivateKey" in n94 ? o26 = Le.fromPrivateKey({ privateKey: n94.toNewPrivateKey, legacy: true }) : o26 = n94.toAccount;
  let a24 = new c4({ sequenceNumber: BigInt(i27.sequence_number), originator: t18.accountAddress, currentAuthKey: l3.from(i27.authentication_key), newPublicKey: o26.publicKey }).bcsToBytes(), c7 = t18.sign(a24), d15 = o26.sign(a24), l14 = await f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new p4(t18.signingScheme), t3.U8(t18.publicKey.toUint8Array()), new p4(o26.signingScheme), t3.U8(o26.publicKey.toUint8Array()), t3.U8(c7.toUint8Array()), t3.U8(d15.toUint8Array())], abi: Ua }, options: r18 });
  return it({ aptosConfig: e20, signer: t18, transaction: l14 });
}
var Da = { typeParameters: [], parameters: [C6.u8()] };
async function Ra(n94) {
  let { aptosConfig: e20, fromAccount: t18, toAuthKey: r18, options: i27 } = n94, o26 = r18, s11 = await f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::account::rotate_authentication_key_call", functionArguments: [t3.U8(o26.toUint8Array())], abi: Da }, options: i27 });
  return it({ aptosConfig: e20, signer: t18, transaction: s11 });
}
async function or(n94) {
  let { aptosConfig: e20, publicKey: t18, options: r18 } = n94, i27 = r18?.noMultiKey ?? false;
  if (i27 && t18 instanceof we) throw new Error("Multi-key accounts are not supported when noMultiKey is true.");
  let o26 = [t18];
  t18 instanceof E7 && t18.publicKey instanceof f6 ? o26.push(t18.publicKey) : t18 instanceof f6 && o26.push(new E7(t18));
  let [s11, a24] = await Promise.all([Promise.all(o26.map(async (g5) => {
    let p11 = await Ba({ aptosConfig: e20, publicKey: g5 });
    if (p11) return { ...p11, publicKey: g5 };
  })), !(t18 instanceof we) && !i27 ? za({ aptosConfig: e20, publicKey: t18, options: r18 }) : Promise.resolve([])]), c7 = [];
  for (let g5 of s11) g5 && c7.push(g5);
  o26.push(...a24);
  let d15 = new Map(o26.map((g5) => [g5.authKey().toString(), g5])), l14 = await Na({ aptosConfig: e20, authKeys: o26.map((g5) => g5.authKey()), options: r18 });
  for (let g5 of l14) {
    if (c7.find((y10) => y10.accountAddress === g5.accountAddress)) continue;
    let p11 = d15.get(g5.authKey.toString());
    if (!p11) throw new Error(`No publicKey found for authentication key ${g5.authKey}. This should never happen.`);
    c7.push({ accountAddress: g5.accountAddress, publicKey: p11, lastTransactionVersion: g5.lastTransactionVersion });
  }
  return c7.sort((g5, p11) => p11.lastTransactionVersion - g5.lastTransactionVersion);
}
async function Zr(n94) {
  let { aptosConfig: e20, signer: t18, options: r18 } = n94;
  if (t18 instanceof z3 || t18 instanceof v2) return ir({ aptosConfig: e20, privateKey: t18, options: r18 });
  if (t18 instanceof Q2 || t18 instanceof ne) return ir({ aptosConfig: e20, privateKey: t18.privateKey, options: r18 });
  if (t18 instanceof he || t18 instanceof Ke) return Oa({ aptosConfig: e20, keylessAccount: t18, options: r18 });
  if (t18 instanceof $e && t18.signers.length === 1) return Zr({ aptosConfig: e20, signer: t18.signers[0], options: r18 });
  if (t18 instanceof Wt && t18.signers.length === 1) return ir({ aptosConfig: e20, privateKey: t18.signers[0], options: r18 });
  throw new Error("Unknown signer type");
}
async function Oa(n94) {
  let { aptosConfig: e20, keylessAccount: t18, options: r18 } = n94, i27 = await or({ aptosConfig: e20, publicKey: t18.getAnyPublicKey(), options: r18 }), o26 = { proof: t18.proofOrPromise, jwt: t18.jwt, ephemeralKeyPair: t18.ephemeralKeyPair, pepper: t18.pepper, verificationKeyHash: t18.verificationKeyHash }, s11 = [];
  for (let { accountAddress: a24, publicKey: c7 } of i27) if (c7 instanceof we) {
    if (c7.getSignaturesRequired() > 1) continue;
    if (c7 instanceof fe) throw new Error("Keyless authentication cannot be used for multi-ed25519 accounts. This should never happen.");
    c7 instanceof W5 && s11.push(new $e({ multiKey: c7, signers: [t18], address: a24 }));
  } else t18 instanceof Ke ? s11.push(Ke.create({ ...o26, address: a24, jwkAddress: t18.publicKey.jwkAddress })) : s11.push(he.create({ ...o26, address: a24 }));
  return s11;
}
async function ir(n94) {
  let { aptosConfig: e20, privateKey: t18, options: r18 } = n94, i27 = Le.fromPrivateKey({ privateKey: t18, legacy: false }), o26 = await or({ aptosConfig: e20, publicKey: new E7(t18.publicKey()), options: r18 }), s11 = [];
  for (let { accountAddress: a24, publicKey: c7 } of o26) if (c7 instanceof we) {
    if (c7.getSignaturesRequired() > 1) continue;
    c7 instanceof fe ? s11.push(new Wt({ publicKey: c7, signers: [t18], address: a24 })) : c7 instanceof W5 && s11.push(new $e({ multiKey: c7, signers: [i27], address: a24 }));
  } else {
    let d15 = c7 instanceof f6;
    s11.push(Le.fromPrivateKey({ privateKey: t18, address: a24, legacy: d15 }));
  }
  return s11;
}
async function za(n94) {
  let { aptosConfig: e20, publicKey: t18, options: r18 } = n94;
  if (t18 instanceof we) throw new Error("Public key is a multi-key.");
  let i27 = r18?.includeUnverified ?? false, o26 = t18 instanceof E7 ? t18 : new E7(t18), s11 = o26.publicKey, a24 = B5(o26.variant), c7 = { public_key: { _eq: s11.toString() }, public_key_type: { _eq: a24 }, ...i27 ? {} : { is_public_key_used: { _eq: true } } }, d15 = { query: b3, variables: { where_condition: c7 } }, { public_key_auth_keys: l14 } = await a17({ aptosConfig: e20, query: d15, originMethod: "getMultiKeysForPublicKey" });
  return l14.map((p11) => {
    switch (p11.signature_type) {
      case "multi_ed25519_signature":
        return fe.deserializeWithoutLength(a11.fromHex(p11.account_public_key));
      case "multi_key_signature":
        return W5.deserialize(a11.fromHex(p11.account_public_key));
      default:
        throw new Error(`Unknown multi-signature type: ${p11.signature_type}`);
    }
  });
}
async function Na(n94) {
  let { aptosConfig: e20, authKeys: t18, options: r18 } = n94, i27 = r18?.includeUnverified ?? false;
  if (t18.length === 0) throw new Error("No authentication keys provided");
  let o26 = { auth_key: { _in: t18.map((c7) => c7.toString()) }, ...i27 ? {} : { is_auth_key_used: { _eq: true } } }, s11 = { query: _5, variables: { where_condition: o26, order_by: [{ last_transaction_version: "desc" }] } }, { auth_key_account_addresses: a24 } = await a17({ aptosConfig: e20, query: s11, originMethod: "getAccountAddressesForAuthKeys" });
  return a24.map((c7) => ({ authKey: new s4({ data: c7.auth_key }), accountAddress: new l3(a3.hexInputToUint8Array(c7.account_address)), lastTransactionVersion: Number(c7.last_transaction_version) }));
}
async function Ga(n94) {
  let { aptosConfig: e20, accountAddress: t18 } = n94, r18 = await $r({ aptosConfig: e20, accountAddress: t18, options: { limit: 1 } });
  return r18.length === 0 ? 0 : Number(r18[0].version);
}
async function Ba(n94) {
  let { aptosConfig: e20, publicKey: t18 } = n94, r18 = t18.authKey().derivedAddress(), [i27, o26] = await Promise.all([Ga({ aptosConfig: e20, accountAddress: r18 }), Vo({ aptosConfig: e20, accountAddress: r18, options: { withAuthKey: t18.authKey() } })]);
  if (o26) return { accountAddress: r18, lastTransactionVersion: i27 };
}
async function re(n94) {
  let { aptosConfig: e20, payload: t18, options: r18 } = n94, i27 = await xo({ ...t18, aptosConfig: e20 }), o26 = new n4();
  i27.serialize(o26);
  let s11 = o26.toUint8Array(), { data: a24 } = await q3({ aptosConfig: e20, path: "view", originMethod: "view", contentType: "application/x.aptos.view_function+bcs", params: { ledger_version: r18?.ledgerVersion }, body: s11 });
  return a24;
}
async function Lo(n94) {
  let { aptosConfig: e20, payload: t18, options: r18 } = n94, { data: i27 } = await q3({ aptosConfig: e20, originMethod: "viewJson", path: "view", params: { ledger_version: r18?.ledgerVersion }, body: { function: t18.function, type_arguments: t18.typeArguments ?? [], arguments: t18.functionArguments ?? [] } });
  return i27;
}
async function qo(n94) {
  let { aptosConfig: e20, sender: t18, authenticationFunction: r18, options: i27 } = n94, { moduleAddress: o26, moduleName: s11, functionName: a24 } = v(r18);
  return f10({ aptosConfig: e20, sender: t18, data: { function: "0x1::account_abstraction::add_authentication_function", typeArguments: [], functionArguments: [o26, s11, a24], abi: { typeParameters: [], parameters: [new D3(), new m12(K()), new m12(K())] } }, options: i27 });
}
async function $o(n94) {
  let { aptosConfig: e20, sender: t18, authenticationFunction: r18, options: i27 } = n94, { moduleAddress: o26, moduleName: s11, functionName: a24 } = v(r18);
  return f10({ aptosConfig: e20, sender: t18, data: { function: "0x1::account_abstraction::remove_authentication_function", typeArguments: [], functionArguments: [o26, s11, a24], abi: { typeParameters: [], parameters: [new D3(), new m12(K()), new m12(K())] } }, options: i27 });
}
async function Wo(n94) {
  let { aptosConfig: e20, sender: t18, options: r18 } = n94;
  return f10({ aptosConfig: e20, sender: t18, data: { function: "0x1::account_abstraction::remove_authenticator", typeArguments: [], functionArguments: [], abi: { typeParameters: [], parameters: [] } }, options: r18 });
}
var Tt = class {
  constructor(e20) {
    this.config = e20;
    this.isAccountAbstractionEnabled = async (e21) => {
      let t18 = await this.getAuthenticationFunction(e21), { moduleAddress: r18, moduleName: i27, functionName: o26 } = v(e21.authenticationFunction);
      return t18?.some((s11) => l3.fromString(r18).equals(s11.moduleAddress) && i27 === s11.moduleName && o26 === s11.functionName) ?? false;
    };
    this.enableAccountAbstractionTransaction = this.addAuthenticationFunctionTransaction;
    this.disableAccountAbstractionTransaction = async (e21) => {
      let { accountAddress: t18, authenticationFunction: r18, options: i27 } = e21;
      return r18 ? this.removeAuthenticationFunctionTransaction({ accountAddress: t18, authenticationFunction: r18, options: i27 }) : this.removeDispatchableAuthenticatorTransaction({ accountAddress: t18, options: i27 });
    };
  }
  async addAuthenticationFunctionTransaction(e20) {
    let { accountAddress: t18, authenticationFunction: r18, options: i27 } = e20;
    return qo({ aptosConfig: this.config, authenticationFunction: r18, sender: t18, options: i27 });
  }
  async removeAuthenticationFunctionTransaction(e20) {
    let { accountAddress: t18, authenticationFunction: r18, options: i27 } = e20;
    return $o({ aptosConfig: this.config, sender: t18, authenticationFunction: r18, options: i27 });
  }
  async removeDispatchableAuthenticatorTransaction(e20) {
    let { accountAddress: t18, options: r18 } = e20;
    return Wo({ aptosConfig: this.config, sender: t18, options: r18 });
  }
  async getAuthenticationFunction(e20) {
    let { accountAddress: t18 } = e20, [{ vec: r18 }] = await re({ aptosConfig: this.config, payload: { function: "0x1::account_abstraction::dispatchable_authenticator", functionArguments: [l3.from(t18)], abi: { typeParameters: [], parameters: [new D3()], returnTypes: [] } } });
    if (r18.length !== 0) return r18[0].map((i27) => ({ moduleAddress: l3.fromString(i27.module_address), moduleName: i27.module_name, functionName: i27.function_name }));
  }
};
var ln = class {
  constructor(e20) {
    this.config = e20;
    this.abstraction = new Tt(e20);
  }
  async getAccountInfo(e20) {
    return Qt({ aptosConfig: this.config, ...e20 });
  }
  async getAccountModules(e20) {
    return Fo({ aptosConfig: this.config, ...e20 });
  }
  async getAccountModulesPage(e20) {
    return Uo({ aptosConfig: this.config, ...e20 });
  }
  async getAccountModule(e20) {
    return er({ aptosConfig: this.config, ...e20 });
  }
  async getAccountTransactions(e20) {
    return $r({ aptosConfig: this.config, ...e20 });
  }
  async getAccountResources(e20) {
    return Wr({ aptosConfig: this.config, ...e20 });
  }
  async getAccountResourcesPage(e20) {
    return Do({ aptosConfig: this.config, ...e20 });
  }
  async getAccountResource(e20) {
    return jr({ aptosConfig: this.config, ...e20 });
  }
  async lookupOriginalAccountAddress(e20) {
    return Jt({ aptosConfig: this.config, ...e20 });
  }
  async getAccountTokensCount(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "account_transactions_processor" }), Ro({ aptosConfig: this.config, ...e20 });
  }
  async getAccountOwnedTokens(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), Oo({ aptosConfig: this.config, ...e20 });
  }
  async getAccountOwnedTokensFromCollectionAddress(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), zo({ aptosConfig: this.config, ...e20 });
  }
  async getAccountCollectionsWithOwnedTokens(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), No({ aptosConfig: this.config, ...e20 });
  }
  async getAccountTransactionsCount(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "account_transactions_processor" }), Go({ aptosConfig: this.config, ...e20 });
  }
  async getAccountCoinsData(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Qr({ aptosConfig: this.config, ...e20 });
  }
  async getAccountCoinsCount(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Bo({ aptosConfig: this.config, ...e20 });
  }
  async getAccountAPTAmount(e20) {
    return this.getAccountCoinAmount({ coinType: n14, faMetadataAddress: A10, ...e20 });
  }
  async getAccountCoinAmount(e20) {
    let { accountAddress: t18, coinType: r18, faMetadataAddress: i27, minimumLedgerVersion: o26 } = e20;
    o26 && console.warn(`minimumLedgerVersion is not used anymore, here for backward 
        compatibility see https://github.com/aptos-labs/aptos-ts-sdk/pull/519, 
        will be removed in the near future`);
    let s11 = r18;
    r18 === void 0 && i27 !== void 0 && (s11 = await m(async () => {
      try {
        let d15 = (await re({ aptosConfig: this.config, payload: { function: "0x1::coin::paired_coin", functionArguments: [i27] } })).at(0);
        if (d15.vec.length > 0 && y(d15.vec[0])) return M(d15.vec[0]);
      } catch {
      }
    }, `coin-mapping-${i27.toString()}`, 1e3 * 60 * 5)());
    let a24;
    if (r18 !== void 0 && i27 !== void 0) a24 = l3.from(i27).toStringLong();
    else if (r18 !== void 0 && i27 === void 0) r18 === n14 ? a24 = l3.A.toStringLong() : a24 = d(l3.A, r18).toStringLong();
    else if (r18 === void 0 && i27 !== void 0) {
      let d15 = l3.from(i27);
      a24 = d15.toStringLong(), d15 === l3.A && (s11 = n14);
    } else throw new Error("Either coinType, faMetadataAddress, or both must be provided");
    if (s11 !== void 0) {
      let [d15] = await re({ aptosConfig: this.config, payload: { function: "0x1::coin::balance", typeArguments: [s11], functionArguments: [t18] } });
      return parseInt(d15, 10);
    }
    let [c7] = await re({ aptosConfig: this.config, payload: { function: "0x1::primary_fungible_store::balance", typeArguments: ["0x1::object::ObjectCore"], functionArguments: [t18, a24] } });
    return parseInt(c7, 10);
  }
  async getAccountOwnedObjects(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "default_processor" }), Jr({ aptosConfig: this.config, ...e20 });
  }
  async deriveAccountFromPrivateKey(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "account_restoration_processor" }), await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "objects_processor" }), Mo({ aptosConfig: this.config, ...e20 });
  }
  async deriveOwnedAccountsFromSigner(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "account_restoration_processor" }), await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "objects_processor" }), Zr({ aptosConfig: this.config, ...e20 });
  }
  async getAccountsForPublicKey(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "account_restoration_processor" }), await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "objects_processor" }), or({ aptosConfig: this.config, ...e20 });
  }
};
var Ma = { typeParameters: [{ constraints: [] }], parameters: [new D3(), new q5()] };
async function jo(n94) {
  let { aptosConfig: e20, sender: t18, recipient: r18, amount: i27, coinType: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [o26 ?? n14], functionArguments: [r18, i27], abi: Ma }, options: s11 });
}
var gn = class {
  constructor(e20) {
    this.config = e20;
  }
  async transferCoinTransaction(e20) {
    return jo({ aptosConfig: this.config, ...e20 });
  }
};
var ot2 = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" };
var be = "0x4::token::Token";
async function Qo(n94) {
  let { aptosConfig: e20, digitalAssetAddress: t18 } = n94, r18 = { token_data_id: { _eq: l3.from(t18).toStringLong() } };
  return (await a17({ aptosConfig: e20, query: { query: O3, variables: { where_condition: r18 } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
}
async function Jo(n94) {
  let { aptosConfig: e20, digitalAssetAddress: t18 } = n94, r18 = { token_data_id: { _eq: l3.from(t18).toStringLong() }, amount: { _gt: 0 } };
  return (await a17({ aptosConfig: e20, query: { query: D2, variables: { where_condition: r18 } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
}
async function Zo(n94) {
  let { aptosConfig: e20, ownerAddress: t18, options: r18 } = n94, i27 = { owner_address: { _eq: l3.from(t18).toStringLong() }, amount: { _gt: 0 } }, o26 = { query: D2, variables: { where_condition: i27, offset: r18?.offset, limit: r18?.limit, order_by: r18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: o26, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
}
async function Yo(n94) {
  let { aptosConfig: e20, digitalAssetAddress: t18, options: r18 } = n94, i27 = { token_data_id: { _eq: l3.from(t18).toStringLong() } }, o26 = { query: F, variables: { where_condition: i27, offset: r18?.offset, limit: r18?.limit, order_by: r18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: o26, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
}
var Va = { typeParameters: [], parameters: [new m12(K()), new q5(), new m12(K()), new m12(K()), new B6(), new B6(), new B6(), new B6(), new B6(), new B6(), new B6(), new B6(), new B6(), new q5(), new q5()] };
async function Xo(n94) {
  let { aptosConfig: e20, options: t18, creator: r18 } = n94;
  return f10({ aptosConfig: e20, sender: r18.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new a13(n94.description), new m7(n94.maxSupply ?? _), new a13(n94.name), new a13(n94.uri), new U5(n94.mutableDescription ?? true), new U5(n94.mutableRoyalty ?? true), new U5(n94.mutableURI ?? true), new U5(n94.mutableTokenDescription ?? true), new U5(n94.mutableTokenName ?? true), new U5(n94.mutableTokenProperties ?? true), new U5(n94.mutableTokenURI ?? true), new U5(n94.tokensBurnableByCreator ?? true), new U5(n94.tokensFreezableByCreator ?? true), new m7(n94.royaltyNumerator ?? 0), new m7(n94.royaltyDenominator ?? 1)], abi: Va }, options: t18 });
}
async function Yt(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = t18?.where;
  t18?.tokenStandard && (r18.token_standard = { _eq: t18?.tokenStandard ?? "v2" });
  let i27 = { query: k3, variables: { where_condition: r18, offset: t18?.offset, limit: t18?.limit } };
  return (await a17({ aptosConfig: e20, query: i27, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function es(n94) {
  let { aptosConfig: e20, creatorAddress: t18, collectionName: r18, options: i27 } = n94, o26 = l3.from(t18), s11 = { collection_name: { _eq: r18 }, creator_address: { _eq: o26.toStringLong() } };
  return i27?.tokenStandard && (s11.token_standard = { _eq: i27?.tokenStandard ?? "v2" }), Yt({ aptosConfig: e20, options: { ...i27, where: s11 } });
}
async function ts(n94) {
  let { aptosConfig: e20, creatorAddress: t18, options: r18 } = n94, o26 = { creator_address: { _eq: l3.from(t18).toStringLong() } };
  return r18?.tokenStandard && (o26.token_standard = { _eq: r18?.tokenStandard ?? "v2" }), Yt({ aptosConfig: e20, options: { ...r18, where: o26 } });
}
async function ns(n94) {
  let { aptosConfig: e20, collectionId: t18, options: r18 } = n94, o26 = { collection_id: { _eq: l3.from(t18).toStringLong() } };
  return r18?.tokenStandard && (o26.token_standard = { _eq: r18?.tokenStandard ?? "v2" }), Yt({ aptosConfig: e20, options: { ...r18, where: o26 } });
}
async function rs(n94) {
  let { creatorAddress: e20, collectionName: t18, options: r18, aptosConfig: i27 } = n94, o26 = l3.from(e20), s11 = { collection_name: { _eq: t18 }, creator_address: { _eq: o26.toStringLong() } };
  return r18?.tokenStandard && (s11.token_standard = { _eq: r18?.tokenStandard ?? "v2" }), (await Yt({ aptosConfig: i27, options: { where: s11 } })).collection_id;
}
var Ha = { typeParameters: [], parameters: [new m12(K()), new m12(K()), new m12(K()), new m12(K()), new C6(new m12(K())), new C6(new m12(K())), new C6(C6.u8())] };
async function is(n94) {
  let { aptosConfig: e20, options: t18, creator: r18, collection: i27, description: o26, name: s11, uri: a24, propertyKeys: c7, propertyTypes: d15, propertyValues: l14 } = n94, g5 = d15?.map((p11) => ot2[p11]);
  return f10({ aptosConfig: e20, sender: r18.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new a13(i27), new a13(o26), new a13(s11), new a13(a24), t3.MoveString(c7 ?? []), t3.MoveString(g5 ?? []), hs(l14 ?? [], g5 ?? [])], abi: Ha }, options: t18 });
}
var La = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new D3()] };
async function os(n94) {
  let { aptosConfig: e20, sender: t18, digitalAssetAddress: r18, recipient: i27, digitalAssetType: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [o26 ?? be], functionArguments: [l3.from(r18), l3.from(i27)], abi: La }, options: s11 });
}
var qa = { typeParameters: [], parameters: [new m12(K()), new m12(K()), new m12(K()), new m12(K()), new C6(new m12(K())), new C6(new m12(K())), new C6(C6.u8()), new D3()] };
async function ss(n94) {
  let { aptosConfig: e20, account: t18, collection: r18, description: i27, name: o26, uri: s11, recipient: a24, propertyKeys: c7, propertyTypes: d15, propertyValues: l14, options: g5 } = n94;
  if (c7?.length !== l14?.length) throw new Error("Property keys and property values counts do not match");
  if (d15?.length !== l14?.length) throw new Error("Property types and property values counts do not match");
  let p11 = d15?.map((y10) => ot2[y10]);
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [r18, i27, o26, s11, t3.MoveString(c7 ?? []), t3.MoveString(p11 ?? []), hs(l14 ?? [], p11 ?? []), a24], abi: qa }, options: g5 });
}
var $a = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0)))] };
async function as(n94) {
  let { aptosConfig: e20, creator: t18, digitalAssetAddress: r18, digitalAssetType: i27, options: o26 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [i27 ?? be], functionArguments: [l3.from(r18)], abi: $a }, options: o26 });
}
var Wa = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0)))] };
async function cs(n94) {
  let { aptosConfig: e20, creator: t18, digitalAssetAddress: r18, digitalAssetType: i27, options: o26 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [i27 ?? be], functionArguments: [r18], abi: Wa }, options: o26 });
}
var ja = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0)))] };
async function us(n94) {
  let { aptosConfig: e20, creator: t18, digitalAssetAddress: r18, digitalAssetType: i27, options: o26 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [i27 ?? be], functionArguments: [r18], abi: ja }, options: o26 });
}
var Qa = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new m12(K())] };
async function ds(n94) {
  let { aptosConfig: e20, creator: t18, description: r18, digitalAssetAddress: i27, digitalAssetType: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [o26 ?? be], functionArguments: [l3.from(i27), new a13(r18)], abi: Qa }, options: s11 });
}
var Ja = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new m12(K())] };
async function ps(n94) {
  let { aptosConfig: e20, creator: t18, name: r18, digitalAssetAddress: i27, digitalAssetType: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [o26 ?? be], functionArguments: [l3.from(i27), new a13(r18)], abi: Ja }, options: s11 });
}
var Za = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new m12(K())] };
async function ls(n94) {
  let { aptosConfig: e20, creator: t18, uri: r18, digitalAssetAddress: i27, digitalAssetType: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [o26 ?? be], functionArguments: [l3.from(i27), new a13(r18)], abi: Za }, options: s11 });
}
var Ya = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new m12(K()), new m12(K()), C6.u8()] };
async function gs(n94) {
  let { aptosConfig: e20, creator: t18, propertyKey: r18, propertyType: i27, propertyValue: o26, digitalAssetAddress: s11, digitalAssetType: a24, options: c7 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [a24 ?? be], functionArguments: [l3.from(s11), new a13(r18), new a13(ot2[i27]), t3.U8(Yr(o26, ot2[i27]))], abi: Ya }, options: c7 });
}
var Xa = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new m12(K())] };
async function ys(n94) {
  let { aptosConfig: e20, creator: t18, propertyKey: r18, digitalAssetAddress: i27, digitalAssetType: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [o26 ?? be], functionArguments: [l3.from(i27), new a13(r18)], abi: Xa }, options: s11 });
}
var ec = { typeParameters: [{ constraints: ["key"] }], parameters: [new m12(ue(new O6(0))), new m12(K()), new m12(K()), C6.u8()] };
async function ms(n94) {
  let { aptosConfig: e20, creator: t18, propertyKey: r18, propertyType: i27, propertyValue: o26, digitalAssetAddress: s11, digitalAssetType: a24, options: c7 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [a24 ?? be], functionArguments: [l3.from(s11), new a13(r18), new a13(ot2[i27]), Yr(o26, ot2[i27])], abi: ec }, options: c7 });
}
var tc = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new m12(ue(new O6(0))), new m12(K()), new O6(1)] };
async function fs(n94) {
  let { aptosConfig: e20, creator: t18, propertyKey: r18, propertyType: i27, propertyValue: o26, digitalAssetAddress: s11, digitalAssetType: a24, options: c7 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [a24 ?? be, ot2[i27]], functionArguments: [l3.from(s11), new a13(r18), o26], abi: tc }, options: c7 });
}
var nc = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new m12(ue(new O6(0))), new m12(K()), new O6(1)] };
async function As(n94) {
  let { aptosConfig: e20, creator: t18, propertyKey: r18, propertyType: i27, propertyValue: o26, digitalAssetAddress: s11, digitalAssetType: a24, options: c7 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [a24 ?? be, ot2[i27]], functionArguments: [l3.from(s11), new a13(r18), o26], abi: nc }, options: c7 });
}
function hs(n94, e20) {
  let t18 = new Array();
  return e20.forEach((r18, i27) => {
    t18.push(Yr(n94[i27], r18));
  }), t18;
}
function Yr(n94, e20) {
  let t18 = xe(e20);
  return wt(n94, t18, 0, []).bcsToBytes();
}
var yn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getCollectionData(e20) {
    await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" });
    let { creatorAddress: t18, collectionName: r18, options: i27 } = e20, o26 = l3.from(t18), s11 = { collection_name: { _eq: r18 }, creator_address: { _eq: o26.toStringLong() } };
    return i27?.tokenStandard && (s11.token_standard = { _eq: i27?.tokenStandard ?? "v2" }), Yt({ aptosConfig: this.config, options: { where: s11 } });
  }
  async getCollectionDataByCreatorAddressAndCollectionName(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), es({ aptosConfig: this.config, ...e20 });
  }
  async getCollectionDataByCreatorAddress(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), ts({ aptosConfig: this.config, ...e20 });
  }
  async getCollectionDataByCollectionId(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), ns({ aptosConfig: this.config, ...e20 });
  }
  async getCollectionId(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), rs({ aptosConfig: this.config, ...e20 });
  }
  async getDigitalAssetData(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), Qo({ aptosConfig: this.config, ...e20 });
  }
  async getCurrentDigitalAssetOwnership(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), Jo({ aptosConfig: this.config, ...e20 });
  }
  async getOwnedDigitalAssets(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), Zo({ aptosConfig: this.config, ...e20 });
  }
  async getDigitalAssetActivity(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "token_v2_processor" }), Yo({ aptosConfig: this.config, ...e20 });
  }
  async createCollectionTransaction(e20) {
    return Xo({ aptosConfig: this.config, ...e20 });
  }
  async mintDigitalAssetTransaction(e20) {
    return is({ aptosConfig: this.config, ...e20 });
  }
  async transferDigitalAssetTransaction(e20) {
    return os({ aptosConfig: this.config, ...e20 });
  }
  async mintSoulBoundTransaction(e20) {
    return ss({ aptosConfig: this.config, ...e20 });
  }
  async burnDigitalAssetTransaction(e20) {
    return as({ aptosConfig: this.config, ...e20 });
  }
  async freezeDigitalAssetTransaferTransaction(e20) {
    return cs({ aptosConfig: this.config, ...e20 });
  }
  async unfreezeDigitalAssetTransaferTransaction(e20) {
    return us({ aptosConfig: this.config, ...e20 });
  }
  async setDigitalAssetDescriptionTransaction(e20) {
    return ds({ aptosConfig: this.config, ...e20 });
  }
  async setDigitalAssetNameTransaction(e20) {
    return ps({ aptosConfig: this.config, ...e20 });
  }
  async setDigitalAssetURITransaction(e20) {
    return ls({ aptosConfig: this.config, ...e20 });
  }
  async addDigitalAssetPropertyTransaction(e20) {
    return gs({ aptosConfig: this.config, ...e20 });
  }
  async removeDigitalAssetPropertyTransaction(e20) {
    return ys({ aptosConfig: this.config, ...e20 });
  }
  async updateDigitalAssetPropertyTransaction(e20) {
    return ms({ aptosConfig: this.config, ...e20 });
  }
  async addDigitalAssetTypedPropertyTransaction(e20) {
    return fs({ aptosConfig: this.config, ...e20 });
  }
  async updateDigitalAssetTypedPropertyTransaction(e20) {
    return As({ aptosConfig: this.config, ...e20 });
  }
};
var bs = 300;
var rc = (n94) => {
  if (n94 && n94.length > bs) throw new Error(`Event type length exceeds the maximum length of ${bs}`);
};
async function ws(n94) {
  let { aptosConfig: e20, eventType: t18, options: r18 } = n94, i27 = { _or: [{ account_address: { _eq: t18.split("::")[0] } }, { account_address: { _eq: "0x0000000000000000000000000000000000000000000000000000000000000000" }, sequence_number: { _eq: 0 }, creation_number: { _eq: 0 } }], indexed_type: { _eq: t18 } };
  return mn({ aptosConfig: e20, options: { ...r18, where: i27 } });
}
async function Ts(n94) {
  let { accountAddress: e20, aptosConfig: t18, creationNumber: r18, options: i27 } = n94, s11 = { account_address: { _eq: l3.from(e20).toStringLong() }, creation_number: { _eq: r18 } };
  return mn({ aptosConfig: t18, options: { ...i27, where: s11 } });
}
async function Ss(n94) {
  let { accountAddress: e20, aptosConfig: t18, eventType: r18, options: i27 } = n94, s11 = { account_address: { _eq: l3.from(e20).toStringLong() }, indexed_type: { _eq: r18 } };
  return mn({ aptosConfig: t18, options: { ...i27, where: s11 } });
}
async function mn(n94) {
  console.warn("[Aptos SDK] Events queries will be deprecated by the end of July 2025. Follow the details in https://aptoslabs.notion.site/Indexer-Feature-Updates-Events-v1-table-deprecation-and-end-of-support-July-1st-1ec8b846eb7280ffa042c0d3d7f45633?source=copy_link to migrate your events queries.");
  let { aptosConfig: e20, options: t18 } = n94;
  rc(t18?.where?.indexed_type?._eq);
  let r18 = { query: f7, variables: { where_condition: t18?.where, offset: t18?.offset, limit: t18?.limit, order_by: t18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: r18, originMethod: "getEvents" })).events;
}
var fn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getModuleEventsByEventType(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "events_processor" }), ws({ aptosConfig: this.config, ...e20 });
  }
  async getAccountEventsByCreationNumber(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "events_processor" }), Ts({ aptosConfig: this.config, ...e20 });
  }
  async getAccountEventsByEventType(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "events_processor" }), Ss({ aptosConfig: this.config, ...e20 });
  }
  async getEvents(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "events_processor" }), mn({ aptosConfig: this.config, ...e20 });
  }
};
async function Ps(n94) {
  let { aptosConfig: e20, accountAddress: t18, amount: r18, options: i27 } = n94, o26 = i27?.timeoutSecs || 20, { data: s11 } = await E4({ aptosConfig: e20, path: "fund", body: { address: l3.from(t18).toString(), amount: r18 }, originMethod: "fundAccount" }), a24 = s11.txn_hashes[0], c7 = await z4({ aptosConfig: e20, transactionHash: a24, options: { timeoutSecs: o26, checkSuccess: i27?.checkSuccess } });
  if (c7.type === "user_transaction") return c7;
  throw new Error(`Unexpected transaction received for fund account: ${c7.type}`);
}
var An = class {
  constructor(e20) {
    this.config = e20;
  }
  async fundAccount(e20) {
    let t18 = await Ps({ aptosConfig: this.config, ...e20 });
    return (e20.options?.waitForIndexer === void 0 || e20.options?.waitForIndexer) && await U6({ aptosConfig: this.config, minimumLedgerVersion: BigInt(t18.version), processorType: "fungible_asset_processor" }), t18;
  }
};
async function sr(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = { query: G, variables: { where_condition: t18?.where, limit: t18?.limit, offset: t18?.offset } };
  return (await a17({ aptosConfig: e20, query: r18, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
}
async function Ks(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = { query: A9, variables: { where_condition: t18?.where, limit: t18?.limit, offset: t18?.offset } };
  return (await a17({ aptosConfig: e20, query: r18, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
}
async function xs(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = { query: $2, variables: { where_condition: t18?.where, limit: t18?.limit, offset: t18?.offset } };
  return (await a17({ aptosConfig: e20, query: r18, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
}
var Es = { typeParameters: [{ constraints: [] }], parameters: [xe("0x1::object::Object"), new D3(), new q5()] };
async function Cs(n94) {
  let { aptosConfig: e20, sender: t18, fungibleAssetMetadataAddress: r18, recipient: i27, amount: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [r18, i27, o26], abi: Es }, options: s11 });
}
async function vs(n94) {
  let { aptosConfig: e20, sender: t18, fromStore: r18, toStore: i27, amount: o26, options: s11 } = n94;
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::dispatchable_fungible_asset::transfer", typeArguments: ["0x1::fungible_asset::FungibleStore"], functionArguments: [r18, i27, o26], abi: Es }, options: s11 });
}
var hn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getFungibleAssetMetadata(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), sr({ aptosConfig: this.config, ...e20 });
  }
  async getFungibleAssetMetadataByAssetType(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), (await sr({ aptosConfig: this.config, options: { where: { asset_type: { _eq: e20.assetType } } } }))[0];
  }
  async getFungibleAssetMetadataByCreatorAddress(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), await sr({ aptosConfig: this.config, options: { where: { creator_address: { _eq: l3.from(e20.creatorAddress).toStringLong() } } } });
  }
  async getFungibleAssetActivities(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Ks({ aptosConfig: this.config, ...e20 });
  }
  async getCurrentFungibleAssetBalances(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "fungible_asset_processor" }), xs({ aptosConfig: this.config, ...e20 });
  }
  async transferFungibleAsset(e20) {
    return Cs({ aptosConfig: this.config, ...e20 });
  }
  async transferFungibleAssetBetweenStores(e20) {
    return vs({ aptosConfig: this.config, ...e20 });
  }
};
var bn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getLedgerInfo() {
    return d6({ aptosConfig: this.config });
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getBlockByVersion(e20) {
    return X({ aptosConfig: this.config, ...e20 });
  }
  async getBlockByHeight(e20) {
    return j2({ aptosConfig: this.config, ...e20 });
  }
  async view(e20) {
    return re({ aptosConfig: this.config, ...e20 });
  }
  async viewJson(e20) {
    return Lo({ aptosConfig: this.config, ...e20 });
  }
  async getChainTopUserTransactions(e20) {
    return C4({ aptosConfig: this.config, ...e20 });
  }
  async queryIndexer(e20) {
    return a17({ aptosConfig: this.config, ...e20 });
  }
  async getIndexerLastSuccessVersion() {
    return h8({ aptosConfig: this.config });
  }
  async getProcessorStatus(e20) {
    return T5({ aptosConfig: this.config, processorType: e20 });
  }
};
var Is = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
function _s(n94) {
  return !(!n94 || n94.length < 3 || n94.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(n94));
}
function st(n94) {
  let [e20, t18, ...r18] = n94.replace(/\.apt$/, "").split(".");
  if (r18.length > 0) throw new Error(`${n94} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
  if (!_s(e20)) throw new Error(`${e20} is not valid. ${Is}`);
  if (t18 && !_s(t18)) throw new Error(`${t18} is not valid. ${Is}`);
  return { domainName: t18 || e20, subdomainName: t18 ? e20 : void 0 };
}
var ic = ((t18) => (t18[t18.Independent = 0] = "Independent", t18[t18.FollowsDomain = 1] = "FollowsDomain", t18))(ic || {});
function ks(n94) {
  if (!n94) return false;
  let e20 = new Date(n94.domain_expiration_timestamp).getTime() < Date.now(), t18 = new Date(n94.expiration_timestamp).getTime() < Date.now();
  return n94.subdomain && e20 ? false : n94.subdomain && n94.subdomain_expiration_policy === 1 ? true : !t18;
}
var oc = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82";
var sc = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: oc, custom: null, devnet: null };
function je(n94) {
  let e20 = sc[n94.network];
  if (!e20) throw new Error(`The ANS contract is not deployed to ${n94.network}`);
  return e20;
}
var ar = (n94) => {
  if (n94 && typeof n94 == "object" && "vec" in n94 && Array.isArray(n94.vec)) return n94.vec[0];
};
async function Fs(n94) {
  let { aptosConfig: e20, name: t18 } = n94, r18 = je(e20), { domainName: i27, subdomainName: o26 } = st(t18), s11 = await re({ aptosConfig: e20, payload: { function: `${r18}::router::get_owner_addr`, functionArguments: [i27, o26] } }), a24 = ar(s11[0]);
  return a24 ? l3.from(a24) : void 0;
}
async function Us(n94) {
  let { aptosConfig: e20, expiration: t18, name: r18, sender: i27, targetAddress: o26, toAddress: s11, options: a24, transferable: c7 } = n94, d15 = je(e20), { domainName: l14, subdomainName: g5 } = st(r18), p11 = t18.policy === "subdomain:independent" || t18.policy === "subdomain:follow-domain";
  if (g5 && !p11) throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
  if (p11 && !g5) throw new Error(`Policy is set to ${t18.policy} but no subdomain was provided`);
  if (t18.policy === "domain") {
    let G3 = t18.years ?? 1;
    if (G3 !== 1) throw new Error("For now, names can only be registered for 1 year at a time");
    let Ue2 = G3 * 31536e3;
    return await f10({ aptosConfig: e20, sender: i27.accountAddress.toString(), data: { function: `${d15}::router::register_domain`, functionArguments: [l14, Ue2, o26, s11] }, options: a24 });
  }
  if (!g5) throw new Error(`${t18.policy} requires a subdomain to be provided.`);
  let y10 = await Xr({ aptosConfig: e20, name: l14 });
  if (!y10) throw new Error("The domain does not exist");
  let h10 = t18.policy === "subdomain:independent" ? t18.expirationDate : y10;
  if (h10 > y10) throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
  return await f10({ aptosConfig: e20, sender: i27.accountAddress.toString(), data: { function: `${d15}::router::register_subdomain`, functionArguments: [l14, g5, Math.round(h10 / 1e3), t18.policy === "subdomain:follow-domain" ? 1 : 0, !!c7, o26, s11] }, options: a24 });
}
async function Xr(n94) {
  let { aptosConfig: e20, name: t18 } = n94, r18 = je(e20), { domainName: i27, subdomainName: o26 } = st(t18);
  try {
    let s11 = await re({ aptosConfig: e20, payload: { function: `${r18}::router::get_expiration`, functionArguments: [i27, o26] } });
    return Number(s11[0]) * 1e3;
  } catch {
    return;
  }
}
async function Ds(n94) {
  let { aptosConfig: e20, address: t18 } = n94, r18 = je(e20), i27 = await re({ aptosConfig: e20, payload: { function: `${r18}::router::get_primary_name`, functionArguments: [l3.from(t18).toString()] } }), o26 = ar(i27[1]), s11 = ar(i27[0]);
  if (o26) return [s11, o26].filter(Boolean).join(".");
}
async function Rs(n94) {
  let { aptosConfig: e20, sender: t18, name: r18, options: i27 } = n94, o26 = je(e20);
  if (!r18) return await f10({ aptosConfig: e20, sender: t18.accountAddress.toString(), data: { function: `${o26}::router::clear_primary_name`, functionArguments: [] }, options: i27 });
  let { domainName: s11, subdomainName: a24 } = st(r18);
  return await f10({ aptosConfig: e20, sender: t18.accountAddress.toString(), data: { function: `${o26}::router::set_primary_name`, functionArguments: [s11, a24] }, options: i27 });
}
async function Os(n94) {
  let { aptosConfig: e20, name: t18 } = n94, r18 = je(e20), { domainName: i27, subdomainName: o26 } = st(t18), s11 = await re({ aptosConfig: e20, payload: { function: `${r18}::router::get_target_addr`, functionArguments: [i27, o26] } }), a24 = ar(s11[0]);
  return a24 ? l3.from(a24) : void 0;
}
async function zs(n94) {
  let { aptosConfig: e20, sender: t18, name: r18, address: i27, options: o26 } = n94, s11 = je(e20), { domainName: a24, subdomainName: c7 } = st(r18);
  return await f10({ aptosConfig: e20, sender: t18.accountAddress.toString(), data: { function: `${s11}::router::set_target_addr`, functionArguments: [a24, c7, i27] }, options: o26 });
}
async function Ns(n94) {
  let { aptosConfig: e20, name: t18 } = n94, { domainName: r18, subdomainName: i27 = "" } = st(t18), a24 = (await a17({ aptosConfig: e20, query: { query: w3, variables: { where_condition: { domain: { _eq: r18 }, subdomain: { _eq: i27 } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
  return a24 && (a24 = wn(a24)), ks(a24) ? a24 : void 0;
}
async function Gs(n94) {
  let { aptosConfig: e20, options: t18, accountAddress: r18 } = n94, i27 = await ei({ aptosConfig: e20 });
  return (await a17({ aptosConfig: e20, originMethod: "getAccountNames", query: { query: w3, variables: { limit: t18?.limit, offset: t18?.offset, order_by: t18?.orderBy, where_condition: { ...n94.options?.where ?? {}, owner_address: { _eq: r18.toString() }, expiration_timestamp: { _gte: i27 } } } } })).current_aptos_names.map(wn);
}
async function Bs(n94) {
  let { aptosConfig: e20, options: t18, accountAddress: r18 } = n94, i27 = await ei({ aptosConfig: e20 });
  return (await a17({ aptosConfig: e20, originMethod: "getAccountDomains", query: { query: w3, variables: { limit: t18?.limit, offset: t18?.offset, order_by: t18?.orderBy, where_condition: { ...n94.options?.where ?? {}, owner_address: { _eq: r18.toString() }, expiration_timestamp: { _gte: i27 }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(wn);
}
async function Ms(n94) {
  let { aptosConfig: e20, options: t18, accountAddress: r18 } = n94, i27 = await ei({ aptosConfig: e20 });
  return (await a17({ aptosConfig: e20, originMethod: "getAccountSubdomains", query: { query: w3, variables: { limit: t18?.limit, offset: t18?.offset, order_by: t18?.orderBy, where_condition: { ...n94.options?.where ?? {}, owner_address: { _eq: r18.toString() }, expiration_timestamp: { _gte: i27 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(wn);
}
async function Vs(n94) {
  let { aptosConfig: e20, options: t18, domain: r18 } = n94;
  return (await a17({ aptosConfig: e20, originMethod: "getDomainSubdomains", query: { query: w3, variables: { limit: t18?.limit, offset: t18?.offset, order_by: t18?.orderBy, where_condition: { ...n94.options?.where ?? {}, domain: { _eq: r18 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(wn).filter(ks);
}
async function ei(n94) {
  let { aptosConfig: e20 } = n94, t18 = je(e20), [r18] = await re({ aptosConfig: e20, payload: { function: `${t18}::config::reregistration_grace_sec`, functionArguments: [] } }), i27 = r18 / 60 / 60 / 24, o26 = () => /* @__PURE__ */ new Date();
  return new Date(o26().setDate(o26().getDate() - i27)).toISOString();
}
async function Hs(n94) {
  let { aptosConfig: e20, sender: t18, name: r18, years: i27 = 1, options: o26 } = n94, s11 = je(e20), a24 = i27 * 31536e3, { domainName: c7, subdomainName: d15 } = st(r18);
  if (d15) throw new Error("Subdomains cannot be renewed");
  if (i27 !== 1) throw new Error("Currently, only 1 year renewals are supported");
  return await f10({ aptosConfig: e20, sender: t18.accountAddress.toString(), data: { function: `${s11}::router::renew_domain`, functionArguments: [c7, a24] }, options: o26 });
}
function wn(n94) {
  return { ...n94, expiration_timestamp: new Date(n94.expiration_timestamp).getTime() };
}
var Tn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getOwnerAddress(e20) {
    return Fs({ aptosConfig: this.config, ...e20 });
  }
  async getExpiration(e20) {
    return Xr({ aptosConfig: this.config, ...e20 });
  }
  async getTargetAddress(e20) {
    return Os({ aptosConfig: this.config, ...e20 });
  }
  async setTargetAddress(e20) {
    return zs({ aptosConfig: this.config, ...e20 });
  }
  async getPrimaryName(e20) {
    return Ds({ aptosConfig: this.config, ...e20 });
  }
  async setPrimaryName(e20) {
    return Rs({ aptosConfig: this.config, ...e20 });
  }
  async registerName(e20) {
    return Us({ aptosConfig: this.config, ...e20 });
  }
  async renewDomain(e20) {
    return Hs({ aptosConfig: this.config, ...e20 });
  }
  async getName(e20) {
    return Ns({ aptosConfig: this.config, ...e20 });
  }
  async getAccountNames(e20) {
    return Gs({ aptosConfig: this.config, ...e20 });
  }
  async getAccountDomains(e20) {
    return Bs({ aptosConfig: this.config, ...e20 });
  }
  async getAccountSubdomains(e20) {
    return Ms({ aptosConfig: this.config, ...e20 });
  }
  async getDomainSubdomains(e20) {
    return Vs({ aptosConfig: this.config, ...e20 });
  }
};
async function Ls(n94) {
  let { aptosConfig: e20, poolAddress: t18 } = n94, r18 = l3.from(t18).toStringLong(), o26 = await a17({ aptosConfig: e20, query: { query: q2, variables: { where_condition: { pool_address: { _eq: r18 } } } } });
  return o26.num_active_delegator_per_pool[0] ? o26.num_active_delegator_per_pool[0].num_active_delegator : 0;
}
async function qs2(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = { query: q2, variables: { order_by: t18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: r18 })).num_active_delegator_per_pool;
}
async function $s(n94) {
  let { aptosConfig: e20, delegatorAddress: t18, poolAddress: r18 } = n94, i27 = { query: h7, variables: { delegatorAddress: l3.from(t18).toStringLong(), poolAddress: l3.from(r18).toStringLong() } };
  return (await a17({ aptosConfig: e20, query: i27 })).delegated_staking_activities;
}
var Sn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getNumberOfDelegators(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "stake_processor" }), Ls({ aptosConfig: this.config, ...e20 });
  }
  async getNumberOfDelegatorsForAllPools(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "stake_processor" }), qs2({ aptosConfig: this.config, ...e20 });
  }
  async getDelegatedStakingActivities(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20?.minimumLedgerVersion, processorType: "stake_processor" }), $s({ aptosConfig: this.config, ...e20 });
  }
};
var cr = class {
  constructor(e20) {
    this.config = e20;
  }
  async simple(e20) {
    return f10({ aptosConfig: this.config, ...e20 });
  }
  async multiAgent(e20) {
    return f10({ aptosConfig: this.config, ...e20 });
  }
};
var Xt = class {
  constructor(e20) {
    this.config = e20;
  }
  async simple(e20) {
    return Lr({ aptosConfig: this.config, ...e20 });
  }
  async multiAgent(e20) {
    return Lr({ aptosConfig: this.config, ...e20 });
  }
};
j([o8], Xt.prototype, "simple", 1), j([o8], Xt.prototype, "multiAgent", 1);
var ur = class {
  constructor(e20) {
    this.config = e20;
  }
  async simple(e20) {
    return i21(this.config, e20), pn({ aptosConfig: this.config, ...e20 });
  }
  async multiAgent(e20) {
    return i21(this.config, e20), pn({ aptosConfig: this.config, ...e20 });
  }
};
var dr = class {
  constructor(e20, t18, r18, i27, o26) {
    this.lastUncommintedNumber = null;
    this.currentNumber = null;
    this.lock = false;
    this.aptosConfig = e20, this.account = t18, this.maxWaitTime = r18, this.maximumInFlight = i27, this.sleepTime = o26;
  }
  async nextSequenceNumber() {
    for (; this.lock; ) await f2(this.sleepTime);
    this.lock = true;
    let e20 = BigInt(0);
    try {
      if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
        await this.update();
        let t18 = _2();
        for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; ) await f2(this.sleepTime), _2() - t18 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, re-syncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
      }
      e20 = this.currentNumber, this.currentNumber += BigInt(1);
    } catch (t18) {
      console.error("error in getting next sequence number for this account", t18);
    } finally {
      this.lock = false;
    }
    return e20;
  }
  async initialize() {
    let { sequence_number: e20 } = await Qt({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    this.currentNumber = BigInt(e20), this.lastUncommintedNumber = BigInt(e20);
  }
  async update() {
    let { sequence_number: e20 } = await Qt({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    return this.lastUncommintedNumber = BigInt(e20), this.lastUncommintedNumber;
  }
  async synchronize() {
    if (this.lastUncommintedNumber !== this.currentNumber) {
      for (; this.lock; ) await f2(this.sleepTime);
      this.lock = true;
      try {
        await this.update();
        let e20 = _2();
        for (; this.lastUncommintedNumber !== this.currentNumber; ) _2() - e20 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, re-syncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await f2(this.sleepTime), await this.update());
      } catch (e20) {
        console.error("error in synchronizing this account sequence number with the one on chain", e20);
      } finally {
        this.lock = false;
      }
    }
  }
};
var Ws = "fulfilled";
var js = ((o26) => (o26.TransactionSent = "transactionSent", o26.TransactionSendFailed = "transactionSendFailed", o26.TransactionExecuted = "transactionExecuted", o26.TransactionExecutionFailed = "transactionExecutionFailed", o26.ExecutionFinish = "executionFinish", o26))(js || {});
var pr = class extends eventemitter3_default {
  constructor(t18, r18, i27 = 30, o26 = 100, s11 = 10) {
    super();
    this.taskQueue = new i6();
    this.transactionsQueue = new i6();
    this.outstandingTransactions = new i6();
    this.sentTransactions = [];
    this.executedTransactions = [];
    this.aptosConfig = t18, this.account = r18, this.started = false, this.accountSequnceNumber = new dr(t18, r18, i27, o26, s11);
  }
  async submitNextTransaction() {
    try {
      for (; ; ) {
        let t18 = await this.accountSequnceNumber.nextSequenceNumber();
        if (t18 === null) return;
        let r18 = await this.generateNextTransaction(this.account, t18);
        if (!r18) return;
        let i27 = it({ aptosConfig: this.aptosConfig, transaction: r18, signer: this.account });
        await this.outstandingTransactions.enqueue([i27, t18]);
      }
    } catch (t18) {
      if (t18 instanceof n9) return;
      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t18}`);
    }
  }
  async processTransactions() {
    try {
      for (; ; ) {
        let t18 = [], r18 = [], [i27, o26] = await this.outstandingTransactions.dequeue();
        for (t18.push(i27), r18.push(o26); !this.outstandingTransactions.isEmpty(); ) [i27, o26] = await this.outstandingTransactions.dequeue(), t18.push(i27), r18.push(o26);
        let s11 = await Promise.allSettled(t18);
        for (let a24 = 0; a24 < s11.length && a24 < r18.length; a24 += 1) {
          let c7 = s11[a24];
          o26 = r18[a24], c7.status === Ws ? (this.sentTransactions.push([c7.value.hash, o26, null]), this.emit("transactionSent", { message: `transaction hash ${c7.value.hash} has been committed to chain`, transactionHash: c7.value.hash }), await this.checkTransaction(c7, o26)) : (this.sentTransactions.push([c7.status, o26, c7.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${c7.reason}`, error: c7.reason }));
        }
        this.emit("executionFinish", { message: `execute ${s11.length} transactions finished` });
      }
    } catch (t18) {
      if (t18 instanceof n9) return;
      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t18}`);
    }
  }
  async checkTransaction(t18, r18) {
    try {
      let i27 = [];
      i27.push(z4({ aptosConfig: this.aptosConfig, transactionHash: t18.value.hash }));
      let o26 = await Promise.allSettled(i27);
      for (let s11 = 0; s11 < o26.length; s11 += 1) {
        let a24 = o26[s11];
        a24.status === Ws ? (this.executedTransactions.push([a24.value.hash, r18, null]), this.emit("transactionExecuted", { message: `transaction hash ${a24.value.hash} has been executed on chain`, transactionHash: t18.value.hash })) : (this.executedTransactions.push([a24.status, r18, a24.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${a24.reason}`, error: a24.reason }));
      }
    } catch (i27) {
      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${i27}`);
    }
  }
  async push(t18, r18) {
    this.transactionsQueue.enqueue([t18, r18]);
  }
  async generateNextTransaction(t18, r18) {
    if (this.transactionsQueue.isEmpty()) return;
    let [i27, o26] = await this.transactionsQueue.dequeue();
    return f10({ aptosConfig: this.aptosConfig, sender: t18.accountAddress, data: i27, options: { ...o26, accountSequenceNumber: r18, replayProtectionNonce: void 0 } });
  }
  async run() {
    try {
      for (; !this.taskQueue.isCancelled(); ) await (await this.taskQueue.dequeue())();
    } catch (t18) {
      throw new Error(`Unable to start transaction batching: ${t18}`);
    }
  }
  start() {
    if (this.started) throw new Error("worker has already started");
    this.started = true, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
  }
  stop() {
    if (this.taskQueue.isCancelled()) throw new Error("worker has already stopped");
    this.started = false, this.taskQueue.cancel();
  }
};
var lr = class extends eventemitter3_default {
  constructor(e20) {
    super(), this.config = e20;
  }
  start(e20) {
    let { sender: t18 } = e20;
    this.account = t18, this.transactionWorker = new pr(this.config, t18), this.transactionWorker.start(), this.registerToEvents();
  }
  push(e20) {
    let { data: t18, options: r18 } = e20;
    for (let i27 of t18) this.transactionWorker.push(i27, r18);
  }
  registerToEvents() {
    this.transactionWorker.on("transactionSent", async (e20) => {
      this.emit("transactionSent", e20);
    }), this.transactionWorker.on("transactionSendFailed", async (e20) => {
      this.emit("transactionSendFailed", e20);
    }), this.transactionWorker.on("transactionExecuted", async (e20) => {
      this.emit("transactionExecuted", e20);
    }), this.transactionWorker.on("transactionExecutionFailed", async (e20) => {
      this.emit("transactionExecutionFailed", e20);
    }), this.transactionWorker.on("executionFinish", async (e20) => {
      this.emit("executionFinish", e20);
    });
  }
  forSingleAccount(e20) {
    try {
      let { sender: t18, data: r18, options: i27 } = e20;
      this.start({ sender: t18 }), this.push({ data: r18, options: i27 });
    } catch (t18) {
      throw new Error(`failed to submit transactions with error: ${t18}`);
    }
  }
};
var Pn = class {
  constructor(e20) {
    this.config = e20, this.build = new cr(this.config), this.simulate = new Xt(this.config), this.submit = new ur(this.config), this.batch = new lr(this.config);
  }
  async getTransactions(e20) {
    return H({ aptosConfig: this.config, ...e20 });
  }
  async getTransactionByVersion(e20) {
    return O5({ aptosConfig: this.config, ...e20 });
  }
  async getTransactionByHash(e20) {
    return y7({ aptosConfig: this.config, ...e20 });
  }
  async isPendingTransaction(e20) {
    return q4({ aptosConfig: this.config, ...e20 });
  }
  async waitForTransaction(e20) {
    return z4({ aptosConfig: this.config, ...e20 });
  }
  async getGasPriceEstimation() {
    return W3({ aptosConfig: this.config });
  }
  getSigningMessage(e20) {
    return Io(e20);
  }
  async publishPackageTransaction(e20) {
    return ko({ aptosConfig: this.config, ...e20 });
  }
  async rotateAuthKey(e20) {
    return Ho({ aptosConfig: this.config, ...e20 });
  }
  sign(e20) {
    return nr({ ...e20 });
  }
  signAsFeePayer(e20) {
    return rr({ ...e20 });
  }
  async batchTransactionsForSingleAccount(e20) {
    try {
      let { sender: t18, data: r18, options: i27 } = e20;
      this.batch.forSingleAccount({ sender: t18, data: r18, options: i27 });
    } catch (t18) {
      throw new Error(`failed to submit transactions with error: ${t18}`);
    }
  }
  async signAndSubmitTransaction(e20) {
    return it({ aptosConfig: this.config, ...e20 });
  }
  async signAndSubmitAsFeePayer(e20) {
    return _o({ aptosConfig: this.config, ...e20 });
  }
};
async function gr(n94) {
  let { aptosConfig: e20, jwt: t18, ephemeralKeyPair: r18, uidKey: i27 = "sub", derivationPath: o26 } = n94, s11 = { jwt_b64: t18, epk: r18.getPublicKey().bcsToHex().toStringWithoutPrefix(), exp_date_secs: r18.expiryDateSecs, epk_blinder: a3.fromHexInput(r18.blinder).toStringWithoutPrefix(), uid_key: i27, derivation_path: o26 }, { data: a24 } = await a16({ aptosConfig: e20, path: "fetch", body: s11, originMethod: "getPepper", overrides: { WITH_CREDENTIALS: false } });
  return a3.fromHexInput(a24.pepper).toUint8Array();
}
async function ti(n94) {
  let { aptosConfig: e20, jwt: t18, ephemeralKeyPair: r18, pepper: i27 = await gr(n94), uidKey: o26 = "sub", maxExpHorizonSecs: s11 = (await $t({ aptosConfig: e20 })).maxExpHorizonSecs } = n94;
  if (a3.fromHexInput(i27).toUint8Array().length !== he.PEPPER_LENGTH) throw new Error(`Pepper needs to be ${he.PEPPER_LENGTH} bytes`);
  let a24 = jwtDecode(t18);
  if (typeof a24.iat != "number") throw new Error("iat was not found");
  if (s11 < r18.expiryDateSecs - a24.iat) throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${s11}`);
  let c7 = { jwt_b64: t18, epk: r18.getPublicKey().bcsToHex().toStringWithoutPrefix(), epk_blinder: a3.fromHexInput(r18.blinder).toStringWithoutPrefix(), exp_date_secs: r18.expiryDateSecs, exp_horizon_secs: s11, pepper: a3.fromHexInput(i27).toStringWithoutPrefix(), uid_key: o26 }, { data: d15 } = await m9({ aptosConfig: e20, path: "prove", body: c7, originMethod: "getProof", overrides: { WITH_CREDENTIALS: false } }), l14 = d15.proof, g5 = new at({ a: l14.a, b: l14.b, c: l14.c });
  return new de({ proof: new en(g5, 0), trainingWheelsSignature: p3.fromHex(d15.training_wheels_signature), expHorizonSecs: s11 });
}
async function Qs(n94) {
  let { aptosConfig: e20, jwt: t18, jwkAddress: r18, uidKey: i27, proofFetchCallback: o26, pepper: s11 = await gr(n94) } = n94, { verificationKey: a24, maxExpHorizonSecs: c7 } = await $t({ aptosConfig: e20 }), d15 = ti({ ...n94, pepper: s11, maxExpHorizonSecs: c7 }), l14 = o26 ? d15 : await d15;
  if (r18 !== void 0) {
    let y10 = V2.fromJwtAndPepper({ jwt: t18, pepper: s11, jwkAddress: r18, uidKey: i27 }), h10 = await Jt({ aptosConfig: e20, authenticationKey: y10.authKey().derivedAddress() });
    return Ke.create({ ...n94, address: h10, proof: l14, pepper: s11, proofFetchCallback: o26, jwkAddress: r18, verificationKey: a24 });
  }
  let g5 = v5.fromJwtAndPepper({ jwt: t18, pepper: s11, uidKey: i27 }), p11 = await Jt({ aptosConfig: e20, authenticationKey: g5.authKey().derivedAddress() });
  return he.create({ ...n94, address: p11, proof: l14, pepper: s11, proofFetchCallback: o26, verificationKey: a24 });
}
async function Js(n94) {
  let { aptosConfig: e20, sender: t18, iss: r18, options: i27 } = n94, { jwksUrl: o26 } = n94;
  o26 === void 0 && (r9.test(r18) ? o26 = "https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com" : o26 = r18.endsWith("/") ? `${r18}.well-known/jwks.json` : `${r18}/.well-known/jwks.json`);
  let s11;
  try {
    if (s11 = await fetch(o26), !s11.ok) throw new Error(`${s11.status} ${s11.statusText}`);
  } catch (c7) {
    let d15;
    throw c7 instanceof Error ? d15 = `${c7.message}` : d15 = `error unknown - ${c7}`, N.fromErrorType({ type: 14, details: `Failed to fetch JWKS at ${o26}: ${d15}` });
  }
  let a24 = await s11.json();
  return f10({ aptosConfig: e20, sender: t18.accountAddress, data: { function: "0x1::jwks::update_federated_jwk_set", functionArguments: [r18, t3.MoveString(a24.keys.map((c7) => c7.kid)), t3.MoveString(a24.keys.map((c7) => c7.alg)), t3.MoveString(a24.keys.map((c7) => c7.e)), t3.MoveString(a24.keys.map((c7) => c7.n))] }, options: i27 });
}
var Kn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getPepper(e20) {
    return gr({ aptosConfig: this.config, ...e20 });
  }
  async getProof(e20) {
    return ti({ aptosConfig: this.config, ...e20 });
  }
  async deriveKeylessAccount(e20) {
    return Qs({ aptosConfig: this.config, ...e20 });
  }
  async updateFederatedKeylessJwkSetTransaction(e20) {
    return Js({ aptosConfig: this.config, ...e20 });
  }
};
async function pc(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = { query: v3, variables: { where_condition: t18?.where, offset: t18?.offset, limit: t18?.limit, order_by: t18?.orderBy } };
  return (await a17({ aptosConfig: e20, query: r18, originMethod: "getObjectData" })).current_objects;
}
async function Zs(n94) {
  let { aptosConfig: e20, objectAddress: t18, options: r18 } = n94, o26 = { object_address: { _eq: l3.from(t18).toStringLong() } };
  return (await pc({ aptosConfig: e20, options: { ...r18, where: o26 } }))[0];
}
var xn = class {
  constructor(e20) {
    this.config = e20;
  }
  async getObjectDataByObjectAddress(e20) {
    return await i23({ config: this.config, minimumLedgerVersion: e20.minimumLedgerVersion, processorType: "objects_processor" }), Zs({ aptosConfig: this.config, ...e20 });
  }
};
var j3 = class {
  constructor(e20) {
    this.config = e20 ?? new a21(), this.account = new ln(this.config), this.abstraction = new Tt(this.config), this.ans = new Tn(this.config), this.coin = new gn(this.config), this.digitalAsset = new yn(this.config), this.event = new fn(this.config), this.faucet = new An(this.config), this.fungibleAsset = new hn(this.config), this.general = new bn(this.config), this.staking = new Sn(this.config), this.transaction = new Pn(this.config), this.table = new a19(this.config), this.keyless = new Kn(this.config), this.object = new xn(this.config);
  }
  setIgnoreTransactionSubmitter(e20) {
    this.config.setIgnoreTransactionSubmitter(e20);
  }
};
function ie(n94, e20, t18) {
  Object.getOwnPropertyNames(e20.prototype).forEach((r18) => {
    let i27 = Object.getOwnPropertyDescriptor(e20.prototype, r18);
    i27 && (i27.value = function(...o26) {
      return this[t18][r18](...o26);
    }, Object.defineProperty(n94.prototype, r18, i27));
  });
}
ie(j3, ln, "account");
ie(j3, Tt, "abstraction");
ie(j3, Tn, "ans");
ie(j3, gn, "coin");
ie(j3, yn, "digitalAsset");
ie(j3, fn, "event");
ie(j3, An, "faucet");
ie(j3, hn, "fungibleAsset");
ie(j3, bn, "general");
ie(j3, Sn, "staking");
ie(j3, Pn, "transaction");
ie(j3, a19, "table");
ie(j3, Kn, "keyless");
ie(j3, xn, "object");
var mc = 1e7;
var ni = 120;
var fc = 30;
var Ac = 330;
var hc = 120;
var bc = 350;
var wc = 300;
var Tc = 93;
var Fe = class Fe2 extends n6 {
  constructor(e20, t18) {
    super();
    let r18 = a3.fromHexInput(t18).toUint8Array();
    if (r18.length !== Fe2.ID_COMMITMENT_LENGTH) throw new Error(`Id Commitment length in bytes should be ${Fe2.ID_COMMITMENT_LENGTH}`);
    this.iss = e20, this.idCommitment = r18;
  }
  authKey() {
    let e20 = new n4();
    return e20.serializeU32AsUleb128(3), e20.serializeFixedBytes(this.bcsToBytes()), s4.fromSchemeAndBytes({ scheme: 2, input: e20.toUint8Array() });
  }
  verifySignature(e20) {
    try {
      return zn({ ...e20, publicKey: this }), true;
    } catch (t18) {
      if (t18 instanceof N) return false;
      throw t18;
    }
  }
  async verifySignatureAsync(e20) {
    return Cr({ ...e20, publicKey: this });
  }
  serialize(e20) {
    e20.serializeStr(this.iss), e20.serializeBytes(this.idCommitment);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeStr(), r18 = e20.deserializeBytes();
    return new Fe2(t18, r18);
  }
  static load(e20) {
    let t18 = e20.deserializeStr(), r18 = e20.deserializeBytes();
    return new Fe2(t18, r18);
  }
  static isPublicKey(e20) {
    return e20 instanceof Fe2;
  }
  static create(e20) {
    return Ys(e20), new Fe2(e20.iss, Ys(e20));
  }
  static fromJwtAndPepper(e20) {
    let { jwt: t18, pepper: r18, uidKey: i27 = "sub" } = e20, o26 = jwtDecode(t18);
    if (typeof o26.iss != "string") throw new Error("iss was not found");
    if (typeof o26.aud != "string") throw new Error("aud was not found or an array of values");
    let s11 = o26[i27];
    return Fe2.create({ iss: o26.iss, uidKey: i27, uidVal: s11, aud: o26.aud, pepper: r18 });
  }
  static isInstance(e20) {
    return "iss" in e20 && typeof e20.iss == "string" && "idCommitment" in e20 && e20.idCommitment instanceof Uint8Array;
  }
};
Fe.ID_COMMITMENT_LENGTH = 32;
var v5 = Fe;
async function Cr(n94) {
  let { aptosConfig: e20, publicKey: t18, message: r18, signature: i27, jwk: o26, keylessConfig: s11 = await $t({ aptosConfig: e20 }), options: a24 } = n94;
  try {
    if (!(i27 instanceof ee)) throw N.fromErrorType({ type: 26, details: "Not a keyless signature" });
    return zn({ message: r18, publicKey: t18, signature: i27, jwk: o26 || await Ir({ aptosConfig: e20, publicKey: t18, kid: i27.getJwkKid() }), keylessConfig: s11 }), true;
  } catch (c7) {
    if (a24?.throwErrorWithReason) throw c7;
    return false;
  }
}
function zn(n94) {
  let { publicKey: e20, message: t18, signature: r18, keylessConfig: i27, jwk: o26 } = n94, { verificationKey: s11, maxExpHorizonSecs: a24, trainingWheelsPubkey: c7 } = i27;
  if (!(r18 instanceof ee)) throw N.fromErrorType({ type: 26, details: "Not a keyless signature" });
  if (!(r18.ephemeralCertificate.signature instanceof de)) throw N.fromErrorType({ type: 26, details: "Unsupported ephemeral certificate variant" });
  let d15 = r18.ephemeralCertificate.signature;
  if (!(d15.proof.proof instanceof at)) throw N.fromErrorType({ type: 26, details: "Unsupported proof variant for ZeroKnowledgeSig" });
  let l14 = d15.proof.proof;
  if (r18.expiryDateSecs < _2()) throw N.fromErrorType({ type: 27, details: "The expiryDateSecs is in the past" });
  if (d15.expHorizonSecs > a24) throw N.fromErrorType({ type: 28 });
  if (!r18.ephemeralPublicKey.verifySignature({ message: t18, signature: r18.ephemeralSignature })) throw N.fromErrorType({ type: 29 });
  let g5 = Sc({ publicKey: e20, signature: r18, jwk: o26, keylessConfig: i27 });
  if (!s11.verifyProof({ publicInputsHash: g5, groth16Proof: l14 })) throw N.fromErrorType({ type: 32 });
  if (c7) {
    if (!d15.trainingWheelsSignature) throw N.fromErrorType({ type: 30 });
    let p11 = new ii(l14, g5);
    if (!c7.verifySignature({ message: p11.hash(), signature: d15.trainingWheelsSignature })) throw N.fromErrorType({ type: 31 });
  }
}
function Sc(n94) {
  let { publicKey: e20, signature: t18, jwk: r18, keylessConfig: i27 } = n94, o26 = e20 instanceof v5 ? e20 : e20.keylessPublicKey;
  if (!(t18.ephemeralCertificate.signature instanceof de)) throw new Error("Signature is not a ZeroKnowledgeSig");
  let s11 = t18.ephemeralCertificate.signature, a24 = [];
  return a24.push(..._4(t18.ephemeralPublicKey.toUint8Array(), i27.maxCommitedEpkBytes)), a24.push(N2(o26.idCommitment)), a24.push(t18.expiryDateSecs), a24.push(s11.expHorizonSecs), a24.push(C(o26.iss, i27.maxIssValBytes)), s11.extraField ? (a24.push(1n), a24.push(C(s11.extraField, i27.maxExtraFieldBytes))) : (a24.push(0n), a24.push(C(" ", i27.maxExtraFieldBytes))), a24.push(C(encode(t18.jwtHeader, true) + ".", i27.maxJwtHeaderB64Bytes)), a24.push(r18.toScalar()), s11.overrideAudVal ? (a24.push(C(s11.overrideAudVal, ni)), a24.push(1n)) : (a24.push(C("", ni)), a24.push(0n)), M2(a24);
}
async function Ir(n94) {
  let { aptosConfig: e20, publicKey: t18, kid: r18 } = n94, i27 = t18 instanceof v5 ? t18 : t18.keylessPublicKey, { iss: o26 } = i27, s11, a24 = t18 instanceof V2 ? t18.jwkAddress : void 0;
  try {
    s11 = await xc({ aptosConfig: e20, jwkAddr: a24 });
  } catch (l14) {
    throw N.fromErrorType({ type: 24, error: l14, details: `Failed to fetch ${a24 ? "Federated" : "Patched"}JWKs ${a24 ? `for address ${a24}` : "0x1"}` });
  }
  let c7 = s11.get(o26);
  if (c7 === void 0) throw N.fromErrorType({ type: 7, details: `JWKs for issuer ${o26} not found.` });
  let d15 = c7.find((l14) => l14.kid === r18);
  if (d15 === void 0) throw N.fromErrorType({ type: 6, details: `JWK with kid '${r18}' for issuer '${o26}' not found.` });
  return d15;
}
function Ys(n94) {
  let { uidKey: e20, uidVal: t18, aud: r18, pepper: i27 } = n94, o26 = [N2(a3.fromHexInput(i27).toUint8Array()), C(r18, ni), C(t18, Ac), C(e20, fc)];
  return W2(M2(o26), v5.ID_COMMITMENT_LENGTH);
}
var ee = class n71 extends o7 {
  constructor(e20) {
    super();
    let { jwtHeader: t18, ephemeralCertificate: r18, expiryDateSecs: i27, ephemeralPublicKey: o26, ephemeralSignature: s11 } = e20;
    this.jwtHeader = t18, this.ephemeralCertificate = r18, this.expiryDateSecs = i27, this.ephemeralPublicKey = o26, this.ephemeralSignature = s11;
  }
  getJwkKid() {
    return Cc(this.jwtHeader).kid;
  }
  serialize(e20) {
    this.ephemeralCertificate.serialize(e20), e20.serializeStr(this.jwtHeader), e20.serializeU64(this.expiryDateSecs), this.ephemeralPublicKey.serialize(e20), this.ephemeralSignature.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = qt.deserialize(e20), r18 = e20.deserializeStr(), i27 = e20.deserializeU64(), o26 = c3.deserialize(e20), s11 = p3.deserialize(e20);
    return new n71({ jwtHeader: r18, expiryDateSecs: Number(i27), ephemeralCertificate: t18, ephemeralPublicKey: o26, ephemeralSignature: s11 });
  }
  static getSimulationSignature() {
    return new n71({ jwtHeader: "{}", ephemeralCertificate: new qt(new de({ proof: new en(new at({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }), 0), expHorizonSecs: 0 }), 0), expiryDateSecs: 0, ephemeralPublicKey: new c3(new f6(new Uint8Array(32))), ephemeralSignature: new p3(new h6(new Uint8Array(64))) });
  }
  static isSignature(e20) {
    return e20 instanceof n71;
  }
};
var qt = class n72 extends o7 {
  constructor(e20, t18) {
    super(), this.signature = e20, this.variant = t18;
  }
  toUint8Array() {
    return this.signature.toUint8Array();
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(this.variant), this.signature.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return new n72(de.deserialize(e20), t18);
      default:
        throw new Error(`Unknown variant index for EphemeralCertificate: ${t18}`);
    }
  }
};
var En = class En2 extends B2 {
  constructor(e20) {
    if (super(), this.data = a3.fromHexInput(e20).toUint8Array(), this.data.length !== 32) throw new Error("Input needs to be 32 bytes");
  }
  serialize(e20) {
    e20.serializeFixedBytes(this.data);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeFixedBytes(32);
    return new En2(t18);
  }
  toArray() {
    let e20 = this.toProjectivePoint();
    return [e20.x.toString(), e20.y.toString(), e20.pz.toString()];
  }
  toProjectivePoint() {
    let e20 = new Uint8Array(this.data);
    e20.reverse();
    let t18 = (e20[0] & 128) >> 7, { Fp: r18 } = bn254.fields, i27 = r18.create(ri(e20)), o26 = r18.sqrt(r18.add(r18.pow(i27, 3n), En2.B)), s11 = r18.neg(o26), a24 = o26 > s11 == (t18 === 1) ? o26 : s11;
    return bn254.G1.ProjectivePoint.fromAffine({ x: i27, y: a24 });
  }
};
En.B = bn254.fields.Fp.create(3n);
var Qe = En;
function ri(n94) {
  if (n94.length !== 32) throw new Error("Input should be 32 bytes");
  let e20 = new Uint8Array(n94);
  return e20[0] = e20[0] & 63, bytesToNumberBE(e20);
}
var Cn = class Cn2 extends B2 {
  constructor(e20) {
    if (super(), this.data = a3.fromHexInput(e20).toUint8Array(), this.data.length !== 64) throw new Error("Input needs to be 64 bytes");
  }
  serialize(e20) {
    e20.serializeFixedBytes(this.data);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeFixedBytes(64);
    return new Cn2(t18);
  }
  toArray() {
    let e20 = this.toProjectivePoint();
    return [[e20.x.c0.toString(), e20.x.c1.toString()], [e20.y.c0.toString(), e20.y.c1.toString()], [e20.pz.c0.toString(), e20.pz.c1.toString()]];
  }
  toProjectivePoint() {
    let e20 = new Uint8Array(this.data), t18 = e20.slice(0, 32).reverse(), r18 = e20.slice(32, 64).reverse(), i27 = (r18[0] & 128) >> 7, { Fp2: o26 } = bn254.fields, s11 = o26.fromBigTuple([ri(t18), ri(r18)]), a24 = o26.sqrt(o26.add(o26.pow(s11, 3n), Cn2.B)), c7 = o26.neg(a24), l14 = (a24.c1 > c7.c1 || a24.c1 === c7.c1 && a24.c0 > c7.c0) === (i27 === 1) ? a24 : c7;
    return bn254.G2.ProjectivePoint.fromAffine({ x: s11, y: l14 });
  }
};
Cn.B = bn254.fields.Fp2.fromBigTuple([19485874751759354771024239261021720505790618469301721065564631296452457478373n, 266929791119991161246907387137283842545076965332900288569378510910307636690n]);
var St = Cn;
var at = class n73 extends e5 {
  constructor(e20) {
    super();
    let { a: t18, b: r18, c: i27 } = e20;
    this.a = new Qe(t18), this.b = new St(r18), this.c = new Qe(i27);
  }
  serialize(e20) {
    this.a.serialize(e20), this.b.serialize(e20), this.c.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = Qe.deserialize(e20).bcsToBytes(), r18 = St.deserialize(e20).bcsToBytes(), i27 = Qe.deserialize(e20).bcsToBytes();
    return new n73({ a: t18, b: r18, c: i27 });
  }
  toSnarkJsJson() {
    return { protocol: "groth16", curve: "bn128", pi_a: this.a.toArray(), pi_b: this.b.toArray(), pi_c: this.c.toArray() };
  }
};
var ii = class n74 extends B2 {
  constructor(t18, r18) {
    super();
    this.domainSeparator = "APTOS::Groth16ProofAndStatement";
    if (this.proof = t18, this.publicInputsHash = typeof r18 == "bigint" ? W2(r18, 32) : a3.fromHexInput(r18).toUint8Array(), this.publicInputsHash.length !== 32) throw new Error("Invalid public inputs hash");
  }
  serialize(t18) {
    this.proof.serialize(t18), t18.serializeFixedBytes(this.publicInputsHash);
  }
  static deserialize(t18) {
    return new n74(at.deserialize(t18), t18.deserializeFixedBytes(32));
  }
  hash() {
    return rt(this.bcsToBytes(), this.domainSeparator);
  }
};
var en = class n75 extends B2 {
  constructor(e20, t18) {
    super(), this.proof = e20, this.variant = t18;
  }
  serialize(e20) {
    e20.serializeU32AsUleb128(this.variant), this.proof.serialize(e20);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeUleb128AsU32();
    switch (t18) {
      case 0:
        return new n75(at.deserialize(e20), t18);
      default:
        throw new Error(`Unknown variant index for ZkProof: ${t18}`);
    }
  }
};
var de = class n76 extends o7 {
  constructor(e20) {
    super();
    let { proof: t18, expHorizonSecs: r18, trainingWheelsSignature: i27, extraField: o26, overrideAudVal: s11 } = e20;
    this.proof = t18, this.expHorizonSecs = r18, this.trainingWheelsSignature = i27, this.extraField = o26, this.overrideAudVal = s11;
  }
  static fromBytes(e20) {
    return n76.deserialize(new a11(e20));
  }
  serialize(e20) {
    this.proof.serialize(e20), e20.serializeU64(this.expHorizonSecs), e20.serializeOption(this.extraField), e20.serializeOption(this.overrideAudVal), e20.serializeOption(this.trainingWheelsSignature);
  }
  static deserialize(e20) {
    let t18 = en.deserialize(e20), r18 = Number(e20.deserializeU64()), i27 = e20.deserializeOption("string"), o26 = e20.deserializeOption("string"), s11 = e20.deserializeOption(p3);
    return new n76({ proof: t18, expHorizonSecs: r18, trainingWheelsSignature: s11, extraField: i27, overrideAudVal: o26 });
  }
};
var oi = class n77 {
  constructor(e20) {
    let { verificationKey: t18, trainingWheelsPubkey: r18, maxExpHorizonSecs: i27 = mc, maxExtraFieldBytes: o26 = bc, maxJwtHeaderB64Bytes: s11 = wc, maxIssValBytes: a24 = hc, maxCommitedEpkBytes: c7 = Tc } = e20;
    this.verificationKey = t18, this.maxExpHorizonSecs = i27, r18 && (this.trainingWheelsPubkey = new c3(new f6(r18))), this.maxExtraFieldBytes = o26, this.maxJwtHeaderB64Bytes = s11, this.maxIssValBytes = a24, this.maxCommitedEpkBytes = c7;
  }
  static create(e20, t18) {
    return new n77({ verificationKey: new si({ alphaG1: e20.alpha_g1, betaG2: e20.beta_g2, deltaG2: e20.delta_g2, gammaAbcG1: e20.gamma_abc_g1, gammaG2: e20.gamma_g2 }), maxExpHorizonSecs: Number(t18.max_exp_horizon_secs), trainingWheelsPubkey: t18.training_wheels_pubkey.vec[0], maxExtraFieldBytes: t18.max_extra_field_bytes, maxJwtHeaderB64Bytes: t18.max_jwt_header_b64_bytes, maxIssValBytes: t18.max_iss_val_bytes, maxCommitedEpkBytes: t18.max_commited_epk_bytes });
  }
};
var si = class n78 {
  constructor(e20) {
    let { alphaG1: t18, betaG2: r18, deltaG2: i27, gammaAbcG1: o26, gammaG2: s11 } = e20;
    this.alphaG1 = new Qe(t18), this.betaG2 = new St(r18), this.deltaG2 = new St(i27), this.gammaAbcG1 = [new Qe(o26[0]), new Qe(o26[1])], this.gammaG2 = new St(s11);
  }
  hash() {
    let e20 = new n4();
    return this.serialize(e20), sha3_256.create().update(e20.toUint8Array()).digest();
  }
  serialize(e20) {
    this.alphaG1.serialize(e20), this.betaG2.serialize(e20), this.deltaG2.serialize(e20), this.gammaAbcG1[0].serialize(e20), this.gammaAbcG1[1].serialize(e20), this.gammaG2.serialize(e20);
  }
  static fromGroth16VerificationKeyResponse(e20) {
    return new n78({ alphaG1: e20.alpha_g1, betaG2: e20.beta_g2, deltaG2: e20.delta_g2, gammaAbcG1: e20.gamma_abc_g1, gammaG2: e20.gamma_g2 });
  }
  verifyProof(e20) {
    let { publicInputsHash: t18, groth16Proof: r18 } = e20;
    try {
      let i27 = r18.a.toProjectivePoint(), o26 = r18.b.toProjectivePoint(), s11 = r18.c.toProjectivePoint(), a24 = this.alphaG1.toProjectivePoint(), c7 = this.betaG2.toProjectivePoint(), d15 = this.gammaG2.toProjectivePoint(), l14 = this.deltaG2.toProjectivePoint(), g5 = this.gammaAbcG1.map((Je) => Je.toProjectivePoint()), { Fp12: p11 } = bn254.fields, y10 = g5[0].add(g5[1].multiply(t18)), h10 = bn254.pairing(y10, d15), _8 = bn254.pairing(i27, o26), G3 = bn254.pairing(a24, c7), J = bn254.pairing(s11, l14), Ue2 = p11.mul(G3, p11.mul(h10, J));
      return p11.eql(_8, Ue2);
    } catch (i27) {
      throw N.fromErrorType({ type: 32, error: i27, details: "Error encountered when checking zero knowledge relation" });
    }
  }
  toSnarkJsJson() {
    return { protocol: "groth16", curve: "bn128", nPublic: 1, vk_alpha_1: this.alphaG1.toArray(), vk_beta_2: this.betaG2.toArray(), vk_gamma_2: this.gammaG2.toArray(), vk_delta_2: this.deltaG2.toArray(), IC: this.gammaAbcG1.map((e20) => e20.toArray()) };
  }
};
async function $t(n94) {
  let { aptosConfig: e20 } = n94;
  try {
    return await m(async () => {
      let [t18, r18] = await Promise.all([Pc(n94), Kc(n94)]);
      return oi.create(r18, t18);
    }, `keyless-configuration-${e20.network}`, 1e3 * 60 * 5)();
  } catch (t18) {
    throw t18 instanceof N ? t18 : N.fromErrorType({ type: 25, error: t18 });
  }
}
function qe(n94) {
  let { jwt: e20, uidKey: t18 = "sub" } = n94, r18;
  try {
    r18 = jwtDecode(e20);
  } catch (o26) {
    throw N.fromErrorType({ type: 12, details: `Failed to parse JWT - ${A2(o26)}` });
  }
  if (typeof r18.iss != "string") throw N.fromErrorType({ type: 12, details: "JWT is missing 'iss' in the payload. This should never happen." });
  if (typeof r18.aud != "string") throw N.fromErrorType({ type: 12, details: "JWT is missing 'aud' in the payload or 'aud' is an array of values." });
  let i27 = r18[t18];
  return { iss: r18.iss, aud: r18.aud, uidVal: i27 };
}
async function Pc(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = "0x1::keyless_account::Configuration";
  try {
    let { data: i27 } = await y2({ aptosConfig: e20, originMethod: "getKeylessConfigurationResource", path: `accounts/${l3.from("0x1").toString()}/resource/${r18}`, params: { ledger_version: t18?.ledgerVersion } });
    return i27.data;
  } catch (i27) {
    throw N.fromErrorType({ type: 22, error: i27 });
  }
}
async function Kc(n94) {
  let { aptosConfig: e20, options: t18 } = n94, r18 = "0x1::keyless_account::Groth16VerificationKey";
  try {
    let { data: i27 } = await y2({ aptosConfig: e20, originMethod: "getGroth16VerificationKeyResource", path: `accounts/${l3.from("0x1").toString()}/resource/${r18}`, params: { ledger_version: t18?.ledgerVersion } });
    return i27.data;
  } catch (i27) {
    throw N.fromErrorType({ type: 23, error: i27 });
  }
}
async function xc(n94) {
  let { aptosConfig: e20, jwkAddr: t18, options: r18 } = n94, i27;
  if (t18) {
    let s11 = "0x1::jwks::FederatedJWKs", { data: a24 } = await y2({ aptosConfig: e20, originMethod: "getKeylessJWKs", path: `accounts/${l3.from(t18).toString()}/resource/${s11}`, params: { ledger_version: r18?.ledgerVersion } });
    i27 = a24;
  } else {
    let s11 = "0x1::jwks::PatchedJWKs", { data: a24 } = await y2({ aptosConfig: e20, originMethod: "getKeylessJWKs", path: `accounts/0x1/resource/${s11}`, params: { ledger_version: r18?.ledgerVersion } });
    i27 = a24;
  }
  let o26 = /* @__PURE__ */ new Map();
  for (let s11 of i27.data.jwks.entries) {
    let a24 = [];
    for (let c7 of s11.jwks) {
      let { data: d15 } = c7.variant, l14 = new a11(a3.fromHexInput(d15).toUint8Array()), g5 = ai.deserialize(l14);
      a24.push(g5);
    }
    o26.set(l2(s11.issuer), a24);
  }
  return o26;
}
var ai = class n79 extends B2 {
  constructor(e20) {
    super();
    let { kid: t18, kty: r18, alg: i27, e: o26, n: s11 } = e20;
    this.kid = t18, this.kty = r18, this.alg = i27, this.e = o26, this.n = s11;
  }
  serialize(e20) {
    e20.serializeStr(this.kid), e20.serializeStr(this.kty), e20.serializeStr(this.alg), e20.serializeStr(this.e), e20.serializeStr(this.n);
  }
  static fromMoveStruct(e20) {
    let { data: t18 } = e20.variant, r18 = new a11(a3.fromHexInput(t18).toUint8Array());
    return n79.deserialize(r18);
  }
  toScalar() {
    if (this.alg !== "RS256") throw N.fromErrorType({ type: 32, details: "Failed to convert JWK to scalar when calculating the public inputs hash. Only RSA 256 is supported currently" });
    let e20 = h3(this.n), r18 = Ec(e20.reverse()).map((i27) => N2(i27));
    return r18.push(256n), M2(r18);
  }
  static deserialize(e20) {
    let t18 = e20.deserializeStr(), r18 = e20.deserializeStr(), i27 = e20.deserializeStr(), o26 = e20.deserializeStr(), s11 = e20.deserializeStr();
    return new n79({ kid: t18, kty: r18, alg: i27, n: s11, e: o26 });
  }
};
function Ec(n94) {
  let e20 = [];
  for (let t18 = 0; t18 < n94.length; t18 += 24) {
    let r18 = n94.slice(t18, Math.min(t18 + 24, n94.length));
    if (r18.length < 24) {
      let i27 = new Uint8Array(24);
      i27.set(r18), e20.push(i27);
    } else e20.push(r18);
  }
  return e20;
}
function Cc(n94) {
  try {
    let e20 = JSON.parse(n94);
    if (e20.kid === void 0) throw new Error("JWT header missing kid");
    return e20;
  } catch {
    throw new Error("Failed to parse JWT header.");
  }
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KJH4KKG6.mjs
var l10 = ((e20) => (e20[e20.V1 = 0] = "V1", e20[e20.DerivableV1 = 1] = "DerivableV1", e20))(l10 || {});

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
var n80 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function i24(t18, e20 = []) {
  return [...n80, ...e20].every((s11) => s11 in t18.features);
}
function d8() {
  let { get: t18, on: e20 } = getWallets(), s11 = t18(), a24 = [];
  return s11.map((l14) => {
    i24(l14) && a24.push(l14);
  }), { aptosWallets: a24, on: e20 };
}

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-NKKS7QPJ.mjs
var o12 = ((e20) => (e20[e20.Unauthorized = 4100] = "Unauthorized", e20[e20.Unsupported = 4200] = "Unsupported", e20[e20.InternalError = -30001] = "InternalError", e20))(o12 || {});
var r11 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r12 = ((e20) => (e20.APPROVED = "Approved", e20.REJECTED = "Rejected", e20))(r12 || {});

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-PFWJQYHN.mjs
var n85 = "aptos:signAndSubmitTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MECB2PDY.mjs
var n86 = "aptos:signIn";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-BIF2XL2R.mjs
var e12 = "aptos:signMessage";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-DIMEBT3E.mjs
var n87 = "aptos:signTransaction";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OYMA2PWW.mjs
var o16 = "aptos:connect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7KTK52MK.mjs
var o17 = "aptos:disconnect";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-EKJ7Y4LP.mjs
var t12 = "aptos:account";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTTDX4QF.mjs
var t13 = "aptos:network";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MNFE4AOY.mjs
var n88 = "aptos:onAccountChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MJDSOKP4.mjs
var e13 = "aptos:onNetworkChange";

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
var d10 = class o18 extends B {
  constructor({ address: e20, publicKey: n94, ansName: t18 }) {
    super();
    this.address = l.from(e20), this.publicKey = n94, this.ansName = t18;
  }
  serialize(e20) {
    if (this.address.serialize(e20), this.publicKey instanceof f) e20.serializeU32AsUleb128(E.Ed25519);
    else if (this.publicKey instanceof Dt) e20.serializeU32AsUleb128(E.MultiEd25519);
    else if (this.publicKey instanceof k) e20.serializeU32AsUleb128(E.SingleKey);
    else if (this.publicKey instanceof Se) e20.serializeU32AsUleb128(E.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e20), e20.serializeStr(this.ansName ?? "");
  }
  static deserialize(e20) {
    let n94 = l.deserialize(e20), t18 = e20.deserializeUleb128AsU32(), s11;
    switch (t18) {
      case E.Ed25519:
        s11 = f.deserialize(e20);
        break;
      case E.MultiEd25519:
        s11 = Dt.deserialize(e20);
        break;
      case E.SingleKey:
        s11 = k.deserialize(e20);
        break;
      case E.MultiKey:
        s11 = Se.deserialize(e20);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t18}`);
    }
    let b8 = e20.deserializeStr() || void 0;
    return new o18({ address: n94, publicKey: s11, ansName: b8 });
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t14 = "aptos:devnet";
var o19 = "aptos:testnet";
var A13 = "aptos:localnet";
var T12 = "aptos:mainnet";
var e14 = [t14, o19, A13, T12];

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-NKKS7QPJ.mjs
var o20 = ((e20) => (e20[e20.Unauthorized = 4100] = "Unauthorized", e20[e20.Unsupported = 4200] = "Unsupported", e20[e20.InternalError = -30001] = "InternalError", e20))(o20 || {});
var r13 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });
var s9 = class n89 extends Error {
  constructor(t18, e20) {
    super(e20 ?? r13[t18]?.message ?? "Unknown error occurred");
    this.code = t18, this.status = r13[t18]?.status ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, n89.prototype);
  }
};

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r14 = ((e20) => (e20.APPROVED = "Approved", e20.REJECTED = "Rejected", e20))(r14 || {});

// node_modules/@identity-connect/crypto/dist/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_ed2curve = __toESM(require_ed2curve(), 1);
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
var d12 = class o21 extends B {
  constructor({ address: e20, publicKey: n94, ansName: t18 }) {
    super();
    this.address = l.from(e20), this.publicKey = n94, this.ansName = t18;
  }
  serialize(e20) {
    if (this.address.serialize(e20), this.publicKey instanceof f) e20.serializeU32AsUleb128(E.Ed25519);
    else if (this.publicKey instanceof Dt) e20.serializeU32AsUleb128(E.MultiEd25519);
    else if (this.publicKey instanceof k) e20.serializeU32AsUleb128(E.SingleKey);
    else if (this.publicKey instanceof Se) e20.serializeU32AsUleb128(E.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e20), e20.serializeStr(this.ansName ?? "");
  }
  static deserialize(e20) {
    let n94 = l.deserialize(e20), t18 = e20.deserializeUleb128AsU32(), s11;
    switch (t18) {
      case E.Ed25519:
        s11 = f.deserialize(e20);
        break;
      case E.MultiEd25519:
        s11 = Dt.deserialize(e20);
        break;
      case E.SingleKey:
        s11 = k.deserialize(e20);
        break;
      case E.MultiKey:
        s11 = Se.deserialize(e20);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t18}`);
    }
    let b8 = e20.deserializeStr() || void 0;
    return new o21({ address: n94, publicKey: s11, ansName: b8 });
  }
};

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-NKKS7QPJ.mjs
var o22 = ((e20) => (e20[e20.Unauthorized = 4100] = "Unauthorized", e20[e20.Unsupported = 4200] = "Unsupported", e20[e20.InternalError = -30001] = "InternalError", e20))(o22 || {});
var r15 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." }, 4200: { status: "Unsupported", message: "The requested feature is not supported." } });

// node_modules/@aptos-connect/wallet-api/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r16 = ((e20) => (e20.APPROVED = "Approved", e20.REJECTED = "Rejected", e20))(r16 || {});

// node_modules/@aptos-connect/wallet-api/dist/index.mjs
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  return Uint8Array.from(binaryString, (m13) => m13.charCodeAt(0));
}
function bytesToBase64(bytes) {
  const binaryString = String.fromCharCode(...bytes);
  return btoa(binaryString);
}
function bytesToBase64url(bytes) {
  return bytesToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function chainIdToNetwork(chainId) {
  switch (chainId) {
    case r.mainnet:
      return e.MAINNET;
    case r.testnet:
      return e.TESTNET;
    default:
      return e.DEVNET;
  }
}
function isSupportedNetwork(network) {
  return [e.MAINNET, e.TESTNET, e.DEVNET].includes(network);
}
function serializeAccountAuthenticatorInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serialize(value.authenticator);
}
function deserializeAccountAuthenticatorInput(deserializer) {
  const address = deserializer.deserialize(l);
  const authenticator = deserializer.deserialize(V);
  return { address, authenticator };
}
function serializePublicKey(serializer, value) {
  if (value instanceof f) {
    serializer.serializeU32AsUleb128(E.Ed25519);
  } else if (value instanceof Dt) {
    serializer.serializeU32AsUleb128(E.MultiEd25519);
  } else if (value instanceof k) {
    serializer.serializeU32AsUleb128(E.SingleKey);
  } else if (value instanceof Se) {
    serializer.serializeU32AsUleb128(E.MultiKey);
  } else {
    throw new Error("Unexpected public key type");
  }
  serializer.serialize(value);
}
function deserializePublicKey(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case E.Ed25519:
      return deserializer.deserialize(f);
    case E.MultiEd25519:
      return deserializer.deserialize(Dt);
    case E.SingleKey:
      return deserializer.deserialize(k);
    case E.MultiKey:
      return deserializer.deserialize(Se);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
function serializeAccountInfo(serializer, value) {
  serializer.serialize(value.address);
  serializePublicKey(serializer, value.publicKey);
  serializer.serializeStr(value.name ?? "");
}
function deserializeAccountInfo(deserializer) {
  const address = deserializer.deserialize(l);
  const publicKey = deserializePublicKey(deserializer);
  const name = deserializer.deserializeStr();
  return {
    address,
    publicKey,
    ...name.length > 0 ? { name } : void 0
  };
}
function serializeAccountInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serializeBool(value.publicKey !== void 0);
  if (value.publicKey) {
    serializePublicKey(serializer, value.publicKey);
  }
}
function deserializeAccountInput(deserializer) {
  const address = deserializer.deserialize(l);
  const hasPublicKey = deserializer.deserializeBool();
  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : void 0;
  return { address, publicKey };
}
function serializeDappInfo(serializer, value) {
  serializer.serializeStr(value.domain);
  serializer.serializeStr(value.name);
  serializer.serializeBool(value.imageURI !== void 0);
  if (value.imageURI !== void 0) {
    serializer.serializeStr(value.imageURI);
  }
}
function deserializeDappInfo(deserializer) {
  const domain = deserializer.deserializeStr();
  const name = deserializer.deserializeStr();
  const hasImageUri = deserializer.deserializeBool();
  const imageURI = hasImageUri ? deserializer.deserializeStr() : void 0;
  return { domain, imageURI, name };
}
var EntryFunctionArgumentVariant = ((EntryFunctionArgumentVariant2) => {
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Undefined"] = 0] = "Undefined";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Array"] = 1] = "Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["String"] = 2] = "String";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Uint8Array"] = 3] = "Uint8Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["AccountAddress"] = 4] = "AccountAddress";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["FixedBytes"] = 5] = "FixedBytes";
  return EntryFunctionArgumentVariant2;
})(EntryFunctionArgumentVariant || {});
function serializeEntryFunctionArgument(serializer, argument) {
  if (argument === void 0 || argument === null) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(argument)) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.length);
    for (const subArgument of argument) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || typeof argument === "bigint") {
    serializer.serializeU32AsUleb128(
      2
      /* String */
    );
    serializer.serializeStr(argument.toString());
    return;
  }
  if (argument instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(argument);
    return;
  }
  if (argument instanceof ArrayBuffer) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(new Uint8Array(argument));
    return;
  }
  if ("values" in argument) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.values.length);
    for (const subArgument of argument.values) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if ("data" in argument) {
    serializer.serializeU32AsUleb128(
      4
      /* AccountAddress */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value === void 0) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      5
      /* FixedBytes */
    );
    serializer.serializeBytes(argument.value);
    return;
  }
  serializer.serializeU32AsUleb128(
    2
    /* String */
  );
  serializer.serializeStr(argument.value.toString());
}
function deserializeEntryFunctionArgument(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 0: {
      return void 0;
    }
    case 1: {
      const length = deserializer.deserializeUleb128AsU32();
      const args = [];
      for (let i27 = 0; i27 < length; i27 += 1) {
        const argument = deserializeEntryFunctionArgument(deserializer);
        args.push(argument);
      }
      return args;
    }
    case 3: {
      return deserializer.deserializeBytes();
    }
    case 4: {
      return deserializer.deserialize(l);
    }
    case 2: {
      return deserializer.deserializeStr();
    }
    case 5: {
      const bytes = deserializer.deserializeBytes();
      return new t(bytes);
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeSignature(serializer, value) {
  if (value instanceof h) {
    serializer.serializeU32AsUleb128(E.Ed25519);
  } else if (value instanceof _e) {
    serializer.serializeU32AsUleb128(E.MultiEd25519);
  } else if (value instanceof O) {
    serializer.serializeU32AsUleb128(E.SingleKey);
  } else {
    throw new Error("Unexpected signature type");
  }
  serializer.serialize(value);
}
function deserializeSignature(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case E.Ed25519:
      return deserializer.deserialize(h);
    case E.MultiEd25519:
      return deserializer.deserialize(_e);
    case E.SingleKey:
      return deserializer.deserialize(O);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
var TransactionPayloadInputVariant = ((TransactionPayloadInputVariant2) => {
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["EntryFunction"] = 0] = "EntryFunction";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Script"] = 1] = "Script";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Multisig"] = 2] = "Multisig";
  return TransactionPayloadInputVariant2;
})(TransactionPayloadInputVariant || {});
function serializeTypeArguments(serializer, typeArguments) {
  serializer.serializeU32AsUleb128(typeArguments.length);
  for (const typeArgument of typeArguments) {
    const typeTag = typeof typeArgument === "string" ? Ae(typeArgument, { allowGenerics: true }) : typeArgument;
    serializer.serialize(typeTag);
  }
}
function deserializeTypeArguments(deserializer) {
  const typeArguments = [];
  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();
  for (let i27 = 0; i27 < typeArgumentsLength; i27 += 1) {
    const typeTag = deserializer.deserialize(U);
    typeArguments.push(typeTag);
  }
  return typeArguments;
}
function serializeEntryFunctionArguments(serializer, functionArguments) {
  serializer.serializeU32AsUleb128(functionArguments.length);
  for (const functionArgument of functionArguments) {
    serializeEntryFunctionArgument(serializer, functionArgument);
  }
}
function deserializeEntryFunctionArguments(deserializer) {
  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
  const functionArguments = [];
  for (let i27 = 0; i27 < functionArgumentsLength; i27 += 1) {
    const functionArgument = deserializeEntryFunctionArgument(deserializer);
    functionArguments.push(functionArgument);
  }
  return functionArguments;
}
function serializeTransactionPayloadInput(serializer, value) {
  if ("multisigAddress" in value) {
    serializer.serializeU32AsUleb128(
      2
      /* Multisig */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
    const multisigAddress = l.from(value.multisigAddress);
    serializer.serialize(multisigAddress);
  } else if ("function" in value) {
    serializer.serializeU32AsUleb128(
      0
      /* EntryFunction */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  } else {
    serializer.serializeU32AsUleb128(
      1
      /* Script */
    );
    const bytecode = a.fromHexInput(value.bytecode);
    serializer.serializeBytes(bytecode.toUint8Array());
    serializer.serializeU32AsUleb128(value.functionArguments.length);
    for (const argument of value.functionArguments) {
      argument.serializeForScriptFunction(serializer);
    }
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  }
}
function deserializeTransactionPayloadInput(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 2: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      const multisigAddress = deserializer.deserialize(l);
      return {
        function: functionId,
        functionArguments,
        multisigAddress,
        typeArguments
      };
    }
    case 0: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        function: functionId,
        functionArguments,
        typeArguments
      };
    }
    case 1: {
      const bytecode = deserializer.deserializeBytes();
      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
      const functionArguments = [];
      for (let i27 = 0; i27 < functionArgumentsLength; i27 += 1) {
        const argument = qs(deserializer);
        functionArguments.push(argument);
      }
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        bytecode,
        functionArguments,
        typeArguments
      };
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeWalletRequest({
  dappInfo,
  name,
  version
}) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  const data = serializer.toUint8Array();
  return { data, name, version };
}
function deserializeWalletRequest({
  data,
  name,
  version
}) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  return { dappInfo, name, version };
}
function serializeWalletRequestWithArgs({ args, dappInfo, name, version }, serializeArgsFn) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  serializeArgsFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data, name, version };
}
function deserializeWalletRequestWithArgs({ data, name, version }, deserializeArgsFn) {
  const deserializer = new a2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  const args = deserializeArgsFn(deserializer);
  return { args, dappInfo, name, version };
}
var ConnectRequest;
((ConnectRequest2) => {
  ConnectRequest2.name = "connect";
  ConnectRequest2.supportedVersions = [1, 2, 3, 4];
  ConnectRequest2.currentVersion = 4;
  function serializeArgs(serializer, value) {
    serializer.serializeOptionStr(value.dappId);
    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);
    serializer.serializeOptionStr(value.preferredWalletName);
    serializer.serializeBool(value.claimOptions !== void 0);
    if (value.claimOptions) {
      serializer.serialize(value.claimOptions.secretKey);
      serializer.serializeStr(value.claimOptions.network);
      serializer.serializeOptionStr(value.claimOptions.asset);
      if (!isSupportedNetwork(value.claimOptions.network)) {
        throw new Error(`Unsupported network '${value.claimOptions.network}'`);
      }
    }
  }
  ConnectRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version) {
    if (version === 1) {
      return {};
    }
    const dappId = deserializer.deserializeOption("string");
    const dappEd25519PublicKeyB64 = deserializer.deserializeOption("string");
    const preferredWalletName = version >= 3 ? deserializer.deserializeOption("string") : void 0;
    const hasClaimOptions = version >= 4 ? deserializer.deserializeBool() : false;
    let claimOptions;
    if (hasClaimOptions) {
      const secretKey = deserializer.deserialize(z);
      const network = deserializer.deserializeStr();
      const asset = deserializer.deserializeOption("string");
      if (!isSupportedNetwork(network)) {
        throw new Error(`Unsupported network '${network}'`);
      }
      claimOptions = { asset, network, secretKey };
    }
    return { claimOptions, dappEd25519PublicKeyB64, dappId, preferredWalletName };
  }
  ConnectRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args = {}) {
    return serializeWalletRequestWithArgs({ args, dappInfo, name: ConnectRequest2.name, version: ConnectRequest2.currentVersion }, serializeArgs);
  }
  ConnectRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequestWithArgs(request, (d15) => deserializeArgs(d15, request.version));
  }
  ConnectRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === ConnectRequest2.name && ConnectRequest2.supportedVersions.includes(request.version);
  }
  ConnectRequest2.isSerialized = isSerialized;
})(ConnectRequest || (ConnectRequest = {}));
function makeUserApproval(args) {
  return { args, status: "approved" };
}
function makeUserResponseSerializeFn(serializeArgs) {
  return (serializer, value) => {
    serializer.serializeBool(value.status === "approved");
    if (value.status === "approved") {
      serializeArgs(serializer, value.args);
    }
  };
}
function makeUserResponseDeserializeFn(deserializeArgs) {
  return (deserializer) => {
    const isApproved = deserializer.deserializeBool();
    return isApproved ? { args: deserializeArgs(deserializer), status: "approved" } : { status: "dismissed" };
  };
}
function serializeWalletResponse(args, serializeFn) {
  const serializer = new n();
  serializeFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data };
}
function deserializeWalletResponse({ data }, deserializeFn) {
  const deserializer = new a2(data);
  const args = deserializeFn(deserializer);
  return { args };
}
var ConnectResponse;
((ConnectResponse2) => {
  ConnectResponse2.supportedVersions = [1, 2];
  ConnectResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAccountInfo(serializer, value.account);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAccountInfo(serializer, value.account);
    serializer.serializeOptionStr(value.pairing !== void 0 ? JSON.stringify(value.pairing) : void 0);
  }
  function deserializeApprovalArgs(deserializer) {
    const account = deserializeAccountInfo(deserializer);
    const serializedPairing = deserializer.deserializeOption("string");
    const pairing = serializedPairing !== void 0 ? JSON.parse(serializedPairing) : void 0;
    return { account, pairing };
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args, version = ConnectResponse2.currentVersion) {
    return serializeWalletResponse(args, version === 1 ? serializeArgsV1 : serializeArgs);
  }
  ConnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  ConnectResponse2.deserialize = deserialize;
})(ConnectResponse || (ConnectResponse = {}));
var DisconnectRequest;
((DisconnectRequest2) => {
  DisconnectRequest2.name = "disconnect";
  DisconnectRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: DisconnectRequest2.name, version: DisconnectRequest2.currentVersion });
  }
  DisconnectRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  DisconnectRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === DisconnectRequest2.name && request.version === DisconnectRequest2.currentVersion;
  }
  DisconnectRequest2.isSerialized = isSerialized;
})(DisconnectRequest || (DisconnectRequest = {}));
var DisconnectResponse;
((DisconnectResponse2) => {
  function serialize(args) {
    return serializeWalletResponse(args, () => {
    });
  }
  DisconnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, () => ({}));
  }
  DisconnectResponse2.deserialize = deserialize;
})(DisconnectResponse || (DisconnectResponse = {}));
function serializeAptosSignInInput(serializer, value) {
  serializer.serializeStr(JSON.stringify(value));
}
function deserializeAptosSignInInput(deserializer) {
  return JSON.parse(deserializer.deserializeStr());
}
var SignInRequest;
((SignInRequest2) => {
  SignInRequest2.name = "signIn";
  SignInRequest2.supportedVersions = [1, 2];
  SignInRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}' in SignInRequest.serializeArgs`);
    }
    serializeAptosSignInInput(serializer, value);
    serializer.serializeStr(value.network);
  }
  SignInRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, _8) {
    return { ...deserializeAptosSignInInput(deserializer), network: deserializer.deserializeStr() };
  }
  SignInRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    return serializeWalletRequestWithArgs({ args, dappInfo, name: SignInRequest2.name, version: SignInRequest2.currentVersion }, serializeArgs);
  }
  SignInRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequestWithArgs(request, (d15) => deserializeArgs(d15, request.version));
  }
  SignInRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignInRequest2.name && SignInRequest2.supportedVersions.includes(request.version);
  }
  SignInRequest2.isSerialized = isSerialized;
})(SignInRequest || (SignInRequest = {}));
function serializeAptosSignInOutputV1(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializer.serializeStr(value.plainText);
  serializeSignature(serializer, value.signature);
  serializer.serializeBytes(value.signingMessage);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutputV1(deserializer) {
  return {
    account: new d12(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    plainText: deserializer.deserializeStr(),
    signature: deserializeSignature(deserializer),
    signingMessage: deserializer.deserializeBytes(),
    type: deserializer.deserializeStr()
  };
}
function serializeAptosSignInOutput(serializer, value) {
  serializeAccountInfo(serializer, value.account);
  serializer.serializeStr(JSON.stringify(value.input));
  serializeSignature(serializer, value.signature);
  serializer.serializeStr(value.type);
}
function deserializeAptosSignInOutput(deserializer) {
  return {
    account: new d12(deserializeAccountInfo(deserializer)),
    input: JSON.parse(deserializer.deserializeStr()),
    signature: deserializeSignature(deserializer),
    type: deserializer.deserializeStr()
  };
}
var SignInResponse;
((SignInResponse2) => {
  SignInResponse2.supportedVersions = [1, 2];
  SignInResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAptosSignInOutputV1(serializer, value);
  }
  function deserializeApprovalArgsV1(deserializer) {
    return deserializeAptosSignInOutputV1(deserializer);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAptosSignInOutput(serializer, value);
  }
  function deserializeApprovalArgs(deserializer) {
    return deserializeAptosSignInOutput(deserializer);
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgsV1 = makeUserResponseDeserializeFn(deserializeApprovalArgsV1);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args, version = SignInResponse2.currentVersion) {
    return serializeWalletResponse(args, version === 1 ? serializeArgsV1 : serializeArgs);
  }
  SignInResponse2.serialize = serialize;
  function deserialize(serializedResponse, version = SignInResponse2.currentVersion) {
    return deserializeWalletResponse(serializedResponse, version === 1 ? deserializeArgsV1 : deserializeArgs);
  }
  SignInResponse2.deserialize = deserialize;
})(SignInResponse || (SignInResponse = {}));
var GetConnectedAccountsRequest;
((GetConnectedAccountsRequest2) => {
  GetConnectedAccountsRequest2.name = "getConnectedAccounts";
  GetConnectedAccountsRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: GetConnectedAccountsRequest2.name, version: GetConnectedAccountsRequest2.currentVersion });
  }
  GetConnectedAccountsRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  GetConnectedAccountsRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === GetConnectedAccountsRequest2.name && request.version === GetConnectedAccountsRequest2.currentVersion;
  }
  GetConnectedAccountsRequest2.isSerialized = isSerialized;
})(GetConnectedAccountsRequest || (GetConnectedAccountsRequest = {}));
var GetConnectedAccountsResponse;
((GetConnectedAccountsResponse2) => {
  function serializeArgs(serializer, args) {
    serializer.serializeU32AsUleb128(args.length);
    for (const account of args) {
      serializeAccountInfo(serializer, account);
    }
  }
  function deserializeArgs(deserializer) {
    const length = deserializer.deserializeUleb128AsU32();
    const accounts = [];
    for (let i27 = 0; i27 < length; i27 += 1) {
      accounts.push(deserializeAccountInfo(deserializer));
    }
    return accounts;
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  GetConnectedAccountsResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  GetConnectedAccountsResponse2.deserialize = deserialize;
})(GetConnectedAccountsResponse || (GetConnectedAccountsResponse = {}));
var IsConnectedRequest;
((IsConnectedRequest2) => {
  IsConnectedRequest2.name = "isConnected";
  IsConnectedRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: IsConnectedRequest2.name, version: IsConnectedRequest2.currentVersion });
  }
  IsConnectedRequest2.serialize = serialize;
  function deserialize(request) {
    return deserializeWalletRequest(request);
  }
  IsConnectedRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === IsConnectedRequest2.name && request.version === IsConnectedRequest2.currentVersion;
  }
  IsConnectedRequest2.isSerialized = isSerialized;
})(IsConnectedRequest || (IsConnectedRequest = {}));
var IsConnectedResponse;
((IsConnectedResponse2) => {
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value);
  }
  function deserializeArgs(deserializer) {
    return deserializer.deserializeBool();
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  IsConnectedResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  IsConnectedResponse2.deserialize = deserialize;
})(IsConnectedResponse || (IsConnectedResponse = {}));
var SignAndSubmitTransactionRequest;
((SignAndSubmitTransactionRequest2) => {
  SignAndSubmitTransactionRequest2.name = "signAndSubmitTransaction";
  SignAndSubmitTransactionRequest2.supportedVersions = [1, 2, 3];
  SignAndSubmitTransactionRequest2.currentVersion = 3;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);
    if (value.feePayer) {
      serializeAccountAuthenticatorInput(serializer, value.feePayer);
    }
  }
  SignAndSubmitTransactionRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const isPayloadBcsSerializable = version === 1 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(ot) : deserializeTransactionPayloadInput(deserializer);
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeUleb128AsU32();
    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : void 0;
    return {
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      signerAddress
    };
  }
  SignAndSubmitTransactionRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignAndSubmitTransactionRequest2.name, version: SignAndSubmitTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignAndSubmitTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignAndSubmitTransactionRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignAndSubmitTransactionRequest2.name && SignAndSubmitTransactionRequest2.supportedVersions.includes(request.version);
  }
  SignAndSubmitTransactionRequest2.isSerialized = isSerialized;
})(SignAndSubmitTransactionRequest || (SignAndSubmitTransactionRequest = {}));
var SignAndSubmitTransactionResponse;
((SignAndSubmitTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.txnHash);
  }
  function deserializeApprovalArgs(deserializer) {
    const txnHash = deserializer.deserializeStr();
    return { txnHash };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignAndSubmitTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignAndSubmitTransactionResponse2.deserialize = deserialize;
})(SignAndSubmitTransactionResponse || (SignAndSubmitTransactionResponse = {}));
var SignMessageRequest;
((SignMessageRequest2) => {
  SignMessageRequest2.name = "signMessage";
  SignMessageRequest2.supportedVersions = [1, 2];
  SignMessageRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeU8(value.chainId);
    serializer.serializeBytes(value.nonce);
    serializer.serializeBytes(value.message);
  }
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 2 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const chainId = deserializer.deserializeU8();
    const nonce = deserializer.deserializeBytes();
    const message = deserializer.deserializeBytes();
    return { chainId, message, nonce, signerAddress };
  }
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignMessageRequest2.name, version: SignMessageRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignMessageRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(serializedRequest, (d15) => deserializeArgs(d15, serializedRequest.version));
  }
  SignMessageRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignMessageRequest2.name && request.version === SignMessageRequest2.currentVersion;
  }
  SignMessageRequest2.isSerialized = isSerialized;
})(SignMessageRequest || (SignMessageRequest = {}));
var SignMessageResponse;
((SignMessageResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.fullMessage);
    serializeSignature(serializer, value.signature);
  }
  function deserializeApprovalArgs(deserializer) {
    const fullMessage = deserializer.deserializeStr();
    const signature = deserializeSignature(deserializer);
    return { fullMessage, signature };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignMessageResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignMessageResponse2.deserialize = deserialize;
})(SignMessageResponse || (SignMessageResponse = {}));
var SignTransactionRequest;
((SignTransactionRequest2) => {
  SignTransactionRequest2.name = "signTransaction";
  SignTransactionRequest2.supportedVersions = [1, 2, 3, 4];
  SignTransactionRequest2.currentVersion = 4;
  function normalizeArgs(args) {
    const { feePayer, secondarySigners, senderPublicKey, signerAddress, transaction } = args;
    const sender = {
      address: transaction.sender,
      publicKey: senderPublicKey
    };
    const network = chainIdToNetwork(args.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(transaction.expiration_timestamp_secs),
      feePayer,
      gasUnitPrice: Number(transaction.gas_unit_price),
      maxGasAmount: Number(transaction.max_gas_amount),
      network,
      payload: transaction.payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  SignTransactionRequest2.normalizeArgs = normalizeArgs;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    serializer.serializeBool(value.sender !== void 0);
    if (value.sender !== void 0) {
      serializeAccountInput(serializer, value.sender);
    }
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeBool(value.feePayer !== void 0);
    if (value.feePayer !== void 0) {
      serializeAccountInput(serializer, value.feePayer);
    }
    const secondarySigners = value.secondarySigners ?? [];
    serializer.serializeU32AsUleb128(secondarySigners.length);
    for (const signer of secondarySigners) {
      serializeAccountInput(serializer, signer);
    }
  }
  function deserializeArgs(deserializer, version) {
    const hasSignerAddress = version >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(l) : void 0;
    const network = version === 1 ? deserializer.deserializeStr() : deserializer.deserializeOption("string");
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const hasSender = deserializer.deserializeBool();
    const sender = hasSender ? deserializeAccountInput(deserializer) : void 0;
    const isPayloadBcsSerializable = version < 4 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(ot) : deserializeTransactionPayloadInput(deserializer);
    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeBool();
    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : void 0;
    const secondarySignersLength = deserializer.deserializeUleb128AsU32();
    const secondarySigners = [];
    for (let i27 = 0; i27 < secondarySignersLength; i27 += 1) {
      secondarySigners.push(deserializeAccountInput(deserializer));
    }
    return {
      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : void 0,
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  function serialize(dappInfo, args) {
    const request = { args, dappInfo, name: SignTransactionRequest2.name, version: SignTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request, serializeArgs);
  }
  SignTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignTransactionRequest2.deserialize = deserialize;
  function isSerialized(request) {
    return request.name === SignTransactionRequest2.name && SignTransactionRequest2.supportedVersions.includes(request.version);
  }
  SignTransactionRequest2.isSerialized = isSerialized;
})(SignTransactionRequest || (SignTransactionRequest = {}));
var SignTransactionResponse;
((SignTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serialize(value.authenticator);
    serializer.serializeBool(value.rawTransaction !== void 0);
    if (value.rawTransaction !== void 0) {
      serializer.serialize(value.rawTransaction);
    }
  }
  function deserializeApprovalArgs(deserializer) {
    const authenticator = deserializer.deserialize(V);
    const hasRawTransaction = deserializer.deserializeBool();
    const rawTransaction = hasRawTransaction ? deserializer.deserialize(pe) : void 0;
    return {
      authenticator,
      rawTransaction
    };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignTransactionResponse2.deserialize = deserialize;
})(SignTransactionResponse || (SignTransactionResponse = {}));
function isTypedMessage(messageCls, message) {
  return message?.__messageType === messageCls.TYPE;
}
var _PromptConnectionRequestMessage = class _PromptConnectionRequestMessage2 {
  constructor() {
    this.__messageType = _PromptConnectionRequestMessage2.TYPE;
  }
};
_PromptConnectionRequestMessage.TYPE = "PromptConnectionRequest";
var PromptConnectionRequestMessage = _PromptConnectionRequestMessage;
var _PromptConnectionResponseMessage = class _PromptConnectionResponseMessage2 {
  constructor(serializedRequest) {
    this.serializedRequest = serializedRequest;
    this.__messageType = _PromptConnectionResponseMessage2.TYPE;
  }
};
_PromptConnectionResponseMessage.TYPE = "PromptConnectionResponse";
var PromptConnectionResponseMessage = _PromptConnectionResponseMessage;
var _PromptApprovalResponseMessage = class _PromptApprovalResponseMessage2 {
  constructor(serializedValue) {
    this.serializedValue = serializedValue;
    this.__messageType = _PromptApprovalResponseMessage2.TYPE;
  }
};
_PromptApprovalResponseMessage.TYPE = "PromptApprovalResponse";
var PromptApprovalResponseMessage = _PromptApprovalResponseMessage;
var _PromptUnauthorizedErrorMessage = class _PromptUnauthorizedErrorMessage2 {
  constructor() {
    this.__messageType = _PromptUnauthorizedErrorMessage2.TYPE;
  }
};
_PromptUnauthorizedErrorMessage.TYPE = "PromptUnauthorizedError";
var PromptUnauthorizedErrorMessage = _PromptUnauthorizedErrorMessage;
function encodeWalletRequestBody({ data, ...rest }) {
  const serialized = JSON.stringify({ data, ...rest }, (key, value) => key === "data" ? bytesToBase64(value) : value);
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64(utf8Encoded);
}
function encodePopupWalletRequest(request) {
  const serialized = JSON.stringify(request, (key, value) => {
    switch (key) {
      case "body":
        return encodeWalletRequestBody(value);
      case "clientIdentityKey":
        return bytesToBase64(value.toUint8Array());
      case "signature":
        return bytesToBase64(value.toUint8Array());
      default:
        return value;
    }
  });
  const utf8Encoded = new TextEncoder().encode(serialized);
  return bytesToBase64url(utf8Encoded);
}
function makePopupWalletRequestChallenge({
  accountAddress,
  body,
  id,
  timestamp
}) {
  const serializer = new n();
  serializer.serializeStr("SignedPopupWalletRequest");
  serializer.serializeStr(id);
  serializer.serializeU64(timestamp);
  serializer.serializeBool(accountAddress !== void 0);
  if (accountAddress !== void 0) {
    serializer.serialize(l.from(accountAddress));
  }
  serializer.serializeStr(body.name);
  serializer.serializeU8(body.version);
  serializer.serializeBytes(body.data);
  return serializer.toUint8Array();
}

// node_modules/@identity-connect/crypto/dist/index.mjs
var EncryptionEnvelopeError = class extends Error {
};
var EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "EnvelopeMessageMismatchError";
    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);
  }
};
var DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {
  constructor(message) {
    super(message);
    this.name = "DecryptionError";
    Object.setPrototypeOf(this, _DecryptionError.prototype);
  }
};
var KeyTypes = ((KeyTypes2) => {
  KeyTypes2["Ed25519PublicKey"] = "Ed25519PublicKey";
  KeyTypes2["Ed25519SecretKey"] = "Ed25519SecretKey";
  KeyTypes2["X25519PublicKey"] = "X25519PublicKey";
  KeyTypes2["X25519SecretKey"] = "X25519SecretKey";
  return KeyTypes2;
})(KeyTypes || {});
function createX25519KeyPair() {
  return keypairToX25519(import_tweetnacl2.default.box.keyPair());
}
function createEd25519KeyPair() {
  return keypairToEd25519(import_tweetnacl2.default.sign.keyPair());
}
function toKey(rawKey, type) {
  return {
    key: rawKey,
    type
  };
}
function keypairToEd25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function keypairToX25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function decodeBase64(base64Str) {
  if (globalThis.Buffer) {
    return new Uint8Array(Buffer.from(base64Str, "base64"));
  }
  return Uint8Array.from(atob(base64Str), (m13) => m13.codePointAt(0));
}
function encodeBase64(bytes) {
  if (globalThis.Buffer) {
    return Buffer.from(bytes).toString("base64");
  }
  return btoa(Array.from(bytes, (x5) => String.fromCodePoint(x5)).join(""));
}
function concatUint8array(arrayOne, arrayTwo) {
  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
  mergedArray.set(arrayOne);
  mergedArray.set(arrayTwo, arrayOne.length);
  return mergedArray;
}
var SIGNATURE_PREFIX = "APTOS::IDENTITY_CONNECT";
function convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {
  const x25519PublicKey = import_ed2curve.default.convertPublicKey(ed25519PublicKey.key.slice(0, 32));
  if (!x25519PublicKey)
    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);
  return toKey(
    x25519PublicKey,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {
  const x25519SecretKey = import_ed2curve.default.convertSecretKey(ed25519SecretKey.key.slice(0, 32));
  return toKey(
    x25519SecretKey,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function serializeEncryptionResult(enc) {
  return {
    nonceB64: encodeBase64(enc.nonce),
    securedB64: encodeBase64(enc.secured)
  };
}
function deserializeEncryptionResult(enc) {
  return {
    nonce: decodeBase64(enc.nonceB64),
    secured: decodeBase64(enc.securedB64)
  };
}
function encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  const nonce = import_tweetnacl.default.randomBytes(import_tweetnacl.default.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(message);
  const secured = import_tweetnacl.default.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));
  return { nonce, secured };
}
function encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {
  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(
    receiverEd25519PublicKey,
    "receiver public key"
  );
  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);
}
function encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));
}
function decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  let decryptedUint8;
  try {
    decryptedUint8 = import_tweetnacl.default.box.open(
      securedMessage,
      nonce,
      senderX25519PublicKey.key.slice(0, 32),
      receiverX25519SecretKey.key.slice(0, 32)
    );
  } catch (e20) {
    throw new DecryptionError(`Could not decrypt message: ${e20.message}`);
  }
  if (!decryptedUint8)
    throw new DecryptionError("Could not decrypt message");
  return new TextDecoder().decode(decryptedUint8);
}
function decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {
  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);
  return decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
}
function decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
  return JSON.parse(decryptedStr);
}
function messageHash(message, purpose) {
  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));
  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));
}
function signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {
  return import_tweetnacl.default.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);
}
function verifySignature(message, signature, signingPublicKey, purpose) {
  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });
}
var REQUIRED_FIELDS = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {
  const intersection = Object.keys(privateMessage).filter((x5) => Object.keys(publicMessage).includes(x5));
  if (intersection.length > 0) {
    const field = intersection[0];
    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);
  }
}
function ensureMetadataFields(message) {
  const messageKeys = Object.keys(message).sort();
  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key));
  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key));
  if (extraFields.length > 0 || missingFields.length > 0) {
    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(", ")})` : "";
    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(", ")})` : "";
    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;
    throw new EnvelopeMessageMismatchError(
      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,
      "_metadata"
    );
  }
}
function encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {
  const senderEphemeralX25519KeyPair = createX25519KeyPair();
  const metadata = constructMetadata(
    senderEd25519PublicKey,
    receiverEd25519PublicKey,
    sequence,
    senderEphemeralX25519KeyPair.publicKey
  );
  ensureMetadataFields(metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return dangerouslyEncryptAndSignEnvelopeUnvalidated(
    senderEd25519SecretKey,
    receiverEd25519PublicKey,
    metadata,
    privateMessage,
    publicMessage,
    senderEphemeralX25519KeyPair
  );
}
function constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {
  return {
    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),
    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),
    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),
    sequence,
    timestampMillis: Date.now()
  };
}
function dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {
  const encryptionResult = encryptObject(
    senderEphemeralX25519KeyPair.secretKey,
    receiverEd25519PublicKey,
    privateMessage
  );
  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);
  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);
  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });
  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);
  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);
  return {
    encryptedPrivateMessage,
    messageSignature,
    serializedPublicMessage
  };
}
function combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {
  const publicMessageBytesHash = sha3_256(publicMessageBytes);
  const privateMessageBytesHash = sha3_256(privateMessageBytes);
  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);
  combinedHash.set(publicMessageBytesHash);
  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);
  return sha3_256(combinedHash);
}
function signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, "SECURED_ENVELOPE");
  return a.fromHexInput(signatureBytes).toString();
}
function verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {
  const messageSignature = new h(a.fromHexInput(messageSignatureInput).toUint8Array());
  const senderPublicKey = new f(senderEd25519PublicKey.key);
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, "SECURED_ENVELOPE");
  if (!messageVerified) {
    throw new EnvelopeMessageMismatchError("Could not verify SecuredEnvelope signature", "messageSignature");
  }
}
function decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {
  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;
  const publicMessage = JSON.parse(serializedPublicMessage);
  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);
  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);
  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);
  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);
  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;
  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {
    throw new EnvelopeMessageMismatchError(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  }
  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);
  const senderX25519PublicKey = toKey(
    senderX25519PublicKeyBytes,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);
  const privateMessage = decryptObject(
    senderX25519PublicKey,
    receiverEd25519SecretKey,
    encryptionResult.secured,
    encryptionResult.nonce
  );
  ensureMetadataFields(publicMessage._metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return {
    messageSignature,
    privateMessage,
    publicMessage
  };
}
function serializePublicKeyB64(publicKey) {
  const serializer = new n();
  serializePublicKey(serializer, publicKey);
  return bytesToBase64(serializer.toUint8Array());
}
function deserializePublicKeyB64(publicKeyB64) {
  const serializedPublicKey = base64ToBytes(publicKeyB64);
  const deserializer = new a2(serializedPublicKey);
  return deserializePublicKey(deserializer);
}
function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {
  return new f(decodeBase64(ed25519PublicKeyB64));
}
var AccountConnectionAction = ((AccountConnectionAction2) => {
  AccountConnectionAction2["ADD"] = "add";
  AccountConnectionAction2["REMOVE"] = "remove";
  return AccountConnectionAction2;
})(AccountConnectionAction || {});

// node_modules/@telegram-apps/bridge/dist/index.js
var d14 = class _d extends Error {
  constructor(t18, r18, n94) {
    super(
      typeof r18 == "object" ? r18.message : r18 || t18,
      {
        cause: typeof r18 == "object" ? r18.cause : n94
      }
    ), this.type = t18, this.name = "TypedError", Object.setPrototypeOf(this, _d.prototype);
  }
};
function we2(e20) {
  return e20.replace(/_[a-z]/g, (t18) => t18[1].toUpperCase());
}
var he2 = "ERR_INVALID_VALUE";
var me2 = "ERR_UNEXPECTED_VALUE";
var de2 = "ERR_UNEXPECTED_TYPE";
var K3 = "ERR_PARSE";
function V3(e20, t18) {
  const r18 = {};
  for (const n94 in e20) {
    const o26 = e20[n94];
    if (!o26)
      continue;
    let s11, a24;
    typeof o26 == "function" ? (s11 = n94, a24 = o26) : [s11, a24] = o26;
    try {
      const c7 = a24(t18(s11));
      c7 !== void 0 && (r18[n94] = c7);
    } catch (c7) {
      throw new d14(
        K3,
        `Parser for "${n94}" property failed${s11 === n94 ? "" : `. Source field: "${s11}"`}`,
        c7
      );
    }
  }
  return r18;
}
function Z(e20) {
  let t18 = e20;
  if (typeof t18 == "string")
    try {
      t18 = JSON.parse(t18);
    } catch (r18) {
      throw new d14(he2, { cause: r18 });
    }
  if (typeof t18 != "object" || !t18 || Array.isArray(t18))
    throw new d14(me2);
  return t18;
}
function g4(e20, t18) {
  return (r18) => {
    const n94 = (o26) => {
      if (!(r18 && o26 === void 0))
        try {
          return t18(o26);
        } catch (s11) {
          throw new d14(K3, {
            message: `"${e20}" transformer failed to parse the value`,
            cause: s11
          });
        }
    };
    return Object.assign(
      n94,
      {
        isValid(o26) {
          try {
            return n94(o26), true;
          } catch {
            return false;
          }
        }
      }
    );
  };
}
function l13(e20, t18) {
  return g4(t18 || "object", (r18) => {
    const n94 = Z(r18);
    return V3(e20, (o26) => n94[o26]);
  });
}
function R5(e20) {
  throw new d14(de2, `Unexpected value received: ${JSON.stringify(e20)}`);
}
var $5 = g4("boolean", (e20) => {
  if (typeof e20 == "boolean")
    return e20;
  const t18 = String(e20);
  if (t18 === "1" || t18 === "true")
    return true;
  if (t18 === "0" || t18 === "false")
    return false;
  R5(e20);
});
var _7 = g4("string", (e20) => {
  if (typeof e20 == "string" || typeof e20 == "number")
    return e20.toString();
  R5(e20);
});
var P6 = g4("number", (e20) => {
  if (typeof e20 == "number")
    return e20;
  if (typeof e20 == "string") {
    const t18 = Number(e20);
    if (!Number.isNaN(t18))
      return t18;
  }
  R5(e20);
});
var Ee = g4("date", (e20) => e20 instanceof Date ? e20 : new Date(P6()(e20) * 1e3));
function ve(e20) {
  return /^#[\da-f]{6}$/i.test(e20);
}
function Pe2(e20) {
  return /^#[\da-f]{3}$/i.test(e20);
}
function Re(e20) {
  const t18 = e20.replace(/\s/g, "").toLowerCase();
  if (ve(t18))
    return t18;
  if (Pe2(t18)) {
    let n94 = "#";
    for (let o26 = 0; o26 < 3; o26 += 1)
      n94 += t18[1 + o26].repeat(2);
    return n94;
  }
  const r18 = t18.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t18.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
  if (!r18)
    throw new Error(`Value "${e20}" does not satisfy any of known RGB formats.`);
  return r18.slice(1).reduce((n94, o26) => {
    const s11 = parseInt(o26, 10).toString(16);
    return n94 + (s11.length === 1 ? "0" : "") + s11;
  }, "#");
}
var Te2 = g4("rgb", (e20) => Re(_7()(e20)));
var I5 = g4(
  "themeParams",
  (e20) => {
    const t18 = Te2(true);
    return Object.entries(Z(e20)).reduce((r18, [n94, o26]) => (r18[we2(n94)] = t18(o26), r18), {});
  }
);
var X2 = l13({
  eventType: _7(),
  eventData: (e20) => e20
}, "miniAppsMessage");
var Y = g4("fn", (e20) => {
  if (typeof e20 == "function")
    return e20;
  R5(e20);
});
var Ce = l13({
  TelegramWebviewProxy: l13({ postEvent: Y() })()
});
function Q3(e20) {
  return Ce().isValid(e20);
}
function Ne2() {
  try {
    return window.self !== window.top;
  } catch {
    return true;
  }
}
var b7 = class _b extends Error {
  constructor(t18, r18, n94) {
    super(
      typeof r18 == "object" ? r18.message : r18 || t18,
      {
        cause: typeof r18 == "object" ? r18.cause : n94
      }
    ), this.type = t18, this.name = "TypedError", Object.setPrototypeOf(this, _b.prototype);
  }
};
function Ue(e20, t18) {
  return e20 instanceof b7 && e20.type === t18;
}
function L4(e20) {
  return (t18) => Ue(t18, e20);
}
var re2 = "ERR_ABORTED";
var ne2 = "ERR_CANCELED";
var oe3 = "ERR_TIMED_OUT";
var nt2 = L4(oe3);
var ot3 = L4(re2);
var st2 = L4(ne2);
function ke2(e20, t18) {
  t18 || (t18 = {});
  const {
    textColor: r18,
    bgColor: n94,
    shouldLog: o26 = true
  } = t18;
  function s11(a24, ...c7) {
    if (!o26 || typeof o26 == "function" && !o26())
      return;
    const i27 = "font-weight:bold;padding:0 5px;border-radius:5px";
    console[a24](
      `%c${Intl.DateTimeFormat("en-GB", {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        fractionalSecondDigits: 3,
        timeZone: "UTC"
      }).format(/* @__PURE__ */ new Date())}%c / %c${e20}`,
      `${i27};background-color: lightblue;color:black`,
      "",
      `${i27};${r18 ? `color:${r18};` : ""}${n94 ? `background-color:${n94}` : ""}`,
      ...c7
    );
  }
  return [
    function(...a24) {
      s11("log", ...a24);
    },
    function(...a24) {
      s11("error", ...a24);
    }
  ];
}
function Le2(e20, t18) {
  t18();
}
function y9(e20, t18) {
  t18 || (t18 = {});
  const r18 = t18.equals || Object.is;
  let n94 = [], o26 = e20;
  const s11 = (u9) => {
    if (!r18(o26, u9)) {
      const f13 = o26;
      o26 = u9, Le2(i27, () => {
        [...n94].forEach(([h10, m13]) => {
          h10(u9, f13), m13 && c7(h10, true);
        });
      });
    }
  };
  function a24(u9) {
    const f13 = typeof u9 != "object" ? { once: u9 } : u9;
    return {
      once: f13.once || false,
      signal: f13.signal || false
    };
  }
  const c7 = (u9, f13) => {
    const h10 = a24(f13), m13 = n94.findIndex(([T14, A15]) => T14 === u9 && A15.once === h10.once && A15.signal === h10.signal);
    m13 >= 0 && n94.splice(m13, 1);
  }, i27 = Object.assign(
    function() {
      return Oe2(i27), o26;
    },
    {
      destroy() {
        n94 = [];
      },
      set: s11,
      reset() {
        s11(e20);
      },
      sub(u9, f13) {
        return n94.push([u9, a24(f13)]), () => c7(u9, f13);
      },
      unsub: c7,
      unsubAll() {
        n94 = n94.filter((u9) => u9[1].signal);
      }
    }
  );
  return i27;
}
var U9 = [];
function Oe2(e20) {
  U9.length && U9[U9.length - 1].add(e20);
}
var ae3 = y9(false);
var [O8, qe2] = ke2("Bridge", {
  bgColor: "#9147ff",
  textColor: "white",
  shouldLog: ae3
});
var Ie = {
  clipboard_text_received: l13({
    req_id: _7(),
    data: (e20) => e20 === null ? e20 : _7(true)(e20)
  }, "clipboard_text_received"),
  custom_method_invoked: l13({
    req_id: _7(),
    result: (e20) => e20,
    error: _7(true)
  }, "custom_method_invoked"),
  popup_closed: g4("popup_closed", (e20) => e20 ? l13({
    button_id: (t18) => t18 == null ? void 0 : _7()(t18)
  })()(e20) : {}),
  viewport_changed: l13({
    height: P6(),
    width: (e20) => e20 == null ? window.innerWidth : P6()(e20),
    is_state_stable: $5(),
    is_expanded: $5()
  }, "viewport_changed")
};
var C7 = y9();
var N4 = y9();
var v6 = y9({});
var Ge2 = "ERR_UNKNOWN_ENV";
var ue2 = y9("https://web.telegram.org");
function pe3(e20, t18) {
  O8("Posting event:", t18 ? { eventType: e20, eventData: t18 } : { eventType: e20 });
  const r18 = window;
  if (Q3(r18)) {
    r18.TelegramWebviewProxy.postEvent(e20, JSON.stringify(t18));
    return;
  }
  const n94 = JSON.stringify({ eventType: e20, eventData: t18 });
  if (Ne2())
    return r18.parent.postMessage(n94, ue2());
  const { external: o26 } = r18;
  if (l13({ notify: Y() })().isValid(o26)) {
    o26.notify(n94);
    return;
  }
  throw new b7(Ge2);
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i27 = 0; i27 < 256; ++i27) {
  byteToHex.push((i27 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v7;
  const arr = new Uint8Array(16);
  arr[0] = (v7 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v7 >>> 16 & 255;
  arr[2] = v7 >>> 8 & 255;
  arr[3] = v7 & 255;
  arr[4] = (v7 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v7 & 255;
  arr[6] = (v7 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v7 & 255;
  arr[8] = (v7 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v7 & 255;
  arr[10] = (v7 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v7 / 4294967296 & 255;
  arr[12] = v7 >>> 24 & 255;
  arr[13] = v7 >>> 16 & 255;
  arr[14] = v7 >>> 8 & 255;
  arr[15] = v7 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i27 = 0; i27 < str.length; ++i27) {
    bytes.push(str.charCodeAt(i27));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i27 = 0; i27 < 16; ++i27) {
        buf[offset + i27] = bytes[i27];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i27 = 0; i27 < msg.length; ++i27) {
      bytes[i27] = msg.charCodeAt(i27);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i27 = 0; i27 < length32; i27 += 8) {
    const x5 = input[i27 >> 5] >>> i27 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x5 >>> 4 & 15) + hexTab.charAt(x5 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x5, len) {
  x5[len >> 5] |= 128 << len % 32;
  x5[getOutputLength(len) - 1] = len;
  let a24 = 1732584193;
  let b8 = -271733879;
  let c7 = -1732584194;
  let d15 = 271733878;
  for (let i27 = 0; i27 < x5.length; i27 += 16) {
    const olda = a24;
    const oldb = b8;
    const oldc = c7;
    const oldd = d15;
    a24 = md5ff(a24, b8, c7, d15, x5[i27], 7, -680876936);
    d15 = md5ff(d15, a24, b8, c7, x5[i27 + 1], 12, -389564586);
    c7 = md5ff(c7, d15, a24, b8, x5[i27 + 2], 17, 606105819);
    b8 = md5ff(b8, c7, d15, a24, x5[i27 + 3], 22, -1044525330);
    a24 = md5ff(a24, b8, c7, d15, x5[i27 + 4], 7, -176418897);
    d15 = md5ff(d15, a24, b8, c7, x5[i27 + 5], 12, 1200080426);
    c7 = md5ff(c7, d15, a24, b8, x5[i27 + 6], 17, -1473231341);
    b8 = md5ff(b8, c7, d15, a24, x5[i27 + 7], 22, -45705983);
    a24 = md5ff(a24, b8, c7, d15, x5[i27 + 8], 7, 1770035416);
    d15 = md5ff(d15, a24, b8, c7, x5[i27 + 9], 12, -1958414417);
    c7 = md5ff(c7, d15, a24, b8, x5[i27 + 10], 17, -42063);
    b8 = md5ff(b8, c7, d15, a24, x5[i27 + 11], 22, -1990404162);
    a24 = md5ff(a24, b8, c7, d15, x5[i27 + 12], 7, 1804603682);
    d15 = md5ff(d15, a24, b8, c7, x5[i27 + 13], 12, -40341101);
    c7 = md5ff(c7, d15, a24, b8, x5[i27 + 14], 17, -1502002290);
    b8 = md5ff(b8, c7, d15, a24, x5[i27 + 15], 22, 1236535329);
    a24 = md5gg(a24, b8, c7, d15, x5[i27 + 1], 5, -165796510);
    d15 = md5gg(d15, a24, b8, c7, x5[i27 + 6], 9, -1069501632);
    c7 = md5gg(c7, d15, a24, b8, x5[i27 + 11], 14, 643717713);
    b8 = md5gg(b8, c7, d15, a24, x5[i27], 20, -373897302);
    a24 = md5gg(a24, b8, c7, d15, x5[i27 + 5], 5, -701558691);
    d15 = md5gg(d15, a24, b8, c7, x5[i27 + 10], 9, 38016083);
    c7 = md5gg(c7, d15, a24, b8, x5[i27 + 15], 14, -660478335);
    b8 = md5gg(b8, c7, d15, a24, x5[i27 + 4], 20, -405537848);
    a24 = md5gg(a24, b8, c7, d15, x5[i27 + 9], 5, 568446438);
    d15 = md5gg(d15, a24, b8, c7, x5[i27 + 14], 9, -1019803690);
    c7 = md5gg(c7, d15, a24, b8, x5[i27 + 3], 14, -187363961);
    b8 = md5gg(b8, c7, d15, a24, x5[i27 + 8], 20, 1163531501);
    a24 = md5gg(a24, b8, c7, d15, x5[i27 + 13], 5, -1444681467);
    d15 = md5gg(d15, a24, b8, c7, x5[i27 + 2], 9, -51403784);
    c7 = md5gg(c7, d15, a24, b8, x5[i27 + 7], 14, 1735328473);
    b8 = md5gg(b8, c7, d15, a24, x5[i27 + 12], 20, -1926607734);
    a24 = md5hh(a24, b8, c7, d15, x5[i27 + 5], 4, -378558);
    d15 = md5hh(d15, a24, b8, c7, x5[i27 + 8], 11, -2022574463);
    c7 = md5hh(c7, d15, a24, b8, x5[i27 + 11], 16, 1839030562);
    b8 = md5hh(b8, c7, d15, a24, x5[i27 + 14], 23, -35309556);
    a24 = md5hh(a24, b8, c7, d15, x5[i27 + 1], 4, -1530992060);
    d15 = md5hh(d15, a24, b8, c7, x5[i27 + 4], 11, 1272893353);
    c7 = md5hh(c7, d15, a24, b8, x5[i27 + 7], 16, -155497632);
    b8 = md5hh(b8, c7, d15, a24, x5[i27 + 10], 23, -1094730640);
    a24 = md5hh(a24, b8, c7, d15, x5[i27 + 13], 4, 681279174);
    d15 = md5hh(d15, a24, b8, c7, x5[i27], 11, -358537222);
    c7 = md5hh(c7, d15, a24, b8, x5[i27 + 3], 16, -722521979);
    b8 = md5hh(b8, c7, d15, a24, x5[i27 + 6], 23, 76029189);
    a24 = md5hh(a24, b8, c7, d15, x5[i27 + 9], 4, -640364487);
    d15 = md5hh(d15, a24, b8, c7, x5[i27 + 12], 11, -421815835);
    c7 = md5hh(c7, d15, a24, b8, x5[i27 + 15], 16, 530742520);
    b8 = md5hh(b8, c7, d15, a24, x5[i27 + 2], 23, -995338651);
    a24 = md5ii(a24, b8, c7, d15, x5[i27], 6, -198630844);
    d15 = md5ii(d15, a24, b8, c7, x5[i27 + 7], 10, 1126891415);
    c7 = md5ii(c7, d15, a24, b8, x5[i27 + 14], 15, -1416354905);
    b8 = md5ii(b8, c7, d15, a24, x5[i27 + 5], 21, -57434055);
    a24 = md5ii(a24, b8, c7, d15, x5[i27 + 12], 6, 1700485571);
    d15 = md5ii(d15, a24, b8, c7, x5[i27 + 3], 10, -1894986606);
    c7 = md5ii(c7, d15, a24, b8, x5[i27 + 10], 15, -1051523);
    b8 = md5ii(b8, c7, d15, a24, x5[i27 + 1], 21, -2054922799);
    a24 = md5ii(a24, b8, c7, d15, x5[i27 + 8], 6, 1873313359);
    d15 = md5ii(d15, a24, b8, c7, x5[i27 + 15], 10, -30611744);
    c7 = md5ii(c7, d15, a24, b8, x5[i27 + 6], 15, -1560198380);
    b8 = md5ii(b8, c7, d15, a24, x5[i27 + 13], 21, 1309151649);
    a24 = md5ii(a24, b8, c7, d15, x5[i27 + 4], 6, -145523070);
    d15 = md5ii(d15, a24, b8, c7, x5[i27 + 11], 10, -1120210379);
    c7 = md5ii(c7, d15, a24, b8, x5[i27 + 2], 15, 718787259);
    b8 = md5ii(b8, c7, d15, a24, x5[i27 + 9], 21, -343485551);
    a24 = safeAdd(a24, olda);
    b8 = safeAdd(b8, oldb);
    c7 = safeAdd(c7, oldc);
    d15 = safeAdd(d15, oldd);
  }
  return [a24, b8, c7, d15];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i27 = 0; i27 < length8; i27 += 8) {
    output[i27 >> 5] |= (input[i27 / 8] & 255) << i27 % 32;
  }
  return output;
}
function safeAdd(x5, y10) {
  const lsw = (x5 & 65535) + (y10 & 65535);
  const msw = (x5 >> 16) + (y10 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q7, a24, b8, x5, s11, t18) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a24, q7), safeAdd(x5, t18)), s11), b8);
}
function md5ff(a24, b8, c7, d15, x5, s11, t18) {
  return md5cmn(b8 & c7 | ~b8 & d15, a24, b8, x5, s11, t18);
}
function md5gg(a24, b8, c7, d15, x5, s11, t18) {
  return md5cmn(b8 & d15 | c7 & ~d15, a24, b8, x5, s11, t18);
}
function md5hh(a24, b8, c7, d15, x5, s11, t18) {
  return md5cmn(b8 ^ c7 ^ d15, a24, b8, x5, s11, t18);
}
function md5ii(a24, b8, c7, d15, x5, s11, t18) {
  return md5cmn(c7 ^ (b8 | ~d15), a24, b8, x5, s11, t18);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v32 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i27 = 0; i27 < 16; ++i27) {
      buf[offset + i27] = rnds[i27];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v42;

// node_modules/uuid/dist/esm-browser/sha1.js
function f12(s11, x5, y10, z6) {
  switch (s11) {
    case 0:
      return x5 & y10 ^ ~x5 & z6;
    case 1:
      return x5 ^ y10 ^ z6;
    case 2:
      return x5 & y10 ^ x5 & z6 ^ y10 & z6;
    case 3:
      return x5 ^ y10 ^ z6;
  }
}
function ROTL(x5, n94) {
  return x5 << n94 | x5 >>> 32 - n94;
}
function sha1(bytes) {
  const K4 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i27 = 0; i27 < msg.length; ++i27) {
      bytes.push(msg.charCodeAt(i27));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l14 = bytes.length / 4 + 2;
  const N5 = Math.ceil(l14 / 16);
  const M4 = new Array(N5);
  for (let i27 = 0; i27 < N5; ++i27) {
    const arr = new Uint32Array(16);
    for (let j5 = 0; j5 < 16; ++j5) {
      arr[j5] = bytes[i27 * 64 + j5 * 4] << 24 | bytes[i27 * 64 + j5 * 4 + 1] << 16 | bytes[i27 * 64 + j5 * 4 + 2] << 8 | bytes[i27 * 64 + j5 * 4 + 3];
    }
    M4[i27] = arr;
  }
  M4[N5 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M4[N5 - 1][14] = Math.floor(M4[N5 - 1][14]);
  M4[N5 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i27 = 0; i27 < N5; ++i27) {
    const W6 = new Uint32Array(80);
    for (let t18 = 0; t18 < 16; ++t18) {
      W6[t18] = M4[i27][t18];
    }
    for (let t18 = 16; t18 < 80; ++t18) {
      W6[t18] = ROTL(W6[t18 - 3] ^ W6[t18 - 8] ^ W6[t18 - 14] ^ W6[t18 - 16], 1);
    }
    let a24 = H4[0];
    let b8 = H4[1];
    let c7 = H4[2];
    let d15 = H4[3];
    let e20 = H4[4];
    for (let t18 = 0; t18 < 80; ++t18) {
      const s11 = Math.floor(t18 / 20);
      const T14 = ROTL(a24, 5) + f12(s11, b8, c7, d15) + e20 + K4[s11] + W6[t18] >>> 0;
      e20 = d15;
      d15 = c7;
      c7 = ROTL(b8, 30) >>> 0;
      b8 = a24;
      a24 = T14;
    }
    H4[0] = H4[0] + a24 >>> 0;
    H4[1] = H4[1] + b8 >>> 0;
    H4[2] = H4[2] + c7 >>> 0;
    H4[3] = H4[3] + d15 >>> 0;
    H4[4] = H4[4] + e20 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v52 = v35("v5", 80, sha1_default);

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/web-transport/dist/index.mjs
var DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };
var PROMPT_POLLER_INTERVAL = 500;
var dismissalSerializedResponse = ConnectResponse.serialize({ status: "dismissed" });
var PromptUnauthorizedError = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function openPrompt(url, size = DEFAULT_PROMPT_SIZE) {
  const { height, width } = size;
  const options = {
    height,
    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),
    popup: true,
    top: window.screenTop + Math.round((window.outerHeight - height) / 2),
    width
  };
  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);
  const href = url instanceof URL ? url.href : url;
  const promptWindow = window.open(href, void 0, strOptions);
  if (promptWindow === null) {
    throw new Error("Couldn't open prompt");
  }
  return promptWindow;
}
async function waitForPromptResponse(baseUrl, promptWindow, request) {
  return new Promise((resolve, reject) => {
    const listeners = {
      onMessage: (message) => {
        if (message.source !== promptWindow || message.origin !== baseUrl) {
          return;
        }
        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          reject(new PromptUnauthorizedError());
          return;
        }
        if (isTypedMessage(PromptConnectionRequestMessage, message.data)) {
          promptWindow.postMessage(new PromptConnectionResponseMessage(request), baseUrl);
          return;
        }
        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(message.data.serializedValue);
        }
      },
      promptPollerId: setInterval(() => {
        if (promptWindow.closed) {
          window.removeEventListener("message", listeners.onMessage);
          clearTimeout(listeners.promptPollerId);
          resolve(dismissalSerializedResponse);
        }
      }, PROMPT_POLLER_INTERVAL)
    };
    window.addEventListener("message", listeners.onMessage);
  });
}
var localDappStateKey = "@aptos-connect/dapp-local-state";
function serializeLocalDappState(state) {
  const serializer = new n();
  serializer.serializeU32AsUleb128(state.connectedAccounts.length);
  for (const account of state.connectedAccounts) {
    serializeAccountInfo(serializer, account);
  }
  return serializer.toUint8Array();
}
function deserializeLocalDappState(serializedValue) {
  const deserializer = new a2(serializedValue);
  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();
  const connectedAccounts = [];
  for (let i27 = 0; i27 < connectedAccountsLength; i27 += 1) {
    connectedAccounts.push(deserializeAccountInfo(deserializer));
  }
  return { connectedAccounts };
}
function getState() {
  const encodedValue = window.localStorage.getItem(localDappStateKey);
  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };
}
function setState(state) {
  const serializedValue = serializeLocalDappState(state);
  const encodedValue = bytesToBase64(serializedValue);
  window.localStorage.setItem(localDappStateKey, encodedValue);
}
function getConnectedAccounts() {
  const state = getState();
  return state.connectedAccounts;
}
function addConnectedAccount(account) {
  const { connectedAccounts, ...state } = getState();
  connectedAccounts.push(account);
  setState({ ...state, connectedAccounts });
}
function removeConnectedAccount(address) {
  const { connectedAccounts, ...state } = getState();
  const index = connectedAccounts.findIndex((a24) => a24.address.equals(address));
  if (index >= 0) {
    connectedAccounts.splice(index, 1);
  }
  setState({ ...state, connectedAccounts });
}
async function createWalletRequest(baseUrl, request) {
  const encodedClientIdentityKey = bytesToBase64url(request.clientIdentityKey.toUint8Array());
  const response = await fetch(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/`, {
    body: JSON.stringify({
      body: encodeWalletRequestBody(request.body),
      id: request.id,
      signature: bytesToBase64(request.signature.toUint8Array()),
      timestamp: request.timestamp
    }),
    headers: { Accept: "application/json", "Content-Type": "application/json" },
    method: "post"
  });
  if (!response.ok) {
    throw new Error("Failed creating the wallet request");
  }
}
var identityKeyStorageKey = "@aptos-connect/client-identity-key";
function getClientIdentityKey() {
  const serialized = window.localStorage.getItem(identityKeyStorageKey);
  if (serialized) {
    return new z(serialized);
  }
  const identityKey = z.generate();
  window.localStorage.setItem(identityKeyStorageKey, identityKey.toString());
  return identityKey;
}
var ON_RESUME_DELAY = 300;
var FG_RESPONSE_POLLING_INTERVAL = 2e3;
var BG_RESPONSE_POLLING_INTERVAL = 3e3;
var POLLING_TIMEOUT = 5 * 6e4;
function waitFor(milliseconds) {
  let timeoutId;
  let cancel = () => {
  };
  const timer = new Promise((resolve) => {
    timeoutId = setTimeout(resolve, milliseconds);
    cancel = () => {
      clearTimeout(timeoutId);
      resolve();
    };
  });
  timer.cancel = cancel;
  return timer;
}
async function smartPolling(callback) {
  let timer;
  let justResumed = false;
  let pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  const onWindowFocus = () => {
    justResumed = true;
    pollingInterval = FG_RESPONSE_POLLING_INTERVAL;
    timer?.cancel();
  };
  const onWindowBlur = () => {
    pollingInterval = BG_RESPONSE_POLLING_INTERVAL;
  };
  window.addEventListener("focus", onWindowFocus);
  window.addEventListener("blur", onWindowBlur);
  try {
    const startTime = Date.now();
    while (Date.now() - startTime < POLLING_TIMEOUT) {
      timer = waitFor(pollingInterval);
      await timer;
      if (justResumed) {
        timer = waitFor(ON_RESUME_DELAY);
        await timer;
      }
      const response = await callback();
      if (response.status === 200) {
        return response;
      }
      justResumed = false;
    }
    throw new Error("Timeout");
  } finally {
    window.removeEventListener("focus", onWindowFocus);
    window.removeEventListener("blur", onWindowFocus);
  }
}
async function getWalletResponse(baseUrl, clientIdentityKey, requestId) {
  const encodedClientIdentityKey = bytesToBase64url(clientIdentityKey.toUint8Array());
  const url = new URL(`${baseUrl}/v1/dapp/clients/${encodedClientIdentityKey}/requests/${requestId}/response/`);
  const response = await smartPolling(
    () => fetch(url, {
      headers: { Accept: "application/json" },
      method: "get"
    })
  );
  const responseBody = await response.json();
  const data = base64ToBytes(responseBody.data.body);
  return { data };
}
async function openTelegramPrompt(args) {
  const { baseUrl, provider, request: body, tgWebAppUrl = "/AptosConnectBot/AptosConnect" } = args;
  const identityKey = getClientIdentityKey();
  const clientIdentityKey = identityKey.publicKey();
  const requestId = v4_default();
  const timestamp = Date.now();
  const challenge = makePopupWalletRequestChallenge({ body, id: requestId, timestamp });
  const signature = identityKey.sign(challenge);
  const signedWalletRequest = {
    body,
    clientIdentityKey,
    id: requestId,
    signature,
    timestamp
  };
  let encodedRequest = encodePopupWalletRequest(signedWalletRequest);
  if (encodedRequest.length > 1024) {
    void createWalletRequest(baseUrl, signedWalletRequest);
    encodedRequest = encodePopupWalletRequest({
      clientIdentityKey,
      id: requestId,
      signature,
      timestamp
    });
  }
  const startParam = `prompt_${provider ?? ""}${encodedRequest}`;
  pe3("web_app_open_tg_link", {
    path_full: `${tgWebAppUrl}?startapp=${startParam}`
  });
  return getWalletResponse(baseUrl, clientIdentityKey, requestId);
}
function isTelegramMiniApp() {
  return window.TelegramWebviewProxy !== void 0;
}
var WebWalletTransport = class {
  constructor(baseUrl, provider = "google", tgWebAppUrl) {
    this.baseUrl = baseUrl;
    this.provider = provider;
    this.tgWebAppUrl = tgWebAppUrl;
    this.baseUrl = baseUrl;
  }
  async sendPromptRequest(request) {
    if (isTelegramMiniApp()) {
      return openTelegramPrompt({
        baseUrl: this.baseUrl,
        provider: this.provider,
        request,
        tgWebAppUrl: this.tgWebAppUrl
      });
    }
    const url = new URL(`${this.baseUrl}/prompt/`);
    url.searchParams.set("provider", this.provider);
    const prompt = openPrompt(url);
    return waitForPromptResponse(this.baseUrl, prompt, request);
  }
  async sendRequest(request) {
    switch (request.name) {
      case IsConnectedRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return IsConnectedResponse.serialize(connectedAccounts.length > 0);
      }
      case GetConnectedAccountsRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return GetConnectedAccountsResponse.serialize(connectedAccounts);
      }
      case ConnectRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request);
        const response = ConnectResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account, pairing } = response.args.args;
          if (pairing === void 0) {
            addConnectedAccount(account);
          }
        }
        return serializedResponse;
      }
      case SignInRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request);
        const response = SignInResponse.deserialize(serializedResponse, request.version);
        if (response.args.status === "approved") {
          const { account } = response.args.args;
          addConnectedAccount(account);
        }
        return serializedResponse;
      }
      case DisconnectRequest.name: {
        const [activeAccount] = getConnectedAccounts();
        if (activeAccount) {
          removeConnectedAccount(activeAccount.address);
        }
        return DisconnectResponse.serialize({});
      }
      case SignMessageRequest.name:
      case SignTransactionRequest.name:
      case SignAndSubmitTransactionRequest.name: {
        return this.sendPromptRequest(request);
      }
      default: {
        throw new Error("Unexpected request");
      }
    }
  }
};

// node_modules/@identity-connect/api/dist/index.mjs
var NetworkName = ((NetworkName22) => {
  NetworkName22["DEVNET"] = "devnet";
  NetworkName22["MAINNET"] = "mainnet";
  NetworkName22["TESTNET"] = "testnet";
  return NetworkName22;
})(NetworkName || {});
var PairingStatus = ((PairingStatus2) => {
  PairingStatus2["Finalized"] = "FINALIZED";
  PairingStatus2["Pending"] = "PENDING";
  return PairingStatus2;
})(PairingStatus || {});
var SigningRequestTypes = ((SigningRequestTypes2) => {
  SigningRequestTypes2["SIGN_AND_SUBMIT_TRANSACTION"] = "SIGN_AND_SUBMIT_TRANSACTION";
  SigningRequestTypes2["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  SigningRequestTypes2["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  return SigningRequestTypes2;
})(SigningRequestTypes || {});
var SigningRequestStatus = ((SigningRequestStatus2) => {
  SigningRequestStatus2["APPROVED"] = "APPROVED";
  SigningRequestStatus2["CANCELLED"] = "CANCELLED";
  SigningRequestStatus2["INVALID"] = "INVALID";
  SigningRequestStatus2["PENDING"] = "PENDING";
  SigningRequestStatus2["REJECTED"] = "REJECTED";
  return SigningRequestStatus2;
})(SigningRequestStatus || {});
var WalletOSEnum = ((WalletOSEnum2) => {
  WalletOSEnum2["Android"] = "android";
  WalletOSEnum2["IdentityConnect"] = "ic";
  WalletOSEnum2["Linux"] = "linux";
  WalletOSEnum2["Macos"] = "osx";
  WalletOSEnum2["Windows"] = "win";
  WalletOSEnum2["iOS"] = "ios";
  return WalletOSEnum2;
})(WalletOSEnum || {});
var WalletPlatformEnum = ((WalletPlatformEnum2) => {
  WalletPlatformEnum2["BraveExtension"] = "brave-extension";
  WalletPlatformEnum2["ChromeExtension"] = "chrome-extension";
  WalletPlatformEnum2["FirefoxExtension"] = "firefox-extension";
  WalletPlatformEnum2["IcDappWallet"] = "ic-dapp-wallet";
  WalletPlatformEnum2["KiwiExtension"] = "kiwi-extension";
  WalletPlatformEnum2["NativeApp"] = "native-app";
  WalletPlatformEnum2["OperaExtension"] = "opera-extension";
  WalletPlatformEnum2["SafariExtension"] = "safari-extension";
  return WalletPlatformEnum2;
})(WalletPlatformEnum || {});

// node_modules/@identity-connect/wallet-api/dist/index.mjs
function isBcsSerializableV1(value) {
  return value?.serialize !== void 0;
}
function isBcsSerializableV2(value) {
  return value?.serialize !== void 0 && value?.bcsToBytes !== void 0 && value?.bcsToHex !== void 0;
}
function isBcsSerializable(value) {
  return isBcsSerializableV1(value) || isBcsSerializableV2(value);
}
function bcsSerialize(serializable) {
  if (isBcsSerializableV2(serializable)) {
    return serializable.bcsToHex().toString();
  }
  const serializedValueBytes = bcs_exports.bcsToBytes(serializable);
  return a.fromHexInput(serializedValueBytes).toString();
}
function bcsDeserialize(deserializableClass, serializedValue) {
  const serializedValueBytes = a.fromHexString(serializedValue).toUint8Array();
  const deserializer = new a2(serializedValueBytes);
  return deserializableClass.deserialize(deserializer);
}
var UnexpectedValueError = class _UnexpectedValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnexpectedValueError";
    Object.setPrototypeOf(this, _UnexpectedValueError.prototype);
  }
};
function serializeEntryFunctionArg(arg) {
  if (arg instanceof Uint8Array) {
    return {
      type: "Uint8Array",
      value: a.fromHexInput(arg).toString()
    };
  }
  if (Array.isArray(arg)) {
    return arg.map(serializeEntryFunctionArg);
  }
  return arg;
}
function serializeEntryFunctionPayload(payload) {
  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);
  return {
    ...payload,
    arguments: normalizedArgs,
    type: "entry_function_payload"
  };
}
function serializeJsonTransactionPayload(payload) {
  if (payload.type === "entry_function_payload" || payload.type === void 0) {
    return serializeEntryFunctionPayload(payload);
  }
  if (payload.type === "multisig_payload") {
    const innerPayload = payload.transaction_payload !== void 0 ? serializeEntryFunctionPayload(payload.transaction_payload) : void 0;
    return { ...payload, transaction_payload: innerPayload };
  }
  throw new UnexpectedValueError();
}
function serializeRawTransaction(rawTxn) {
  const value = bcsSerialize(rawTxn);
  if ("fee_payer_address" in rawTxn) {
    return { type: "fee_payer_raw_txn", value };
  }
  if ("secondary_signer_addresses" in rawTxn) {
    return { type: "multi_agent_raw_txn", value };
  }
  if ("chain_id" in rawTxn) {
    return { type: "raw_txn", value };
  }
  throw new UnexpectedValueError("Invalid raw transaction type");
}
function serializeSignAndSubmitTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("feePayerAuthenticator" in args) {
    return {
      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),
      rawTxn: serializeRawTransaction(args.rawTxn)
    };
  }
  if ("rawTxn" in args) {
    return { rawTxn: serializeRawTransaction(args.rawTxn) };
  }
  throw new UnexpectedValueError();
}
function serializeSignTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("rawTxn" in args) {
    const serializedRawTxn = serializeRawTransaction(args.rawTxn);
    return { rawTxn: serializedRawTxn };
  }
  throw new UnexpectedValueError();
}
function deserializeSignTransactionResponseArgs(args) {
  const accountAuthenticator = bcsDeserialize(V, args.accountAuthenticator);
  if ("rawTxn" in args) {
    const rawTxn = bcsDeserialize(pe, args.rawTxn);
    return { accountAuthenticator, rawTxn };
  }
  return { accountAuthenticator };
}

// node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/dist/index.mjs
var DEFAULT_FRONTEND_URL = "https://aptosconnect.app";
function convertToSerializableArgument(argument) {
  if (argument === void 0 || argument === null) {
    return argument;
  }
  if (Array.isArray(argument)) {
    return argument.map((subArgument) => convertToSerializableArgument(subArgument));
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || argument instanceof Uint8Array) {
    return argument;
  }
  if (typeof argument === "bigint") {
    return argument.toString();
  }
  if (argument instanceof ArrayBuffer) {
    return new Uint8Array(argument);
  }
  if ("values" in argument) {
    return argument.values.map((subArgument) => convertToSerializableArgument(subArgument));
  }
  if ("data" in argument) {
    return l.from(argument.data).toString();
  }
  if (argument.value === void 0) {
    return void 0;
  }
  if (typeof argument.value === "string" || typeof argument.value === "number" || typeof argument.value === "boolean" || argument.value instanceof Uint8Array) {
    return argument.value;
  }
  if (typeof argument.value === "bigint") {
    return argument.value.toString();
  }
  throw new Error("Unexpected argument");
}
function normalizePayloadForIC(payload, aptosConfig) {
  if ("bcsToBytes" in payload) {
    return payload;
  }
  if ("bytecode" in payload) {
    return Wn(payload);
  }
  if (aptosConfig) {
    return payload.abi !== void 0 ? pa({ ...payload, abi: payload.abi }) : Wn({ aptosConfig, ...payload });
  }
  const entryFunctionPayload = {
    arguments: payload.functionArguments.map(convertToSerializableArgument),
    function: payload.function,
    type: "entry_function_payload",
    type_arguments: (payload.typeArguments ?? []).map((ta2) => ta2.toString())
  };
  return "multisigAddress" in payload ? {
    multisig_address: l.from(payload.multisigAddress).toString(),
    transaction_payload: entryFunctionPayload,
    type: "multisig_payload"
  } : entryFunctionPayload;
}
var SignatureRequestError = class _SignatureRequestError extends Error {
  constructor(status) {
    super(status);
    this.name = "SignatureRequestError";
    Object.setPrototypeOf(this, _SignatureRequestError.prototype);
  }
};
var UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {
  constructor(missingFields) {
    const message = `Missing the following fields: ${missingFields.join(", ")}`;
    super(message);
    this.name = "UnexpectedSignatureResponseError";
    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);
  }
};
var PairingExpiredError = class _PairingExpiredError extends Error {
  constructor() {
    super();
    this.name = "PairingExpiredError";
    Object.setPrototypeOf(this, _PairingExpiredError.prototype);
  }
};
var DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
var windowStateAccessors = {
  async get(address) {
    const pairings = await this.getAll();
    return pairings[address];
  },
  async getAll() {
    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);
    return serialized ? JSON.parse(serialized) : {};
  },
  async update(address, pairing) {
    const pairings = await this.getAll();
    if (pairing === void 0) {
      delete pairings[address];
    } else {
      pairings[address] = pairing;
    }
    const newSerialized = JSON.stringify(pairings);
    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);
  }
};
var SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function validateSignMessageResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = ["hash"];
function validateSignAndSubmitTransactionResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var API_VERSION = "0.2.0";
var SIGNING_REQUEST_POLLING_INTERVAL = 2500;
var SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function waitFor2(milliseconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function withRetries(requestFn, onError, retries = 1) {
  for (let i27 = 0; i27 < retries; i27 += 1) {
    try {
      return await requestFn();
    } catch (err) {
      onError(err);
    }
  }
  return requestFn();
}
var ACPairingClient = class {
  constructor({
    accessors = windowStateAccessors,
    axiosConfig,
    defaultNetworkName = NetworkName.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set();
    this.accessors = accessors;
    this.defaultNetworkName = defaultNetworkName;
    this.axiosInstance = axios_default.create({
      baseURL: DEFAULT_FRONTEND_URL,
      ...axiosConfig
    });
    const isClientSideRendering = typeof window !== "undefined";
    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;
  }
  async getPairing(id) {
    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);
    return response.data.data.pairing;
  }
  async syncFirstPairing() {
    const pairings = await this.accessors.getAll();
    const firstPairing = Object.values(pairings)[0];
    if (firstPairing === void 0) {
      return;
    }
    try {
      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);
      await this.accessors.update(firstPairing.accountAddress, {
        ...firstPairing,
        currSequenceNumber: maxDappSequenceNumber,
        dappWalletId: dappSpecificWallet?.id
      });
    } catch (err) {
      await this.accessors.update(firstPairing.accountAddress, void 0);
    }
  }
  async createSigningRequest(pairing, type, networkName, requestBody) {
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    let sequenceNumber = pairing.currSequenceNumber + 1;
    return withRetries(
      async () => {
        const requestEnvelope = await encryptAndSignEnvelope(
          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          sequenceNumber,
          { apiVersion: API_VERSION, networkName, requestType: type },
          requestBody
        );
        const response = await this.axiosInstance.post(
          `v1/pairing/${pairing.pairingId}/signing-request/`,
          requestEnvelope
        );
        await this.accessors.update(pairing.accountAddress, {
          ...pairing,
          currSequenceNumber: sequenceNumber
        });
        return response.data.data.signingRequest;
      },
      (err) => {
        if (isAxiosError(err)) {
          const errorMessage = err.response?.data?.message;
          const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];
          if (expectedSequenceNumber !== void 0) {
            sequenceNumber = Number(expectedSequenceNumber);
            return;
          }
        }
        throw err;
      }
    );
  }
  async getSigningRequest(id) {
    const response = await this.axiosInstance.get(
      `v1/signing-request/${id}/`,
      {
        validateStatus: (status) => status === 200 || status === 404
      }
    );
    return response.data?.data?.signingRequest;
  }
  async deletePairing(pairingId, secretKey, publicKey) {
    const requestEnvelope = await encryptAndSignEnvelope(
      secretKey,
      publicKey,
      publicKey,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${pairingId}/delete/`,
      requestEnvelope,
      { validateStatus: (status) => status === 204 || status === 404 }
    );
  }
  async cancelSigningRequest(pairing, id) {
    const sequenceNumber = pairing.currSequenceNumber;
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    const requestEnvelope = await encryptAndSignEnvelope(
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      sequenceNumber + 1,
      {},
      {}
    );
    const response = await this.axiosInstance.patch(
      `v1/signing-request/${id}/cancel/`,
      requestEnvelope
    );
    await this.accessors.update(pairing.accountAddress, {
      ...pairing,
      currSequenceNumber: sequenceNumber + 1
    });
    return response.data.data.signingRequest;
  }
  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {
    await this.initPromise;
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The requested account is not paired");
    }
    let signingRequest;
    try {
      signingRequest = await this.createSigningRequest(
        pairing,
        type,
        networkName || this.defaultNetworkName,
        requestBody
      );
      while (signingRequest.status === "PENDING") {
        await waitFor2(SIGNING_REQUEST_POLLING_INTERVAL);
        if (cancelToken?.cancelled) {
          signingRequest.status = SigningRequestStatus.CANCELLED;
          break;
        }
        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;
      }
    } catch (err) {
      if (isAxiosError(err) && err.code === "404") {
        await this.accessors.update(address, void 0);
        for (const listener of this.onDisconnectListeners) {
          listener(address);
        }
        throw new PairingExpiredError();
      }
      throw err;
    }
    if (signingRequest.status !== "APPROVED") {
      throw new SignatureRequestError(signingRequest.status);
    }
    const decrypted = decryptEnvelope(
      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),
      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),
      signingRequest.responseEnvelope
    );
    return decrypted.privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey, secretKey }, finalizedPairing) {
    await this.accessors.update(finalizedPairing.account.accountAddress, {
      accountAddress: finalizedPairing.account.accountAddress,
      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,
      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),
      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),
      dappWalletId: finalizedPairing.dappSpecificWalletId,
      pairingId: finalizedPairing.id
    });
  }
  async disconnect(address) {
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The specified account is not paired");
    }
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    await this.deletePairing(
      pairing.pairingId,
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey)
    );
    await this.accessors.update(address, void 0);
    for (const listener of this.onDisconnectListeners) {
      listener(address);
    }
  }
  async signMessage(address, args, options) {
    const response = await this.signRequest(
      address,
      SigningRequestTypes.SIGN_MESSAGE,
      args,
      options
    );
    validateSignMessageResponse(response);
    return response;
  }
  async signTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);
    const serializedResponseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);
    return deserializeSignTransactionResponseArgs(serializedResponseArgs);
  }
  // endregion
  async signAndSubmitTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);
    try {
      const responseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);
      validateSignAndSubmitTransactionResponse(responseArgs);
      return responseArgs;
    } catch (e20) {
      if (e20 instanceof AxiosError && e20.response?.data?.message) {
        throw new Error(e20.response?.data?.message);
      }
      throw e20;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const pairings = await this.accessors.getAll();
    return Object.values(pairings).map(
      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({
        address: l.from(accountAddress),
        publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)
      })
    );
  }
  onDisconnect(listener) {
    this.onDisconnectListeners.add(listener);
    return () => this.onDisconnectListeners.delete(listener);
  }
};
var ACDappClient = class {
  constructor({
    backendBaseURL,
    dappId,
    dappImageURI,
    dappName,
    defaultNetworkName = NetworkName.MAINNET,
    frontendBaseURL = DEFAULT_FRONTEND_URL,
    provider = "google",
    tgWebAppURL
  } = {}) {
    this.defaultNetworkName = defaultNetworkName;
    this.dappInfo = {
      domain: window.location.origin,
      imageURI: dappImageURI,
      name: dappName ?? document.title
    };
    this.transport = new WebWalletTransport(frontendBaseURL, provider, tgWebAppURL);
    this.dappId = dappId;
    this.pairingClient = new ACPairingClient({
      axiosConfig: {
        baseURL: backendBaseURL ?? frontendBaseURL
      },
      defaultNetworkName
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);
    return response.args;
  }
  async getIcAccounts() {
    return this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(address) {
    const icAccounts = await this.getIcAccounts();
    return icAccounts.find((account) => account.address.equals(l.from(address))) !== void 0;
  }
  async getConnectedAccounts() {
    const keylessAccounts = await this.getKeylessAccounts();
    const icAccounts = await this.getIcAccounts();
    return [...keylessAccounts, ...icAccounts];
  }
  async disconnect(address) {
    if (await this.isIcAccount(address)) {
      const stringAddress = l.from(address).toString();
      await this.pairingClient.disconnect(stringAddress);
    } else {
      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);
      await this.transport.sendRequest(serializedRequest);
    }
  }
  async connect({
    claimOptions,
    preferredWalletName
  } = {}) {
    const dappKeypair = createEd25519KeyPair();
    const injectedPreferredWalletName = typeof window !== "undefined" ? window.AC_PREFERRED_WALLET_NAME : void 0;
    const requestArgs = {
      claimOptions,
      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),
      dappId: this.dappId,
      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName
    };
    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = ConnectResponse.deserialize(serializedResponse);
    if (response.args.status === "approved") {
      const { account, pairing } = response.args.args;
      if (pairing) {
        await this.pairingClient.addPairing(dappKeypair, pairing);
      }
      return makeUserApproval({ account });
    }
    return response.args;
  }
  async signIn(args) {
    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignInResponse.deserialize(serializedResponse, serializedRequest.version);
    return response.args;
  }
  async signMessage(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { chainId } = args;
      const network = chainIdToNetwork(chainId);
      let message;
      let nonce;
      try {
        message = new TextDecoder().decode(args.message);
        nonce = new TextDecoder().decode(args.nonce);
      } catch (err) {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(
        signerAddress.toString(),
        {
          address: true,
          application: true,
          chainId: true,
          message,
          nonce
        },
        { networkName: network }
      );
      const signatureBytes = a.fromHexInput(hexSignature).toUint8Array();
      const signature = signatureBytes.length === h.LENGTH ? new h(signatureBytes) : O.deserialize(new a2(signatureBytes));
      return makeUserApproval({
        fullMessage,
        signature
      });
    }
    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignMessageResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signTransaction(args) {
    const normalizedArgs = "transaction" in args ? SignTransactionRequest.normalizeArgs(args) : args;
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationSecondsFromNow,
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network,
        payload,
        secondarySigners,
        sender,
        sequenceNumber
      } = normalizedArgs;
      if (feePayer !== void 0) {
        throw new Error("Sponsored transaction not currently supported");
      }
      if (secondarySigners && secondarySigners.length > 0) {
        throw new Error("Multi-agent transactions not currently supported");
      }
      if (!("bcsToBytes" in payload)) {
        throw new Error("Payload input format is only supported with Keyless accounts.");
      }
      const responseArgs = await this.pairingClient.signTransaction(
        signerAddress.toString(),
        {
          options: {
            expirationSecondsFromNow,
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount,
            sender: sender?.address.toString(),
            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0
          },
          payload
        },
        {
          networkName: network
        }
      );
      return makeUserApproval({
        authenticator: responseArgs.accountAuthenticator,
        rawTransaction: responseArgs.rawTxn
      });
    }
    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signAndSubmitTransaction(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;
      const aptosConfig = new s({ network });
      let convertedArgs;
      if (feePayer !== void 0) {
        const payload = await normalizePayloadForIC(args.payload, aptosConfig);
        const rawTxn = await Ur({
          aptosConfig,
          feePayerAddress: feePayer.address,
          options: {
            gasUnitPrice,
            maxGasAmount
          },
          payload,
          sender: signerAddress
        });
        convertedArgs = {
          feePayerAuthenticator: feePayer.authenticator,
          rawTxn: new ut(rawTxn, [], feePayer.address)
        };
      } else {
        const payload = normalizePayloadForIC(args.payload);
        convertedArgs = {
          options: {
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount
          },
          payload
        };
      }
      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {
        networkName: network
      });
      return makeUserApproval({ txnHash: hash });
    }
    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  // endregion
};

// node_modules/@aptos-connect/wallet-adapter-plugin/dist/index.mjs
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _address;
var _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    this.chains = e14;
    this.features = [];
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof f) {
      return E.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof Dt) {
      return E.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof k) {
      return E.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof Se) {
      return E.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = /* @__PURE__ */ new WeakMap();
_publicKey = /* @__PURE__ */ new WeakMap();
function customAccountToStandardAccount({ address, name, publicKey }) {
  return new d10({
    address,
    ansName: name,
    publicKey
  });
}
function unwrapUserResponse(response, callback) {
  if (response.status === "dismissed") {
    return { status: r14.REJECTED };
  }
  return { args: callback(response.args), status: r14.APPROVED };
}
function networkToChainId(network) {
  switch (network) {
    case e.MAINNET:
      return r.mainnet;
    case e.TESTNET:
      return r.testnet;
    default:
      return r.devnet;
  }
}
var _AptosConnectWallet = class _AptosConnectWallet2 {
  constructor({
    claimSecretKey,
    network = e.MAINNET,
    preferredWalletName,
    ...clientConfig
  }) {
    this.version = "1.0.0";
    this.chains = e14;
    this.client = new ACDappClient(clientConfig);
    if (!o[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new s({ network });
    this.aptosClient = new W(aptosConfig);
    this.preferredWalletName = preferredWalletName;
    this.claimOptions = claimSecretKey ? { network, secretKey: new z(claimSecretKey) } : void 0;
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(_AptosConnectWallet2.connectedAccountStorageKey);
    if (!serialized) {
      return void 0;
    }
    try {
      const { address, publicKey } = JSON.parse(serialized);
      return new d10({
        address: l.from(address),
        publicKey: deserializePublicKeyB64(publicKey)
      });
    } catch (err) {
      console.warn("Inconsistent state, resetting it");
      this.connectedAccount = void 0;
      return void 0;
    }
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(_AptosConnectWallet2.connectedAccountStorageKey, JSON.stringify(serialized));
    } else {
      localStorage.removeItem(_AptosConnectWallet2.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet2;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: r14.APPROVED };
    }
    const response = await this.client.connect({
      claimOptions: this.claimOptions,
      preferredWalletName: this.preferredWalletName
    });
    if (response.status === "dismissed") {
      return { status: r14.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(response.args.account);
    _AptosConnectWallet2.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: r14.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet2.connectedAccount = void 0;
    }
  }
  async signIn(input) {
    const response = await this.client.signIn({ network: this.aptosClient.config.network, ...input });
    if (response.status === "dismissed") {
      return { status: r14.REJECTED };
    }
    const output = response.args;
    _AptosConnectWallet2.connectedAccount = output.account;
    return { args: output, status: r14.APPROVED };
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s9(o20.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = o[network];
    return {
      chainId,
      name: network,
      url
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s9(o20.Unauthorized);
    }
    const chainId = networkToChainId(this.aptosClient.config.network);
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r14.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: r14.APPROVED
    };
  }
  async signTransaction(txnOrArgs, _asFeePayer) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s9(o20.Unauthorized);
    }
    if ("bcsToBytes" in txnOrArgs) {
      const transaction = txnOrArgs;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = transaction.secondarySignerAddresses?.map((address) => ({ address }));
      const response2 = await this.client.signTransaction({
        feePayer,
        secondarySigners,
        signerAddress: connectedAccount.address,
        transaction: transaction.rawTransaction
      });
      return unwrapUserResponse(response2, (args) => args.authenticator);
    }
    const requestArgs = txnOrArgs;
    const response = await this.client.signTransaction({
      ...requestArgs,
      signerAddress: connectedAccount.address
    });
    return unwrapUserResponse(response, (responseArgs) => {
      const { authenticator, rawTransaction } = responseArgs;
      if (!rawTransaction) {
        throw new Error("Expected raw transaction in response args");
      }
      const secondarySigners = requestArgs.secondarySigners ?? [];
      let transaction;
      if (secondarySigners.length > 0) {
        transaction = new Gn(
          rawTransaction,
          secondarySigners.map((s11) => s11.address),
          requestArgs.feePayer?.address
        );
      } else {
        transaction = new Gt(rawTransaction, requestArgs.feePayer?.address);
      }
      return {
        authenticator,
        rawTransaction: transaction
      };
    });
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new s9(o20.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.aptosClient.config.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r14.REJECTED };
    }
    return {
      args: { hash: response.args.txnHash },
      status: r14.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;
var walletMetadata = {
  apple: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxzdHlsZT4KICAgICAgICBwYXRoIHsKICAgICAgICAgICAgZmlsbDogYmxhY2s7CiAgICAgICAgfQoKICAgICAgICBAbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7CiAgICAgICAgICAgIHBhdGggewogICAgICAgICAgICAgICAgZmlsbDogd2hpdGU7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgogICAgPHBhdGgKICAgICAgICBkPSJNMjAuMzkzMiA4LjE4MjQyQzIwLjI1NzggOC4yOTA0MyAxNy44NjggOS42NzUzNyAxNy44NjggMTIuNzU0OUMxNy44NjggMTYuMzE2OCAyMC45MDkgMTcuNTc3IDIxIDE3LjYwODJDMjAuOTg2IDE3LjY4NSAyMC41MTY5IDE5LjMzMzkgMTkuMzk2NiAyMS4wMTQxQzE4LjM5NzcgMjIuNDkyNiAxNy4zNTQ1IDIzLjk2ODggMTUuNzY3NSAyMy45Njg4QzE0LjE4MDQgMjMuOTY4OCAxMy43NzIgMjMuMDIwNyAxMS45Mzk5IDIzLjAyMDdDMTAuMTU0NSAyMy4wMjA3IDkuNTE5NzIgMjQgOC4wNjgwNSAyNEM2LjYxNjM5IDI0IDUuNjAzNDkgMjIuNjMxOSA0LjQzODg5IDIwLjk1MTdDMy4wODk5MiAxOC45Nzg3IDIgMTUuOTEzNiAyIDEzLjAwNDVDMiA4LjMzODQzIDQuOTUwMDEgNS44NjM3OSA3Ljg1MzM0IDUuODYzNzlDOS4zOTYwMiA1Ljg2Mzc5IDEwLjY4MiA2LjkwNTQ5IDExLjY1MDUgNi45MDU0OUMxMi41NzI0IDYuOTA1NDkgMTQuMDEwMSA1LjgwMTM4IDE1Ljc2NTEgNS44MDEzOEMxNi40MzAzIDUuODAxMzggMTguODIwMiA1Ljg2Mzc5IDIwLjM5MzIgOC4xODI0MlpNMTQuOTMxOSAzLjgyNTk4QzE1LjY1NzggMi45NDAyOSAxNi4xNzEyIDEuNzExMzcgMTYuMTcxMiAwLjQ4MjQ0OEMxNi4xNzEyIDAuMzEyMDMxIDE2LjE1NzIgMC4xMzkyMTQgMTYuMTI2OSAwQzE0Ljk0NiAwLjA0NTYwNDYgMTMuNTQxIDAuODA4ODgxIDEyLjY5MzggMS44MTkzOEMxMi4wMjg2IDIuNTk3MDYgMTEuNDA3OCAzLjgyNTk4IDExLjQwNzggNS4wNzE3MUMxMS40MDc4IDUuMjU4OTMgMTEuNDM4MiA1LjQ0NjE0IDExLjQ1MjIgNS41MDYxNUMxMS41MjY4IDUuNTIwNTUgMTEuNjQ4MiA1LjUzNzM1IDExLjc2OTYgNS41MzczNUMxMi44MjkxIDUuNTM3MzUgMTQuMTYxOCA0LjgwNzY4IDE0LjkzMTkgMy44MjU5OFoiIC8+Cjwvc3ZnPg=="
    ),
    name: "Continue with Apple",
    url: "https://aptosconnect.app"
  },
  google: {
    icon: (
      // eslint-disable-next-line max-len
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
    ),
    name: "Continue with Google",
    url: "https://aptosconnect.app"
  }
};
var AptosConnectGoogleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "google" });
    this.name = walletMetadata.google.name;
    this.icon = walletMetadata.google.icon;
    this.url = walletMetadata.google.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o16]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o17]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t12]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t13]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n88]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e13]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n85]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n86]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e12]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n87]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1"
      }
    };
  }
  // endregion
};
var AptosConnectAppleWallet = class extends AptosConnectWallet {
  constructor(config) {
    super({ ...config, provider: "apple" });
    this.name = walletMetadata.apple.name;
    this.icon = walletMetadata.apple.icon;
    this.url = walletMetadata.apple.url;
  }
  // region AptosWallet
  get features() {
    return {
      [o16]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o17]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t12]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t13]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n88]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e13]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n85]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [n86]: {
        signIn: this.signIn.bind(this),
        version: "1.0.0"
      },
      [e12]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n87]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.1"
      }
    };
  }
  // endregion
};

// node_modules/@aptos-labs/wallet-adapter-react/node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i27 = 0, arr2 = new Array(len); i27 < len; i27++) arr2[i27] = arr[i27];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _assert_this_initialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _async_to_generator(fn2) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _call_super(_this, derived, args) {
  derived = _get_prototype_of(derived);
  return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _construct(Parent, args, Class) {
  if (_is_native_reflect_construct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function construct(Parent2, args2, Class2) {
      var a24 = [
        null
      ];
      a24.push.apply(a24, args2);
      var Constructor = Function.bind.apply(Parent2, a24);
      var instance = new Constructor();
      if (Class2) _set_prototype_of(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
  for (var i27 = 0; i27 < props.length; i27++) {
    var descriptor = props[i27];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _get_prototype_of(o26) {
  _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o27) {
    return o27.__proto__ || Object.getPrototypeOf(o27);
  };
  return _get_prototype_of(o26);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _set_prototype_of(subClass, superClass);
}
function _is_native_function(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _iterable_to_array(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i27 = 1; i27 < arguments.length; i27++) {
    var source = arguments[i27] != null ? arguments[i27] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  source = source != null ? source : {};
  if (Object.getOwnPropertyDescriptors) {
    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
  } else {
    ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _possible_constructor_return(self, call) {
  if (call && (_type_of(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assert_this_initialized(self);
}
function _set_prototype_of(o26, p11) {
  _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o27, p12) {
    o27.__proto__ = p12;
    return o27;
  };
  return _set_prototype_of(o26, p11);
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o26, minLen) {
  if (!o26) return;
  if (typeof o26 === "string") return _array_like_to_array(o26, minLen);
  var n94 = Object.prototype.toString.call(o26).slice(8, -1);
  if (n94 === "Object" && o26.constructor) n94 = o26.constructor.name;
  if (n94 === "Map" || n94 === "Set") return Array.from(n94);
  if (n94 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n94)) return _array_like_to_array(o26, minLen);
}
function _wrap_native_super(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrap_native_super = function wrapNativeSuper(Class2) {
    if (Class2 === null || !_is_native_function(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _get_prototype_of(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _set_prototype_of(Wrapper, Class2);
  };
  return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
  try {
    var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (_8) {
  }
  return (_is_native_reflect_construct = function() {
    return !!result;
  })();
}
function _ts_generator(thisArg, body) {
  var f13, y10, t18, g5, _8 = {
    label: 0,
    sent: function() {
      if (t18[0] & 1) throw t18[1];
      return t18[1];
    },
    trys: [],
    ops: []
  };
  return g5 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g5[Symbol.iterator] = function() {
    return this;
  }), g5;
  function verb(n94) {
    return function(v7) {
      return step([
        n94,
        v7
      ]);
    };
  }
  function step(op) {
    if (f13) throw new TypeError("Generator is already executing.");
    while (_8) try {
      if (f13 = 1, y10 && (t18 = op[0] & 2 ? y10["return"] : op[0] ? y10["throw"] || ((t18 = y10["return"]) && t18.call(y10), 0) : y10.next) && !(t18 = t18.call(y10, op[1])).done) return t18;
      if (y10 = 0, t18) op = [
        op[0] & 2,
        t18.value
      ];
      switch (op[0]) {
        case 0:
        case 1:
          t18 = op;
          break;
        case 4:
          _8.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _8.label++;
          y10 = op[1];
          op = [
            0
          ];
          continue;
        case 7:
          op = _8.ops.pop();
          _8.trys.pop();
          continue;
        default:
          if (!(t18 = _8.trys, t18 = t18.length > 0 && t18[t18.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _8 = 0;
            continue;
          }
          if (op[0] === 3 && (!t18 || op[1] > t18[0] && op[1] < t18[3])) {
            _8.label = op[1];
            break;
          }
          if (op[0] === 6 && _8.label < t18[1]) {
            _8.label = t18[1];
            t18 = op;
            break;
          }
          if (t18 && _8.label < t18[2]) {
            _8.label = t18[2];
            _8.ops.push(op);
            break;
          }
          if (t18[2]) _8.ops.pop();
          _8.trys.pop();
          continue;
      }
      op = body.call(thisArg, _8);
    } catch (e20) {
      op = [
        6,
        e20
      ];
      y10 = 0;
    } finally {
      f13 = t18 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
var WALLET_ADAPTER_CORE_VERSION = "7.1.1";
var GA4 = (function() {
  "use strict";
  function GA42() {
    _class_call_check(this, GA42);
    this.aptosGAID = "G-GNVVWBL3J9";
    this.injectGA(this.aptosGAID);
  }
  _create_class(GA42, [
    {
      key: "gtag",
      value: function gtag(a24, b8, c7) {
        var dataLayer = window.dataLayer || [];
        dataLayer.push(arguments);
      }
    },
    {
      key: "injectGA",
      value: function injectGA(gaID) {
        if (typeof window === "undefined") return;
        if (!gaID) return;
        var head = document.getElementsByTagName("head")[0];
        var myScript = document.createElement("script");
        myScript.setAttribute("src", "https://www.googletagmanager.com/gtag/js?id=".concat(gaID));
        var that = this;
        myScript.onload = function() {
          that.gtag("js", /* @__PURE__ */ new Date());
          that.gtag("config", "".concat(gaID), {
            send_page_view: false
          });
        };
        head.insertBefore(myScript, head.children[1]);
      }
    }
  ]);
  return GA42;
})();
var WalletError = (function(Error1) {
  "use strict";
  _inherits(WalletError2, Error1);
  function WalletError2(message, error) {
    _class_call_check(this, WalletError2);
    var _this;
    _this = _call_super(this, WalletError2, [
      message
    ]);
    _this.error = error;
    return _this;
  }
  return WalletError2;
})(_wrap_native_super(Error));
var WalletNotSelectedError = (function(WalletError2) {
  "use strict";
  _inherits(WalletNotSelectedError2, WalletError2);
  function WalletNotSelectedError2() {
    _class_call_check(this, WalletNotSelectedError2);
    var _this;
    _this = _call_super(this, WalletNotSelectedError2, arguments);
    _this.name = "WalletNotSelectedError";
    return _this;
  }
  return WalletNotSelectedError2;
})(WalletError);
var WalletNotReadyError = (function(WalletError2) {
  "use strict";
  _inherits(WalletNotReadyError2, WalletError2);
  function WalletNotReadyError2() {
    _class_call_check(this, WalletNotReadyError2);
    var _this;
    _this = _call_super(this, WalletNotReadyError2, arguments);
    _this.name = "WalletNotReadyError";
    return _this;
  }
  return WalletNotReadyError2;
})(WalletError);
var WalletConnectionError = (function(WalletError2) {
  "use strict";
  _inherits(WalletConnectionError2, WalletError2);
  function WalletConnectionError2() {
    _class_call_check(this, WalletConnectionError2);
    var _this;
    _this = _call_super(this, WalletConnectionError2, arguments);
    _this.name = "WalletConnectionError";
    return _this;
  }
  return WalletConnectionError2;
})(WalletError);
var WalletDisconnectionError = (function(WalletError2) {
  "use strict";
  _inherits(WalletDisconnectionError2, WalletError2);
  function WalletDisconnectionError2() {
    _class_call_check(this, WalletDisconnectionError2);
    var _this;
    _this = _call_super(this, WalletDisconnectionError2, arguments);
    _this.name = "WalletDisconnectionError";
    return _this;
  }
  return WalletDisconnectionError2;
})(WalletError);
var WalletAccountError = (function(WalletError2) {
  "use strict";
  _inherits(WalletAccountError2, WalletError2);
  function WalletAccountError2() {
    _class_call_check(this, WalletAccountError2);
    var _this;
    _this = _call_super(this, WalletAccountError2, arguments);
    _this.name = "WalletAccountError";
    return _this;
  }
  return WalletAccountError2;
})(WalletError);
var WalletGetNetworkError = (function(WalletError2) {
  "use strict";
  _inherits(WalletGetNetworkError2, WalletError2);
  function WalletGetNetworkError2() {
    _class_call_check(this, WalletGetNetworkError2);
    var _this;
    _this = _call_super(this, WalletGetNetworkError2, arguments);
    _this.name = "WalletGetNetworkError";
    return _this;
  }
  return WalletGetNetworkError2;
})(WalletError);
var WalletAccountChangeError = (function(WalletError2) {
  "use strict";
  _inherits(WalletAccountChangeError2, WalletError2);
  function WalletAccountChangeError2() {
    _class_call_check(this, WalletAccountChangeError2);
    var _this;
    _this = _call_super(this, WalletAccountChangeError2, arguments);
    _this.name = "WalletAccountChangeError";
    return _this;
  }
  return WalletAccountChangeError2;
})(WalletError);
var WalletNetworkChangeError = (function(WalletError2) {
  "use strict";
  _inherits(WalletNetworkChangeError2, WalletError2);
  function WalletNetworkChangeError2() {
    _class_call_check(this, WalletNetworkChangeError2);
    var _this;
    _this = _call_super(this, WalletNetworkChangeError2, arguments);
    _this.name = "WalletNetworkChangeError";
    return _this;
  }
  return WalletNetworkChangeError2;
})(WalletError);
var WalletNotConnectedError = (function(WalletError2) {
  "use strict";
  _inherits(WalletNotConnectedError2, WalletError2);
  function WalletNotConnectedError2() {
    _class_call_check(this, WalletNotConnectedError2);
    var _this;
    _this = _call_super(this, WalletNotConnectedError2, arguments);
    _this.name = "WalletNotConnectedError";
    return _this;
  }
  return WalletNotConnectedError2;
})(WalletError);
var WalletSignMessageError = (function(WalletError2) {
  "use strict";
  _inherits(WalletSignMessageError2, WalletError2);
  function WalletSignMessageError2() {
    _class_call_check(this, WalletSignMessageError2);
    var _this;
    _this = _call_super(this, WalletSignMessageError2, arguments);
    _this.name = "WalletSignMessageError";
    return _this;
  }
  return WalletSignMessageError2;
})(WalletError);
var WalletSignMessageAndVerifyError = (function(WalletError2) {
  "use strict";
  _inherits(WalletSignMessageAndVerifyError2, WalletError2);
  function WalletSignMessageAndVerifyError2() {
    _class_call_check(this, WalletSignMessageAndVerifyError2);
    var _this;
    _this = _call_super(this, WalletSignMessageAndVerifyError2, arguments);
    _this.name = "WalletSignMessageAndVerifyError";
    return _this;
  }
  return WalletSignMessageAndVerifyError2;
})(WalletError);
var WalletSignAndSubmitMessageError = (function(WalletError2) {
  "use strict";
  _inherits(WalletSignAndSubmitMessageError2, WalletError2);
  function WalletSignAndSubmitMessageError2() {
    _class_call_check(this, WalletSignAndSubmitMessageError2);
    var _this;
    _this = _call_super(this, WalletSignAndSubmitMessageError2, arguments);
    _this.name = "WalletSignAndSubmitMessageError";
    return _this;
  }
  return WalletSignAndSubmitMessageError2;
})(WalletError);
var WalletSignTransactionError = (function(WalletError2) {
  "use strict";
  _inherits(WalletSignTransactionError2, WalletError2);
  function WalletSignTransactionError2() {
    _class_call_check(this, WalletSignTransactionError2);
    var _this;
    _this = _call_super(this, WalletSignTransactionError2, arguments);
    _this.name = "WalletSignTransactionError";
    return _this;
  }
  return WalletSignTransactionError2;
})(WalletError);
var WalletNotSupportedMethod = (function(WalletError2) {
  "use strict";
  _inherits(WalletNotSupportedMethod2, WalletError2);
  function WalletNotSupportedMethod2() {
    _class_call_check(this, WalletNotSupportedMethod2);
    var _this;
    _this = _call_super(this, WalletNotSupportedMethod2, arguments);
    _this.name = "WalletNotSupportedMethod";
    return _this;
  }
  return WalletNotSupportedMethod2;
})(WalletError);
var WalletChangeNetworkError = (function(WalletError2) {
  "use strict";
  _inherits(WalletChangeNetworkError2, WalletError2);
  function WalletChangeNetworkError2() {
    _class_call_check(this, WalletChangeNetworkError2);
    var _this;
    _this = _call_super(this, WalletChangeNetworkError2, arguments);
    _this.name = "WalletChangeNetworkError";
    return _this;
  }
  return WalletChangeNetworkError2;
})(WalletError);
var WalletSubmitTransactionError = (function(WalletError2) {
  "use strict";
  _inherits(WalletSubmitTransactionError2, WalletError2);
  function WalletSubmitTransactionError2() {
    _class_call_check(this, WalletSubmitTransactionError2);
    var _this;
    _this = _call_super(this, WalletSubmitTransactionError2, arguments);
    _this.name = "WalletSubmitTransactionError";
    return _this;
  }
  return WalletSubmitTransactionError2;
})(WalletError);
var WalletNotFoundError = (function(WalletError2) {
  "use strict";
  _inherits(WalletNotFoundError2, WalletError2);
  function WalletNotFoundError2() {
    _class_call_check(this, WalletNotFoundError2);
    var _this;
    _this = _call_super(this, WalletNotFoundError2, arguments);
    _this.name = "WalletNotFoundError";
    return _this;
  }
  return WalletNotFoundError2;
})(WalletError);
var WalletReadyState = (function(WalletReadyState2) {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName2 = (function(NetworkName22) {
  NetworkName22["Mainnet"] = "mainnet";
  NetworkName22["Testnet"] = "testnet";
  NetworkName22["Devnet"] = "devnet";
  return NetworkName22;
})(NetworkName2 || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  // mainnet
  "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(navigator.userAgent);
}
function isInAppBrowser() {
  var isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
  var isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(navigator.userAgent);
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator) return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return (typeof error === "undefined" ? "undefined" : _type_of(error)) === "object" && "message" in error ? error.message : error;
}
var getAptosConfig = function(networkInfo, dappConfig) {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  var pluginSettings = {
    TRANSACTION_SUBMITTER: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.transactionSubmitter
  };
  if (isAptosNetwork(networkInfo)) {
    var currentNetwork = convertNetwork(networkInfo);
    if (isAptosLiveNetwork(currentNetwork)) {
      var apiKey = dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosApiKeys;
      return new a21({
        network: currentNetwork,
        clientConfig: {
          API_KEY: apiKey ? apiKey[currentNetwork] : void 0
        },
        pluginSettings
      });
    }
    return new a21({
      network: currentNetwork,
      pluginSettings
    });
  }
  var knownNetworks = {
    okx: "https://wallet.okx.com/fullnode/aptos/discover/rpc"
  };
  if (networkInfo.url) {
    var isKnownNetwork = Object.values(knownNetworks).includes(networkInfo.url);
    if (isKnownNetwork) {
      return new a21({
        network: e7.CUSTOM,
        fullnode: networkInfo.url,
        pluginSettings
      });
    }
  }
  throw new Error("Invalid network, network ".concat(networkInfo.name, " not supported with Aptos wallet adapter to prevent user from using an unexpected network."));
};
var isAptosNetwork = function(networkInfo) {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return o11[networkInfo.name] !== void 0;
};
var isAptosLiveNetwork = function(networkInfo) {
  return networkInfo === "devnet" || networkInfo === "testnet" || networkInfo === "mainnet";
};
var fetchDevnetChainId = (function() {
  var _ref = _async_to_generator(function() {
    var aptos;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          aptos = new j3();
          return [
            4,
            aptos.getChainId()
          ];
        case 1:
          return [
            2,
            _state.sent()
          ];
      }
    });
  });
  return function fetchDevnetChainId2() {
    return _ref.apply(this, arguments);
  };
})();
var handlePublishPackageTransaction = function(transactionInput) {
  var metadataBytes = transactionInput.data.functionArguments[0];
  if (typeof metadataBytes === "string") {
    metadataBytes = a3.fromHexInput(metadataBytes).toUint8Array();
  }
  var byteCode = transactionInput.data.functionArguments[1];
  if (Array.isArray(byteCode)) {
    byteCode = byteCode.map(function(byte) {
      if (typeof byte === "string") {
        return a3.fromHexInput(byte).toUint8Array();
      }
      return byte;
    });
  } else {
    throw new WalletSignAndSubmitMessageError("The bytecode argument must be an array.").message;
  }
  return {
    metadataBytes,
    byteCode
  };
};
function convertNetwork(networkInfo) {
  switch (networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.name) {
    case "mainnet":
      return e7.MAINNET;
    case "testnet":
      return e7.TESTNET;
    case "devnet":
      return e7.DEVNET;
    case "local":
      return e7.LOCAL;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
function partitionWallets(wallets) {
  var partitionFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInstalledOrLoadable;
  var defaultWallets = [];
  var moreWallets = [];
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = wallets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var wallet = _step.value;
      if (partitionFunction(wallet)) defaultWallets.push(wallet);
      else moreWallets.push(wallet);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return {
    defaultWallets,
    moreWallets
  };
}
function isInstalledOrLoadable(wallet) {
  return wallet.readyState === "Installed";
}
function isInstallRequired(wallet) {
  var isWalletReady = isInstalledOrLoadable(wallet);
  var isMobile2 = !isWalletReady && isRedirectable();
  return !isMobile2 && !isWalletReady;
}
function truncateAddress(address) {
  if (!address) return;
  return "".concat(address.slice(0, 6), "...").concat(address.slice(-5));
}
function isAptosConnectWallet(wallet) {
  if (!wallet.url) return false;
  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);
}
function getAptosConnectWallets(wallets) {
  var _partitionWallets = partitionWallets(wallets, isAptosConnectWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  return {
    aptosConnectWallets: defaultWallets,
    otherWallets: moreWallets
  };
}
function groupAndSortWallets(wallets, options) {
  var _getAptosConnectWallets = getAptosConnectWallets(wallets), aptosConnectWallets = _getAptosConnectWallets.aptosConnectWallets, otherWallets = _getAptosConnectWallets.otherWallets;
  var _partitionWallets = partitionWallets(otherWallets), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
  if (options === null || options === void 0 ? void 0 : options.sortAptosConnectWallets) {
    aptosConnectWallets.sort(options.sortAptosConnectWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortAvailableWallets) {
    defaultWallets.sort(options.sortAvailableWallets);
  }
  if (options === null || options === void 0 ? void 0 : options.sortInstallableWallets) {
    moreWallets.sort(options.sortInstallableWallets);
  }
  return {
    /** Wallets that use social login to create an account on the blockchain */
    aptosConnectWallets,
    /** Wallets that are currently installed or loadable. */
    availableWallets: defaultWallets,
    /** Wallets that are NOT currently installed or loadable. */
    installableWallets: moreWallets
  };
}
var aptosStandardSupportedWalletList = [
  {
    name: "OKX Wallet",
    url: "https://chromewebstore.google.com/detail/okx-wallet/mcohilncbfahbmgdjkbpemcciiolgcge",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJDSURBVHgB7Zq9jtpAEMfHlhEgQLiioXEkoAGECwoKxMcTRHmC5E3IoyRPkPAEkI7unJYmTgEFTYwA8a3NTKScLnCHN6c9r1e3P2llWQy7M/s1Gv1twCP0ej37dDq9x+Zut1t3t9vZjDEHIiSRSPg4ZpDL5fxkMvn1cDh8m0wmfugfO53OoFQq/crn8wxfY9EymQyrVCqMfHvScZx1p9ls3pFxXBy/bKlUipGPrVbLuQqAfsCliq3zl0H84zwtjQrOw4Mt1W63P5LvBm2d+Xz+YzqdgkqUy+WgWCy+Mc/nc282m4FqLBYL+3g8fjDxenq72WxANZbLJeA13zDX67UDioL5ybXwafMYu64Ltn3bdDweQ5R97fd7GyhBQMipx4POeEDHIu2LfDdBIGGz+hJ9CQ1ABjoA2egAZPM6AgiCAEQhsi/C4jHyPA/6/f5NG3Ks2+3CYDC4aTccDrn6ojG54MnEvG00GoVmWLIRNZ7wTCwDHYBsdACy0QHIhiuRETxlICWpMMhGZHmqS8qH6JLyGegAZKMDkI0uKf8X4SWlaZo+Pp1bRrwlJU8ZKLIvUjKh0WiQ3sRUbNVq9c5Ebew7KEo2m/1p4jJ4qAmDaqDQBzj5XyiAT4VCQezJigAU+IDU+z8vJFnGWeC+bKQV/5VZ71FV6L7PA3gg3tXrdQ+DgLhC+75Wq3no69P3MC0NFQpx2lL04Ql9gHK1bRDjsSBIvScBnDTk1WrlGIZBorIDEYJj+rhdgnQ67VmWRe0zlplXl81vcyEt0rSoYDUAAAAASUVORK5CYII=",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAeMSURBVHgB7Z09bFNXFMfPtQKVUgZXAomJGokFFlK1Iw1mKkyFlqENVKRTOyARNqRWIkhU6ghSl051pZZ26EeYyoZBjK1wF7og1emEVIYMEKkBcnv+tl9iHMf2s9+979x3z0+K7Dh2JL///3zcj/eeoQyYr9ryGtFJQ3TYWqrwSzP8vGz5h5SsaPIxbZKhxjrRnVeIGrW6adKEGBoTiP6MH8jSuyx0lZQ8aLCC13cS1cc1Q2oDtKJ9nS4YQwsa4XJgIWs7DF1Ja4RUBpibtZdVeOFYWrxx11wZ9e0jGYCjvrJm6Vd+OkNKCDR3Gjo2SjYoDXvDmVl77pml+6TihwQC9v6HVXty2BsHGgAp3xqqacoPkrLhrA0NB71p2xLQ+qChRVLCZ0Bf0NcASB2mXfOVgsB6zn9/13y75fXeF9DwoeZr2i8cK9wYvtHbGG7pAbh5uK3iF5LyWp+s/pIBOg1DhZSiMjNXtYvdL2yUgM5Y/29Sig5KwX4uBSv4ZSMD8Lz+ZVJiAAt3C8kvrQyg0R8dG1mglQHWdDUvNsr/YSWXOiWAx4gXSImKEi/j49Fo+o8XLgOvlZ7rIk+0YBdXaV3rf8zMlLj+HyYlVipTvNxb4dWiaNm9l+jVXUTT/LNn79a///to8/HxIyoWHPxTZOOY+oXI+w4Qvd71A8EhfBqWH7aN8KDRfv5Xg0KmbOaO2sLG/0Fubw/NtB8POmp1V58Q/X6vbYS7tyg4CmeARPTjp9NH96QkZviltlk6pFMYA7x5hOjEaXeRnhZkhJ9r8ktE0AZAXUekv328fwMnAZQFyRkhWAPMsujvzcsVvheYABlBGsEZACn+/Xk5qT4NyAJfLMjKBsEYAOkeEY+UHzrffUX0208kgikKAIzZL14NJ90P4+z59ghFQkkQbwBE/EfnqXAgm8HYX39J9PQJ5cbQU8PyAin/00vFFD8BQ9fPrrW/a16INABSPQ4MhndFB1kA3zUvxBkgER8HJhbwXT+5RLkgygCJ+EVp9tKAeQ0Mb30jxgAxi5+AxvCtI+QVEQZQ8TdBKfB5HHI3ADrgIo3xJwXzAz77gdwNkIyHlU0wzX3C04xnrgZA01OEqV0XIDB8zA/kZgCkfHxJpT/Tu/wcn1wMAGfnOfkRCsiOrnujXAwQ0jp+3rjOAt4NAOG17o8O5gVc9gLeDaCpPx3oBd5xGDBeDTAreO+eZE4UxQDa9Y8HsoCrLXDeDKDRPxmu1gi8GUCjfzJmHe2N8GIAjf7JcVUGvOwJ9BX9ODWr+ZBEUjkw+alqWDPJ+kwj5waAa31FP87LwyZLaSADHspghQ/nPN7KeDu58xIwG8G+vkFkud1rn4NVU+cGCPEMnqyA+J9nOPG1Z2/2s4JODeAz/UsjET/rU9R3Z3w8nRog1vTvSnyQdRlwaoB9Ee70cSk+CKYEIPVXIjOAa/HBdCgGiC36fYjvAmcGiKn7D1V84MwAsaT/kMUHzgwQw1bv0MUHTgwwvSvsgzIKRRAfODFA0Sd/8hQ/6+sLOcsARSXvyH8cggGKmgEkpP3VjC8noxlgRKSIv5zxfgc1wAhIafhcbHYRe5EoKUjq9v9RA/hF2lAPO56yRg2wDRLH+ZoBPCFR/D/uubmgpBqgB6kzfC7SP1ADdCFVfEz+uLodjRqgg+S5/QcO7zqiBiD5Czu42YQrojeAdPGR+l3eYCJqA4SwpOsy+kG0BghBfNfRD6I0QAjio/N3Hf0gOgOEspMHt5PxcXOp6AyAJdXVHG/RMgpI/b5uQxudARBVVxfk3gncV+pPiLIHkGoCZKarnu8rGO0oQKIJfNX9bqKeB5BkAoif9dU/RiH6mUAJJoD4Put+N7oWQPmaIE/xgRqgQx4myFt8oAbowqcJJIgP1AA9+DCBFPGBGqAPLk0gSXygBtgGFyaQJj5QAwwgSxNIFB+oAYaQhQmkig/UACMwiQkkiw/UACMyjgmkiw/UAClIY4IQxAdqgJSMYoJQxAdqgDEYZIKQxAdqgDHpZ4LQxAdm7qi1lDHYeJnHdQIhSta3VBkGroeETaZ3boUnPnBigNjAFbyfCt9ouh1aAjIgVPFByRCtkBItJWvUABHTRAnw3DYpUjCmbYBlUqKEu/8/NQNEDItfL+0kWiIlSp5z8JdqdbPCI4E6KVHBmjd+rJtmqfPbTVKigkd/1/HYMsAOoprOB8TFeifrtwyAMpA4QomCGtI/nmxMBXMzeE2zQBysG7qSPN8wgGaBSGDxk+hv/9rDmaP2Pk8QzJBSRJo37pj93S9sWQ18YeiUloLiAU059R/rfX2LAZAeuBRcJKVQsPgfd6f+hL77AW7UTY26GgUlcFjLH+pmqf+fBjBXtYu8YnCZlHBh8TmgF7f/8xDOVu1Ja+kbbgzLpAQDaj5KeSubD37fcD6o2krJ0m1+WiElBBpc80/1q/m9jGSABC0JsulE/fVBKb/PZ9KBbMAfWjSWzpEigkT4VZ7NXeIJvZSfHY9WWSCq8j+4wD2CThzlgDGtBZ2bT3kiN63wG/+DMgBmmOLZwxdsCDbFYYtewWq/kBWdCIfADT62y1jL52hfGlf0bv4H4emQh2jTz1sAAAAASUVORK5CYII=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://petra.app/explore?link="
  },
  {
    name: "Nightly",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true
  }
];
var crossChainStandardSupportedWalletList = [
  {
    name: "Phantom (Solana)",
    url: "https://phantom.com/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://phantom.app/ul/browse/"
  },
  {
    name: "Phantom (Ethereum)",
    url: "https://phantom.com/",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "https://phantom.app/ul/browse/"
  },
  {
    name: "Nightly (Solana)",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  },
  {
    name: "Nightly (Ethereum)",
    url: "https://nightly.app/",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true,
    deeplinkProvider: "nightly://v1?network=aptos&url="
  }
];
function getSDKWallets(dappConfig) {
  var sdkWallets = [];
  if (typeof window !== "undefined") {
    sdkWallets.push(new AptosConnectGoogleWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)), new AptosConnectAppleWallet(_object_spread({
      network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
      dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnectDappId
    }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.aptosConnect)));
  }
  return sdkWallets;
}
var WalletCore = (function(EventEmitter2) {
  "use strict";
  _inherits(WalletCore2, EventEmitter2);
  function WalletCore2(optInWallets, dappConfig, disableTelemetry) {
    _class_call_check(this, WalletCore2);
    var _this;
    _this = _call_super(this, WalletCore2);
    _this._wallet = null;
    _this._sdkWallets = [];
    _this._standard_wallets = [];
    _this._standard_not_detected_wallets = [];
    _this._network = null;
    _this._connected = false;
    _this._connecting = false;
    _this._account = null;
    _this._optInWallets = [];
    _this._disableTelemetry = false;
    _this.ga4 = null;
    _this._optInWallets = optInWallets || [];
    _this._dappConfig = dappConfig;
    _this._disableTelemetry = disableTelemetry !== null && disableTelemetry !== void 0 ? disableTelemetry : false;
    _this._sdkWallets = getSDKWallets(_this._dappConfig);
    if (!_this._disableTelemetry) {
      _this.ga4 = new GA4();
    }
    _this.fetchExtensionAIP62AptosWallets();
    _this.fetchSDKAIP62AptosWallets();
    _this.appendNotDetectedStandardSupportedWallets();
    return _this;
  }
  _create_class(WalletCore2, [
    {
      key: "fetchExtensionAIP62AptosWallets",
      value: function fetchExtensionAIP62AptosWallets() {
        var _getAptosWallets = d8(), aptosWallets = _getAptosWallets.aptosWallets, on2 = _getAptosWallets.on;
        this.setExtensionAIP62Wallets(aptosWallets);
        if (typeof window === "undefined") return;
        var that = this;
        var removeRegisterListener = on2("register", function() {
          var _getAptosWallets2 = d8(), aptosWallets2 = _getAptosWallets2.aptosWallets;
          that.setExtensionAIP62Wallets(aptosWallets2);
        });
        var removeUnregisterListener = on2("unregister", function() {
          var _getAptosWallets2 = d8(), aptosWallets2 = _getAptosWallets2.aptosWallets;
          that.setExtensionAIP62Wallets(aptosWallets2);
        });
      }
    },
    {
      /**
      * Set AIP-62 extension wallets
      *
      * @param extensionwWallets
      */
      key: "setExtensionAIP62Wallets",
      value: function setExtensionAIP62Wallets(extensionwWallets) {
        var _this = this;
        extensionwWallets.map(function(wallet) {
          if (_this.excludeWallet(wallet)) {
            return;
          }
          if (wallet.name === "Rimosafe") {
            return;
          }
          var isValid = i24(wallet);
          if (isValid) {
            var index = _this._standard_not_detected_wallets.findIndex(function(notDetctedWallet) {
              return notDetctedWallet.name == wallet.name;
            });
            if (index !== -1) {
              _this._standard_not_detected_wallets.splice(index, 1);
            }
            var alreadyExists = _this._standard_wallets.some(function(w5) {
              return w5.name === wallet.name;
            });
            if (!alreadyExists) {
              wallet.readyState = "Installed";
              wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
              _this._standard_wallets.push(wallet);
              _this.emit("standardWalletsAdded", wallet);
            }
          }
        });
      }
    },
    {
      /**
      * Set AIP-62 SDK wallets
      */
      key: "fetchSDKAIP62AptosWallets",
      value: function fetchSDKAIP62AptosWallets() {
        var _this = this;
        this._sdkWallets.map(function(wallet) {
          if (_this.excludeWallet(wallet)) {
            return;
          }
          var isValid = i24(wallet);
          if (isValid) {
            wallet.readyState = "Installed";
            wallet.isAptosNativeWallet = _this.isAptosNativeWallet(wallet);
            _this._standard_wallets.push(wallet);
          }
        });
      }
    },
    {
      // Aptos native wallets do not have an authenticationFunction property
      key: "isAptosNativeWallet",
      value: function isAptosNativeWallet(wallet) {
        return !("authenticationFunction" in wallet);
      }
    },
    {
      // Since we can't discover AIP-62 wallets that are not installed on the user machine,
      // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.
      // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array
      // when wallet is not installed on the user machine
      key: "appendNotDetectedStandardSupportedWallets",
      value: function appendNotDetectedStandardSupportedWallets() {
        var _this = this;
        var _this__dappConfig;
        var walletRegistry = ((_this__dappConfig = this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.crossChainWallets) ? _to_consumable_array(aptosStandardSupportedWalletList).concat(_to_consumable_array(crossChainStandardSupportedWalletList)) : aptosStandardSupportedWalletList;
        walletRegistry.map(function(supportedWallet) {
          var existingStandardWallet = _this._standard_wallets.find(function(wallet) {
            return wallet.name == supportedWallet.name;
          });
          if (existingStandardWallet) {
            return;
          }
          if (_this.excludeWallet(supportedWallet)) {
            return;
          }
          if (!existingStandardWallet) {
            supportedWallet.isAptosNativeWallet = !("authenticationFunction" in supportedWallet);
            _this._standard_not_detected_wallets.push(supportedWallet);
            _this.emit("standardNotDetectedWalletAdded", supportedWallet);
          }
        });
      }
    },
    {
      /**
      * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include
      *
      * @param wallet AdapterWallet | AdapterNotDetectedWallet
      * @returns boolean
      */
      key: "excludeWallet",
      value: function excludeWallet(wallet) {
        if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
          return true;
        }
        return false;
      }
    },
    {
      key: "recordEvent",
      value: function recordEvent(eventName, additionalInfo) {
        var _this__wallet, _this__network, _this__network1, _this_ga4;
        (_this_ga4 = this.ga4) === null || _this_ga4 === void 0 ? void 0 : _this_ga4.gtag("event", "wallet_adapter_".concat(eventName), _object_spread({
          wallet: (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name,
          network: (_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
          network_url: (_this__network1 = this._network) === null || _this__network1 === void 0 ? void 0 : _this__network1.url,
          adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
          send_to: "G-GNVVWBL3J9"
        }, additionalInfo));
      }
    },
    {
      /**
      * Helper function to ensure wallet exists
      *
      * @param wallet A wallet
      */
      key: "ensureWalletExists",
      value: function ensureWalletExists(wallet) {
        if (!wallet) {
          throw new WalletNotConnectedError().name;
        }
        if (!(wallet.readyState === "Installed")) throw new WalletNotReadyError("Wallet is not set").name;
      }
    },
    {
      /**
      * Helper function to ensure account exists
      *
      * @param account An account
      */
      key: "ensureAccountExists",
      value: function ensureAccountExists(account) {
        if (!account) {
          throw new WalletAccountError("Account is not set").name;
        }
      }
    },
    {
      key: "setAnsName",
      value: (
        /**
        * Queries and sets ANS name for the current connected wallet account
        */
        function setAnsName() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__network, aptosConfig, aptos, name, error;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (!(((_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.chainId) && _this._account)) return [
                    3,
                    4
                  ];
                  if (_this._account.ansName) return [
                    2
                  ];
                  if (!ChainIdToAnsSupportedNetworkMap[_this._network.chainId] || !isAptosNetwork(_this._network)) {
                    _this._account.ansName = void 0;
                    return [
                      2
                    ];
                  }
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new j3(aptosConfig);
                  _state.label = 1;
                case 1:
                  _state.trys.push([
                    1,
                    3,
                    ,
                    4
                  ]);
                  return [
                    4,
                    aptos.ans.getPrimaryName({
                      address: _this._account.address.toString()
                    })
                  ];
                case 2:
                  name = _state.sent();
                  _this._account.ansName = name;
                  return [
                    3,
                    4
                  ];
                case 3:
                  error = _state.sent();
                  console.log("Error setting ANS name ".concat(error));
                  return [
                    3,
                    4
                  ];
                case 4:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      /**
      * Function to cleat wallet adapter data.
      *
      * - Removes current connected wallet state
      * - Removes current connected account state
      * - Removes current connected network state
      * - Removes autoconnect local storage value
      */
      key: "clearData",
      value: function clearData() {
        this._connected = false;
        this.setWallet(null);
        this.setAccount(null);
        this.setNetwork(null);
        removeLocalStorage();
      }
    },
    {
      /**
      * Sets the connected wallet
      *
      * @param wallet A wallet
      */
      key: "setWallet",
      value: function setWallet(wallet) {
        this._wallet = wallet;
      }
    },
    {
      /**
      * Sets the connected account
      *
      * @param account An account
      */
      key: "setAccount",
      value: function setAccount(account) {
        this._account = account;
      }
    },
    {
      /**
      * Sets the connected network
      *
      * @param network A network
      */
      key: "setNetwork",
      value: function setNetwork(network) {
        this._network = network;
      }
    },
    {
      /**
      * Helper function to detect whether a wallet is connected
      *
      * @returns boolean
      */
      key: "isConnected",
      value: function isConnected() {
        return this._connected;
      }
    },
    {
      key: "wallets",
      get: (
        /**
        * Getter to fetch all detected wallets
        */
        function get() {
          return this._standard_wallets;
        }
      )
    },
    {
      key: "notDetectedWallets",
      get: function get() {
        return this._standard_not_detected_wallets;
      }
    },
    {
      key: "wallet",
      get: (
        /**
        * Getter for the current connected wallet
        *
        * @return wallet info
        * @throws WalletNotSelectedError
        */
        function get() {
          try {
            if (!this._wallet) return null;
            return this._wallet;
          } catch (error) {
            throw new WalletNotSelectedError(error).message;
          }
        }
      )
    },
    {
      key: "account",
      get: (
        /**
        * Getter for the current connected account
        *
        * @return account info
        * @throws WalletAccountError
        */
        function get() {
          try {
            return this._account;
          } catch (error) {
            throw new WalletAccountError(error).message;
          }
        }
      )
    },
    {
      key: "network",
      get: (
        /**
        * Getter for the current wallet network
        *
        * @return network info
        * @throws WalletGetNetworkError
        */
        function get() {
          try {
            return this._network;
          } catch (error) {
            throw new WalletGetNetworkError(error).message;
          }
        }
      )
    },
    {
      key: "connect",
      value: (
        /**
        * Helper function to run some checks before we connect with a wallet.
        *
        * @param walletName. The wallet name we want to connect with.
        */
        function connect(walletName) {
          var _this = this;
          return _async_to_generator(function() {
            var selectedWallet2, uninstalledWallet, parameter, url, ref, location, allDetectedWallets, selectedWallet, _this__wallet;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  if (isRedirectable()) {
                    selectedWallet2 = _this._standard_not_detected_wallets.find(function(wallet) {
                      return wallet.name === walletName;
                    });
                    if (selectedWallet2) {
                      uninstalledWallet = selectedWallet2;
                      if (uninstalledWallet.deeplinkProvider) {
                        parameter = "";
                        if (uninstalledWallet.name.includes("Phantom")) {
                          url = encodeURIComponent(window.location.href);
                          ref = encodeURIComponent(window.location.origin);
                          parameter = "".concat(url, "?ref=").concat(ref);
                        } else {
                          parameter = encodeURIComponent(window.location.href);
                        }
                        location = uninstalledWallet.deeplinkProvider.concat(parameter);
                        window.location.href = location;
                        return [
                          2
                        ];
                      }
                    }
                  }
                  allDetectedWallets = _this._standard_wallets;
                  selectedWallet = allDetectedWallets.find(function(wallet) {
                    return wallet.name === walletName;
                  });
                  if (!selectedWallet) return [
                    2
                  ];
                  if (_this._connected && _this._account) {
                    ;
                    if (((_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name) === walletName) throw new WalletConnectionError("".concat(walletName, " wallet is already connected")).message;
                  }
                  return [
                    4,
                    _this.connectWallet(selectedWallet, _async_to_generator(function() {
                      var response;
                      return _ts_generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            return [
                              4,
                              selectedWallet.features["aptos:connect"].connect()
                            ];
                          case 1:
                            response = _state2.sent();
                            if (response.status === r12.REJECTED) {
                              throw new WalletConnectionError("User has rejected the request").message;
                            }
                            return [
                              2,
                              {
                                account: response.args,
                                output: void 0
                              }
                            ];
                        }
                      });
                    }))
                  ];
                case 1:
                  _state.sent();
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signIn",
      value: (
        /**
        * Signs into the wallet by connecting and signing an authentication messages.
        *
        * For more information, visit: https://siwa.aptos.dev
        *
        * @param args
        * @param args.input The AptosSignInInput which defines how the SIWA Message should be constructed
        * @param args.walletName The name of the wallet to sign into
        * @returns The AptosSignInOutput which contains the account and signature information
        */
        function signIn(args) {
          var _this = this;
          return _async_to_generator(function() {
            var input, walletName, allDetectedWallets, selectedWallet;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  input = args.input, walletName = args.walletName;
                  allDetectedWallets = _this._standard_wallets;
                  selectedWallet = allDetectedWallets.find(function(wallet) {
                    return wallet.name === walletName;
                  });
                  if (!selectedWallet) {
                    throw new WalletNotFoundError("Wallet ".concat(walletName, " not found")).message;
                  }
                  if (!selectedWallet.features["aptos:signIn"]) {
                    throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(walletName)).message;
                  }
                  return [
                    4,
                    _this.connectWallet(selectedWallet, _async_to_generator(function() {
                      var response;
                      return _ts_generator(this, function(_state2) {
                        switch (_state2.label) {
                          case 0:
                            if (!selectedWallet.features["aptos:signIn"]) {
                              throw new WalletNotSupportedMethod("aptos:signIn is not supported by ".concat(selectedWallet.name)).message;
                            }
                            return [
                              4,
                              selectedWallet.features["aptos:signIn"].signIn(input)
                            ];
                          case 1:
                            response = _state2.sent();
                            if (response.status === r12.REJECTED) {
                              throw new WalletConnectionError("User has rejected the request").message;
                            }
                            return [
                              2,
                              {
                                account: response.args.account,
                                output: response.args
                              }
                            ];
                        }
                      });
                    }))
                  ];
                case 1:
                  return [
                    2,
                    _state.sent()
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "connectWallet",
      value: (
        /**
        * Connects a wallet to the dapp.
        * On connect success, we set the current account and the network, and keeping the selected wallet
        * name in LocalStorage to support autoConnect function.
        *
        * @param selectedWallet. The wallet we want to connect.
        * @emit emits "connect" event
        * @throws WalletConnectionError
        */
        function connectWallet(selectedWallet, onConnect) {
          var _this = this;
          return _async_to_generator(function() {
            var _ref, account, output, network, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    4,
                    5,
                    6
                  ]);
                  _this._connecting = true;
                  _this.setWallet(selectedWallet);
                  return [
                    4,
                    onConnect()
                  ];
                case 1:
                  _ref = _state.sent(), account = _ref.account, output = _ref.output;
                  _this.setAccount(account);
                  return [
                    4,
                    selectedWallet.features["aptos:network"].network()
                  ];
                case 2:
                  network = _state.sent();
                  _this.setNetwork(network);
                  return [
                    4,
                    _this.setAnsName()
                  ];
                case 3:
                  _state.sent();
                  setLocalStorage(selectedWallet.name);
                  _this._connected = true;
                  _this.recordEvent("wallet_connect");
                  _this.emit("connect", account);
                  return [
                    2,
                    output
                  ];
                case 4:
                  error = _state.sent();
                  _this.clearData();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletConnectionError(errMsg).message;
                case 5:
                  _this._connecting = false;
                  return [
                    7
                  ];
                case 6:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "disconnect",
      value: (
        /**
        * Disconnect the current connected wallet. On success, we clear the
        * current account, current network and LocalStorage data.
        *
        * @emit emits "disconnect" event
        * @throws WalletDisconnectionError
        */
        function disconnect() {
          var _this = this;
          return _async_to_generator(function() {
            var error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    _this._wallet.features["aptos:disconnect"].disconnect()
                  ];
                case 1:
                  _state.sent();
                  _this.clearData();
                  _this.recordEvent("wallet_disconnect");
                  _this.emit("disconnect");
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletDisconnectionError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signAndSubmitTransaction",
      value: (
        /**
        * Signs and submits a transaction to chain
        *
        * @param transactionInput InputTransactionData
        * @returns AptosSignAndSubmitTransactionOutput
        */
        function signAndSubmitTransaction(transactionInput) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__dappConfig, ref, shouldUseTxnSubmitter, _transactionInput_options, _transactionInput_options1, aptosConfig2, aptos2, transaction2, signAndSubmitTransactionMethod, response3, response2, aptosConfig, aptos, transaction, signTransactionResponse, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    9,
                    ,
                    10
                  ]);
                  if ("function" in transactionInput.data) {
                    if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
                      throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
                    }
                    if (transactionInput.data.function === "0x1::code::publish_package_txn") {
                      ;
                      ref = handlePublishPackageTransaction(transactionInput), transactionInput.data.functionArguments[0] = ref.metadataBytes, transactionInput.data.functionArguments[1] = ref.byteCode, ref;
                    }
                  }
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_and_submit_transaction");
                  shouldUseTxnSubmitter = ((_this__dappConfig = _this._dappConfig) === null || _this__dappConfig === void 0 ? void 0 : _this__dappConfig.transactionSubmitter) !== void 0 || transactionInput.transactionSubmitter !== void 0;
                  if (!(_this._wallet.features["aptos:signAndSubmitTransaction"] && !shouldUseTxnSubmitter)) return [
                    3,
                    5
                  ];
                  if (!(_this._wallet.features["aptos:signAndSubmitTransaction"].version !== "1.1.0")) return [
                    3,
                    3
                  ];
                  aptosConfig2 = getAptosConfig(_this._network, _this._dappConfig);
                  aptos2 = new j3(aptosConfig2);
                  return [
                    4,
                    aptos2.transaction.build.simple({
                      sender: _this._account.address.toString(),
                      data: transactionInput.data,
                      options: transactionInput.options
                    })
                  ];
                case 1:
                  transaction2 = _state.sent();
                  signAndSubmitTransactionMethod = _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction;
                  return [
                    4,
                    signAndSubmitTransactionMethod(transaction2)
                  ];
                case 2:
                  response3 = _state.sent();
                  if (response3.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response3.args
                  ];
                case 3:
                  return [
                    4,
                    _this._wallet.features["aptos:signAndSubmitTransaction"].signAndSubmitTransaction({
                      payload: transactionInput.data,
                      gasUnitPrice: (_transactionInput_options = transactionInput.options) === null || _transactionInput_options === void 0 ? void 0 : _transactionInput_options.gasUnitPrice,
                      maxGasAmount: (_transactionInput_options1 = transactionInput.options) === null || _transactionInput_options1 === void 0 ? void 0 : _transactionInput_options1.maxGasAmount
                    })
                  ];
                case 4:
                  response2 = _state.sent();
                  if (response2.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response2.args
                  ];
                case 5:
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new j3(aptosConfig);
                  return [
                    4,
                    aptos.transaction.build.simple({
                      sender: _this._account.address.toString(),
                      data: transactionInput.data,
                      options: transactionInput.options,
                      withFeePayer: shouldUseTxnSubmitter
                    })
                  ];
                case 6:
                  transaction = _state.sent();
                  return [
                    4,
                    _this.signTransaction({
                      transactionOrPayload: transaction
                    })
                  ];
                case 7:
                  signTransactionResponse = _state.sent();
                  return [
                    4,
                    _this.submitTransaction({
                      transaction,
                      senderAuthenticator: signTransactionResponse.authenticator,
                      transactionSubmitter: transactionInput.transactionSubmitter,
                      pluginParams: transactionInput.pluginParams
                    })
                  ];
                case 8:
                  response = _state.sent();
                  return [
                    2,
                    {
                      hash: response.hash
                    }
                  ];
                case 9:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignAndSubmitMessageError(errMsg).message;
                case 10:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signTransaction",
      value: (
        /**
        * Signs a transaction
        *
        * This method supports 2 input types -
        * 1. A raw transaction that was already built by the dapp,
        * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing
        *
        * @param transactionOrPayload AnyRawTransaction | InputTransactionData
        * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer
        * @param options optional. Transaction options
        *
        * @returns AccountAuthenticator
        */
        function signTransaction(args) {
          var _this = this;
          return _async_to_generator(function() {
            var transactionOrPayload, asFeePayer, _this__wallet_features_aptossignTransaction, _this__wallet, response, _transactionOrPayload_options, _transactionOrPayload_options1, _transactionOrPayload_options2, _transactionOrPayload_options3, _transactionOrPayload_options4, _this__wallet1, signTransactionV1_1StandardInput, walletSignTransactionMethod, response1, _this__wallet2, aptosConfig, aptos, transaction, response2, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  transactionOrPayload = args.transactionOrPayload, asFeePayer = args.asFeePayer;
                  _state.label = 1;
                case 1:
                  _state.trys.push([
                    1,
                    9,
                    ,
                    10
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_transaction");
                  if (!("rawTransaction" in transactionOrPayload)) return [
                    3,
                    3
                  ];
                  return [
                    4,
                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.features["aptos:signTransaction"].signTransaction(transactionOrPayload, asFeePayer)
                  ];
                case 2:
                  response = _state.sent();
                  if (response.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response.args,
                      rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()
                    }
                  ];
                case 3:
                  if (!(((_this__wallet_features_aptossignTransaction = _this._wallet.features["aptos:signTransaction"]) === null || _this__wallet_features_aptossignTransaction === void 0 ? void 0 : _this__wallet_features_aptossignTransaction.version) === "1.1")) return [
                    3,
                    5
                  ];
                  signTransactionV1_1StandardInput = {
                    payload: transactionOrPayload.data,
                    expirationTimestamp: (_transactionOrPayload_options = transactionOrPayload.options) === null || _transactionOrPayload_options === void 0 ? void 0 : _transactionOrPayload_options.expirationTimestamp,
                    expirationSecondsFromNow: (_transactionOrPayload_options1 = transactionOrPayload.options) === null || _transactionOrPayload_options1 === void 0 ? void 0 : _transactionOrPayload_options1.expirationSecondsFromNow,
                    gasUnitPrice: (_transactionOrPayload_options2 = transactionOrPayload.options) === null || _transactionOrPayload_options2 === void 0 ? void 0 : _transactionOrPayload_options2.gasUnitPrice,
                    maxGasAmount: (_transactionOrPayload_options3 = transactionOrPayload.options) === null || _transactionOrPayload_options3 === void 0 ? void 0 : _transactionOrPayload_options3.maxGasAmount,
                    sequenceNumber: (_transactionOrPayload_options4 = transactionOrPayload.options) === null || _transactionOrPayload_options4 === void 0 ? void 0 : _transactionOrPayload_options4.accountSequenceNumber,
                    sender: transactionOrPayload.sender ? {
                      address: l3.from(transactionOrPayload.sender)
                    } : void 0
                  };
                  walletSignTransactionMethod = (_this__wallet1 = _this._wallet) === null || _this__wallet1 === void 0 ? void 0 : _this__wallet1.features["aptos:signTransaction"].signTransaction;
                  return [
                    4,
                    walletSignTransactionMethod(signTransactionV1_1StandardInput)
                  ];
                case 4:
                  response1 = _state.sent();
                  if (response1.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response1.args.authenticator,
                      rawTransaction: response1.args.rawTransaction.bcsToBytes()
                    }
                  ];
                case 5:
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  aptos = new j3(aptosConfig);
                  return [
                    4,
                    aptos.transaction.build.simple({
                      sender: _this._account.address,
                      data: transactionOrPayload.data,
                      options: transactionOrPayload.options,
                      withFeePayer: transactionOrPayload.withFeePayer
                    })
                  ];
                case 6:
                  transaction = _state.sent();
                  return [
                    4,
                    (_this__wallet2 = _this._wallet) === null || _this__wallet2 === void 0 ? void 0 : _this__wallet2.features["aptos:signTransaction"].signTransaction(transaction, asFeePayer)
                  ];
                case 7:
                  response2 = _state.sent();
                  if (response2.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    {
                      authenticator: response2.args,
                      rawTransaction: transaction.bcsToBytes()
                    }
                  ];
                case 8:
                  return [
                    3,
                    10
                  ];
                case 9:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignTransactionError(errMsg).message;
                case 10:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signMessage",
      value: (
        /**
        * Sign a message (doesnt submit to chain).
        *
        * @param message - AptosSignMessageInput
        *
        * @return response from the wallet's signMessage function
        * @throws WalletSignMessageError
        */
        function signMessage(message) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptossignMessage, _this__wallet, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.recordEvent("sign_message");
                  return [
                    4,
                    (_this__wallet = _this._wallet) === null || _this__wallet === void 0 ? void 0 : (_this__wallet_features_aptossignMessage = _this__wallet.features["aptos:signMessage"]) === null || _this__wallet_features_aptossignMessage === void 0 ? void 0 : _this__wallet_features_aptossignMessage.signMessage(message)
                  ];
                case 1:
                  response = _state.sent();
                  if (response.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response.args
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignMessageError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "submitTransaction",
      value: (
        /**
        * Submits transaction to chain
        *
        * @param transaction - InputSubmitTransactionData
        * @returns PendingTransactionResponse
        */
        function submitTransaction(transaction) {
          var _this = this;
          return _async_to_generator(function() {
            var additionalSignersAuthenticators, transactionType, aptosConfig, aptos, multiAgentTxn, errMsg;
            return _ts_generator(this, function(_state) {
              try {
                _this.ensureWalletExists(_this._wallet);
                additionalSignersAuthenticators = transaction.additionalSignersAuthenticators;
                transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
                _this.recordEvent("submit_transaction", {
                  transaction_type: transactionType
                });
                aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                aptos = new j3(aptosConfig);
                if (additionalSignersAuthenticators !== void 0) {
                  multiAgentTxn = _object_spread_props(_object_spread({}, transaction), {
                    additionalSignersAuthenticators
                  });
                  return [
                    2,
                    aptos.transaction.submit.multiAgent(multiAgentTxn)
                  ];
                } else {
                  return [
                    2,
                    aptos.transaction.submit.simple(transaction)
                  ];
                }
              } catch (error) {
                errMsg = generalizedErrorMessage(error);
                throw new WalletSubmitTransactionError(errMsg).message;
              }
              return [
                2
              ];
            });
          })();
        }
      )
    },
    {
      key: "onAccountChange",
      value: (
        /**
        Event for when account has changed on the wallet
        @return the new account info
        @throws WalletAccountChangeError
        */
        function onAccountChange() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptosonAccountChange, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    (_this__wallet_features_aptosonAccountChange = _this._wallet.features["aptos:onAccountChange"]) === null || _this__wallet_features_aptosonAccountChange === void 0 ? void 0 : _this__wallet_features_aptosonAccountChange.onAccountChange((function() {
                      var _ref = _async_to_generator(function(data) {
                        return _ts_generator(this, function(_state2) {
                          switch (_state2.label) {
                            case 0:
                              _this.setAccount(data);
                              return [
                                4,
                                _this.setAnsName()
                              ];
                            case 1:
                              _state2.sent();
                              _this.recordEvent("account_change");
                              _this.emit("accountChange", _this._account);
                              return [
                                2
                              ];
                          }
                        });
                      });
                      return function(data) {
                        return _ref.apply(this, arguments);
                      };
                    })())
                  ];
                case 1:
                  _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletAccountChangeError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "onNetworkChange",
      value: (
        /**
        Event for when network has changed on the wallet
        @return the new network info
        @throws WalletNetworkChangeError
        */
        function onNetworkChange() {
          var _this = this;
          return _async_to_generator(function() {
            var _this__wallet_features_aptosonNetworkChange, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    2,
                    ,
                    3
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  return [
                    4,
                    (_this__wallet_features_aptosonNetworkChange = _this._wallet.features["aptos:onNetworkChange"]) === null || _this__wallet_features_aptosonNetworkChange === void 0 ? void 0 : _this__wallet_features_aptosonNetworkChange.onNetworkChange((function() {
                      var _ref = _async_to_generator(function(data) {
                        return _ts_generator(this, function(_state2) {
                          switch (_state2.label) {
                            case 0:
                              _this.setNetwork(data);
                              return [
                                4,
                                _this.setAnsName()
                              ];
                            case 1:
                              _state2.sent();
                              _this.emit("networkChange", _this._network);
                              return [
                                2
                              ];
                          }
                        });
                      });
                      return function(data) {
                        return _ref.apply(this, arguments);
                      };
                    })())
                  ];
                case 1:
                  _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletNetworkChangeError(errMsg).message;
                case 3:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "changeNetwork",
      value: (
        /**
        * Sends a change network request to the wallet to change the connected network
        *
        * @param network - Network
        * @returns AptosChangeNetworkOutput
        */
        function changeNetwork(network) {
          var _this = this;
          return _async_to_generator(function() {
            var _this__network, chainId, _tmp, networkInfo, response, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    6,
                    ,
                    7
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.recordEvent("change_network_request", {
                    from: (_this__network = _this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                    to: network
                  });
                  if (!(network === e7.DEVNET)) return [
                    3,
                    2
                  ];
                  return [
                    4,
                    fetchDevnetChainId()
                  ];
                case 1:
                  _tmp = _state.sent();
                  return [
                    3,
                    3
                  ];
                case 2:
                  _tmp = r10[network];
                  _state.label = 3;
                case 3:
                  chainId = _tmp;
                  networkInfo = {
                    name: network,
                    chainId
                  };
                  if (!_this._wallet.features["aptos:changeNetwork"]) return [
                    3,
                    5
                  ];
                  return [
                    4,
                    _this._wallet.features["aptos:changeNetwork"].changeNetwork(networkInfo)
                  ];
                case 4:
                  response = _state.sent();
                  if (response.status === r12.REJECTED) {
                    throw new WalletConnectionError("User has rejected the request").message;
                  }
                  return [
                    2,
                    response.args
                  ];
                case 5:
                  throw new WalletChangeNetworkError("".concat(_this._wallet.name, " does not support changing network request")).message;
                case 6:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletChangeNetworkError(errMsg).message;
                case 7:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    },
    {
      key: "signMessageAndVerify",
      value: (
        /**
        * Signs a message and verifies the signer
        * @param message - AptosSignMessageInput
        * @returns boolean
        */
        function signMessageAndVerify(message) {
          var _this = this;
          return _async_to_generator(function() {
            var response, aptosConfig, signingMessage, error, errMsg;
            return _ts_generator(this, function(_state) {
              switch (_state.label) {
                case 0:
                  _state.trys.push([
                    0,
                    4,
                    ,
                    5
                  ]);
                  _this.ensureWalletExists(_this._wallet);
                  _this.ensureAccountExists(_this._account);
                  _this.recordEvent("sign_message_and_verify");
                  return [
                    4,
                    _this._wallet.features["aptos:signMessage"].signMessage(message)
                  ];
                case 1:
                  response = _state.sent();
                  if (response.status === r12.REJECTED) {
                    throw new WalletConnectionError("Failed to sign a message").message;
                  }
                  aptosConfig = getAptosConfig(_this._network, _this._dappConfig);
                  signingMessage = new TextEncoder().encode(response.args.fullMessage);
                  if (!("verifySignatureAsync" in _this._account.publicKey)) return [
                    3,
                    3
                  ];
                  return [
                    4,
                    _this._account.publicKey.verifySignatureAsync({
                      aptosConfig,
                      message: signingMessage,
                      signature: response.args.signature,
                      options: {
                        throwErrorWithReason: true
                      }
                    })
                  ];
                case 2:
                  return [
                    2,
                    _state.sent()
                  ];
                case 3:
                  return [
                    2,
                    _this._account.publicKey.verifySignature({
                      message: signingMessage,
                      signature: response.args.signature
                    })
                  ];
                case 4:
                  error = _state.sent();
                  errMsg = generalizedErrorMessage(error);
                  throw new WalletSignMessageAndVerifyError(errMsg).message;
                case 5:
                  return [
                    2
                  ];
              }
            });
          })();
        }
      )
    }
  ]);
  return WalletCore2;
})(import_eventemitter34.default);
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i27 = 0; i27 < cleanups.length; i27++) {
          const cleanup = cleanups[i27];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i27], null);
          }
        }
      };
    }
  };
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a24, b8) => {
  for (var prop in b8 || (b8 = {}))
    if (__hasOwnProp.call(b8, prop))
      __defNormalProp(a24, prop, b8[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b8)) {
      if (__propIsEnum.call(b8, prop))
        __defNormalProp(a24, prop, b8[prop]);
    }
  return a24;
};
var __spreadProps = (a24, b8) => __defProps(a24, __getOwnPropDescs(b8));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e20) {
        reject(e20);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e20) {
        reject(e20);
      }
    };
    var step = (x5) => x5.done ? resolve(x5.value) : Promise.resolve(x5.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var DEFAULT_CONTEXT = {
  connected: false
};
var WalletContext = (0, import_react2.createContext)(
  DEFAULT_CONTEXT
);
function useWallet() {
  const context = (0, import_react2.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  optInWallets,
  autoConnect = false,
  dappConfig,
  disableTelemetry = false,
  onError
}) => {
  const didAttemptAutoConnectRef = (0, import_react.useRef)(false);
  const [{ account, network, connected, wallet }, setState2] = (0, import_react.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [walletCore, setWalletCore] = (0, import_react.useState)();
  const [wallets, setWallets] = (0, import_react.useState)([]);
  const [notDetectedWallets, setNotDetectedWallets] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    const walletCore2 = new WalletCore(
      optInWallets,
      dappConfig,
      disableTelemetry
    );
    setWalletCore(walletCore2);
  }, []);
  (0, import_react.useEffect)(() => {
    var _a2, _b;
    setWallets((_a2 = walletCore == null ? void 0 : walletCore.wallets) != null ? _a2 : []);
    setNotDetectedWallets((_b = walletCore == null ? void 0 : walletCore.notDetectedWallets) != null ? _b : []);
  }, [walletCore]);
  (0, import_react.useEffect)(() => {
    if (didAttemptAutoConnectRef.current || !(walletCore == null ? void 0 : walletCore.wallets.length)) {
      return;
    }
    didAttemptAutoConnectRef.current = true;
    if (!autoConnect) {
      setIsLoading(false);
      return;
    }
    const walletName = localStorage.getItem("AptosWalletName");
    if (!walletName) {
      setIsLoading(false);
      return;
    }
    const selectedWallet = walletCore.wallets.find(
      (e20) => e20.name === walletName
    );
    if (!selectedWallet || selectedWallet.readyState !== WalletReadyState.Installed) {
      setIsLoading(false);
      return;
    }
    if (!connected) {
      (() => __async(void 0, null, function* () {
        try {
          let shouldConnect = true;
          if (typeof autoConnect === "function") {
            shouldConnect = yield autoConnect(walletCore, selectedWallet);
          } else {
            shouldConnect = autoConnect;
          }
          if (shouldConnect) yield connect(walletName);
        } catch (error) {
          if (onError) onError(error);
          return Promise.reject(error);
        } finally {
          setIsLoading(false);
        }
      }))();
    } else {
      setIsLoading(false);
    }
  }, [autoConnect, wallets]);
  const connect = (walletName) => __async(void 0, null, function* () {
    try {
      setIsLoading(true);
      yield walletCore == null ? void 0 : walletCore.connect(walletName);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  });
  const signIn = (args) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      setIsLoading(true);
      return yield walletCore == null ? void 0 : walletCore.signIn(args);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  });
  const disconnect = () => __async(void 0, null, function* () {
    try {
      yield walletCore == null ? void 0 : walletCore.disconnect();
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signAndSubmitTransaction = (transaction) => __async(void 0, null, function* () {
    try {
      if (!walletCore) {
        throw new Error("WalletCore is not initialized");
      }
      return yield walletCore.signAndSubmitTransaction(transaction);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signTransaction = (args) => __async(void 0, null, function* () {
    const { transactionOrPayload, asFeePayer, options } = args;
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore.signTransaction({
        transactionOrPayload,
        asFeePayer
      });
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const submitTransaction = (transaction) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.submitTransaction(transaction);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signMessage = (message) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.signMessage(message);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const signMessageAndVerify = (message) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.signMessageAndVerify(message);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const changeNetwork = (network2) => __async(void 0, null, function* () {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return yield walletCore == null ? void 0 : walletCore.changeNetwork(network2);
    } catch (error) {
      if (onError) onError(error);
      return Promise.reject(error);
    }
  });
  const handleConnect = () => {
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        connected: true,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: (walletCore == null ? void 0 : walletCore.wallet) || null
      });
    });
  };
  const handleAccountChange = (0, import_react.useCallback)(() => {
    if (!connected) return;
    if (!(walletCore == null ? void 0 : walletCore.wallet)) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        account: (walletCore == null ? void 0 : walletCore.account) || null
      });
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react.useCallback)(() => {
    if (!connected) return;
    if (!(walletCore == null ? void 0 : walletCore.wallet)) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        network: (walletCore == null ? void 0 : walletCore.network) || null
      });
    });
  }, [connected]);
  (0, import_react.useEffect)(() => {
    if (connected) {
      walletCore == null ? void 0 : walletCore.onAccountChange();
      walletCore == null ? void 0 : walletCore.onNetworkChange();
    }
  }, [connected]);
  const handleDisconnect = () => {
    if (!connected) return;
    setState2((state) => {
      return __spreadProps(__spreadValues({}, state), {
        connected: false,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: null
      });
    });
  };
  const handleStandardWalletsAdded = (standardWallet) => {
    const existingWalletIndex = wallets.findIndex(
      (wallet2) => wallet2.name == standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setWallets((wallets2) => [
        ...wallets2.slice(0, existingWalletIndex),
        standardWallet,
        ...wallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setWallets((wallets2) => [...wallets2, standardWallet]);
    }
  };
  const handleStandardNotDetectedWalletsAdded = (notDetectedWallet) => {
    const existingWalletIndex = wallets.findIndex(
      (wallet2) => wallet2.name == notDetectedWallet.name
    );
    if (existingWalletIndex !== -1) {
      setNotDetectedWallets((wallets2) => [
        ...wallets2.slice(0, existingWalletIndex),
        notDetectedWallet,
        ...wallets2.slice(existingWalletIndex + 1)
      ]);
    } else {
      setNotDetectedWallets((wallets2) => [...wallets2, notDetectedWallet]);
    }
  };
  (0, import_react.useEffect)(() => {
    walletCore == null ? void 0 : walletCore.on("connect", handleConnect);
    walletCore == null ? void 0 : walletCore.on("accountChange", handleAccountChange);
    walletCore == null ? void 0 : walletCore.on("networkChange", handleNetworkChange);
    walletCore == null ? void 0 : walletCore.on("disconnect", handleDisconnect);
    walletCore == null ? void 0 : walletCore.on("standardWalletsAdded", handleStandardWalletsAdded);
    walletCore == null ? void 0 : walletCore.on(
      "standardNotDetectedWalletAdded",
      handleStandardNotDetectedWalletsAdded
    );
    return () => {
      walletCore == null ? void 0 : walletCore.off("connect", handleConnect);
      walletCore == null ? void 0 : walletCore.off("accountChange", handleAccountChange);
      walletCore == null ? void 0 : walletCore.off("networkChange", handleNetworkChange);
      walletCore == null ? void 0 : walletCore.off("disconnect", handleDisconnect);
      walletCore == null ? void 0 : walletCore.off("standardWalletsAdded", handleStandardWalletsAdded);
      walletCore == null ? void 0 : walletCore.off(
        "standardNotDetectedWalletAdded",
        handleStandardNotDetectedWalletsAdded
      );
    };
  }, [wallets, account]);
  return (0, import_jsx_runtime2.jsx)(
    WalletContext.Provider,
    {
      value: {
        connect,
        signIn,
        disconnect,
        signAndSubmitTransaction,
        signTransaction,
        signMessage,
        signMessageAndVerify,
        changeNetwork,
        submitTransaction,
        account,
        network,
        connected,
        wallet,
        wallets,
        notDetectedWallets,
        isLoading
      },
      children
    }
  );
};
var LinkGraphic = (0, import_react4.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime3.jsx)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "102",
        height: "132",
        viewBox: "0 0 102 132",
        fill: "none"
      }, props), {
        children: (0, import_jsx_runtime3.jsxs)("g", { stroke: "currentColor", strokeMiterlimit: "10", children: [
          (0, import_jsx_runtime3.jsx)("path", { d: "M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425" }),
          (0, import_jsx_runtime3.jsx)("path", { d: "M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z" })
        ] })
      })
    );
  }
);
LinkGraphic.displayName = "LinkGraphic";
var WalletGraphic = (0, import_react5.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime4.jsxs)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "128",
        height: "102",
        viewBox: "0 0 128 102",
        fill: "none"
      }, props), {
        children: [
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M9.86 23.69V5.72h107.97v18.04H84.65"
            }
          ),
          (0, import_jsx_runtime4.jsx)(
            "path",
            {
              stroke: "currentColor",
              strokeMiterlimit: "10",
              d: "M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78"
            }
          )
        ]
      })
    );
  }
);
WalletGraphic.displayName = "WalletGraphic";
var Web3Graphic = (0, import_react6.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime5.jsx)(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "142",
        height: "108",
        viewBox: "0 0 142 108",
        fill: "none"
      }, props), {
        children: (0, import_jsx_runtime5.jsxs)("g", { stroke: "currentColor", strokeLinejoin: "round", children: [
          (0, import_jsx_runtime5.jsx)("path", { d: "m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "m105.44 30.8.11 9-.1-9Z" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07l34.44-19.64.11 9L78.5 55" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71 59.51v-9.07l34.56 20.34.1 9.14L87 69" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8" }),
          (0, import_jsx_runtime5.jsx)("path", { d: "m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z" })
        ] })
      })
    );
  }
);
Web3Graphic.displayName = "Web3Graphic";
function createHeadlessComponent(displayName, elementType, props) {
  const component = (0, import_react7.forwardRef)(({ className, asChild, children }, ref) => {
    const Component = asChild ? Slot : elementType;
    const _a2 = typeof props === "function" ? props(displayName) : props != null ? props : {}, { children: defaultChildren } = _a2, resolvedProps = __objRest(_a2, ["children"]);
    const resolvedChildren = (
      /**
       * Use props' default children if no children are set in the component element's children and when asChild is true.
       */
      asChild && (0, import_react7.isValidElement)(children) && !children.props.children ? (0, import_react7.cloneElement)(children, {}, defaultChildren) : children != null ? children : defaultChildren
    );
    return (
      /**
       * Due to the complexity of the types at play, TypeScript reports the
       * following error for our JSX below:
       *
       * `Expression produces a union type that is too complex to represent.`
       *
       * We can safely ignore this error and retain accurate return types for
       * consumers of this function. The only drawback is that type-checking is
       * ignored for the JSX block below.
       */
      // @ts-expect-error
      (0, import_jsx_runtime6.jsx)(Component, __spreadProps(__spreadValues({ ref, className }, resolvedProps), { children: resolvedChildren }))
    );
  });
  component.displayName = displayName;
  return component;
}
var EXPLORE_ECOSYSTEM_URL = "https://aptosfoundation.org/ecosystem/projects/all";
var AboutAptosConnectContext = (0, import_react3.createContext)(null);
function useAboutAptosConnectContext(displayName) {
  const context = (0, import_react3.useContext)(AboutAptosConnectContext);
  if (!context) {
    throw new Error(
      `\`${displayName}\` must be used within \`AboutAptosConnect\``
    );
  }
  return context;
}
var educationScreens = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Aptos Connect is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
        "Aptos Connect lets you take one account across any application built on Aptos.",
        " ",
        (0, import_jsx_runtime7.jsx)(
          "a",
          {
            href: EXPLORE_ECOSYSTEM_URL,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }
        ),
        "."
      ] })
    })
  }
];
var educationScreenIndicators = Array(educationScreens.length).fill(null).map(
  (_8, index) => createHeadlessComponent(
    "AboutAptosConnect.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutAptosConnectContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react3.useState)(0);
  const currentEducationScreen = (0, import_react3.useMemo)(
    () => educationScreens.map((screen, i27) => __spreadProps(__spreadValues({}, screen), {
      screenIndex: i27,
      totalScreens: educationScreens.length,
      screenIndicators: educationScreenIndicators,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime7.jsx)(AboutAptosConnectContext.Provider, { value: { screenIndex, setScreenIndex }, children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen) });
};
Root.displayName = "AboutAptosConnect";
var Trigger = createHeadlessComponent(
  "AboutAptosConnect.Trigger",
  "button",
  (displayName) => {
    const context = useAboutAptosConnectContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutAptosConnect = Object.assign(Root, {
  Trigger
});
var SmallAptosLogo = (0, import_react9.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime8.jsx)(
    "svg",
    __spreadProps(__spreadValues({
      ref,
      width: "12",
      height: "12",
      viewBox: "0 0 12 12",
      fill: "none"
    }, props), {
      children: (0, import_jsx_runtime8.jsx)(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z",
          fill: "currentColor"
        }
      )
    })
  );
});
SmallAptosLogo.displayName = "SmallAptosLogo";
var APTOS_PRIVACY_POLICY_URL = "https://aptoslabs.com/privacy";
var Root2 = createHeadlessComponent("AptosPrivacyPolicy.Root", "div");
var Disclaimer = createHeadlessComponent(
  "AptosPrivacyPolicy.Disclaimer",
  "span",
  { children: "By continuing, you agree to Aptos Labs'" }
);
var Link = createHeadlessComponent("AptosPrivacyPolicy.Disclaimer", "a", {
  href: APTOS_PRIVACY_POLICY_URL,
  target: "_blank",
  rel: "noopener noreferrer",
  children: "Privacy Policy"
});
var PoweredBy = (0, import_react8.forwardRef)(({ className }, ref) => {
  return (0, import_jsx_runtime9.jsxs)("div", { ref, className, children: [
    (0, import_jsx_runtime9.jsx)("span", { children: "Powered by" }),
    (0, import_jsx_runtime9.jsx)(SmallAptosLogo, {}),
    (0, import_jsx_runtime9.jsx)("span", { children: "Aptos Labs" })
  ] });
});
PoweredBy.displayName = "AptosPrivacyPolicy.PoweredBy";
var AptosPrivacyPolicy = Object.assign(Root2, {
  Disclaimer,
  Link,
  PoweredBy
});
function useWalletItemContext(displayName) {
  const context = (0, import_react10.useContext)(WalletItemContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`WalletItem\``);
  }
  return context;
}
var WalletItemContext = (0, import_react10.createContext)(null);
var Root3 = (0, import_react10.forwardRef)(
  ({ wallet, onConnect, className, asChild, children }, ref) => {
    const { connect } = useWallet();
    const connectWallet = (0, import_react10.useCallback)(() => {
      connect(wallet.name);
      onConnect == null ? void 0 : onConnect();
    }, [connect, wallet.name, onConnect]);
    const isWalletReady = wallet.readyState === WalletReadyState.Installed;
    const mobileSupport = "deeplinkProvider" in wallet && wallet.deeplinkProvider;
    if (!isWalletReady && isRedirectable() && !mobileSupport) return null;
    const Component = asChild ? Slot : "div";
    return (0, import_jsx_runtime10.jsx)(WalletItemContext.Provider, { value: { wallet, connectWallet }, children: (0, import_jsx_runtime10.jsx)(Component, { ref, className, children }) });
  }
);
Root3.displayName = "WalletItem";
var Icon = createHeadlessComponent(
  "WalletItem.Icon",
  "img",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      src: context.wallet.icon,
      alt: `${context.wallet.name} icon`
    };
  }
);
var Name = createHeadlessComponent(
  "WalletItem.Name",
  "div",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      children: context.wallet.name
    };
  }
);
var ConnectButton = createHeadlessComponent(
  "WalletItem.ConnectButton",
  "button",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      onClick: context.connectWallet,
      children: "Connect"
    };
  }
);
var InstallLink = createHeadlessComponent(
  "WalletItem.InstallLink",
  "a",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      href: context.wallet.url,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Install"
    };
  }
);
var WalletItem = Object.assign(Root3, {
  Icon,
  Name,
  ConnectButton,
  InstallLink
});
export {
  APTOS_CONNECT_ACCOUNT_URL,
  APTOS_CONNECT_BASE_URL,
  APTOS_PRIVACY_POLICY_URL,
  AboutAptosConnect,
  AptosPrivacyPolicy,
  AptosWalletAdapterProvider,
  ChainIdToAnsSupportedNetworkMap,
  EXPLORE_ECOSYSTEM_URL,
  NetworkName2 as NetworkName,
  WalletContext,
  WalletCore,
  WalletItem,
  WalletReadyState,
  aptosStandardSupportedWalletList,
  convertNetwork,
  crossChainStandardSupportedWalletList,
  fetchDevnetChainId,
  generalizedErrorMessage,
  getAptosConfig,
  getAptosConnectWallets,
  getLocalStorage,
  getSDKWallets,
  groupAndSortWallets,
  handlePublishPackageTransaction,
  isAptosConnectWallet,
  isAptosLiveNetwork,
  isAptosNetwork,
  isInAppBrowser,
  isInstallRequired,
  isInstalledOrLoadable,
  isMobile,
  isRedirectable,
  partitionWallets,
  removeLocalStorage,
  setLocalStorage,
  truncateAddress,
  useWallet
};
//# sourceMappingURL=@aptos-labs_wallet-adapter-react.js.map
